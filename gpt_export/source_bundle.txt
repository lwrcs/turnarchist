--- src/astarclass.ts ---
import { EntityDirection } from "./entity/entity";
import { Direction } from "./game";
import { SpikeTrap } from "./tile/spiketrap";
import { Wall } from "./tile/wall";

export namespace astar {
  //================== start graph js
  /* 
  graph.js http://github.com/bgrins/javascript-astar
  MIT License
  Creates a Graph class used in the astar search algorithm.
  Includes Binary Heap (with modifications) from Marijn Haverbeke 
      URL: http://eloquentjavascript.net/appendix2.html
      License: http://creativecommons.org/licenses/by/3.0/
  */

  export interface Position {
    x: number;
    y: number;
  }

  export enum GraphNodeType {
    WALL,
    OPEN,
  }

  let getTileCost = (tile) => {
    if (tile) return tile.isSolid() || tile.isDoor ? 99999999 : 300;
    else return 99999999;
  };

  export class Graph {
    nodes: GraphNode[][];
    elements: number[][];

    constructor(grid: number[][]) {
      this.elements = grid;
      var nodes: GraphNode[][] = [];
      var row: number[],
        rowLength: number,
        len = grid.length;
      for (var x = 0; x < len; ++x) {
        row = grid[x];
        rowLength = row.length;
        nodes[x] = new Array(rowLength); // optimum array with size
        for (var y = 0; y < rowLength; ++y) {
          nodes[x][y] = new GraphNode(x, y, row[y]);
        }
      }
      this.nodes = nodes;
    }

    toString(): string {
      var graphString = "\n";
      var nodes = this.nodes;
      var rowDebug: string, row: GraphNode[], y: number, l: number;
      for (var x = 0, len = nodes.length; x < len; ) {
        rowDebug = "";
        row = nodes[x++];
        for (y = 0, l = row.length; y < l; ) {
          rowDebug += row[y++].type + " ";
        }
        graphString = graphString + rowDebug + "\n";
      }
      return graphString;
    }
  }

  export class GraphNode {
    x: number;
    y: number;
    type: GraphNodeType;
    data: any;
    pos: Position;

    constructor(x: number, y: number, type: GraphNodeType) {
      this.data = {};
      this.x = x;
      this.y = y;
      this.pos = { x: x, y: y };
      this.type = type;
    }

    toString(): string {
      return "[" + this.x + " " + this.y + "]";
    }

    isWall() {
      return this.type == GraphNodeType.WALL;
    }
  }

  export class BinaryHeap {
    content: any[];
    scoreFunction: (node: any) => number;

    constructor(scoreFunction: (node: any) => number) {
      this.content = [];
      this.scoreFunction = scoreFunction;
    }

    push(node: any) {
      // Add the new node to the end of the array.
      this.content.push(node);
      // Allow it to sink down.
      this.sinkDown(this.content.length - 1);
    }

    pop() {
      // Store the first node so we can return it later.
      var result = this.content[0];
      // Get the node at the end of the array.
      var end = this.content.pop();
      // If there are any elements left, put the end node at the
      // start, and let it bubble up.
      if (this.content.length > 0) {
        this.content[0] = end;
        this.bubbleUp(0);
      }
      return result;
    }

    remove(node: any) {
      var i = this.content.indexOf(node);

      // When it is found, the process seen in 'pop' is repeated
      // to fill up the hole.
      var end = this.content.pop();
      if (i !== this.content.length - 1) {
        this.content[i] = end;
        if (this.scoreFunction(end) < this.scoreFunction(node))
          this.sinkDown(i);
        else this.bubbleUp(i);
      }
    }

    size() {
      return this.content.length;
    }

    rescoreElement(node: any) {
      this.sinkDown(this.content.indexOf(node));
    }

    sinkDown(n: number) {
      // Fetch the element that has to be sunk.
      var element = this.content[n];
      // When at 0, an element can not sink any further.
      while (n > 0) {
        // Compute the parent element's index, and fetch it.
        var parentN = ((n + 1) >> 1) - 1,
          parent = this.content[parentN];
        // Swap the elements if the parent is greater.
        if (this.scoreFunction(element) < this.scoreFunction(parent)) {
          this.content[parentN] = element;
          this.content[n] = parent;
          // Update 'n' to continue at the new position.
          n = parentN;
        } else {
          // Found a parent that is less, no need to sink any further.
          break;
        }
      }
    }

    bubbleUp(n: number) {
      // Look up the target element and its score.
      var length = this.content.length,
        element = this.content[n],
        elemScore = this.scoreFunction(element);

      while (true) {
        // Compute the indices of the child elements.
        var child2N = (n + 1) << 1,
          child1N = child2N - 1;
        // This is used to store the new position of the element,
        // if any.
        var swap = null;
        // If the first child exists (is inside the array)...
        if (child1N < length) {
          // Look it up and compute its score.
          var child1 = this.content[child1N],
            child1Score = this.scoreFunction(child1);
          // If the score is less than our element's, we need to swap.
          if (child1Score < elemScore) swap = child1N;
        }
        // Do the same checks for the other child.
        if (child2N < length) {
          var child2 = this.content[child2N],
            child2Score = this.scoreFunction(child2);
          if (child2Score < (swap === null ? elemScore : child1Score))
            swap = child2N;
        }

        // If the element needs to be moved, swap it, and continue.
        if (swap !== null) {
          this.content[n] = this.content[swap];
          this.content[swap] = element;
          n = swap;
        } else {
          // Otherwise, we are done.
          break;
        }
      }
    }
  }
  //end graph.js ==================

  // javascript-astar
  // http://github.com/bgrins/javascript-astar
  // Freely distributable under the MIT License.
  // Implements the astar search algorithm in javascript using a binary heap.
  export interface AStarData {
    f: number;
    g: number;
    h: number;
    cost: number;
    visited: boolean;
    closed: boolean;
    parent: AStarData;
    pos: Position;
    org: any;
  }

  export class AStar {
    static NO_CHECK_START_POINT: boolean = false;
    grid: AStarData[][];
    constructor(
      grid: any[][],
      disablePoints?: Position[],
      lastPlayerPosition?: Position,
      enableCost?: boolean,
    ) {
      this.grid = [];
      for (var x = 0, xl = grid.length; x < xl; x++) {
        this.grid[x] = [];
        for (var y = 0, yl = grid[x].length; y < yl; y++) {
          var cost = getTileCost(grid[x][y]);
          this.grid[x][y] = {
            org: grid[x][y],
            f: 0,
            g: 0,
            h: 0,
            cost: cost,
            visited: false,
            closed: false,
            pos: {
              x: x,
              y: y,
            },
            parent: null,
          };
        }
      }
      if (disablePoints !== undefined) {
        for (var i = 0; i < disablePoints.length; i++) {
          if (
            disablePoints[i].x >= 0 &&
            disablePoints[i].x < this.grid.length &&
            disablePoints[i].y >= 0 &&
            disablePoints[i].y < this.grid[0].length
          )
            this.grid[disablePoints[i].x][disablePoints[i].y].cost = 99999999;
        }
      }
      if (lastPlayerPosition) {
        if (
          lastPlayerPosition.x >= 0 &&
          lastPlayerPosition.x < this.grid.length &&
          lastPlayerPosition.y >= 0 &&
          lastPlayerPosition.y < this.grid[0].length
        )
          this.grid[lastPlayerPosition.x][lastPlayerPosition.y].cost = 0.5;
      }
    }

    heap(): BinaryHeap {
      return new BinaryHeap(function (node: AStarData) {
        return node.f;
      });
    }

    _find(org: any) {
      for (var x = 0; x < this.grid.length; x++)
        for (var y = 0; y < this.grid[x].length; y++)
          if (this.grid[x][y].org == org) return this.grid[x][y];
    }

    _search(
      start: any,
      end: any,
      diagonal?: boolean,
      diagonalsOnly?: boolean,
      turnCostsExtra?: boolean,
      turnDirection?: Direction,
      heuristic?: Function,
      diagonalsOmni?: boolean,
      lastPlayerPosition?: Position,
    ) {
      heuristic = heuristic || this.manhattan;
      diagonal = !!diagonal;
      diagonalsOnly = !!diagonalsOnly;
      turnCostsExtra = !!turnCostsExtra;
      diagonalsOmni = !!diagonalsOmni;

      var openHeap = this.heap();

      var _start: AStarData, _end: AStarData;
      if (start.x !== undefined && start.y !== undefined)
        _start = this.grid[start.x][start.y];
      else _start = this._find(start);

      if (end.x !== undefined && end.y !== undefined)
        _end = this.grid[end.x][end.y];
      else _end = this._find(end);

      if (AStar.NO_CHECK_START_POINT == false && _start.cost <= 0) return [];

      openHeap.push(_start);

      while (openHeap.size() > 0) {
        // Grab the lowest f(x) to process next.  Heap keeps this sorted for us.
        var currentNode: AStarData = openHeap.pop();

        // End case -- result has been found, return the traced path.
        if (currentNode === _end) {
          var curr = currentNode;
          var ret = [];
          while (curr.parent) {
            ret.push(curr);
            curr = curr.parent;
          }
          return ret.reverse();
        }

        // Normal case -- move currentNode from open to closed, process each of its neighbors.
        currentNode.closed = true;

        // Find all neighbors for the current node. Optionally find diagonal neighbors as well (false by default).
        var neighbors = this.neighbors(
          currentNode,
          diagonal,
          diagonalsOnly,
          diagonalsOmni,
        );

        for (var i = 0, il = neighbors.length; i < il; i++) {
          var neighbor = neighbors[i];

          if (neighbor.closed || neighbor.cost <= 0) {
            // Not a valid node to process, skip to next neighbor.
            continue;
          }

          // The g score is the shortest distance from start to current node.
          // We need to check if the path we have arrived at this neighbor is the shortest one we have seen yet.

          var gScore = currentNode.g + neighbor.cost;
          if (turnCostsExtra) {
            var isTurn = false;
            if (currentNode.parent)
              isTurn = !(
                (currentNode.parent.pos.x === currentNode.pos.x &&
                  currentNode.pos.x === neighbor.pos.x) ||
                (currentNode.parent.pos.y === currentNode.pos.y &&
                  currentNode.pos.y === neighbor.pos.y)
              );
            else {
              // initial step
              isTurn = true;
              if (
                neighbor.pos.x - currentNode.pos.x === 0 &&
                neighbor.pos.y - currentNode.pos.y === -1 &&
                turnDirection === Direction.UP
              )
                isTurn = false;
              if (
                neighbor.pos.x - currentNode.pos.x === 0 &&
                neighbor.pos.y - currentNode.pos.y === 1 &&
                turnDirection === Direction.DOWN
              )
                isTurn = false;
              if (
                neighbor.pos.x - currentNode.pos.x === 1 &&
                neighbor.pos.y - currentNode.pos.y === 0 &&
                turnDirection === Direction.RIGHT
              )
                isTurn = false;
              if (
                neighbor.pos.x - currentNode.pos.x === -1 &&
                neighbor.pos.y - currentNode.pos.y === 0 &&
                turnDirection === Direction.LEFT
              )
                isTurn = false;
            }
            if (isTurn) gScore++;
          }
          var beenVisited = neighbor.visited;

          if (!beenVisited || gScore < neighbor.g) {
            // Found an optimal (so far) path to this node.  Take score for node to see how good it is.
            neighbor.visited = true;
            neighbor.parent = currentNode;
            neighbor.h =
              neighbor.h ||
              heuristic(neighbor.pos, _end.pos, lastPlayerPosition);
            neighbor.g = gScore;
            neighbor.f = neighbor.g + neighbor.h;

            if (!beenVisited) {
              // Pushing to heap will put it in proper place based on the 'f' value.
              openHeap.push(neighbor);
            } else {
              // Already seen the node, but since it has been rescored we need to reorder it in the heap
              openHeap.rescoreElement(neighbor);
            }
          }
        }
      }

      // No result was found - empty array signifies failure to find path.
      return [];
    }

    static search(
      grid: any[][],
      start: any,
      end: any,
      disablePoints?: Position[],
      diagonal?: boolean,
      diagonalsOnly?: boolean,
      turnCostsExtra?: boolean,
      turnDirection?: Direction,
      heuristic?: Function,
      diagonalsOmni?: boolean,
      lastPlayerPosition?: Position,
    ) {
      var astar = new AStar(grid, disablePoints, lastPlayerPosition);
      return astar._search(
        start,
        end,
        diagonal,
        diagonalsOnly,
        turnCostsExtra,
        turnDirection,
        heuristic,
        diagonalsOmni,
      );
    }

    manhattan(pos0: Position, pos1: Position): number {
      var d1 = Math.abs(pos1.x - pos0.x);
      var d2 = Math.abs(pos1.y - pos0.y);
      var heuristic = d1 + d2;

      return heuristic;
    }

    neighbors(
      node: AStarData,
      diagonals?: boolean,
      diagonalsOnly?: boolean,
      diagonalsOmni?: boolean,
    ): AStarData[] {
      var grid = this.grid;
      var ret = [];
      var x = node.pos.x;
      var y = node.pos.y;

      if (!diagonalsOnly) {
        // West
        if (grid[x - 1] && grid[x - 1][y]) {
          ret.push(grid[x - 1][y]);
        }

        // East
        if (grid[x + 1] && grid[x + 1][y]) {
          ret.push(grid[x + 1][y]);
        }

        // South
        if (grid[x] && grid[x][y - 1]) {
          ret.push(grid[x][y - 1]);
        }

        // North
        if (grid[x] && grid[x][y + 1]) {
          ret.push(grid[x][y + 1]);
        }
      }

      if (diagonals) {
        // Southwest
        if (grid[x - 1] && grid[x - 1][y - 1]) {
          ret.push(grid[x - 1][y - 1]);
        }

        // Southeast
        if (grid[x + 1] && grid[x + 1][y - 1]) {
          ret.push(grid[x + 1][y - 1]);
        }

        // Northwest
        if (grid[x - 1] && grid[x - 1][y + 1]) {
          ret.push(grid[x - 1][y + 1]);
        }

        // Northeast
        if (grid[x + 1] && grid[x + 1][y + 1]) {
          ret.push(grid[x + 1][y + 1]);
        }
      }
      function getRandomBoolean(): boolean {
        return Random.rand() < 0.5;
      }
      if (diagonalsOmni) {
        const randomBool: boolean = getRandomBoolean();
        // West
        if (grid[x - 1] && grid[x - 1][y]) {
          // Instead of pushing West, choose between Southwest and Northwest
          if (randomBool == true) {
            ret.push(grid[x - 1][y - 1]);
            return;
          } else {
            ret.push(grid[x - 1][y + 1]);
            return;
          }
        }
        // East
        if (grid[x + 1] && grid[x + 1][y]) {
          if (randomBool == true) {
            ret.push(grid[x + 1][y - 1]);
            return;
          } else {
            ret.push(grid[x + 1][y + 1]);
            return;
          }
        }
        // South
        if (grid[x] && grid[x][y - 1]) {
          if (randomBool == true) {
            ret.push(grid[x - 1][y - 1]);
            return;
          } else {
            ret.push(grid[x + 1][y - 1]);
            return;
          }
        }
        // North
        if (grid[x] && grid[x][y + 1]) {
          if (randomBool == true) {
            ret.push(grid[x - 1][y + 1]);
            return;
          } else {
            ret.push(grid[x + 1][y + 1]);
            return;
          }
        } else {
          return;
        }
      }

      return ret;
    }
  }
}


--- src/beamEffect.ts ---
import { Entity } from "./entity/entity";
import { Game } from "./game";
import { GameConstants } from "./gameConstants";
import { Particle } from "./particle/particle";
import { Projectile } from "./projectile/projectile";
import { Room } from "./room";

interface Point {
  x: number;
  y: number;
  oldX: number;
  oldY: number;
  velocityX: number;
  velocityY: number;
  angle: number;
}

export class BeamEffect extends Projectile {
  // Number of points that make up the beam (higher = smoother but more expensive)
  // Range: 10-100, recommended: 30
  private static readonly SEGMENTS = 30;

  // Downward force applied to each point (0 = no gravity)
  // Range: 0-10, recommended: 2
  private static readonly GRAVITY = 2;

  // Physics simulation steps per frame (higher = more accurate but more expensive)
  // Range: 1-10, recommended: 1
  private static readonly ITERATIONS = 5;

  // How much the beam reacts to movement of start/end points
  // Range: 0-5, recommended: 1
  private static readonly MOTION_INFLUENCE = 1;

  // Amount of random movement applied to points (0 = straight beam)
  // Range: 0-1, recommended: 0.5
  private static readonly TURBULENCE = 0.5;

  // How quickly velocity decreases over time
  // Range: 0-1, recommended: 0.5
  private static readonly VELOCITY_DECAY = 0.1;

  // How quickly the turbulence angle changes
  // Range: 0-2, recommended: 0.9
  private static readonly ANGLE_CHANGE = 0.01; // for turbulence specifically

  // Maximum speed any point can move per frame
  // Range: 10-1000, recommended: 100
  private static readonly MAX_VELOCITY = 100;

  // General movement resistance (1 = no damping, 0 = full stop)
  // Range: 0.9-0.999, recommended: 0.8
  private static readonly DAMPING = 0.8;

  // How strongly points pull toward their neighbors
  // Range: 0.01-1, recommended: 0.01
  private static readonly SPRING_STIFFNESS = 0.01;

  // How quickly spring oscillations settle
  // Range: 0.001-0.1, recommended: 0.1
  private static readonly SPRING_DAMPING = 0.1;

  private points: Point[];
  private prevStartX: number;
  private prevStartY: number;
  private prevEndX: number;
  private prevEndY: number;
  private active: boolean = true;
  private time: number = 0;
  alpha: number = 1;
  targetX: number;
  targetY: number;
  color: string;
  compositeOperation: string;
  gravity: number = BeamEffect.GRAVITY;
  motionInfluence: number = BeamEffect.MOTION_INFLUENCE;
  turbulence: number = BeamEffect.TURBULENCE;
  velocityDecay: number = BeamEffect.VELOCITY_DECAY;
  angleChange: number = BeamEffect.ANGLE_CHANGE;
  maxVelocity: number = BeamEffect.MAX_VELOCITY;
  damping: number = BeamEffect.DAMPING;
  springStiffness: number = BeamEffect.SPRING_STIFFNESS;
  springDamping: number = BeamEffect.SPRING_DAMPING;
  iterations: number = BeamEffect.ITERATIONS;
  segments: number = BeamEffect.SEGMENTS;
  constructor(x1: number, y1: number, x2: number, y2: number, parent: Entity) {
    super(parent, x1, y1);
    const startX = x1 * GameConstants.TILESIZE + 0.5 * GameConstants.TILESIZE;
    const startY = y1 * GameConstants.TILESIZE + 0.5 * GameConstants.TILESIZE;
    const endX = x2 * GameConstants.TILESIZE + 0.5 * GameConstants.TILESIZE;
    const endY = y2 * GameConstants.TILESIZE + 0.5 * GameConstants.TILESIZE;
    this.x = x1;
    this.y = y1;
    this.targetX = x2;
    this.targetY = y2;

    this.points = this.initializePoints(startX, startY, endX, endY);
    this.prevStartX = startX;
    this.prevStartY = startY;
    this.prevEndX = endX;
    this.prevEndY = endY;
    this.color = "cyan";
    this.compositeOperation = "source-over";
  }
  /**
   * Sets the physics properties for the beam effect.
   *
   * @param {number} [gravity] - The gravitational force applied to the beam. Default: 2
   * @param {number} [motionInfluence] - The influence of motion on the beam. Default: 1
   * @param {number} [turbulence] - The turbulence applied to the beam. Default: 0.5
   * @param {number} [velocityDecay] - The rate at which velocity decays. Default: 0.1
   * @param {number} [angleChange] - The change in angle of the beam. Default: 0.01
   * @param {number} [maxVelocity] - The maximum velocity of the beam.
   * @param {number} [damping] - The damping factor for the beam's motion.
   * @param {number} [springStiffness] - The stiffness of the spring effect.
   * @param {number} [springDamping] - The damping of the spring effect.
   * @param {number} [iterations] - The number of iterations for the physics simulation.
   * @param {number} [segments] - The number of segments for the beam.
   */
  setPhysics(
    gravity?: number,
    motionInfluence?: number,
    turbulence?: number,
    velocityDecay?: number,
    angleChange?: number,
    maxVelocity?: number,
    damping?: number,
    springStiffness?: number,
    springDamping?: number,
    iterations?: number,
    segments?: number,
  ) {
    this.gravity = gravity ?? BeamEffect.GRAVITY;
    this.motionInfluence = motionInfluence ?? BeamEffect.MOTION_INFLUENCE;
    this.turbulence = turbulence ?? BeamEffect.TURBULENCE;
    this.velocityDecay = velocityDecay ?? BeamEffect.VELOCITY_DECAY;
    this.angleChange = angleChange ?? BeamEffect.ANGLE_CHANGE;
    this.maxVelocity = maxVelocity ?? BeamEffect.MAX_VELOCITY;
    this.damping = damping ?? BeamEffect.DAMPING;
    this.springStiffness = springStiffness ?? BeamEffect.SPRING_STIFFNESS;
    this.springDamping = springDamping ?? BeamEffect.SPRING_DAMPING;
    this.iterations = iterations ?? BeamEffect.ITERATIONS;
    this.segments = segments ?? BeamEffect.SEGMENTS;
  }

  setTarget(x: number, y: number, x2: number, y2: number) {
    this.x = x;
    this.y = y;
    this.targetX = x2;
    this.targetY = y2;
  }

  render(
    x1: number,
    y1: number,
    x2: number,
    y2: number,
    color: string = this.color,
    lineWidth: number = 2,
    delta: number = 1 / 60,
    compositeOperation: string = this.compositeOperation,
  ): void {
    const startX =
      this.x * GameConstants.TILESIZE + 0.5 * GameConstants.TILESIZE;
    const startY =
      this.y * GameConstants.TILESIZE + 0.5 * GameConstants.TILESIZE;
    const endX =
      this.targetX * GameConstants.TILESIZE + 0.5 * GameConstants.TILESIZE;
    const endY =
      this.targetY * GameConstants.TILESIZE + 0.5 * GameConstants.TILESIZE;

    const startForceX =
      (startX - this.prevStartX) * this.motionInfluence * delta;
    const startForceY =
      (startY - this.prevStartY) * this.motionInfluence * delta;
    const endForceX = (endX - this.prevEndX) * this.motionInfluence * delta;
    const endForceY = (endY - this.prevEndY) * this.motionInfluence * delta;

    for (let i = 1; i < 4; i++) {
      const influence = 1 - i / 4;
      this.points[i].x += startForceX * influence;
      this.points[i].y += startForceY * influence;
    }
    for (let i = this.points.length - 4; i < this.points.length - 1; i++) {
      const influence = 1 - (this.points.length - i) / 4;
      this.points[i].x += endForceX * influence;
      this.points[i].y += endForceY * influence;
    }

    this.simulateRope(startX, startY, endX, endY, delta);

    const ctx = Game.ctx;
    ctx.save();
    Game.ctx.globalCompositeOperation =
      compositeOperation as GlobalCompositeOperation;
    for (let i = 0; i < this.points.length - 1; i++) {
      const p1 = this.points[i];
      const p2 = this.points[i + 1];

      const dx = p2.x - p1.x;
      const dy = p2.y - p1.y;
      const steps = Math.max(Math.abs(dx), Math.abs(dy));

      const xIncrement = dx / steps;
      const yIncrement = dy / steps;

      let x = p1.x;
      let y = p1.y;

      for (let step = 0; step <= steps; step++) {
        for (let w = 0; w < lineWidth; w++) {
          for (let h = 0; h < lineWidth; h++) {
            ctx.fillStyle = color;
            ctx.fillRect(Math.round(x + w), Math.round(y + h), 1, 1);
          }
        }
        x += xIncrement;
        y += yIncrement;
      }
    }

    ctx.restore();

    this.prevStartX = startX;
    this.prevStartY = startY;
    this.prevEndX = endX;
    this.prevEndY = endY;
  }

  private initializePoints(
    startX: number,
    startY: number,
    endX: number,
    endY: number,
  ): Point[] {
    const points: Point[] = [];
    for (let i = 0; i < this.segments; i++) {
      const t = i / (this.segments - 1);
      points.push({
        x: startX + (endX - startX) * t,
        y: startY + (endY - startY) * t,
        oldX: startX + (endX - startX) * t,
        oldY: startY + (endY - startY) * t,
        velocityX: 0,
        velocityY: 0,
        angle: Random.rand() * Math.PI * 2,
      });
    }
    return points;
  }

  private applyTurbulence(point: Point, index: number): void {
    point.angle += Math.sin(this.time * 0.1 + index * 0.5) * this.angleChange;

    const turbulenceX = Math.cos(point.angle) * this.turbulence;
    const turbulenceY = Math.sin(point.angle) * this.turbulence;

    point.velocityX += turbulenceX;
    point.velocityY += turbulenceY;

    point.velocityX = Math.min(
      Math.max(point.velocityX, -this.maxVelocity),
      this.maxVelocity,
    );
    point.velocityY = Math.min(
      Math.max(point.velocityY, -this.maxVelocity),
      this.maxVelocity,
    );
  }

  tick = () => {
    if (this.parent.dead) {
      this.destroy();
    }
  };

  private simulateRope(
    startX: number,
    startY: number,
    endX: number,
    endY: number,
    delta: number,
  ): void {
    const iterationsThisFrame = Math.ceil(this.iterations * delta);

    for (let iteration = 0; iteration < iterationsThisFrame; iteration++) {
      for (let i = 1; i < this.points.length - 1; i++) {
        const point = this.points[i];
        const prevPoint = this.points[i - 1];
        const nextPoint = this.points[i + 1];

        const springForceXPrev = (prevPoint.x - point.x) * this.springStiffness;
        const springForceYPrev = (prevPoint.y - point.y) * this.springStiffness;
        const springForceXNext = (nextPoint.x - point.x) * this.springStiffness;
        const springForceYNext = (nextPoint.y - point.y) * this.springStiffness;

        this.applyTurbulence(point, i);

        point.velocityX =
          (point.velocityX + springForceXPrev + springForceXNext) *
          this.damping;
        point.velocityY =
          (point.velocityY + springForceYPrev + springForceYNext) *
          this.damping;

        const relativeVXPrev = prevPoint.velocityX - point.velocityX;
        const relativeVYPrev = prevPoint.velocityY - point.velocityY;
        const relativeVXNext = nextPoint.velocityX - point.velocityX;
        const relativeVYNext = nextPoint.velocityY - point.velocityY;

        point.velocityX +=
          (relativeVXPrev + relativeVXNext) * this.springDamping;
        point.velocityY +=
          (relativeVYPrev + relativeVYNext) * this.springDamping;

        point.oldX = point.x;
        point.oldY = point.y;

        point.x += point.velocityX;
        point.y += point.velocityY + this.gravity;
      }

      const segmentLength =
        Math.sqrt(Math.pow(endX - startX, 2) + Math.pow(endY - startY, 2)) /
        (this.segments - 1);

      for (
        let constraintIteration = 0;
        constraintIteration < 2;
        constraintIteration++
      ) {
        for (let i = 0; i < this.points.length - 1; i++) {
          const p1 = this.points[i];
          const p2 = this.points[i + 1];

          const dx = p2.x - p1.x;
          const dy = p2.y - p1.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          const difference = segmentLength - distance;
          const percent = difference / distance / 2;
          const offsetX = dx * percent;
          const offsetY = dy * percent;

          if (i > 0) {
            p1.x -= offsetX * 1.5;
            p1.y -= offsetY * 1.5;
          }
          if (i < this.points.length - 2) {
            p2.x += offsetX * 1.5;
            p2.y += offsetY * 1.5;
          }
        }
      }
    }

    this.points[0].x = startX;
    this.points[0].y = startY;
    this.points[0].oldX = startX;
    this.points[0].oldY = startY;
    this.points[this.points.length - 1].x = endX;
    this.points[this.points.length - 1].y = endY;
    this.points[this.points.length - 1].oldX = endX;
    this.points[this.points.length - 1].oldY = endY;
  }

  draw = (delta: number) => {
    this.drawableY = this.y - 0.01;
    this.render(
      this.targetX,
      this.targetY,
      this.x,
      this.y,
      this.color,
      2,
      delta,
      this.compositeOperation,
    );
  };

  static renderBeam(
    x1: number,
    y1: number,
    x2: number,
    y2: number,
    color: string = "cyan",
    lineWidth: number = 2,
    alpha: number = 1,
  ): void {
    const ctx = Game.ctx;
    ctx.globalAlpha = alpha;

    const startX = x1 * GameConstants.TILESIZE + 0.5 * GameConstants.TILESIZE;
    const startY = y1 * GameConstants.TILESIZE + 0.5 * GameConstants.TILESIZE;
    const endX = x2 * GameConstants.TILESIZE + 0.5 * GameConstants.TILESIZE;
    const endY = y2 * GameConstants.TILESIZE + 0.5 * GameConstants.TILESIZE;

    ctx.save();
    ctx.beginPath();
    ctx.moveTo(startX, startY);
    ctx.lineTo(endX, endY);
    ctx.lineWidth = lineWidth;
    ctx.strokeStyle = color;
    ctx.stroke();
    ctx.restore();
  }

  destroy(): void {
    this.active = false;
    this.points = [];
    this.dead = true;
  }

  isActive(): boolean {
    return this.active;
  }
}


--- src/bestiary.ts ---
import { Game } from "./game";
import { Player } from "./player";
import { Input } from "./input";
import { MouseCursor } from "./mouseCursor";
import { LevelConstants } from "./levelConstants";
import { GameConstants } from "./gameConstants";
import { Enemy } from "./entity/enemy/enemy";
import { CrabEnemy } from "./entity/enemy/crabEnemy";
import { FrogEnemy } from "./entity/enemy/frogEnemy";
import { ZombieEnemy } from "./entity/enemy/zombieEnemy";
import { SkullEnemy } from "./entity/enemy/skullEnemy";
import { EnergyWizardEnemy } from "./entity/enemy/energyWizard";
import { ChargeEnemy } from "./entity/enemy/chargeEnemy";
import { RookEnemy } from "./entity/enemy/rookEnemy";
import { BishopEnemy } from "./entity/enemy/bishopEnemy";
import { ArmoredzombieEnemy } from "./entity/enemy/armoredzombieEnemy";
import { BigSkullEnemy } from "./entity/enemy/bigSkullEnemy";
import { QueenEnemy } from "./entity/enemy/queenEnemy";
import { KnightEnemy } from "./entity/enemy/knightEnemy";
import { BigKnightEnemy } from "./entity/enemy/bigKnightEnemy";
import { FireWizardEnemy } from "./entity/enemy/fireWizard";
import { Spawner } from "./entity/enemy/spawner";
import { OccultistEnemy } from "./entity/enemy/occultistEnemy";

//enemy typeof to class map
const enemyClassMap = {
  CrabEnemy: CrabEnemy,
  FrogEnemy: FrogEnemy,
  ZombieEnemy: ZombieEnemy,
  SkullEnemy: SkullEnemy,
  EnergyWizardEnemy: EnergyWizardEnemy,
  ChargeEnemy: ChargeEnemy,
  RookEnemy: RookEnemy,
  BishopEnemy: BishopEnemy,
  ArmoredzombieEnemy: ArmoredzombieEnemy,
  BigSkullEnemy: BigSkullEnemy,
  QueenEnemy: QueenEnemy,
  KnightEnemy: KnightEnemy,
  BigKnightEnemy: BigKnightEnemy,
  FireWizardEnemy: FireWizardEnemy,
  Spawner: Spawner,
  OccultistEnemy: OccultistEnemy,
};

interface BestiaryEntry {
  name: string;
  description: string;
  tileX: number;
  tileY: number;
}

export class Bestiary {
  game: Game;
  player: Player;
  isOpen: boolean = false;
  openTime: number = Date.now();
  entries: Array<BestiaryEntry>;
  seenEnemies: Set<typeof Enemy>;
  frame: number = 0;
  activeEntryIndex: number = 0;
  // Static variables for logbook button position
  private buttonY: number;
  private buttonX: number;

  constructor(game: Game, player: Player) {
    this.game = game;
    this.player = player;
    this.entries = [];
    this.activeEntryIndex = 0;
    this.buttonX = Math.round(
      (Math.round(GameConstants.WIDTH / 2) + 3) / GameConstants.TILESIZE,
    );
    this.buttonY = Math.round(10);
    this.seenEnemies = new Set();
  }

  /**
   * Opens the logbook window.
   */
  open = () => {
    if (this.seenEnemies.size === 0)
      this.seenEnemies = this.game.tutorialListener.seenEnemies;
    this.isOpen = true;
    this.openTime = Date.now();
  };

  /**
   * Closes the logbook window.
   */
  close = () => {
    this.isOpen = false;
  };

  entryUp = () => {
    this.activeEntryIndex =
      (this.activeEntryIndex - 1 + this.entries.length) % this.entries.length;
  };

  entryDown = () => {
    this.activeEntryIndex = (this.activeEntryIndex + 1) % this.entries.length;
  };

  /**
   * Toggles the logbook window's open state.
   */
  toggleOpen = () => {
    this.isOpen ? this.close() : this.open();
  };

  /**
   * Adds a new entry to the logbook.
   * @param enemy The enemy to add.
   */
  addEntry = (enemy: typeof Enemy) => {
    const enemyClass = enemyClassMap[enemy.name];
    this.entries.push({
      name: enemy.name,
      description: enemyClass.prototype.description,
      tileX: enemyClass.prototype.tileX,
      tileY: enemyClass.prototype.tileY,
    });
  };

  /**
   * Draws the logbook interface.
   * @param delta The time delta since the last frame.
   */
  draw = (delta: number) => {
    if (!this.isOpen) return;
    Game.ctx.save();

    // Draw semi-transparent background
    Game.ctx.fillStyle = "rgba(0, 0, 0, 0.8)";
    Game.ctx.fillRect(0, 0, GameConstants.WIDTH, GameConstants.HEIGHT);

    // Define dimensions similar to Inventory
    const s = Math.min(18, (18 * (Date.now() - this.openTime)) / 100); // example scaling
    const b = 2; // border
    const g = -2; // gap
    const ob = 1; // outer border
    const width = 5 * (s + 2 * b + g) - g; // assuming 5 columns
    const height = 4 * (s + 2 * b + g) - g; // assuming 4 rows

    const startX = Math.round(0.5 * GameConstants.WIDTH - 0.5 * width) - ob;
    const startY = Math.round(0.5 * GameConstants.HEIGHT - 0.5 * height) - ob;

    // Draw main logbook background
    Game.ctx.fillStyle = "white";
    Game.ctx.fillRect(startX, startY, width + 2 * ob, height + 2 * ob);

    // Draw logbook entries
    Game.ctx.fillStyle = "black";
    const padding = 10;

    if (this.entries.length === 0) {
      Game.fillText("No enemies seen yet", startX + padding, startY + padding);
    } else {
      this.entries.forEach((entry, index) => {
        Game.fillText(
          entry.name,
          startX + padding,
          startY + padding + index * 20,
        );
      });

      this.drawEnemySprite(
        this.entries[this.activeEntryIndex].tileX,
        this.entries[this.activeEntryIndex].tileY,
        delta,
      );
    }
    // Draw logbook button
    this.drawLogbookButton(delta);
    Game.ctx.restore();
  };

  drawEnemySprite = (tileX: number, tileY: number, delta: number) => {
    this.frame += Math.round(0.1 * delta * 10) / 10;
    if (this.frame >= 4) this.frame = 0;

    Game.drawMob(tileX, tileY, 1, 1, 1, 1, 1, 1, "Black", 0);
  };

  /**
   * Draws the logbook button on the screen.
   * @param delta The time delta since the last frame.
   */
  drawLogbookButton = (delta: number) => {
    Game.ctx.save();
    this.buttonX = LevelConstants.SCREEN_W - 2;
    this.buttonY = LevelConstants.SCREEN_H - 2.25;
    Game.drawFX(0, 0, 2, 2, this.buttonX, this.buttonY, 2, 2);
    Game.ctx.restore();
  };

  /**
   * Handles mouse down events.
   * @param x The x-coordinate of the mouse.
   * @param y The y-coordinate of the mouse.
   * @param button The mouse button pressed.
   */
  handleMouseDown = (x: number, y: number, button: number) => {
    if (button !== 0) return; // Only respond to left click

    if (this.isPointInLogbookButton(x, y)) {
      this.toggleOpen();
    }
  };

  /**
   * Handles mouse up events.
   * @param x The x-coordinate of the mouse.
   * @param y The y-coordinate of the mouse.
   * @param button The mouse button released.
   */
  handleMouseUp = (x: number, y: number, button: number) => {
    // Implement if needed
  };

  /**
   * Handles hold detection.
   */
  onHoldDetected = () => {
    // Implement if needed
  };

  /**
   * Checks if a point is within the logbook button bounds.
   * @param x The x-coordinate to check.
   * @param y The y-coordinate to check.
   * @returns True if the point is within the button bounds, else false.
   */
  isPointInLogbookButton = (x: number, y: number): boolean => {
    const tX = x / GameConstants.TILESIZE;
    const tY = y / GameConstants.TILESIZE;
    return (
      tX >= this.buttonX &&
      tX <= this.buttonX + 2 &&
      tY >= this.buttonY &&
      tY <= this.buttonY + 2
    );
  };

  /**
   * Updates the logbook state each game tick.
   */
  tick = () => {
    if (this.isOpen) {
      // Update logbook-related logic here
    }
  };
}


--- src/drawable.ts ---
export class Drawable {
  drawableY = 0;

  draw = (delta: number) => {};

  hasBloom: boolean = false;
  bloomColor: string = "#FFFFFF";
  bloomAlpha: number = 1;
  softBloomAlpha: number = 0;
  updateBloom = (delta: number) => {
    if (this.hasBloom) {
      let diff = this.softBloomAlpha - this.bloomAlpha;
      if (Math.abs(diff) > 0.001) {
        this.softBloomAlpha = this.softBloomAlpha - diff * 0.1 * delta;
      } else {
        this.softBloomAlpha = this.bloomAlpha;
      }
    } else {
      this.softBloomAlpha = 0;
    }
  };
}


--- src/entity/enemy/armoredSkullEnemy.ts ---
import { Direction, Game } from "../../game";
import { Room } from "../../room";
import { Player } from "../../player";
import { Item } from "../../item/item";
import { astar } from "../../astarclass";
import { SpikeTrap } from "../../tile/spiketrap";
import { ImageParticle } from "../../particle/imageParticle";
import { Enemy } from "./enemy";

export class ArmoredSkullEnemy extends Enemy {
  frame: number;
  ticks: number;
  seenPlayer: boolean;
  aggro: boolean;
  ticksSinceFirstHit: number;
  flashingFrame: number;
  targetPlayer: Player;
  readonly REGEN_TICKS = 5;
  drop: Item;
  static difficulty: number = 2;
  static tileX: number = 5;
  static tileY: number = 8;
  constructor(room: Room, game: Game, x: number, y: number, drop?: Item) {
    super(room, game, x, y);
    this.ticks = 0;
    this.frame = 0;
    this.health = 3;
    this.maxHealth = 3;
    this.tileX = 17;
    this.tileY = 16;
    this.seenPlayer = false;
    this.aggro = false;
    this.ticksSinceFirstHit = 0;
    this.flashingFrame = 0;
    this.deathParticleColor = "#ffffff";
    this.name = "armored skeleton";
    this.forwardOnlyAttack = true;
    if (drop) this.drop = drop;
    if (Random.rand() < this.dropChance) {
      this.getDrop(["weapon", "consumable", "gem", "tool", "coin"]);
    }
  }

  hit = (): number => {
    return 1;
  };

  hurt = (
    playerHitBy: Player,
    damage: number,
    type: "none" | "poison" | "blood" | "heal" = "none",
  ) => {
    this.handleEnemyCase(playerHitBy);

    let hitShield = false;
    let shieldHealth = 0;
    if (this.shielded) {
      shieldHealth = this.shield.health;
      if (shieldHealth > 0) {
        this.shield.hurt(damage);
        hitShield = true;
      }
    }
    this.ticksSinceFirstHit = 0;
    if (this.health == 2) this.unconscious = false;
    this.health -= damage;
    this.maxHealth -= shieldHealth;
    this.startHurting();

    this.healthBar.hurt();
    this.createDamageNumber(damage, type);
    this.playHitSound();

    if (this.health === 1) {
      this.unconscious = true;

      ImageParticle.spawnCluster(this.room, this.x + 0.5, this.y + 0.5, 3, 28);
    } else if (this.health === 2) {
      ImageParticle.spawnCluster(this.room, this.x + 0.5, this.y + 0.5, 6, 26);
    } else this.healthBar.hurt();

    if (this.health <= 0) {
      ImageParticle.spawnCluster(this.room, this.x + 0.5, this.y + 0.5, 0, 24);
      this.kill();
    } else this.hurtCallback();
  };

  behavior = () => {
    this.lastX = this.x;
    this.lastY = this.y;

    if (!this.dead) {
      if (this.skipNextTurns > 0) {
        this.skipNextTurns--;
        this.ticks++;

        return;
      }

      if (this.health <= 1) {
        this.unconscious = true;
        this.ticksSinceFirstHit++;
        if (this.ticksSinceFirstHit >= this.REGEN_TICKS) {
          this.healthBar.hurt();
          this.health = 2;
          this.unconscious = false;
        }
        this.ticks++;

        return;
      }

      this.ticks++;
      if (!this.seenPlayer) {
        this.lookForPlayer();
      } else if (this.seenPlayer) {
        if (this.room.playerTicked === this.targetPlayer) {
          this.alertTicks = Math.max(0, this.alertTicks - 1);
          let oldX = this.x;
          let oldY = this.y;

          let disablePositions = Array<astar.Position>();
          for (const e of this.room.entities) {
            if (e !== this) {
              disablePositions.push({ x: e.x, y: e.y } as astar.Position);
            }
          }
          for (let xx = this.x - 1; xx <= this.x + 1; xx++) {
            for (let yy = this.y - 1; yy <= this.y + 1; yy++) {
              if (
                this.room.roomArray[xx][yy] instanceof SpikeTrap &&
                (this.room.roomArray[xx][yy] as SpikeTrap).on
              ) {
                disablePositions.push({ x: xx, y: yy } as astar.Position);
              }
            }
          }
          let grid = [];
          for (let x = 0; x < this.room.roomX + this.room.width; x++) {
            grid[x] = [];
            for (let y = 0; y < this.room.roomY + this.room.height; y++) {
              if (this.room.roomArray[x] && this.room.roomArray[x][y])
                grid[x][y] = this.room.roomArray[x][y];
              else grid[x][y] = false;
            }
          }
          let moves = astar.AStar.search(
            grid,
            this,
            this.targetPlayer,
            disablePositions,
            false,
            false,
            true,
            this.direction,
            undefined,
            undefined,
          );
          if (moves.length > 0) {
            let moveX = moves[0].pos.x;
            let moveY = moves[0].pos.y;
            let oldDir = this.direction;
            let player = this.targetPlayer;

            this.facePlayer(player);

            if (moveX > oldX) this.direction = Direction.RIGHT;
            else if (moveX < oldX) this.direction = Direction.LEFT;
            else if (moveY > oldY) this.direction = Direction.DOWN;
            else if (moveY < oldY) this.direction = Direction.UP;

            if (oldDir == this.direction) {
              let hitPlayer = false;
              for (const i in this.game.players) {
                if (
                  this.game.rooms[this.game.players[i].levelID] === this.room &&
                  this.game.players[i].x === moveX &&
                  this.game.players[i].y === moveY
                ) {
                  this.game.players[i].hurt(this.hit(), this.name);
                  this.drawX = 0.5 * (this.x - this.game.players[i].x);
                  this.drawY = 0.5 * (this.y - this.game.players[i].y);
                  if (
                    this.game.players[i] ===
                    this.game.players[this.game.localPlayerID]
                  )
                    this.game.shakeScreen(10 * this.drawX, 10 * this.drawY);
                }
              }
              if (!hitPlayer) {
                this.tryMove(moveX, moveY);
                this.setDrawXY(oldX, oldY);

                if (this.x > oldX) this.direction = Direction.RIGHT;
                else if (this.x < oldX) this.direction = Direction.LEFT;
                else if (this.y > oldY) this.direction = Direction.DOWN;
                else if (this.y < oldY) this.direction = Direction.UP;
              }
            }
          }

          if (this.direction == Direction.LEFT) {
            disablePositions.push({
              x: this.x,
              y: this.y + 1,
            } as astar.Position);
            disablePositions.push({
              x: this.x,
              y: this.y - 1,
            } as astar.Position);
          }
          if (this.direction == Direction.RIGHT) {
            disablePositions.push({
              x: this.x,
              y: this.y + 1,
            } as astar.Position);
            disablePositions.push({
              x: this.x,
              y: this.y - 1,
            } as astar.Position);
          }
          if (this.direction == Direction.DOWN) {
            disablePositions.push({
              x: this.x + 1,
              y: this.y,
            } as astar.Position);
            disablePositions.push({
              x: this.x - 1,
              y: this.y,
            } as astar.Position);
          }
          if (this.direction == Direction.UP) {
            disablePositions.push({
              x: this.x + 1,
              y: this.y,
            } as astar.Position);
            disablePositions.push({
              x: this.x - 1,
              y: this.y,
            } as astar.Position);
          }
          this.makeHitWarnings();
        }

        let targetPlayerOffline =
          Object.values(this.game.offlinePlayers).indexOf(this.targetPlayer) !==
          -1;
        if (!this.aggro || targetPlayerOffline) {
          let p = this.nearestPlayer();
          if (p !== false) {
            let [distance, player] = p;
            if (
              distance <= 4 &&
              (targetPlayerOffline ||
                distance < this.playerDistance(this.targetPlayer))
            ) {
              if (player !== this.targetPlayer) {
                this.targetPlayer = player;
                this.facePlayer(player);
                if (player === this.game.players[this.game.localPlayerID])
                  this.alertTicks = 1;
                this.makeHitWarnings();
              }
            }
          }
        }
      }
    }
  };

  draw = (delta: number) => {
    if (this.dead) return;
    Game.ctx.save();
    Game.ctx.globalAlpha = this.alpha;
    if (!this.dead) {
      this.updateDrawXY(delta);
      this.tileX = 27;
      this.tileY = 16;
      if (this.health <= 2) {
        this.tileX = 5;
        this.tileY = 8;
      }

      if (this.health <= 1 || this.dying) {
        this.tileX = 3;
        this.tileY = 0;
        if (this.ticksSinceFirstHit >= 3) {
          this.flashingFrame += 0.1 * delta;
          if (Math.floor(this.flashingFrame) % 2 === 0) {
            this.tileX = 2;
          }
        }
      }

      this.frame += 0.1 * delta;
      if (this.frame >= 4) this.frame = 0;

      if (this.hasShadow)
        Game.drawMob(
          0,
          0,
          1,
          1,
          this.x - this.drawX,
          this.y - this.drawY,
          1,
          1,
          this.room.shadeColor,
          this.shadeAmount(),
        );
      Game.drawMob(
        this.tileX +
          (this.tileX % 5 && !this.unconscious && !this.dying
            ? Math.floor(this.frame)
            : 0),
        this.tileY + this.direction * 2,
        1,
        2,
        this.x - this.drawX,
        this.y - this.drawYOffset - this.drawY - this.jumpY,
        1,
        2,
        this.softShadeColor,
        this.shadeAmount(),
      );
    }
    if (!this.cloned) {
      if (!this.seenPlayer) {
        this.drawSleepingZs(delta);
      }
      if (this.alertTicks > 0) {
        this.drawExclamation(delta);
      }
    }
    Game.ctx.restore();
  };
}


--- src/entity/enemy/armoredzombieEnemy.ts ---
import { Direction, Game } from "../../game";
import { Room } from "../../room";
import { Player } from "../../player";
import { GenericParticle } from "../../particle/genericParticle";
import { Item } from "../../item/item";
import { astar } from "../../astarclass";
import { SpikeTrap } from "../../tile/spiketrap";
import { Enemy } from "./enemy";

export class ArmoredzombieEnemy extends Enemy {
  frame: number;
  ticks: number;
  seenPlayer: boolean;
  aggro: boolean;
  targetPlayer: Player;
  drop: Item;
  static difficulty: number = 2;
  static tileX: number = 17;
  static tileY: number = 8;
  constructor(room: Room, game: Game, x: number, y: number, drop?: Item) {
    super(room, game, x, y);
    this.ticks = 0;
    this.frame = 0;
    this.health = 2;
    this.maxHealth = 1;
    this.tileX = 17;
    this.tileY = 8;
    this.seenPlayer = false;
    this.aggro = false;
    this.deathParticleColor = "#ffffff";
    this.name = "armored zombie";
    this.forwardOnlyAttack = true;

    if (drop) this.drop = drop;
    if (Random.rand() < this.dropChance) {
      this.getDrop([
        "weapon",
        "equipment",
        "consumable",
        "gem",
        "tool",
        "coin",
      ]);
    }
  }

  hit = (): number => {
    return 1;
  };

  behavior = () => {
    this.lastX = this.x;
    this.lastY = this.y;
    if (!this.dead) {
      if (this.skipNextTurns > 0) {
        this.skipNextTurns--;
        return;
      }
      this.ticks++;
      if (!this.seenPlayer) this.lookForPlayer();
      else if (this.seenPlayer) {
        if (this.room.playerTicked === this.targetPlayer) {
          this.alertTicks = Math.max(0, this.alertTicks - 1);
          let oldX = this.x;
          let oldY = this.y;

          let disablePositions = Array<astar.Position>();
          for (const e of this.room.entities) {
            if (e !== this) {
              disablePositions.push({ x: e.x, y: e.y } as astar.Position);
            }
          }
          for (let xx = this.x - 1; xx <= this.x + 1; xx++) {
            for (let yy = this.y - 1; yy <= this.y + 1; yy++) {
              if (
                this.room.roomArray[xx][yy] instanceof SpikeTrap &&
                (this.room.roomArray[xx][yy] as SpikeTrap).on
              ) {
                // don't walk on active spiketraps
                disablePositions.push({ x: xx, y: yy } as astar.Position);
              }
            }
          }

          let grid = [];
          for (let x = 0; x < this.room.roomX + this.room.width; x++) {
            grid[x] = [];
            for (let y = 0; y < this.room.roomY + this.room.height; y++) {
              if (this.room.roomArray[x] && this.room.roomArray[x][y])
                grid[x][y] = this.room.roomArray[x][y];
              else grid[x][y] = false;
            }
          }
          let moves = astar.AStar.search(
            grid,
            this,
            this.targetPlayer,
            disablePositions,
            false,
            false,
            true,
            this.direction,
          );
          if (moves.length > 0) {
            let moveX = moves[0].pos.x;
            let moveY = moves[0].pos.y;
            let oldDir = this.direction;
            let player = this.targetPlayer;
            this.facePlayer(player);
            if (moveX > oldX) this.direction = Direction.RIGHT;
            else if (moveX < oldX) this.direction = Direction.LEFT;
            else if (moveY > oldY) this.direction = Direction.DOWN;
            else if (moveY < oldY) this.direction = Direction.UP;
            if (oldDir == this.direction) {
              let hitPlayer = false;
              for (const i in this.game.players) {
                if (
                  this.game.rooms[this.game.players[i].levelID] === this.room &&
                  this.game.players[i].x === moveX &&
                  this.game.players[i].y === moveY &&
                  oldDir == this.direction
                ) {
                  this.game.players[i].hurt(this.hit(), this.name);
                  this.drawX = 0.5 * (this.x - this.game.players[i].x);
                  this.drawY = 0.5 * (this.y - this.game.players[i].y);
                  if (
                    this.game.players[i] ===
                    this.game.players[this.game.localPlayerID]
                  )
                    this.game.shakeScreen(10 * this.drawX, 10 * this.drawY);
                }
              }
              if (!hitPlayer) {
                this.tryMove(moveX, moveY);
                this.setDrawXY(oldX, oldY);

                if (this.x > oldX) this.direction = Direction.RIGHT;
                else if (this.x < oldX) this.direction = Direction.LEFT;
                else if (this.y > oldY) this.direction = Direction.DOWN;
                else if (this.y < oldY) this.direction = Direction.UP;
              }
            }
          }

          if (this.direction == Direction.LEFT) {
            disablePositions.push({
              x: this.x,
              y: this.y + 1,
            } as astar.Position);
            disablePositions.push({
              x: this.x,
              y: this.y - 1,
            } as astar.Position);
          }
          if (this.direction == Direction.RIGHT) {
            disablePositions.push({
              x: this.x,
              y: this.y + 1,
            } as astar.Position);
            disablePositions.push({
              x: this.x,
              y: this.y - 1,
            } as astar.Position);
          }
          if (this.direction == Direction.DOWN) {
            disablePositions.push({
              x: this.x + 1,
              y: this.y,
            } as astar.Position);
            disablePositions.push({
              x: this.x - 1,
              y: this.y,
            } as astar.Position);
          }
          if (this.direction == Direction.UP) {
            disablePositions.push({
              x: this.x + 1,
              y: this.y,
            } as astar.Position);
            disablePositions.push({
              x: this.x - 1,
              y: this.y,
            } as astar.Position);
          }
          this.makeHitWarnings();
        }

        let targetPlayerOffline =
          Object.values(this.game.offlinePlayers).indexOf(this.targetPlayer) !==
          -1;
        if (!this.aggro || targetPlayerOffline) {
          let p = this.nearestPlayer();
          if (p !== false) {
            let [distance, player] = p;
            if (
              distance <= 4 &&
              (targetPlayerOffline ||
                distance < this.playerDistance(this.targetPlayer))
            ) {
              if (player !== this.targetPlayer) {
                this.targetPlayer = player;
                this.facePlayer(player);
                if (player === this.game.players[this.game.localPlayerID])
                  this.alertTicks = 1;
                this.makeHitWarnings();
              }
            }
          }
        }
      }
    }
  };

  draw = (delta: number) => {
    if (this.dead) return;
    Game.ctx.save();
    Game.ctx.globalAlpha = this.alpha;

    if (!this.dead) {
      this.updateDrawXY(delta);
      this.tileX = 27;
      this.tileY = 8;
      if (this.health <= 1 || this.dying) {
        this.tileX = 17;
        this.tileY = 8;
      }
      this.frame += 0.1 * delta;
      if (this.frame >= 4) this.frame = 0;

      if (this.hasShadow)
        Game.drawMob(
          0,
          0,
          1,
          1,
          this.x - this.drawX,
          this.y - this.drawY,
          1,
          1,
          this.room.shadeColor,
          this.shadeAmount(),
        );
      Game.drawMob(
        this.tileX + (this.tileX === 5 ? Math.floor(this.frame) : 0),
        this.tileY + this.direction * 2,
        1,
        2,
        this.x - this.drawX,
        this.y - this.drawYOffset - this.drawY,
        1,
        2,
        this.softShadeColor,
        this.shadeAmount(),
      );
    }
    if (!this.cloned) {
      if (!this.seenPlayer) {
        this.drawSleepingZs(delta);
      }
      if (this.alertTicks > 0) {
        this.drawExclamation(delta);
      }
    }
    Game.ctx.restore();
  };
}


--- src/entity/enemy/bigKnightEnemy.ts ---
import { Direction, Game } from "../../game";
import { Room } from "../../room";
import { Player } from "../../player";
import { HitWarning } from "../../hitWarning";
import { GenericParticle } from "../../particle/genericParticle";
import { Coin } from "../../item/coin";
import { RedGem } from "../../item/redgem";
import { Item } from "../../item/item";
import { Spear } from "../../weapon/spear";
import { GameConstants } from "../../gameConstants";
import { DeathParticle } from "../../particle/deathParticle";
import { Enemy } from "./enemy";
import { Random } from "../../random";

export class BigKnightEnemy extends Enemy {
  frame: number;
  ticks: number;
  seenPlayer: boolean;
  ticksSinceFirstHit: number;
  flashingFrame: number;
  targetPlayer: Player;
  aggro: boolean;
  readonly REGEN_TICKS = 5;
  drops: Array<Item>;
  static difficulty: number = 4;
  static tileX: number = 29;
  static tileY: number = 0;

  constructor(room: Room, game: Game, x: number, y: number, drop?: Item) {
    super(room, game, x, y);
    this.w = 2;
    this.h = 2;
    this.ticks = 0;
    this.frame = 0;
    this.health = 4;
    this.maxHealth = 4;
    this.tileX = 29;
    this.tileY = 0;
    this.seenPlayer = false;
    this.aggro = false;
    this.ticksSinceFirstHit = 0;
    this.flashingFrame = 0;
    this.deathParticleColor = "#ffffff";
    this.chainPushable = false;
    this.name = "giant knight";

    this.drops = [];
    if (drop) this.drops.push(drop);
    while (this.drops.length < 4) {
      let dropProb = Random.rand();
      if (dropProb < 0.005)
        this.drops.push(new Spear(this.room, this.x, this.y));
      else if (dropProb < 0.04)
        this.drops.push(new RedGem(this.room, this.x, this.y));
      else if (dropProb < 0.075)
        this.drops.push(new RedGem(this.room, this.x, this.y));
      else if (dropProb < 0.1)
        this.drops.push(new RedGem(this.room, this.x, this.y));
      else this.drops.push(new Coin(this.room, this.x, this.y));
    }
  }

  addHitWarnings = () => {
    this.room.hitwarnings.push(
      new HitWarning(this.game, this.x - 1, this.y, this.x, this.y),
    );
    this.room.hitwarnings.push(
      new HitWarning(this.game, this.x - 1, this.y + 1, this.x, this.y),
    );
    this.room.hitwarnings.push(
      new HitWarning(this.game, this.x + 2, this.y, this.x, this.y),
    );
    this.room.hitwarnings.push(
      new HitWarning(this.game, this.x + 2, this.y + 1, this.x, this.y),
    );
    this.room.hitwarnings.push(
      new HitWarning(this.game, this.x, this.y - 1, this.x, this.y),
    );
    this.room.hitwarnings.push(
      new HitWarning(this.game, this.x + 1, this.y - 1, this.x, this.y),
    );
    this.room.hitwarnings.push(
      new HitWarning(this.game, this.x, this.y + 2, this.x, this.y),
    );
    this.room.hitwarnings.push(
      new HitWarning(this.game, this.x + 1, this.y + 2, this.x, this.y),
    );
  };

  hit = (): number => {
    return 1;
  };

  behavior = () => {
    this.lastX = this.x;
    this.lastY = this.y;
    if (!this.dead) {
      if (this.skipNextTurns > 0) {
        this.skipNextTurns--;
        return;
      }
      if (this.health == 1) {
        this.ticksSinceFirstHit++;
        if (this.ticksSinceFirstHit >= this.REGEN_TICKS) {
          this.health++;
          this.ticksSinceFirstHit = 0;
        }
      } else {
        this.ticks++;
        if (!this.seenPlayer) {
          let p = this.nearestPlayer();
          if (p !== false) {
            let [distance, player] = p;
            if (distance <= 4) {
              this.targetPlayer = player;
              this.facePlayer(player);
              this.seenPlayer = true;
              if (player === this.game.players[this.game.localPlayerID])
                this.alertTicks = 1;
              if (this.health >= 3) this.addHitWarnings();
            }
          }
        } else if (this.seenPlayer) {
          if (this.room.playerTicked === this.targetPlayer) {
            this.alertTicks = Math.max(0, this.alertTicks - 1);
            let oldX = this.x;
            let oldY = this.y;
            let moveX = this.x;
            let moveY = this.y;
            if (this.ticks % 2 === 0) {
              // horizontal preference
              if (this.targetPlayer.x >= this.x + this.w) moveX++;
              else if (this.targetPlayer.x < this.x) moveX--;
              else if (this.targetPlayer.y >= this.y + this.h) moveY++;
              else if (this.targetPlayer.y < this.y) moveY--;
            } else {
              // vertical preference
              if (this.targetPlayer.y >= this.y + this.h) moveY++;
              else if (this.targetPlayer.y < this.y) moveY--;
              else if (this.targetPlayer.x >= this.x + this.w) moveX++;
              else if (this.targetPlayer.x < this.x) moveX--;
            }

            let hitPlayer = false;
            if (this.health >= 3) {
              let wouldHit = (player: Player, moveX: number, moveY: number) => {
                return (
                  player.x >= moveX &&
                  player.x < moveX + this.w &&
                  player.y >= moveY &&
                  player.y < moveY + this.h
                );
              };
              for (const i in this.game.players) {
                if (
                  this.game.rooms[this.game.players[i].levelID] === this.room &&
                  wouldHit(this.game.players[i], moveX, moveY)
                ) {
                  this.game.players[i].hurt(this.hit(), this.name);
                  this.drawX = 0.5 * (this.x - this.game.players[i].x);
                  this.drawY = 0.5 * (this.y - this.game.players[i].y);
                  if (
                    this.game.players[i] ===
                    this.game.players[this.game.localPlayerID]
                  )
                    this.game.shakeScreen(10 * this.drawX, 10 * this.drawY);
                }
              }
            }
            if (!hitPlayer) {
              this.tryMove(moveX, moveY);
              this.drawX = this.x - oldX;
              this.drawY = this.y - oldY;
              if (this.x > oldX) this.direction = Direction.RIGHT;
              else if (this.x < oldX) this.direction = Direction.LEFT;
              else if (this.y > oldY) this.direction = Direction.DOWN;
              else if (this.y < oldY) this.direction = Direction.UP;
            }

            if (this.health < this.maxHealth) {
              this.ticksSinceFirstHit++;
              if (this.ticksSinceFirstHit >= this.REGEN_TICKS) {
                this.health++;
                this.ticksSinceFirstHit = 0;
              }
            }

            if (this.health >= 3) this.addHitWarnings();
          }

          let targetPlayerOffline =
            Object.values(this.game.offlinePlayers).indexOf(
              this.targetPlayer,
            ) !== -1;
          if (!this.aggro || targetPlayerOffline) {
            let p = this.nearestPlayer();
            if (p !== false) {
              let [distance, player] = p;
              if (
                distance <= 4 &&
                (targetPlayerOffline ||
                  distance < this.playerDistance(this.targetPlayer))
              ) {
                if (player !== this.targetPlayer) {
                  this.targetPlayer = player;
                  this.facePlayer(player);
                  if (player === this.game.players[this.game.localPlayerID])
                    this.alertTicks = 1;
                  if (this.health >= 3) this.addHitWarnings();
                }
              }
            }
          }
        }
      }
    }
  };

  draw = (delta: number) => {
    if (this.dead) return;
    Game.ctx.save();
    Game.ctx.globalAlpha = this.alpha;
    if (!this.dead) {
      this.updateDrawXY(delta);
      this.frame += 0.1 * delta;
      if (this.frame >= 4) this.frame = 0;

      if (this.hasShadow)
        Game.drawMob(
          18,
          0,
          2,
          2,
          this.x - this.drawX,
          this.y - this.drawY,
          2,
          2,
          this.room.shadeColor,
          this.shadeAmount(),
        );
      Game.drawMob(
        2 * Math.floor((this.tileX + this.frame) / 2) + 1,
        this.tileY,
        2,
        4,
        this.x - this.drawX,
        this.y - 2.5 - this.drawY,
        2,
        4,
        this.softShadeColor,
        this.shadeAmount(),
      );

      if (!this.cloned) {
        if (!this.seenPlayer) {
          this.drawSleepingZs(
            delta,
            GameConstants.TILESIZE * 0.5,
            GameConstants.TILESIZE * -1,
          );
        }
        if (this.alertTicks > 0) {
          this.drawExclamation(
            delta,
            GameConstants.TILESIZE * 0.5,
            GameConstants.TILESIZE * -1,
          );
        }
      }
    }
    Game.ctx.restore();
  };

  drawTopLayer = (delta: number) => {
    this.drawableY = this.y;

    this.healthBar.draw(
      delta,
      this.health,
      this.maxHealth,
      this.x + 0.5,
      this.y,
      true,
    );
  };

  dropLoot = () => {
    let dropOffsets = [
      { x: 0, y: 0 },
      { x: 1, y: 0 },
      { x: 0, y: 1 },
      { x: 1, y: 1 },
    ];
    for (let i = 0; i < this.drops.length; i++) {
      this.drops[i].level = this.room;
      this.drops[i].x = this.x + dropOffsets[i].x;
      this.drops[i].y = this.y + dropOffsets[i].y;
      this.room.items.push(this.drops[i]);
    }
  };
}


--- src/entity/enemy/bigSkullEnemy.ts ---
import { Direction, Game } from "../../game";
import { Room } from "../../room";
import { Player } from "../../player";
import { HitWarning } from "../../hitWarning";
import { GenericParticle } from "../../particle/genericParticle";
import { Coin } from "../../item/coin";
import { RedGem } from "../../item/redgem";
import { Item } from "../../item/item";
import { Spear } from "../../weapon/spear";
import { GameConstants } from "../../gameConstants";
import { DeathParticle } from "../../particle/deathParticle";
import { Enemy } from "./enemy";
import { Random } from "../../random";

export class BigSkullEnemy extends Enemy {
  frame: number;
  ticks: number;
  seenPlayer: boolean;
  ticksSinceFirstHit: number;
  flashingFrame: number;
  targetPlayer: Player;
  aggro: boolean;
  readonly REGEN_TICKS = 5;
  drops: Array<Item>;
  static difficulty: number = 4;
  static tileX: number = 21;
  static tileY: number = 0;

  constructor(room: Room, game: Game, x: number, y: number, drop?: Item) {
    super(room, game, x, y);
    this.w = 2;
    this.h = 2;
    this.ticks = 0;
    this.frame = 0;
    this.health = 4;
    this.maxHealth = 4;
    this.tileX = 21;
    this.tileY = 0;
    this.seenPlayer = false;
    this.aggro = false;
    this.ticksSinceFirstHit = 0;
    this.flashingFrame = 0;
    this.deathParticleColor = "#ffffff";
    this.chainPushable = false;
    this.name = "giant skeleton";

    this.drops = [];
    if (drop) this.drops.push(drop);
    while (this.drops.length < 4) {
      let dropProb = Random.rand();
      if (dropProb < 0.005)
        this.drops.push(new Spear(this.room, this.x, this.y));
      else if (dropProb < 0.04)
        this.drops.push(new RedGem(this.room, this.x, this.y));
      else if (dropProb < 0.075)
        this.drops.push(new RedGem(this.room, this.x, this.y));
      else if (dropProb < 0.1)
        this.drops.push(new RedGem(this.room, this.x, this.y));
      else this.drops.push(new Coin(this.room, this.x, this.y));
    }
  }

  addHitWarnings = () => {
    this.room.hitwarnings.push(
      new HitWarning(this.game, this.x - 1, this.y, this.x, this.y),
    );
    this.room.hitwarnings.push(
      new HitWarning(this.game, this.x - 1, this.y + 1, this.x, this.y),
    );
    this.room.hitwarnings.push(
      new HitWarning(this.game, this.x + 2, this.y, this.x, this.y),
    );
    this.room.hitwarnings.push(
      new HitWarning(this.game, this.x + 2, this.y + 1, this.x, this.y),
    );
    this.room.hitwarnings.push(
      new HitWarning(this.game, this.x, this.y - 1, this.x, this.y),
    );
    this.room.hitwarnings.push(
      new HitWarning(this.game, this.x + 1, this.y - 1, this.x, this.y),
    );
    this.room.hitwarnings.push(
      new HitWarning(this.game, this.x, this.y + 2, this.x, this.y),
    );
    this.room.hitwarnings.push(
      new HitWarning(this.game, this.x + 1, this.y + 2, this.x, this.y),
    );
  };

  hit = (): number => {
    return 1;
  };

  behavior = () => {
    this.lastX = this.x;
    this.lastY = this.y;
    if (!this.dead) {
      if (this.skipNextTurns > 0) {
        this.skipNextTurns--;
        return;
      }
      if (this.health <= 2) {
        this.ticksSinceFirstHit++;
        if (this.ticksSinceFirstHit >= this.REGEN_TICKS) {
          this.health++;
          this.ticksSinceFirstHit = 0;
        }
        this.ticks++;
      } else {
        this.ticks++;
        if (!this.seenPlayer) {
          let p = this.nearestPlayer();
          if (p !== false) {
            let [distance, player] = p;
            if (distance <= 4) {
              this.targetPlayer = player;
              this.facePlayer(player);
              this.seenPlayer = true;
              if (player === this.game.players[this.game.localPlayerID])
                this.alertTicks = 1;
              if (this.health >= 3) this.addHitWarnings();
            }
          }
        } else if (this.seenPlayer) {
          if (this.room.playerTicked === this.targetPlayer) {
            this.alertTicks = Math.max(0, this.alertTicks - 1);
            let oldX = this.x;
            let oldY = this.y;
            let moveX = this.x;
            let moveY = this.y;
            if (this.ticks % 2 === 0) {
              // horizontal preference
              if (this.targetPlayer.x >= this.x + this.w) moveX++;
              else if (this.targetPlayer.x < this.x) moveX--;
              else if (this.targetPlayer.y >= this.y + this.h) moveY++;
              else if (this.targetPlayer.y < this.y) moveY--;
            } else {
              // vertical preference
              if (this.targetPlayer.y >= this.y + this.h) moveY++;
              else if (this.targetPlayer.y < this.y) moveY--;
              else if (this.targetPlayer.x >= this.x + this.w) moveX++;
              else if (this.targetPlayer.x < this.x) moveX--;
            }

            let hitPlayer = false;
            if (this.health >= 2.5) {
              let wouldHit = (player: Player, moveX: number, moveY: number) => {
                return (
                  player.x >= moveX &&
                  player.x < moveX + this.w &&
                  player.y >= moveY &&
                  player.y < moveY + this.h
                );
              };
              for (const i in this.game.players) {
                if (
                  this.game.rooms[this.game.players[i].levelID] === this.room &&
                  wouldHit(this.game.players[i], moveX, moveY)
                ) {
                  this.game.players[i].hurt(this.hit(), this.name);
                  this.drawX = 0.5 * (this.x - this.game.players[i].x);
                  this.drawY = 0.5 * (this.y - this.game.players[i].y);
                  if (
                    this.game.players[i] ===
                    this.game.players[this.game.localPlayerID]
                  )
                    this.game.shakeScreen(10 * this.drawX, 10 * this.drawY);
                }
              }
            }
            if (!hitPlayer) {
              this.tryMove(moveX, moveY);
              this.drawX = this.x - oldX;
              this.drawY = this.y - oldY;
              if (this.x > oldX) this.direction = Direction.RIGHT;
              else if (this.x < oldX) this.direction = Direction.LEFT;
              else if (this.y > oldY) this.direction = Direction.DOWN;
              else if (this.y < oldY) this.direction = Direction.UP;
            }

            if (this.health < this.maxHealth) {
              this.ticksSinceFirstHit++;
              if (this.ticksSinceFirstHit >= this.REGEN_TICKS) {
                this.health++;
                this.ticksSinceFirstHit = 0;
              }
            }

            if (this.health >= 2.5) this.addHitWarnings();
          }

          let targetPlayerOffline =
            Object.values(this.game.offlinePlayers).indexOf(
              this.targetPlayer,
            ) !== -1;
          if (!this.aggro || targetPlayerOffline) {
            let p = this.nearestPlayer();
            if (p !== false) {
              let [distance, player] = p;
              if (
                distance <= 4 &&
                (targetPlayerOffline ||
                  distance < this.playerDistance(this.targetPlayer))
              ) {
                if (player !== this.targetPlayer) {
                  this.targetPlayer = player;
                  this.facePlayer(player);
                  if (player === this.game.players[this.game.localPlayerID])
                    this.alertTicks = 1;
                  if (this.health >= 3) this.addHitWarnings();
                }
              }
            }
          }
        }
      }
    }
  };

  draw = (delta: number) => {
    if (this.dead) return;
    Game.ctx.save();
    Game.ctx.globalAlpha = this.alpha;
    if (!this.dead) {
      this.updateDrawXY(delta);
      this.tileX = 21;
      this.tileY = 0;
      if (this.health === 3) {
        this.tileX = 21;
        this.tileY = 4;
        if (this.ticksSinceFirstHit >= 3) {
          this.flashingFrame += 0.1 * delta;
          if (Math.floor(this.flashingFrame) % 2 === 0) {
            this.tileY = 0;
          }
        }
      } else if (this.health === 2) {
        this.tileX = 21;
        this.tileY = 8;
        if (this.ticksSinceFirstHit >= 3) {
          this.flashingFrame += 0.1 * delta;
          if (Math.floor(this.flashingFrame) % 2 === 0) {
            this.tileY = 4;
          }
        }
      } else if (this.health === 1) {
        this.tileX = 21;
        this.tileY = 12;
        if (this.ticksSinceFirstHit >= 3) {
          this.flashingFrame += 0.1 * delta;
          if (Math.floor(this.flashingFrame) % 2 === 0) {
            this.tileY = 8;
          }
        }
      }

      this.frame += 0.1 * delta;
      if (this.frame >= 4) this.frame = 0;

      if (this.hasShadow)
        Game.drawMob(
          18,
          0,
          2,
          2,
          this.x - this.drawX,
          this.y - this.drawY,
          2,
          2,
          this.room.shadeColor,
          this.shadeAmount(),
        );
      Game.drawMob(
        this.tileX + (this.tileX === 20 ? Math.floor(this.frame) * 2 : 0),
        this.tileY,
        2,
        4,
        this.x - this.drawX,
        this.y - 2.5 - this.drawY,
        2,
        4,
        this.softShadeColor,
        this.shadeAmount(),
      );
      if (!this.cloned) {
        if (!this.seenPlayer) {
          this.drawSleepingZs(
            delta,
            GameConstants.TILESIZE * 0.5,
            GameConstants.TILESIZE * -1,
          );
        }
        if (this.alertTicks > 0) {
          this.drawExclamation(
            delta,
            GameConstants.TILESIZE * 0.5,
            GameConstants.TILESIZE * -1,
          );
        }
      }
    }
    Game.ctx.restore();
  };

  drawTopLayer = (delta: number) => {
    this.drawableY = this.y;

    this.healthBar.draw(
      delta,
      this.health,
      this.maxHealth,
      this.x + 0.5,
      this.y,
      true,
    );
  };

  dropLoot = () => {
    let dropOffsets = [
      { x: 0, y: 0 },
      { x: 1, y: 0 },
      { x: 0, y: 1 },
      { x: 1, y: 1 },
    ];
    for (let i = 0; i < this.drops.length; i++) {
      this.drops[i].level = this.room;
      this.drops[i].x = this.x + dropOffsets[i].x;
      this.drops[i].y = this.y + dropOffsets[i].y;
      this.room.items.push(this.drops[i]);
    }
  };
}


--- src/entity/enemy/bishopEnemy.ts ---
import { Entity, EntityDirection } from "../entity";
import { Game } from "../../game";
import { Room } from "../../room";
import { Player } from "../../player";
import { Item } from "../../item/item";
import { astar } from "../../astarclass";
import { SpikeTrap } from "../../tile/spiketrap";
import { Door } from "../../tile/door";
import { Enemy } from "./enemy";

export class BishopEnemy extends Enemy {
  frame: number;
  ticks: number;
  seenPlayer: boolean;
  aggro: boolean;
  targetPlayer: Player;
  drop: Item;
  static difficulty: number = 2;
  static tileX: number = 31;
  static tileY: number = 8;
  constructor(room: Room, game: Game, x: number, y: number, drop?: Item) {
    super(room, game, x, y);
    this.ticks = 0;
    this.frame = 0;
    this.health = 1;
    this.maxHealth = 1;
    this.tileX = 31;
    this.tileY = 8;
    this.seenPlayer = false;
    this.aggro = false;
    this.name = "bishop";
    this.jumpHeight = 1;
    this.drawMoveSpeed = 0.2;
    this.diagonalAttackRange = 1;
    this.diagonalAttack = true;
    this.orthogonalAttack = false;
    this.imageParticleX = 0;
    this.imageParticleY = 26;
    if (drop) this.drop = drop;
    if (Random.rand() < this.dropChance) {
      this.getDrop([
        "weapon",
        "equipment",
        "consumable",
        "gem",
        "tool",
        "coin",
      ]);
    }
  }

  tryMove = (x: number, y: number) => {
    let pointWouldBeIn = (someX: number, someY: number): boolean => {
      return (
        someX >= x && someX < x + this.w && someY >= y && someY < y + this.h
      );
    };
    let enemyCollide = (enemy: Entity): boolean => {
      if (enemy.x >= x + this.w || enemy.x + enemy.w <= x) return false;
      if (enemy.y >= y + this.h || enemy.y + enemy.h <= y) return false;
      return true;
    };
    for (const e of this.room.entities) {
      if (e !== this && enemyCollide(e)) {
        return;
      }
    }
    for (const i in this.game.players) {
      if (pointWouldBeIn(this.game.players[i].x, this.game.players[i].y)) {
        return;
      }
    }
    let tiles = [];
    for (let xx = 0; xx < this.w; xx++) {
      for (let yy = 0; yy < this.h; yy++) {
        if (!this.room.roomArray[x + xx][y + yy].isSolid()) {
          tiles.push(this.room.roomArray[x + xx][y + yy]);
        } else {
          return;
        }
      }
    }
    for (let tile of tiles) {
      tile.onCollideEnemy(this);
    }
    this.x = x;
    this.y = y;
  };

  hit = (): number => {
    return 1;
  };

  jump = (delta: number) => {
    let j = Math.max(Math.abs(this.drawX), Math.abs(this.drawY));

    let jumpY = Math.abs(Math.sin(j * Math.PI)) * this.jumpHeight;
    if (jumpY < 0.01) jumpY = 0;
    if (jumpY > this.jumpHeight) jumpY = this.jumpHeight;
    this.jumpY = jumpY;
  };

  behavior = () => {
    if (!this.dead) {
      if (this.skipNextTurns > 0) {
        this.skipNextTurns--;
        return;
      }
      this.ticks++;
      if (!this.seenPlayer) this.lookForPlayer();
      else if (this.seenPlayer) {
        if (this.room.playerTicked === this.targetPlayer) {
          this.alertTicks = Math.max(0, this.alertTicks - 1);
          let oldX = this.x;
          let oldY = this.y;

          let disablePositions = Array<astar.Position>();
          for (const e of this.room.entities) {
            if (e !== this) {
              disablePositions.push({ x: e.x, y: e.y } as astar.Position);
            }
          }
          for (let xx = this.x - 1; xx <= this.x + 1; xx++) {
            for (let yy = this.y - 1; yy <= this.y + 1; yy++) {
              if (
                this.room.roomArray[xx][yy] instanceof SpikeTrap &&
                (this.room.roomArray[xx][yy] as SpikeTrap).on
              ) {
                // don't walk on active spiketraps
                disablePositions.push({ x: xx, y: yy } as astar.Position);
              }
              if (this.room.roomArray[xx][yy] instanceof Door) {
                // don't walk into doorways (normally wouldn't be an issue without diagonals)
                disablePositions.push({ x: xx, y: yy } as astar.Position);
              }
            }
          }
          let grid = [];
          for (let x = 0; x < this.room.roomX + this.room.width; x++) {
            grid[x] = [];
            for (let y = 0; y < this.room.roomY + this.room.height; y++) {
              if (this.room.roomArray[x] && this.room.roomArray[x][y])
                grid[x][y] = this.room.roomArray[x][y];
              else grid[x][y] = false;
            }
          }
          disablePositions.push({ x: this.x + 1, y: this.y } as astar.Position);
          disablePositions.push({ x: this.x - 1, y: this.y } as astar.Position);
          disablePositions.push({ x: this.x, y: this.y + 1 } as astar.Position);
          disablePositions.push({ x: this.x, y: this.y - 1 } as astar.Position);
          disablePositions.push({ x: this.x, y: this.y } as astar.Position);
          let moves = astar.AStar.search(
            grid,
            this,
            this.targetPlayer,
            disablePositions,
            true, //diagonals
          );
          moves = moves.filter((move) => {
            const dx = Math.abs(move.pos.x - this.x);
            const dy = Math.abs(move.pos.y - this.y);
            return dx === 1 && dy === 1;
          });
          if (moves.length > 0) {
            let moveX = moves[0].pos.x;
            let moveY = moves[0].pos.y;
            let hitPlayer = false;
            for (const i in this.game.players) {
              if (
                this.game.rooms[this.game.players[i].levelID] === this.room &&
                this.game.players[i].x === moveX &&
                this.game.players[i].y === moveY
              ) {
                this.game.players[i].hurt(this.hit(), this.name);
                this.drawX = 0.5 * (this.x - this.game.players[i].x);
                this.drawY = 0.5 * (this.y - this.game.players[i].y);
                hitPlayer = true;
                if (
                  this.game.players[i] ===
                  this.game.players[this.game.localPlayerID]
                )
                  this.game.shakeScreen(10 * this.drawX, 10 * this.drawY);
              }
            }
            if (!hitPlayer) {
              this.tryMove(moveX, moveY);
              this.setDrawXY(oldX, oldY);
            }
          }
          this.makeHitWarnings();
        }

        let targetPlayerOffline =
          Object.values(this.game.offlinePlayers).indexOf(this.targetPlayer) !==
          -1;
        if (!this.aggro || targetPlayerOffline) {
          let p = this.nearestPlayer();
          if (p !== false) {
            let [distance, player] = p;
            if (
              distance <= 4 &&
              (targetPlayerOffline ||
                distance < this.playerDistance(this.targetPlayer))
            ) {
              if (player !== this.targetPlayer) {
                this.targetPlayer = player;
                this.facePlayer(player);
                if (player === this.game.players[this.game.localPlayerID])
                  this.alertTicks = 1;
                this.makeHitWarnings();
              }
            }
          }
        }
      }
    }
  };

  draw = (delta: number) => {
    if (this.dead) return;
    Game.ctx.save();
    Game.ctx.globalAlpha = this.alpha;
    if (!this.dead) {
      this.updateDrawXY(delta);
      this.frame += 0.1 * delta;
      if (this.frame >= 4) this.frame = 0;

      if (this.hasShadow)
        Game.drawMob(
          0,
          0,
          1,
          1,
          this.x - this.drawX,
          this.y - this.drawY,
          1,
          1,
          this.room.shadeColor,
          this.shadeAmount(),
        );
      Game.drawMob(
        this.tileX + Math.floor(this.frame),
        this.tileY,
        1,
        2,
        this.x - this.drawX,
        this.y - this.drawYOffset - this.drawY - this.jumpY,
        1,
        2,
        this.softShadeColor,
        this.shadeAmount() * (1 + this.jumpY / 3),
      );
    }
    if (!this.cloned) {
      if (!this.seenPlayer) {
        this.drawSleepingZs(delta);
      }
      if (this.alertTicks > 0) {
        this.drawExclamation(delta);
      }
    }
    Game.ctx.restore();
  };
}


--- src/entity/enemy/chargeEnemy.ts ---
import { Direction, Game } from "../../game";
import { Room } from "../../room";
import { HitWarning } from "../../hitWarning";
import { Door } from "../../tile/door";
import { GenericParticle } from "../../particle/genericParticle";
import { GameConstants } from "../../gameConstants";
import { Item } from "../../item/item";
import { Enemy } from "./enemy";

export enum ChargeEnemyState {
  IDLE,
  ALERTED,
  CHARGING,
}

export class ChargeEnemy extends Enemy {
  startX: number;
  startY: number;
  targetX: number;
  targetY: number;
  visualTargetX: number;
  visualTargetY: number;
  ticks: number;
  frame: number;
  state: ChargeEnemyState;
  trailFrame: number;
  drop: Item;
  static difficulty: number = 3;
  static tileX: number = 13;
  static tileY: number = 8;

  constructor(room: Room, game: Game, x: number, y: number, drop?: Item) {
    super(room, game, x, y);
    this.ticks = 0;
    this.frame = 0;
    this.health = 1;
    this.maxHealth = 1;
    this.tileX = 13;
    this.tileY = 8;
    this.trailFrame = 0;
    this.alertTicks = 0;
    this.deathParticleColor = "#ffffff";
    this.lastX = this.x;
    this.lastY = this.y;
    this.name = "charge knight";

    this.state = ChargeEnemyState.IDLE;
    if (drop) this.drop = drop;
    if (Random.rand() < this.dropChance) {
      this.getDrop([
        "weapon",
        "equipment",
        "consumable",
        "gem",
        "tool",
        "coin",
      ]);
    }
  }

  hit = (): number => {
    return 1;
  };

  canMoveOver = (x: number, y: number): boolean => {
    for (const e of this.room.entities) {
      if (e !== this && x === e.x && y === e.y) return false;
    }
    let t = this.room.roomArray[x][y];
    return !(t.isSolid() || t instanceof Door);
  };

  behavior = () => {
    this.lastX = this.x;
    this.lastY = this.y;
    if (!this.dead) {
      if (this.skipNextTurns > 0) {
        this.skipNextTurns--;
        return;
      }
      this.ticks++;
      if (this.state === ChargeEnemyState.IDLE) {
        let blocked = false;
        let dx = 0;
        let dy = 0;
        for (const i in this.game.players) {
          if (this.x === this.game.players[i].x) {
            if (this.y < this.game.players[i].y) dy = 1;
            else dy = -1;
            for (let yy = this.y; yy !== this.game.players[i].y; yy += dy) {
              if (!this.canMoveOver(this.x, yy)) blocked = true;
            }
          } else if (this.y === this.game.players[i].y) {
            if (this.x < this.game.players[i].x) dx = 1;
            else dx = -1;
            for (let xx = this.x; xx !== this.game.players[i].x; xx += dx) {
              if (!this.canMoveOver(xx, this.y)) blocked = true;
            }
          }
          if ((dx !== 0 || dy !== 0) && !blocked) {
            this.state = ChargeEnemyState.ALERTED;
            this.targetX = this.x;
            this.targetY = this.y;
            while (this.canMoveOver(this.targetX + dx, this.targetY + dy)) {
              this.targetX += dx;
              this.targetY += dy;
              if (
                (this.targetX === this.game.players[i].x &&
                  this.targetY === this.game.players[i].y) ||
                (this.targetX === this.game.players[i].x - 1 &&
                  this.targetY === this.game.players[i].y) ||
                (this.targetX === this.game.players[i].x + 1 &&
                  this.targetY === this.game.players[i].y) ||
                (this.targetX === this.game.players[i].x &&
                  this.targetY === this.game.players[i].y - 1) ||
                (this.targetX === this.game.players[i].x &&
                  this.targetY === this.game.players[i].y + 1)
              )
                this.room.hitwarnings.push(
                  new HitWarning(
                    this.game,
                    this.targetX,
                    this.targetY,
                    this.x,
                    this.y,
                  ),
                );
            }
            this.visualTargetX = this.targetX + 0.5 * dx;
            this.visualTargetY = this.targetY + 0.5 * dy;
            if (dy === 1) this.visualTargetY += 0.65;
            if (dx > 0) this.direction = Direction.RIGHT;
            else if (dx < 0) this.direction = Direction.LEFT;
            else if (dy < 0) this.direction = Direction.UP;
            else if (dy > 0) this.direction = Direction.DOWN;
            break;
          }
        }
      } else if (this.state === ChargeEnemyState.ALERTED) {
        this.state = ChargeEnemyState.CHARGING;
        this.trailFrame = 0;

        for (const i in this.game.players) {
          if (
            (this.y === this.game.players[i].y &&
              ((this.x < this.game.players[i].x &&
                this.game.players[i].x <= this.targetX) ||
                (this.targetX <= this.game.players[i].x &&
                  this.game.players[i].x < this.x))) ||
            (this.x === this.game.players[i].x &&
              ((this.y < this.game.players[i].y &&
                this.game.players[i].y <= this.targetY) ||
                (this.targetY <= this.game.players[i].y &&
                  this.game.players[i].y < this.y)))
          ) {
            this.game.players[i].hurt(this.hit(), this.name);
          }
        }

        this.startX = this.x;
        this.startY = this.y;
        this.drawX = this.targetX - this.x;
        this.drawY = this.targetY - this.y;
        this.x = this.targetX;
        this.y = this.targetY;
      } else if (this.state === ChargeEnemyState.CHARGING) {
        this.state = ChargeEnemyState.IDLE;
      }
    }
  };

  draw = (delta: number) => {
    if (this.dead) return;
    Game.ctx.save();
    Game.ctx.globalAlpha = this.alpha;

    if (!this.dead) {
      this.updateDrawXY(delta);
      this.frame += 0.1 * delta;
      if (this.frame >= 4) this.frame = 0;

      if (
        (this.state === ChargeEnemyState.CHARGING &&
          Math.abs(this.drawX) > 0.1) ||
        Math.abs(this.drawY) > 0.1
      ) {
        GenericParticle.spawnCluster(
          this.room,
          this.x - this.drawX + 0.5,
          this.y - this.drawY + 0.5,
          "black",
        );
        GenericParticle.spawnCluster(
          this.room,
          this.x - this.drawX + 0.5,
          this.y - this.drawY + 0.5,
          "white",
        );
      }

      if (this.state === ChargeEnemyState.CHARGING) {
        this.trailFrame += 0.01 * delta;
        let t = this.trailFrame;

        if (t >= 0 && t <= 1) {
          Game.ctx.strokeStyle = "white";
          if (GameConstants.ALPHA_ENABLED) Game.ctx.globalAlpha = 1 - t;
          Game.ctx.lineWidth = GameConstants.TILESIZE * 0.25;
          Game.ctx.beginPath();
          Game.ctx.moveTo(
            (this.startX + 0.5) * GameConstants.TILESIZE,
            (this.startY + 0.5) * GameConstants.TILESIZE,
          );
          Game.ctx.lineCap = "round";
          Game.ctx.lineTo(
            (this.x - this.drawX + 0.5) * GameConstants.TILESIZE,
            (this.y - this.drawY + 0.5) * GameConstants.TILESIZE,
          );
          Game.ctx.stroke();
          Game.ctx.globalAlpha = 1;
        }
      }

      if (this.hasShadow)
        Game.drawMob(
          0,
          0,
          1,
          1,
          this.x - this.drawX,
          this.y - this.drawY,
          1,
          1,
          this.room.shadeColor,
          this.shadeAmount(),
        );
      Game.drawMob(
        this.tileX + Math.floor(this.frame),
        this.tileY + this.direction * 2,
        1,
        2,
        this.x - this.drawX,
        this.y - this.drawYOffset - this.drawY,
        1,
        2,
        this.softShadeColor,
        this.shadeAmount(),
      );
      if (!this.cloned) {
        if (this.state === ChargeEnemyState.IDLE) {
          this.drawSleepingZs(delta);
        } else if (this.state === ChargeEnemyState.ALERTED) {
          this.drawExclamation(delta);
        }
      }
    }
    Game.ctx.restore();
  };

  drawTopLayer = (delta: number) => {
    if (this.dying) return;
    this.drawableY = this.y;

    this.healthBar.draw(
      delta,
      this.health,
      this.maxHealth,
      this.x,
      this.y,
      true,
    );
    this.drawX += -0.1 * this.drawX;
    this.drawY += -0.1 * this.drawY;

    if (this.state === ChargeEnemyState.ALERTED) {
      this.trailFrame += 0.4 * delta;

      if (Math.floor(this.trailFrame) % 2 === 0) {
        let startX = (this.x + 0.5) * GameConstants.TILESIZE;
        let startY = (this.y - 0.25) * GameConstants.TILESIZE;
        if (this.direction === Direction.LEFT) startX -= 3;
        else if (this.direction === Direction.RIGHT) startX += 3;
        else if (this.direction === Direction.DOWN) startY += 2;
        else if (this.direction === Direction.UP) startY -= 8;

        Game.ctx.strokeStyle = "white";
        Game.ctx.lineWidth = GameConstants.TILESIZE * 0.25;
        Game.ctx.beginPath();
        Game.ctx.moveTo(Math.round(startX), Math.round(startY));
        Game.ctx.lineCap = "round";
        Game.ctx.lineTo(
          Math.round((this.visualTargetX + 0.5) * GameConstants.TILESIZE),
          Math.round((this.visualTargetY - 0.25) * GameConstants.TILESIZE),
        );
        Game.ctx.stroke();
        Game.ctx.globalAlpha = 1;
      }
    }
  };
}


--- src/entity/enemy/crabEnemy.ts ---
import { Direction, Game } from "../../game";
import { Room } from "../../room";
import { astar } from "../../astarclass";
import { SpikeTrap } from "../../tile/spiketrap";
import { Player } from "../../player";
import { Item } from "../../item/item";
import { GameConstants } from "../../gameConstants";
import { Enemy } from "./enemy";
import { Utils } from "../../utils";

export class CrabEnemy extends Enemy {
  ticks: number;
  frame: number;
  seenPlayer: boolean;
  aggro: boolean;
  targetPlayer: Player;
  drop: Item;
  static difficulty: number = 1;
  static tileX: number = 8;
  static tileY: number = 4;

  constructor(room: Room, game: Game, x: number, y: number, drop?: Item) {
    super(room, game, x, y);
    this.ticks = 0;
    this.frame = 0;
    this.health = 1;
    this.maxHealth = 1;
    this.tileX = 8;
    this.tileY = 4;
    this.seenPlayer = false;
    this.aggro = false;
    this.name = "crab";
    this.orthogonalAttack = true;
    this.imageParticleX = 3;
    this.imageParticleY = 24;
    //if (drop) this.drop = drop;
    this.drawYOffset = 0.175;
    if (Random.rand() < this.dropChance) {
      this.getDrop([
        "weapon",
        "equipment",
        "consumable",
        "gem",
        "tool",
        "coin",
      ]);
    }
  }

  get alertText() {
    return `New Enemy Spotted: Crab 
    Health: ${this.health}
    Attack Pattern: Omnidirectional
    Moves every other turn`;
  }

  hit = (): number => {
    return 1;
  };

  behavior = () => {
    this.lastX = this.x;
    this.lastY = this.y;

    if (!this.dead) {
      if (this.skipNextTurns > 0) {
        this.skipNextTurns--;
        return;
      }
      if (!this.seenPlayer) this.lookForPlayer();
      else if (this.seenPlayer) {
        if (this.room.playerTicked === this.targetPlayer) {
          this.alertTicks = Math.max(0, this.alertTicks - 1);
          this.ticks++;
          if (this.ticks % 2 === 1) {
            this.rumbling = true;
            let oldX = this.x;
            let oldY = this.y;
            let disablePositions = Array<astar.Position>();

            for (const e of this.room.entities) {
              if (e !== this) {
                disablePositions.push({ x: e.x, y: e.y } as astar.Position);
              }
            }

            for (let xx = this.x - 1; xx <= this.x + 1; xx++) {
              for (let yy = this.y - 1; yy <= this.y + 1; yy++) {
                if (
                  this.room.roomArray[xx][yy] instanceof SpikeTrap &&
                  (this.room.roomArray[xx][yy] as SpikeTrap).on
                ) {
                  // don't walk on active spiketraps
                  disablePositions.push({ x: xx, y: yy } as astar.Position);
                }
              }
            }

            let grid = [];
            for (let x = 0; x < this.room.roomX + this.room.width; x++) {
              grid[x] = [];
              for (let y = 0; y < this.room.roomY + this.room.height; y++) {
                if (this.room.roomArray[x] && this.room.roomArray[x][y])
                  grid[x][y] = this.room.roomArray[x][y];
                else grid[x][y] = false;
              }
            }
            this.target =
              this.getAverageLuminance() > 0 // 0.8
                ? this.targetPlayer
                : this.room.getExtremeLuminanceFromPoint(this.x, this.y)
                    .darkest;
            let moves = astar.AStar.search(
              grid,
              this,
              this.target,
              disablePositions,
              undefined,
              undefined,
              undefined,
              undefined,
              undefined,
              undefined,
              this.lastPlayerPos,
            );
            if (moves.length > 0) {
              let hitPlayer = false;
              for (const i in this.game.players) {
                if (
                  this.game.rooms[this.game.players[i].levelID] === this.room &&
                  this.game.players[i].x === moves[0].pos.x &&
                  this.game.players[i].y === moves[0].pos.y
                ) {
                  this.game.players[i].hurt(this.hit(), this.name);
                  this.drawX = 0.5 * (this.x - this.game.players[i].x);
                  this.drawY = 0.5 * (this.y - this.game.players[i].y);
                  if (
                    this.game.players[i] ===
                    this.game.players[this.game.localPlayerID]
                  )
                    this.game.shakeScreen(10 * this.drawX, 10 * this.drawY);
                  hitPlayer = true;
                }
              }

              if (!hitPlayer) {
                this.tryMove(moves[0].pos.x, moves[0].pos.y);
                this.setDrawXY(oldX, oldY);
                if (this.x > oldX) this.direction = Direction.RIGHT;
                else if (this.x < oldX) this.direction = Direction.LEFT;
                else if (this.y > oldY) this.direction = Direction.DOWN;
                else if (this.y < oldY) this.direction = Direction.UP;
              }
            }
            this.rumbling = false;
          } else {
            this.rumbling = true;
            /*
            if (
              (this.target.x === this.targetPlayer.x &&
                this.target.y === this.targetPlayer.y) ||
              Utils.distance(
                this.targetPlayer.x,
                this.targetPlayer.y,
                this.x,
                this.y,
              ) <= 2
            )
              */ {
              this.makeHitWarnings();
            }
          }
        }

        let targetPlayerOffline =
          Object.values(this.game.offlinePlayers).indexOf(this.targetPlayer) !==
          -1;
        if (!this.aggro || targetPlayerOffline) {
          let p = this.nearestPlayer();
          if (p !== false) {
            let [distance, player] = p;
            if (
              distance <= 4 &&
              (targetPlayerOffline ||
                distance < this.playerDistance(this.targetPlayer))
            ) {
              if (player !== this.targetPlayer) {
                this.targetPlayer = player;
                this.facePlayer(player);
                if (player === this.game.players[this.game.localPlayerID])
                  this.alertTicks = 1;
                if (this.ticks % 2 === 0) {
                  /*
                  if (
                    (this.target.x === this.targetPlayer.x &&
                      this.target.y === this.targetPlayer.y) ||
                    Utils.distance(
                      this.targetPlayer.x,
                      this.targetPlayer.y,
                      this.x,
                      this.y,
                    ) <= 2
                  ) */ {
                    this.makeHitWarnings();
                  }
                }
              }
            }
          }
        }
      }
    }
  };

  draw = (delta: number) => {
    if (this.dead) return;
    Game.ctx.save();
    Game.ctx.globalAlpha = this.alpha;

    if (!this.dead) {
      this.updateDrawXY(delta);
      if (this.ticks % 2 === 0) {
        this.tileX = 9;
        this.tileY = 4;
      } else {
        this.tileX = 8;
        this.tileY = 4;
      }
      let rumbleX = this.rumble(this.rumbling, this.frame, this.direction).x;
      let rumbleY = this.rumble(this.rumbling, this.frame, this.direction).y;
      this.frame += 0.1 * delta;
      if (this.frame >= 4) this.frame = 0;
      if (this.hasShadow)
        Game.drawMob(
          0,
          0,
          1,
          1,
          this.x - this.drawX,
          this.y - 0.25 - this.drawY,
          1,
          1,
          this.room.shadeColor,
          this.shadeAmount(),
        );
      Game.drawMob(
        this.tileX,
        this.tileY + this.direction,
        1,
        1,
        this.x - this.drawX + rumbleX,
        this.y - this.drawYOffset - this.drawY + rumbleY,
        1 * this.crushX,
        1 * this.crushY,
        this.softShadeColor,
        this.shadeAmount(),
      );
      if (this.crushed) {
        this.crushAnim(delta);
      }
    }
    if (!this.cloned) {
      if (!this.seenPlayer) {
        this.drawSleepingZs(delta, 0, 0.75 * GameConstants.TILESIZE);
      }
      if (this.alertTicks > 0) {
        this.drawExclamation(delta, 0, 0.75 * GameConstants.TILESIZE);
      }
    }
    Game.ctx.restore();
  };
}


--- src/entity/enemy/enemy.ts ---
import { Entity, EntityDirection } from "../entity";
import { Direction, Game } from "../../game";
import { Room } from "../../room";
import { Player } from "../../player";
import { Item } from "../../item/item";
import { astar } from "../../astarclass";
import { SpikeTrap } from "../../tile/spiketrap";
import { EntityType } from "../entity";
import { ImageParticle } from "../../particle/imageParticle";
import { globalEventBus } from "../../eventBus";
import { Sound } from "../../sound";

enum EnemyState {
  SLEEP,
  AGGRO,
  ATTACK,
  DEAD,
  IDLE,
}

interface EnemyStatus {
  poison: {
    active: boolean;
    hitCount: number;
    startTick: number;
    effectTick: number;
  };
  bleed: {
    active: boolean;
    hitCount: number;
    startTick: number;
    effectTick: number;
  };
}

export abstract class Enemy extends Entity {
  seenPlayer: boolean;
  heardPlayer: boolean;
  frame: number;
  ticks: number;
  aggro: boolean;
  targetPlayer: Player;
  drop: Item;
  status: EnemyStatus;
  protected jumpY: number;
  protected jumpHeight: number;
  static difficulty: number = 1;
  private effectStartTick: number;
  private startTick: number;
  private poisonHitCount;
  private bleedHitCount;

  constructor(room: Room, game: Game, x: number, y: number) {
    super(room, game, x, y);
    this.drawYOffset = 1.5;
    this.name = "";
    this.seenPlayer = false;
    this.heardPlayer = false;
    this.ticks = 0;
    this.frame = 0;
    this.health = 1;
    this.maxHealth = 1;
    this.tileX = 17;
    this.tileY = 8;
    this.aggro = false;
    this.jumpY = 0;
    this.jumpHeight = 0.3;
    //this.dir = Direction.South;
    this.name = "generic enemy";
    this.dropChance = 0.1;
    this.status = {
      poison: { active: false, hitCount: 0, startTick: 0, effectTick: 0 },
      bleed: { active: false, hitCount: 0, startTick: 0, effectTick: 0 },
    };
    this.effectStartTick = 1;
    this.startTick = 1;
    this.isEnemy = true;
    this.poisonHitCount = 0;
    this.bleedHitCount = 0;
    //this.getDrop(["weapon", "equipment", "consumable", "gem", "tool", "coin"]);
  }

  readonly tryMove = (x: number, y: number, collide: boolean = true) => {
    let pointWouldBeIn = (someX: number, someY: number): boolean => {
      return (
        someX >= x && someX < x + this.w && someY >= y && someY < y + this.h
      );
    };
    let entityCollide = (entity: Entity): boolean => {
      if (entity.x >= x + this.w || entity.x + entity.w <= x) return false;
      if (entity.y >= y + this.h || entity.y + entity.h <= y) return false;
      return true;
    };
    for (const e of this.room.entities) {
      if (e !== this && entityCollide(e) && collide) {
        return;
      }
    }
    for (const i in this.game.players) {
      if (pointWouldBeIn(this.game.players[i].x, this.game.players[i].y)) {
        return;
      }
    }
    let tiles = [];
    for (let xx = 0; xx < this.w; xx++) {
      for (let yy = 0; yy < this.h; yy++) {
        if (!this.room.roomArray[x + xx][y + yy].isSolid()) {
          tiles.push(this.room.roomArray[x + xx][y + yy]);
        } else {
          return;
        }
      }
    }
    for (let tile of tiles) {
      tile.onCollideEnemy(this);
    }
    this.x = x;
    this.y = y;
  };

  hit = (): number => {
    return 1;
  };

  handleEnemyCase = (playerHitBy?: Player) => {
    if (!playerHitBy) return;
    if (playerHitBy) {
      this.aggro = true;
      this.targetPlayer = playerHitBy;
      //this.facePlayer(playerHitBy);
      if (playerHitBy === this.game.players[this.game.localPlayerID])
        this.alertTicks = 2; // this is really 1 tick, it will be decremented immediately in tick()
    }
  };

  poison = () => {
    if (!this.status.poison.active) {
      this.status.poison = {
        active: true,
        hitCount: 0,
        startTick: this.ticks,
        effectTick: this.ticks % 3,
      };
      this.shadeColor = "#00FF00";
    }
  };

  bleed = () => {
    if (!this.status.bleed.active) {
      this.status.bleed = {
        active: true,
        hitCount: 0,
        startTick: this.ticks,
        effectTick: this.ticks % 1,
      };
    }
  };

  tickPoison = () => {
    if (this.status.poison.active && this.targetPlayer) {
      if (
        this.ticks % 3 === this.status.poison.effectTick &&
        this.ticks !== this.status.poison.startTick &&
        this.health >= 1
      ) {
        this.hurt(this.targetPlayer, 1, "poison");
        this.shadeColor = "#00FF00";
        //this.status.poison.hitCount++;

        /*
        if (this.status.poison.hitCount >= 2) {
          this.status.poison = {
            active: false,
            hitCount: 0,
            startTick: 0,
            effectTick: 0,
          };
        }
        */
      }
    }
  };

  tickBleed = () => {
    if (this.status.bleed.active && this.targetPlayer) {
      if (
        this.ticks % 1 === this.status.bleed.effectTick &&
        this.ticks !== this.status.bleed.startTick
      ) {
        this.hurt(this.targetPlayer, 0.5, "blood");
        //this.targetPlayer.heal(0.5);
        this.shadeColor = "#FF0000";
        this.status.bleed.hitCount++;

        if (this.status.bleed.hitCount >= 4) {
          this.status.bleed = {
            active: false,
            hitCount: 0,
            startTick: 0,
            effectTick: 0,
          };
        }
      }
    }
  };

  tick = () => {
    console.log(this.name, this.ticks);
    this.tickPoison();
    this.tickBleed();
    this.behavior();
    if (this.x !== this.lastX || this.y !== this.lastY) {
      this.emitEntityData();
    }
    if (this.shielded) this.shield.updateLightSourcePos();
  };

  lookForPlayer = (face: boolean = true) => {
    if (this.seenPlayer) return;
    let p = this.nearestPlayer();
    if (p !== false) {
      let [distance, player] = p;
      if (distance <= 4) {
        this.targetPlayer = player;
        if (face) this.facePlayer(player);
        this.seenPlayer = true;
        let type = this.constructor;
        globalEventBus.emit("EnemySeenPlayer", {
          enemyType: this.constructor.name,
          enemyName: this.name,
        });
        if (player === this.game.players[this.game.localPlayerID])
          this.alertTicks = 1;
        this.makeHitWarnings();
      }
    }
  };

  getDisablePositions = (): Array<astar.Position> => {
    let disablePositions = Array<astar.Position>();
    for (const e of this.room.entities) {
      if (e !== this) {
        disablePositions.push({ x: e.x, y: e.y } as astar.Position);
      }
    }
    for (let xx = this.x - 1; xx <= this.x + 1; xx++) {
      for (let yy = this.y - 1; yy <= this.y + 1; yy++) {
        if (
          this.room.roomArray[xx][yy] instanceof SpikeTrap &&
          (this.room.roomArray[xx][yy] as SpikeTrap).on
        ) {
          // Don't walk on active spike traps
          disablePositions.push({ x: xx, y: yy } as astar.Position);
        }
      }
    }
    return disablePositions;
  };

  findPath = () => {
    let disablePositions = Array<astar.Position>();
    for (const e of this.room.entities) {
      if (e !== this) {
        disablePositions.push({ x: e.x, y: e.y } as astar.Position);
      }
    }
    for (let xx = this.x - 1; xx <= this.x + 1; xx++) {
      for (let yy = this.y - 1; yy <= this.y + 1; yy++) {
        if (
          this.room.roomArray[xx][yy] instanceof SpikeTrap &&
          (this.room.roomArray[xx][yy] as SpikeTrap).on
        ) {
          // Don't walk on active spike traps
          disablePositions.push({ x: xx, y: yy } as astar.Position);
        }
      }
    }
    // Create a grid of the room
    let grid = [];
    for (let x = 0; x < this.room.roomX + this.room.width; x++) {
      grid[x] = [];
      for (let y = 0; y < this.room.roomY + this.room.height; y++) {
        if (this.room.roomArray[x] && this.room.roomArray[x][y])
          grid[x][y] = this.room.roomArray[x][y];
        else grid[x][y] = false;
      }
    }

    // Find a path to the target player
    let moves = astar.AStar.search(
      grid,
      this,
      this.targetPlayer,
      disablePositions,
      false,
      false,
      true,
      this.direction,
    );
  };

  behavior = () => {
    // Store the current position
    this.lastX = this.x;
    this.lastY = this.y;

    // If the enemy is not dead
    if (!this.dead) {
      // Skip turns if necessary
      if (this.skipNextTurns > 0) {
        this.skipNextTurns--;
        return;
      }

      // Increment the tick counter
      this.ticks++;

      // If the enemy has not seen the player yet
      if (!this.seenPlayer) this.lookForPlayer();
      else if (this.seenPlayer) {
        // If the target player has taken their turn
        if (this.room.playerTicked === this.targetPlayer) {
          // Decrement alert ticks
          this.alertTicks = Math.max(0, this.alertTicks - 1);

          // Store the old position
          let oldX = this.x;
          let oldY = this.y;

          // Create a list of positions to avoid
          let disablePositions = Array<astar.Position>();
          for (const e of this.room.entities) {
            if (e !== this) {
              disablePositions.push({ x: e.x, y: e.y } as astar.Position);
            }
          }
          for (let xx = this.x - 1; xx <= this.x + 1; xx++) {
            for (let yy = this.y - 1; yy <= this.y + 1; yy++) {
              if (
                this.room.roomArray[xx][yy] instanceof SpikeTrap &&
                (this.room.roomArray[xx][yy] as SpikeTrap).on
              ) {
                // Don't walk on active spike traps
                disablePositions.push({ x: xx, y: yy } as astar.Position);
              }
            }
          }
          // Create a grid of the room
          let grid = [];
          for (let x = 0; x < this.room.roomX + this.room.width; x++) {
            grid[x] = [];
            for (let y = 0; y < this.room.roomY + this.room.height; y++) {
              if (this.room.roomArray[x] && this.room.roomArray[x][y])
                grid[x][y] = this.room.roomArray[x][y];
              else grid[x][y] = false;
            }
          }

          // Find a path to the target player
          let moves = astar.AStar.search(
            grid,
            this,
            this.targetPlayer,
            disablePositions,
            false,
            false,
            true,
            this.direction,
          );

          // If there are moves available
          if (moves.length > 0) {
            let moveX = moves[0].pos.x;
            let moveY = moves[0].pos.y;
            let oldDir = this.direction;
            let player = this.targetPlayer;

            // Face the target player
            this.facePlayer(player);

            // Determine the new direction based on the move
            if (moveX > oldX) this.direction = Direction.RIGHT;
            else if (moveX < oldX) this.direction = Direction.LEFT;
            else if (moveY > oldY) this.direction = Direction.DOWN;
            else if (moveY < oldY) this.direction = Direction.UP;

            // If the direction hasn't changed, attempt to move or attack
            if (oldDir == this.direction) {
              let hitPlayer = false;
              for (const i in this.game.players) {
                if (
                  this.game.rooms[this.game.players[i].levelID] === this.room &&
                  this.game.players[i].x === moveX &&
                  this.game.players[i].y === moveY
                ) {
                  // Attack the player if they are in the way
                  this.game.players[i].hurt(this.hit(), this.name);
                  this.drawX = 0.5 * (this.x - this.game.players[i].x);
                  this.drawY = 0.5 * (this.y - this.game.players[i].y);
                  if (
                    this.game.players[i] ===
                    this.game.players[this.game.localPlayerID]
                  )
                    this.game.shakeScreen(10 * this.drawX, 10 * this.drawY);
                }
              }
              if (!hitPlayer) {
                // Move to the new position
                this.tryMove(moveX, moveY);
                this.setDrawXY(moveX, moveY);
                if (this.x > moveX) this.direction = Direction.RIGHT;
                else if (this.x < moveX) this.direction = Direction.LEFT;
                else if (this.y > moveY) this.direction = Direction.DOWN;
                else if (this.y < moveY) this.direction = Direction.UP;
              }
            }
          }

          // Add positions to avoid based on the current direction
          if (this.direction == Direction.LEFT) {
            disablePositions.push({
              x: this.x,
              y: this.y + 1,
            } as astar.Position);
            disablePositions.push({
              x: this.x,
              y: this.y - 1,
            } as astar.Position);
          }
          if (this.direction == Direction.RIGHT) {
            disablePositions.push({
              x: this.x,
              y: this.y + 1,
            } as astar.Position);
            disablePositions.push({
              x: this.x,
              y: this.y - 1,
            } as astar.Position);
          }
          if (this.direction == Direction.DOWN) {
            disablePositions.push({
              x: this.x + 1,
              y: this.y,
            } as astar.Position);
            disablePositions.push({
              x: this.x - 1,
              y: this.y,
            } as astar.Position);
          }
          if (this.direction == Direction.UP) {
            disablePositions.push({
              x: this.x + 1,
              y: this.y,
            } as astar.Position);
            disablePositions.push({
              x: this.x - 1,
              y: this.y,
            } as astar.Position);
          }
          // Make hit warnings
          this.makeHitWarnings();
        }

        // Check if the target player is offline
        let targetPlayerOffline =
          Object.values(this.game.offlinePlayers).indexOf(this.targetPlayer) !==
          -1;
        // If the enemy is not aggro or the target player is offline, find a new target player
        if (!this.aggro || targetPlayerOffline) {
          let p = this.nearestPlayer();
          if (p !== false) {
            let [distance, player] = p;
            if (
              distance <= 4 &&
              (targetPlayerOffline ||
                distance < this.playerDistance(this.targetPlayer))
            ) {
              if (player !== this.targetPlayer) {
                this.targetPlayer = player;
                this.facePlayer(player);
                if (player === this.game.players[this.game.localPlayerID])
                  this.alertTicks = 1;
                this.makeHitWarnings();
              }
            }
          }
        }
      }
    }
  };

  jump = (delta: number) => {
    let j = Math.max(Math.abs(this.drawX), Math.abs(this.drawY));
    this.jumpY = Math.abs(Math.sin(j * Math.PI)) * this.jumpHeight;
    if (this.jumpY < 0.01) this.jumpY = 0;
    if (this.jumpY > this.jumpHeight) this.jumpY = this.jumpHeight;
  };

  updateDrawXY = (delta: number) => {
    //putting this here bc i'm lazy
    this.updateHurtFrame(delta);
    this.animateDying(delta);

    if (!this.doneMoving()) {
      this.drawX *= 0.85 ** delta;
      this.drawY *= 0.85 ** delta;

      this.drawX = Math.abs(this.drawX) < 0.01 ? 0 : this.drawX;
      this.drawY = Math.abs(this.drawY) < 0.01 ? 0 : this.drawY;
      this.jump(delta);
    }

    this.updateShadeColor(delta);
  };

  setDrawXY = (x: number, y: number) => {
    this.drawX += this.x - x;
    this.drawY += this.y - y;
  };

  get lastPlayerPos() {
    return {
      x: this.targetPlayer.lastX,
      y: this.targetPlayer.lastY,
    };
  }

  draw = (delta: number) => {
    if (!this.dead) {
      this.updateDrawXY(delta);
      this.frame += 0.1 * delta;
      if (this.frame >= 4) this.frame = 0;
      if (this.hasShadow)
        Game.drawMob(
          0,
          0,
          1,
          1,
          this.x - this.drawX,
          this.y - this.drawY,
          1,
          1,
          this.room.shadeColor,
          this.shadeAmount(),
        );
      Game.drawMob(
        this.tileX + Math.floor(this.frame),
        this.tileY + this.direction * 2,
        1,
        2,
        this.x - this.drawX,
        this.y - this.drawYOffset - this.drawY - this.jumpY,
        1,
        2,
        this.softShadeColor,
        this.shadeAmount(),
      );
    }
    if (!this.dying) {
      if (!this.seenPlayer) {
        this.drawSleepingZs(delta);
      }
      if (this.alertTicks > 0) {
        this.drawExclamation(delta);
      }
    }
  };

  get type() {
    return EntityType.ENEMY;
  }
}


--- src/entity/enemy/energyWizard.ts ---
import { Game } from "../../game";
import { Room } from "../../room";
import { Floor } from "../../tile/floor";
import { Bones } from "../../tile/bones";
import { DeathParticle } from "../../particle/deathParticle";
import { Item } from "../../item/item";
import { WizardEnemy } from "./wizardEnemy";

export enum WizardState {
  idle,
  attack,
  justAttacked,
  teleport,
}

export class EnergyWizardEnemy extends WizardEnemy {
  static difficulty: number = 3;
  static tileX: number = 6;
  static tileY: number = 0;
  constructor(room: Room, game: Game, x: number, y: number, drop?: Item) {
    super(room, game, x, y);
    this.ticks = 0;
    this.health = 1;
    this.tileX = 6;
    this.tileY = 0;
    this.frame = 0;
    this.state = WizardState.attack;
    this.seenPlayer = false;
    this.alertTicks = 0;
    this.name = "wizard bomber";
    this.projectileColor = [0, 50, 150];

    if (drop) this.drop = drop;
    if (Random.rand() < this.dropChance) {
      this.getDrop([
        "weapon",
        "equipment",
        "consumable",
        "gem",
        "tool",
        "coin",
      ]);
    }
  }

  draw = (delta: number) => {
    if (this.dead) return;
    Game.ctx.save();
    Game.ctx.globalAlpha = this.alpha;
    if (!this.dead) {
      this.updateDrawXY(delta);
      if (this.state === WizardState.attack) this.tileX = 7;
      else this.tileX = 6;

      if (this.hasShadow)
        Game.drawMob(
          0,
          0,
          1,
          1,
          this.x - this.drawX,
          this.y - this.drawY,
          1,
          1,
          this.room.shadeColor,
          this.shadeAmount(),
        );
      if (this.frame >= 0) {
        Game.drawMob(
          Math.floor(this.frame) + 6,
          2,
          1,
          2,
          this.x,
          this.y - 1.5,
          1,
          2,
          this.softShadeColor,
          this.shadeAmount(),
        );
        this.frame += 0.4 * delta;
        if (this.frame > 11) this.frame = -1;
      } else {
        Game.drawMob(
          this.tileX,
          this.tileY,
          1,
          2,
          this.x - this.drawX,
          this.y - 1.3 - this.drawY,
          1,
          2,
          this.softShadeColor,
          this.shadeAmount(),
        );
      }
      if (!this.cloned) {
        if (!this.seenPlayer) {
          this.drawSleepingZs(delta);
        }
        if (this.alertTicks > 0) {
          this.drawExclamation(delta);
        }
      }
    }
    Game.ctx.restore();
  };
}


--- src/entity/enemy/fireWizard.ts ---
import { Game } from "../../game";
import { Room } from "../../room";
import { Floor } from "../../tile/floor";
import { Bones } from "../../tile/bones";
import { DeathParticle } from "../../particle/deathParticle";
import { WizardTeleportParticle } from "../../particle/wizardTeleportParticle";
import { WizardFireball } from "../../projectile/wizardFireball";
import { Random } from "../../random";
import { Item } from "../../item/item";
import { WizardEnemy } from "./wizardEnemy";

export enum WizardState {
  idle,
  attack,
  justAttacked,
  teleport,
}

export class FireWizardEnemy extends WizardEnemy {
  static difficulty: number = 3;
  static tileX: number = 35;
  static tileY: number = 8;
  readonly ATTACK_RADIUS = 5;

  constructor(room: Room, game: Game, x: number, y: number, drop?: Item) {
    super(room, game, x, y);
    this.ticks = 0;
    this.health = 1;
    this.tileX = 35;
    this.tileY = 8;
    this.frame = 0;
    this.state = WizardState.attack;
    this.seenPlayer = false;
    this.alertTicks = 0;
    this.name = "fire wizard";
    this.projectileColor = [200, 20, 0];
    if (drop) this.drop = drop;
    if (Random.rand() < this.dropChance) {
      this.getDrop([
        "weapon",
        "equipment",
        "consumable",
        "gem",
        "tool",
        "coin",
      ]);
    }
  }

  hit = (): number => {
    return 1;
  };

  withinAttackingRangeOfPlayer = (): boolean => {
    let withinRange = false;
    for (const i in this.game.players) {
      if (
        (this.x - this.game.players[i].x) ** 2 +
          (this.y - this.game.players[i].y) ** 2 <=
        this.ATTACK_RADIUS ** 2
      ) {
        withinRange = true;
      }
    }
    return withinRange;
  };

  shuffle = (a) => {
    let j, x, i;
    for (i = a.length - 1; i > 0; i--) {
      j = Math.floor(Random.rand() * (i + 1));
      x = a[i];
      a[i] = a[j];
      a[j] = x;
    }
    return a;
  };

  behavior = () => {
    this.lastX = this.x;
    this.lastY = this.y;
    if (!this.dead) {
      if (this.skipNextTurns > 0) {
        this.skipNextTurns--;
        return;
      }
      if (!this.seenPlayer) this.lookForPlayer();
      else if (this.seenPlayer) {
        this.alertTicks = Math.max(0, this.alertTicks - 1);
        switch (this.state) {
          case WizardState.attack:
            const nearestPlayerInfo = this.nearestPlayer();
            if (nearestPlayerInfo !== false) {
              const [distance, targetPlayer] = nearestPlayerInfo;
              const attackLength = 20;

              const offsets = this.calculateProjectileOffsets(
                targetPlayer.x,
                targetPlayer.y,
                10,
              );

              this.attemptProjectilePlacement(
                [
                  { x: -1, y: 0 },
                  { x: -2, y: 0 },
                  { x: 1, y: 0 },
                  { x: 2, y: 0 },
                  { x: 0, y: -1 },
                  { x: 0, y: -2 },
                  { x: 0, y: 1 },
                  { x: 0, y: 2 },
                ],
                WizardFireball,
                false,
              );
            }
            this.state = WizardState.justAttacked;
            break;
          case WizardState.justAttacked:
            this.state = WizardState.idle;
            break;
          case WizardState.teleport:
            let oldX = this.x;
            let oldY = this.y;
            let min = 100000;
            let bestPos;
            let emptyTiles = this.shuffle(this.room.getEmptyTiles());
            emptyTiles = emptyTiles.filter(
              (tile) =>
                !this.room.projectiles.some(
                  (projectile) =>
                    projectile.x === tile.x && projectile.y === tile.y,
                ),
            );

            let optimalDist = Game.randTable(
              [2, 2, 3, 3, 3, 3, 3],
              Random.rand,
            );
            // pick a random player to target
            let player_ids = [];
            for (const i in this.game.players) player_ids.push(i);
            let target_player_id = Game.randTable(player_ids, Random.rand);
            for (let t of emptyTiles) {
              let newPos = t;
              let dist =
                Math.abs(newPos.x - this.game.players[target_player_id].x) +
                Math.abs(newPos.y - this.game.players[target_player_id].y);
              if (Math.abs(dist - optimalDist) < Math.abs(min - optimalDist)) {
                min = dist;
                bestPos = newPos;
              }
            }
            this.tryMove(bestPos.x, bestPos.y);
            this.drawX = this.x - oldX;
            this.drawY = this.y - oldY;
            this.frame = 0; // trigger teleport animation
            this.room.particles.push(new WizardTeleportParticle(oldX, oldY));
            if (this.withinAttackingRangeOfPlayer()) {
              this.state = WizardState.attack;
            } else {
              this.state = WizardState.idle;
            }
            break;
          case WizardState.idle:
            this.state = WizardState.teleport;
            break;
        }
      }
    }
  };

  draw = (delta: number) => {
    this.frame += 0.1 * delta;
    if (this.frame >= 4) this.frame = 0;
    if (!this.dead) {
      this.updateDrawXY(delta);
      if (this.hasShadow)
        Game.drawMob(
          0,
          0,
          1,
          1,
          this.x - this.drawX,
          this.y - this.drawY,
          1,
          1,
          this.room.shadeColor,
          this.shadeAmount(),
        );
      if (this.frame >= 0) {
        Game.drawMob(
          this.tileX + Math.floor(this.frame),
          this.tileY,
          1,
          2,
          this.x,
          this.y - 1.3,
          1,
          2,
          this.softShadeColor,
          this.shadeAmount(),
        );
      } else {
        Game.drawMob(
          this.tileX,
          this.tileY,
          1,
          2,
          this.x - this.drawX,
          this.y - 1.3 - this.drawY,
          1,
          2,
          this.softShadeColor,
          this.shadeAmount(),
        );
      }
      if (!this.seenPlayer) {
        this.drawSleepingZs(delta);
      }
      if (this.alertTicks > 0) {
        this.drawExclamation(delta);
      }
    }
  };

  kill = () => {
    if (this.room.roomArray[this.x][this.y] instanceof Floor) {
      let b = new Bones(this.room, this.x, this.y);
      b.skin = this.room.roomArray[this.x][this.y].skin;
      this.room.roomArray[this.x][this.y] = b;
    }

    this.dead = true;
    this.room.particles.push(new DeathParticle(this.x, this.y));

    this.dropLoot();
  };
}


--- src/entity/enemy/frogEnemy.ts ---
import { Direction, Game } from "../../game";
import { Room } from "../../room";
import { astar } from "../../astarclass";
import { HitWarning } from "../../hitWarning";
import { SpikeTrap } from "../../tile/spiketrap";
import { Coin } from "../../item/coin";
import { Player } from "../../player";
import { Item } from "../../item/item";
import { Enemy } from "./enemy";
import { Utils } from "../../utils";

export class FrogEnemy extends Enemy {
  ticks: number;
  frame: number;
  seenPlayer: boolean;
  aggro: boolean;
  targetPlayer: Player;
  drop: Item;
  frameLength: number;
  startFrame: number;
  animationSpeed: number;
  tickCount: number;
  rumbling: boolean;
  jumping: boolean;
  jumpDistance: number;
  static difficulty: number = 1;
  static tileX: number = 12;
  static tileY: number = 16;

  constructor(room: Room, game: Game, x: number, y: number, drop?: Item) {
    super(room, game, x, y);
    this.ticks = 0;
    this.frame = 0;
    this.health = 1;
    this.maxHealth = 1;
    this.tileX = 12;
    this.tileY = 16;
    this.seenPlayer = false;
    this.aggro = false;
    this.deathParticleColor = "#ffffff";
    this.frameLength = 3;
    this.startFrame = 0;
    this.animationSpeed = 0.1;
    this.tickCount = 0;
    this.jumping = false;
    this.jumpDistance = 1;
    this.drop = drop ? drop : new Coin(this.room, this.x, this.y);
    this.name = "frog";
    this.orthogonalAttack = true;
    this.diagonalAttack = true;
    this.jumpHeight = 1;
    this.drawMoveSpeed = 0.2;
    this.imageParticleX = 3;
    this.imageParticleY = 30;
    if (drop) this.drop = drop;
    if (Random.rand() < this.dropChance) {
      this.getDrop(["weapon", "consumable", "gem", "tool", "coin", "poison"]);
    }
  }

  hit = (): number => {
    return 0.5;
  };

  behavior = () => {
    this.lastX = this.x;
    this.lastY = this.y;
    this.tileX = 1;
    this.frameLength = 3;
    this.animationSpeed = 0.1;

    if (!this.dead) {
      if (this.skipNextTurns > 0) {
        this.skipNextTurns--;
        return;
      }
      if (!this.seenPlayer) {
        this.tileX = 12;
        this.lookForPlayer();
      } else if (this.seenPlayer) {
        this.tileX = 1;
        if (this.room.playerTicked === this.targetPlayer) {
          this.alertTicks = Math.max(0, this.alertTicks - 1);
          this.ticks++;
          if (this.ticks % 2 === 1) {
            this.rumbling = true;
            let oldX = this.x;
            let oldY = this.y;
            let disablePositions = Array<astar.Position>();

            for (const e of this.room.entities) {
              if (e !== this) {
                disablePositions.push({ x: e.x, y: e.y } as astar.Position);
              }
            }

            for (let xx = this.x - 1; xx <= this.x + 1; xx++) {
              for (let yy = this.y - 1; yy <= this.y + 1; yy++) {
                if (
                  this.room.roomArray[xx][yy] instanceof SpikeTrap &&
                  (this.room.roomArray[xx][yy] as SpikeTrap).on
                ) {
                  // don't walk on active spiketraps
                  disablePositions.push({ x: xx, y: yy } as astar.Position);
                }
              }
            }

            let grid = [];
            for (let x = 0; x < this.room.roomX + this.room.width; x++) {
              grid[x] = [];
              for (let y = 0; y < this.room.roomY + this.room.height; y++) {
                if (this.room.roomArray[x] && this.room.roomArray[x][y])
                  grid[x][y] = this.room.roomArray[x][y];
                else grid[x][y] = false;
              }
            }
            let targetPosition = {
              x: this.targetPlayer.x,
              y: this.targetPlayer.y,
            };
            let dx = this.targetPlayer.x - this.x;
            let dy = this.targetPlayer.y - this.y;
            if (
              (dx === 0 && dy <= 1) ||
              (dx <= 1 && dy === 0) ||
              (dx === 0 && dy >= -1) ||
              (dx >= -1 && dy === 0)
            ) {
              let jumpOverX = this.targetPlayer.x + dx;
              let jumpOverY = this.targetPlayer.y + dy;
              if (
                this.room.roomArray[jumpOverX] &&
                this.room.roomArray[jumpOverX][jumpOverY]
              ) {
                if (!this.room.roomArray[jumpOverX][jumpOverY].isSolid()) {
                  targetPosition = {
                    x: jumpOverX,
                    y: jumpOverY,
                  };
                }
              }
            }
            let moves = astar.AStar.search(
              grid,
              this,
              targetPosition,
              disablePositions,
              false,
              false,
              false,
              undefined,
              undefined,
              false,
              this.lastPlayerPos,
            );
            //console.log(moves); //DON'T REMOVE THIS

            if (moves[1]) {
              let hitPlayer = false;
              for (const i in this.game.players) {
                if (
                  this.game.rooms[this.game.players[i].levelID] === this.room &&
                  this.game.players[i].x === moves[1].pos.x &&
                  this.game.players[i].y === moves[1].pos.y
                ) {
                  this.game.players[i].hurt(this.hit(), this.name);
                  this.drawX += 1.5 * (this.x - this.game.players[i].x);
                  this.drawY += 1.5 * (this.y - this.game.players[i].y);
                  if (
                    this.game.players[i] ===
                    this.game.players[this.game.localPlayerID]
                  )
                    this.game.shakeScreen(5 * this.drawX, 5 * this.drawY);
                  hitPlayer = true;
                }
              }
              if (!hitPlayer) {
                if (moves.length > 1) {
                  let moveX = moves[1].pos.x;
                  let moveY = moves[1].pos.y;
                  this.tryMove(moveX, moveY);
                  this.setDrawXY(this.lastX, this.lastY);

                  if (this.jumping) {
                    this.frame = 8;
                    this.animationSpeed = 1;
                  }
                  if (this.x > moveX) this.direction = Direction.RIGHT;
                  else if (this.x < moveX) this.direction = Direction.LEFT;
                  else if (this.y > moveY) this.direction = Direction.DOWN;
                  else if (this.y < moveY) this.direction = Direction.UP;
                }
              }
            }
            this.rumbling = false;
          } else {
            this.makeHitWarnings();
            this.rumbling = true;
            this.tileX = 3;
            this.frame = 0;
            this.frameLength = 2;
            this.animationSpeed = 0.2;
          }
        }

        let targetPlayerOffline =
          Object.values(this.game.offlinePlayers).indexOf(this.targetPlayer) !==
          -1;
        if (!this.aggro || targetPlayerOffline) {
          let p = this.nearestPlayer();
          if (p !== false) {
            let [distance, player] = p;
            if (
              distance <= 4 &&
              (targetPlayerOffline ||
                distance < this.playerDistance(this.targetPlayer))
            ) {
              if (player !== this.targetPlayer) {
                this.targetPlayer = player;
                this.facePlayer(player);
                if (player === this.game.players[this.game.localPlayerID])
                  this.alertTicks = 1;
                if (this.ticks % 2 === 0) {
                  this.makeHitWarnings();
                }
              }
            }
          }
        }
      }
    }
  };

  jump = (delta: number) => {
    //console.log(`this.drawX, this.drawY: ${this.drawX}, ${this.drawY}`);
    if (this.jumping) {
      let j = Math.max(Math.abs(this.drawX), Math.abs(this.drawY));
      if (j > 1) {
        this.jumpDistance = 2;
        this.drawMoveSpeed = 0.2;
      }
      this.jumpY =
        Math.sin((j / this.jumpDistance) * Math.PI) * this.jumpHeight;
      if (this.jumpY < 0.01 && this.jumpY > -0.01) {
        this.jumpY = 0;
        this.jumpDistance = 1;
        this.drawMoveSpeed = 0.2;
      }
      if (this.jumpY > this.jumpHeight) this.jumpY = this.jumpHeight;
    }
  };

  makeHitWarnings = () => {
    const cullFactor = 0.25;
    const player: Player = this.getPlayer();
    const orthogonal = this.orthogonalAttack;
    const diagonal = this.diagonalAttack;
    const forwardOnly = this.forwardOnlyAttack;
    const direction = this.direction;
    const orthoRange = this.attackRange;
    const diagRange = this.diagonalAttackRange;

    const generateOffsets = (
      isOrthogonal: boolean,
      range: number,
    ): number[][] => {
      const baseOffsets = isOrthogonal
        ? [
            [-2, 0],
            [2, 0],
            [0, -2],
            [0, 2],
          ]
        : [
            [-1, -1],
            [1, 1],
            [1, -1],
            [-1, 1],
          ];
      return baseOffsets.flatMap(([dx, dy]) =>
        Array.from({ length: range }, (_, i) => [(i + 1) * dx, (i + 1) * dy]),
      );
    };

    const directionOffsets = {
      [Direction.LEFT]: [-1, 0],
      [Direction.RIGHT]: [1, 0],
      [Direction.UP]: [0, -1],
      [Direction.DOWN]: [0, 1],
    };

    let offsets: number[][] = [];
    if (forwardOnly) {
      const [dx, dy] = directionOffsets[direction];
      offsets = Array.from({ length: orthoRange }, (_, i) => [
        (i + 1) * dx,
        (i + 1) * dy,
      ]);
    } else {
      if (orthogonal) offsets.push(...generateOffsets(true, orthoRange));
      if (diagonal) offsets.push(...generateOffsets(false, diagRange));
    }

    const warningCoordinates = offsets
      .map(([dx, dy]) => ({
        x: dx,
        y: dy,
        distance: Utils.distance(dx, dy, player.x - this.x, player.y - this.y),
      }))
      .sort((a, b) => a.distance - b.distance);

    const keepCount = Math.ceil(warningCoordinates.length * (1 - cullFactor));
    const culledWarnings = warningCoordinates.slice(0, keepCount);

    culledWarnings.forEach(({ x, y }) => {
      const targetX = this.x + x;
      const targetY = this.y + y;
      if (this.isWithinRoomBounds(targetX, targetY)) {
        const hitWarning = new HitWarning(
          this.game,
          targetX,
          targetY,
          this.x,
          this.y,
          true,
          false,
          this,
        );
        this.room.hitwarnings.push(hitWarning);
        //this.hitWarnings.push(hitWarning);
      }
    });
  };

  draw = (delta: number) => {
    if (this.dead) return;
    Game.ctx.save();
    Game.ctx.globalAlpha = this.alpha;
    if (!this.dead) {
      this.updateDrawXY(delta);
      this.frame += this.animationSpeed * delta;
      if (this.frame >= this.frameLength) {
        this.frame = 0;
      }
      let rumbleX = this.rumble(this.rumbling, this.frame).x;
      let rumbleY = this.rumble(this.rumbling, this.frame).y;
      if (this.drawX !== 0 || this.drawY !== 0) {
        this.jumping = true;
      } else {
        this.jumping = false;
      }
      if (this.jumping) {
        this.frameLength = 10;
        this.animationSpeed = 0.4;
      } else {
        this.frameLength = 3;
        this.animationSpeed = 0.1;
      }
      if (this.hasShadow)
        Game.drawMob(
          0,
          0,
          1,
          1,
          this.x - this.drawX,
          this.y - this.drawY,
          1,
          1,
          this.room.shadeColor,
          this.shadeAmount(),
        );
      Game.drawMob(
        this.tileX +
          (this.tileX !== 12 && !this.rumbling ? Math.floor(this.frame) : 0),
        this.tileY /*+ this.direction * 2,*/,
        1,
        2,
        this.x + rumbleX - this.drawX,
        this.y - this.drawYOffset - this.drawY - this.jumpY,
        1,
        2,
        this.softShadeColor,
        this.shadeAmount(),
      );
    }
    if (!this.cloned) {
      if (!this.seenPlayer) {
        this.drawSleepingZs(delta);
      }
      if (this.alertTicks > 0) {
        this.drawExclamation(delta);
      }
    }
    Game.ctx.restore();
  };
}


--- src/entity/enemy/knightEnemy.ts ---
import { Direction, Game } from "../../game";
import { Room } from "../../room";
import { astar } from "../../astarclass";
import { SpikeTrap } from "../../tile/spiketrap";
import { Player } from "../../player";
import { Item } from "../../item/item";
import { Enemy } from "./enemy";

export class KnightEnemy extends Enemy {
  ticks: number;
  frame: number;
  seenPlayer: boolean;
  targetPlayer: Player;
  aggro: boolean;
  drop: Item;
  static difficulty: number = 2;
  static tileX: number = 9;
  static tileY: number = 8;

  constructor(room: Room, game: Game, x: number, y: number, drop?: Item) {
    super(room, game, x, y);
    this.ticks = 0;
    this.frame = 0;
    this.health = 2;
    this.maxHealth = 2;
    this.tileX = 9;
    this.tileY = 8;
    this.seenPlayer = false;
    this.aggro = false;
    this.deathParticleColor = "#ffffff";
    this.lastX = this.x;
    this.lastY = this.y;
    this.name = "burrow knight";
    this.orthogonalAttack = true;
    this.imageParticleX = 3;
    this.imageParticleY = 29;
    if (drop) this.drop = drop;
    if (Random.rand() < this.dropChance) {
      this.getDrop([
        "weapon",
        "equipment",
        "consumable",
        "gem",
        "tool",
        "coin",
      ]);
    }
  }

  hit = (): number => {
    return 1;
  };

  behavior = () => {
    this.lastX = this.x;
    this.lastY = this.y;
    if (!this.dead) {
      if (this.skipNextTurns > 0) {
        this.skipNextTurns--;
        return;
      }
      if (!this.seenPlayer) {
        const result = this.nearestPlayer();
        if (result !== false) {
          let [distance, p] = result;
          if (distance < 4) {
            this.rumbling = true;
            this.seenPlayer = true;
            this.targetPlayer = p;
            this.facePlayer(p);
            if (p === this.game.players[this.game.localPlayerID])
              this.alertTicks = 1;
            this.makeHitWarnings();
          }
        }
      } else if (this.seenPlayer) {
        if (this.room.playerTicked === this.targetPlayer) {
          this.alertTicks = Math.max(0, this.alertTicks - 1);
          this.ticks++;
          if (this.ticks % 2 === 1) {
            this.rumbling = true;
            let oldX = this.x;
            let oldY = this.y;
            let disablePositions = Array<astar.Position>();
            for (const e of this.room.entities) {
              if (e !== this) {
                disablePositions.push({ x: e.x, y: e.y } as astar.Position);
              }
            }
            for (let xx = this.x - 1; xx <= this.x + 1; xx++) {
              for (let yy = this.y - 1; yy <= this.y + 1; yy++) {
                if (
                  this.room.roomArray[xx][yy] instanceof SpikeTrap &&
                  (this.room.roomArray[xx][yy] as SpikeTrap).on
                ) {
                  // don't walk on active spiketraps
                  disablePositions.push({ x: xx, y: yy } as astar.Position);
                }
              }
            }
            let grid = [];
            for (let x = 0; x < this.room.roomX + this.room.width; x++) {
              grid[x] = [];
              for (let y = 0; y < this.room.roomY + this.room.height; y++) {
                if (this.room.roomArray[x] && this.room.roomArray[x][y])
                  grid[x][y] = this.room.roomArray[x][y];
                else grid[x][y] = false;
              }
            }
            let moves = astar.AStar.search(
              grid,
              this,
              this.targetPlayer,
              disablePositions,
              undefined,
              undefined,
              undefined,
              undefined,
              undefined,
              undefined,
              this.lastPlayerPos,
            );
            if (moves.length > 0) {
              let hitPlayer = false;
              for (const i in this.game.players) {
                if (
                  this.game.rooms[this.game.players[i].levelID] === this.room &&
                  this.game.players[i].x === moves[0].pos.x &&
                  this.game.players[i].y === moves[0].pos.y
                ) {
                  this.game.players[i].hurt(this.hit(), this.name);
                  this.drawX = 0.5 * (this.x - this.game.players[i].x);
                  this.drawY = 0.5 * (this.y - this.game.players[i].y);
                  if (
                    this.game.players[i] ===
                    this.game.players[this.game.localPlayerID]
                  )
                    this.game.shakeScreen(10 * this.drawX, 10 * this.drawY);
                  hitPlayer = true;
                }
              }
              if (!hitPlayer) {
                this.tryMove(moves[0].pos.x, moves[0].pos.y);
                this.setDrawXY(oldX, oldY);

                if (this.x > oldX) this.direction = Direction.RIGHT;
                else if (this.x < oldX) this.direction = Direction.LEFT;
                else if (this.y > oldY) this.direction = Direction.DOWN;
                else if (this.y < oldY) this.direction = Direction.UP;
              }
            }
            this.rumbling = false;
          } else {
            this.rumbling = true;
            this.makeHitWarnings();
          }
        }

        let targetPlayerOffline =
          Object.values(this.game.offlinePlayers).indexOf(this.targetPlayer) !==
          -1;
        if (!this.aggro || targetPlayerOffline) {
          let p = this.nearestPlayer();
          if (p !== false) {
            let [distance, player] = p;
            if (
              distance <= 4 &&
              (targetPlayerOffline ||
                distance < this.playerDistance(this.targetPlayer))
            ) {
              if (player !== this.targetPlayer) {
                this.targetPlayer = player;
                this.facePlayer(player);
                if (player === this.game.players[this.game.localPlayerID])
                  this.alertTicks = 1;
                if (this.ticks % 2 === 0) {
                  this.rumbling = true;
                  this.makeHitWarnings();
                }
              }
            }
          }
        }
      }
    }
  };

  draw = (delta: number) => {
    if (this.dead) return;
    Game.ctx.save();
    Game.ctx.globalAlpha = this.alpha;
    let rumbleX = this.rumble(this.rumbling, this.frame).x;
    let rumbleY = this.rumble(this.rumbling, this.frame, this.direction).y;
    if (!this.dead) {
      this.updateDrawXY(delta);
      if (this.ticks % 2 === 0) {
        this.tileX = 9;
        this.tileY = 8;
      } else {
        this.tileX = 4;
        this.tileY = 0;
      }

      this.frame += 0.1 * delta;
      if (this.frame >= 4) this.frame = 0;
      if (this.hasShadow)
        Game.drawMob(
          0,
          0,
          1,
          1,
          this.x - this.drawX,
          this.y - this.drawY,
          1,
          1,
          this.room.shadeColor,
          this.shadeAmount(),
        );
      Game.drawMob(
        this.tileX + (this.tileX === 4 ? 0 : Math.floor(this.frame)),
        this.tileY + this.direction * 2,
        1,
        2,
        this.x - this.drawX + rumbleX,
        this.y -
          this.drawYOffset -
          this.drawY +
          (this.tileX === 4 ? 0.1875 : 0),
        1,
        2,
        this.softShadeColor,
        this.shadeAmount(),
      );
    }
    if (!this.cloned) {
      if (!this.seenPlayer) {
        this.drawSleepingZs(delta);
      }
      if (this.alertTicks > 0) {
        this.drawExclamation(delta);
      }
    }
    Game.ctx.restore();
  };
}


--- src/entity/enemy/occultistEnemy.ts ---
import { Game } from "../../game";
import { Room } from "../../room";

import { Enemy } from "./enemy";

import { Utils } from "../../utils";
import { BeamEffect } from "../../beamEffect";
import { Player } from "../../player";
import { ImageParticle } from "../../particle/imageParticle";
import { Lighting } from "../../lighting";

export class OccultistEnemy extends Enemy {
  ticks: number;
  seenPlayer: boolean;
  shieldedEnemies: Enemy[];
  range: number;
  static tileX: number = 55;
  static tileY: number = 8;

  constructor(room: Room, game: Game, x: number, y: number) {
    super(room, game, x, y);
    this.ticks = 0;
    this.health = 6;
    this.maxHealth = 6;
    this.tileX = 55;
    this.tileY = 8;
    this.seenPlayer = true;
    this.name = "occultist";
    this.range = 6;
    this.aggro = false;
    this.frame = 0;
    this.hasShadow = true;
    this.shieldedBefore = false;
    this.shieldedEnemies = [];
    this.shadeColor = "#000000";
    this.lightSource = Lighting.newLightSource(
      this.x + 0.5,
      this.y + 0.5,
      [20, 0, 40],
      3.5,
      20,
    );
    this.addLightSource(this.lightSource);
    this.room.updateLighting();
    this.hasBloom = true;
    this.bloomColor = "#2E0854";
    this.bloomAlpha = 1;
    this.softBloomAlpha = 0;
  }

  hit = (): number => {
    return 1;
  };

  uniqueKillBehavior = () => {
    this.unshieldEnemies();
    this.removeLightSource(this.lightSource);
    this.lightSource = null;
  };

  behavior = () => {
    this.lastX = this.x;
    this.lastY = this.y;

    let enemiesToShield = this.room.entities.filter(
      (entity) =>
        entity instanceof Enemy &&
        Utils.distance(this.x, this.y, entity.x, entity.y) <= this.range &&
        !entity.shielded &&
        !entity.dead &&
        entity !== this &&
        !entity.shieldedBefore,
    );

    if (!this.dead) {
      if (this.skipNextTurns > 0) {
        this.skipNextTurns--;
        return;
      }

      this.ticks++;

      if (this.ticks % 2 === 0) {
        if (enemiesToShield.length > 0) {
          enemiesToShield.forEach((enemy) => {
            const distance = Utils.distance(this.x, this.y, enemy.x, enemy.y);
            if (Random.rand() * 10 > distance) {
              this.applyShieldTo(enemy as Enemy);
            }
          });

          //this.createBeam(this.shieldedEnemies);
        }
      }

      this.shieldedEnemies.forEach((enemy) => {
        if (enemy.dead) {
          this.shieldedEnemies = this.shieldedEnemies.filter(
            (e) => e !== enemy,
          );
        }
      });
    }

    if (this.shieldedEnemies.length > 0) {
      this.shadeColor = "#2E0854";
    } else {
      this.shadeColor = "#000000";
    }
  };

  unshieldEnemies = () => {
    if (this.shieldedEnemies.length > 0) {
      for (let enemy of this.shieldedEnemies) {
        if (!enemy.cloned) {
          enemy.removeShield();
          console.log("unshielded enemy:", enemy.name);
        }
      }
      this.shieldedEnemies = [];
    }
  };

  applyShieldTo = (enemy: Enemy) => {
    //this.shadeColor = "#2E0854";
    this.shadeMultiplier = 1.5;
    enemy.applyShield();
    this.shieldedEnemies.push(enemy);
    if (enemy.shielded && enemy.shield) {
      let beam = new BeamEffect(enemy.x, enemy.y, this.x, this.y, enemy);
      beam.compositeOperation = "source-over";
      beam.color = "#2E0854";
      beam.turbulence = 0.4;
      beam.gravity = 0.1;
      beam.iterations = 1;
      beam.segments = 100;
      beam.angleChange = 0.001;
      beam.springDamping = 0.01;
      beam.drawableY = enemy.drawableY;
      this.room.projectiles.push(beam);
      console.log("beam created");
    }
  };

  private createBeam = (enemies: Enemy[]) => {
    for (let enemy of enemies) {
      if (enemy.shielded && enemy.shield) {
        let beam = new BeamEffect(enemy.x, enemy.y, this.x, this.y, enemy);
        beam.compositeOperation = "source-over";
        beam.color = "#2E0854";
        beam.turbulence = 0.5;
        beam.gravity = 0.1;
        beam.iterations = 1;
        beam.segments = 30;
        beam.angleChange = 0.01;
        beam.springDamping = 0.1;
        beam.drawableY = enemy.drawableY;
        this.room.projectiles.push(beam);
        console.log("beam created");
      }
    }
  };

  updateBeam = (delta: number) => {
    for (let beam of this.room.projectiles) {
      if (beam instanceof BeamEffect) {
        beam.setTarget(
          this.x - this.drawX,
          this.y - this.drawY,
          beam.parent.x - beam.parent.drawX,
          beam.parent.y - beam.parent.drawY,
        );
        beam.drawableY = beam.parent.drawableY;

        switch (Math.floor(this.frame)) {
          case 0:
            beam.color = "#2e0854";
            break;
          case 1:
            beam.color = "#331988";
            break;
          case 2:
            beam.color = "#4729db";
            break;
          case 3:
            beam.color = "#331988";
            break;
        }
      }
    }
  };

  draw = (delta: number) => {
    if (this.dead) return;
    Game.ctx.save();
    Game.ctx.globalAlpha = this.alpha;

    this.drawableY = this.y;
    if (!this.dead) {
      this.updateDrawXY(delta);
      this.updateBeam(delta);

      this.frame += 0.1 * delta;
      if (this.frame >= 4) this.frame = 0;

      if (this.hasShadow)
        Game.drawMob(
          0,
          0,
          1,
          1,
          this.x - this.drawX,
          this.y - this.drawY,
          1,
          1,
          this.room.shadeColor,
          this.shadeAmount(),
        );
      Game.drawMob(
        this.tileX + Math.floor(this.frame),
        this.tileY,
        1,
        2,
        this.x - this.drawX,
        this.y - this.drawYOffset - this.drawY,
        1,
        2,
        this.softShadeColor,
        this.shadeAmount(),
      );
    }
    Game.ctx.restore();
  };
}


--- src/entity/enemy/queenEnemy.ts ---
import { Game } from "../../game";
import { Room } from "../../room";
import { Player } from "../../player";
import { Item } from "../../item/item";
import { astar } from "../../astarclass";
import { SpikeTrap } from "../../tile/spiketrap";
import { Enemy } from "./enemy";

export class QueenEnemy extends Enemy {
  frame: number;
  ticks: number;
  seenPlayer: boolean;
  aggro: boolean;
  targetPlayer: Player;
  drop: Item;
  static difficulty: number = 4;
  static tileX: number = 23;
  static tileY: number = 8;
  constructor(room: Room, game: Game, x: number, y: number, drop?: Item) {
    super(room, game, x, y);
    this.ticks = 0;
    this.frame = 0;
    this.health = 1;
    this.maxHealth = 1;
    this.tileX = 23;
    this.tileY = 8;
    this.seenPlayer = false;
    this.aggro = false;
    this.name = "queen";
    this.orthogonalAttack = true;
    this.diagonalAttack = true;
    this.jumpHeight = 1;
    if (drop) this.drop = drop;
    if (Random.rand() < this.dropChance) {
      this.getDrop([
        "weapon",
        "equipment",
        "consumable",
        "gem",
        "tool",
        "coin",
      ]);
    }
  }

  hit = (): number => {
    return 1;
  };

  behavior = () => {
    this.lastX = this.x;
    this.lastY = this.y;
    if (!this.dead) {
      if (this.skipNextTurns > 0) {
        this.skipNextTurns--;
        return;
      }
      this.ticks++;
      if (!this.seenPlayer) {
        let p = this.nearestPlayer();
        if (p !== false) {
          let [distance, player] = p;
          if (distance <= 4) {
            this.targetPlayer = player;
            this.facePlayer(player);
            this.seenPlayer = true;
            if (player === this.game.players[this.game.localPlayerID])
              this.alertTicks = 1;
            this.makeHitWarnings();
          }
        }
      } else if (this.seenPlayer) {
        if (this.room.playerTicked === this.targetPlayer) {
          this.alertTicks = Math.max(0, this.alertTicks - 1);
          let oldX = this.x;
          let oldY = this.y;

          let disablePositions = Array<astar.Position>();
          for (const e of this.room.entities) {
            if (e !== this) {
              disablePositions.push({ x: e.x, y: e.y } as astar.Position);
            }
          }
          for (let xx = this.x - 1; xx <= this.x + 1; xx++) {
            for (let yy = this.y - 1; yy <= this.y + 1; yy++) {
              if (
                this.room.roomArray[xx][yy] instanceof SpikeTrap &&
                (this.room.roomArray[xx][yy] as SpikeTrap).on
              ) {
                // don't walk on active spiketraps
                disablePositions.push({ x: xx, y: yy } as astar.Position);
              }
            }
          }
          let grid = [];
          for (let x = 0; x < this.room.roomX + this.room.width; x++) {
            grid[x] = [];
            for (let y = 0; y < this.room.roomY + this.room.height; y++) {
              if (this.room.roomArray[x] && this.room.roomArray[x][y])
                grid[x][y] = this.room.roomArray[x][y];
              else grid[x][y] = false;
            }
          }
          let moves = astar.AStar.search(
            grid,
            this,
            this.targetPlayer,
            disablePositions,
            true, //diagonals
            false, //diagonalsOnly
            undefined,
            undefined,
            undefined,
            false, //diagonalsOmni
          );
          if (moves.length > 0) {
            disablePositions.push({ x: oldX + 1, y: oldY } as astar.Position);
            disablePositions.push({ x: oldX - 1, y: oldY } as astar.Position);
            disablePositions.push({ x: oldX, y: oldY + 1 } as astar.Position);
            disablePositions.push({ x: oldX, y: oldY - 1 } as astar.Position);
            let moveX = moves[0].pos.x;
            let moveY = moves[0].pos.y;

            let hitPlayer = false;
            for (const i in this.game.players) {
              if (
                this.game.rooms[this.game.players[i].levelID] === this.room &&
                this.game.players[i].x === moveX &&
                this.game.players[i].y === moveY
              ) {
                this.game.players[i].hurt(this.hit(), this.name);
                this.drawX = 0.5 * (this.x - this.game.players[i].x);
                this.drawY = 0.5 * (this.y - this.game.players[i].y);
                if (
                  this.game.players[i] ===
                  this.game.players[this.game.localPlayerID]
                )
                  this.game.shakeScreen(10 * this.drawX, 10 * this.drawY);
              }
            }
            if (!hitPlayer) {
              //if ()
              this.tryMove(moveX, moveY);
              this.setDrawXY(oldX, oldY);
            }
          }
          this.makeHitWarnings();
        }

        let targetPlayerOffline =
          Object.values(this.game.offlinePlayers).indexOf(this.targetPlayer) !==
          -1;
        if (!this.aggro || targetPlayerOffline) {
          let p = this.nearestPlayer();
          if (p !== false) {
            let [distance, player] = p;
            if (
              distance <= 4 &&
              (targetPlayerOffline ||
                distance < this.playerDistance(this.targetPlayer))
            ) {
              if (player !== this.targetPlayer) {
                this.targetPlayer = player;
                this.facePlayer(player);
                if (player === this.game.players[this.game.localPlayerID])
                  this.alertTicks = 1;
                this.makeHitWarnings();
              }
            }
          }
        }
      }
    }
  };

  jump = (delta: number) => {
    let j = Math.max(Math.abs(this.drawX), Math.abs(this.drawY));

    let jumpY = Math.abs(Math.sin(j * Math.PI)) * this.jumpHeight;
    if (jumpY < 0.01) jumpY = 0;
    if (jumpY > this.jumpHeight) jumpY = this.jumpHeight;
    this.jumpY = jumpY;
  };

  draw = (delta: number) => {
    if (this.dead) return;
    Game.ctx.save();
    Game.ctx.globalAlpha = this.alpha;

    if (!this.dead) {
      this.updateDrawXY(delta);
      this.frame += 0.1 * delta;
      if (this.frame >= 4) this.frame = 0;

      if (this.hasShadow)
        Game.drawMob(
          0,
          0,
          1,
          1,
          this.x - this.drawX,
          this.y - this.drawY,
          1,
          1,
          this.room.shadeColor,
          this.shadeAmount(),
        );
      Game.drawMob(
        this.tileX + Math.floor(this.frame),
        this.tileY + this.direction * 2,
        1,
        2,
        this.x - this.drawX,
        this.y - this.drawYOffset - this.drawY - this.jumpY,
        1,
        2,
        this.softShadeColor,
        this.shadeAmount() * (1 + this.jumpY / 3),
      );
    }
    if (!this.cloned) {
      if (!this.seenPlayer) {
        this.drawSleepingZs(delta);
      }
      if (this.alertTicks > 0) {
        this.drawExclamation(delta);
      }
    }
    Game.ctx.restore();
  };
}


--- src/entity/enemy/rookEnemy.ts ---
import { Game } from "../../game";
import { Room } from "../../room";
import { Player } from "../../player";
import { Item } from "../../item/item";
import { astar } from "../../astarclass";
import { SpikeTrap } from "../../tile/spiketrap";
import { Enemy } from "./enemy";

export class RookEnemy extends Enemy {
  frame: number;
  ticks: number;
  seenPlayer: boolean;
  aggro: boolean;
  targetPlayer: Player;
  drop: Item;
  static difficulty: number = 4;
  static tileX: number = 23 + 28;
  static tileY: number = 8;

  constructor(room: Room, game: Game, x: number, y: number, drop?: Item) {
    super(room, game, x, y);
    this.ticks = 0;
    this.frame = 0;
    this.health = 1;
    this.maxHealth = 1;
    this.tileX = 23 + 28;
    this.tileY = 8;
    this.seenPlayer = false;
    this.aggro = false;
    this.name = "rook";
    this.orthogonalAttack = true;
    this.diagonalAttack = false;
    this.jumpHeight = 0.5;
    if (drop) this.drop = drop;
    if (Random.rand() < this.dropChance) {
      this.getDrop([
        "weapon",
        "equipment",
        "consumable",
        "gem",
        "tool",
        "coin",
      ]);
    }
  }

  hit = (): number => {
    return 1;
  };

  behavior = () => {
    this.lastX = this.x;
    this.lastY = this.y;
    if (!this.dead) {
      if (this.skipNextTurns > 0) {
        this.skipNextTurns--;
        return;
      }
      this.ticks++;
      if (!this.seenPlayer) {
        let p = this.nearestPlayer();
        if (p !== false) {
          let [distance, player] = p;
          if (distance <= 4) {
            this.targetPlayer = player;
            this.facePlayer(player);
            this.seenPlayer = true;
            if (player === this.game.players[this.game.localPlayerID])
              this.alertTicks = 1;
            this.makeHitWarnings();
          }
        }
      } else if (this.seenPlayer) {
        if (this.room.playerTicked === this.targetPlayer) {
          this.alertTicks = Math.max(0, this.alertTicks - 1);
          let oldX = this.x;
          let oldY = this.y;

          let disablePositions = Array<astar.Position>();
          for (const e of this.room.entities) {
            if (e !== this) {
              disablePositions.push({ x: e.x, y: e.y } as astar.Position);
            }
          }
          for (let xx = this.x - 1; xx <= this.x + 1; xx++) {
            for (let yy = this.y - 1; yy <= this.y + 1; yy++) {
              if (
                this.room.roomArray[xx][yy] instanceof SpikeTrap &&
                (this.room.roomArray[xx][yy] as SpikeTrap).on
              ) {
                // don't walk on active spiketraps
                disablePositions.push({ x: xx, y: yy } as astar.Position);
              }
            }
          }
          let grid = [];
          for (let x = 0; x < this.room.roomX + this.room.width; x++) {
            grid[x] = [];
            for (let y = 0; y < this.room.roomY + this.room.height; y++) {
              if (this.room.roomArray[x] && this.room.roomArray[x][y])
                grid[x][y] = this.room.roomArray[x][y];
              else grid[x][y] = false;
            }
          }

          let moves = astar.AStar.search(
            grid,
            this,
            this.targetPlayer,
            disablePositions,
            false, //diagonals
            false, //diagonalsOnly
            undefined,
            undefined,
            undefined,
            false, //diagonalsOmni
            this.lastPlayerPos,
          );
          if (moves.length > 0) {
            let moveX = moves[0].pos.x;

            let moveY = moves[0].pos.y;

            let hitPlayer = false;
            for (const i in this.game.players) {
              if (
                this.game.rooms[this.game.players[i].levelID] === this.room &&
                this.game.players[i].x === moveX &&
                this.game.players[i].y === moveY
              ) {
                this.game.players[i].hurt(this.hit(), this.name);
                this.drawX = 0.5 * (this.x - this.game.players[i].x);
                this.drawY = 0.5 * (this.y - this.game.players[i].y);
                if (
                  this.game.players[i] ===
                  this.game.players[this.game.localPlayerID]
                )
                  this.game.shakeScreen(10 * this.drawX, 10 * this.drawY);
              }
            }

            if (!hitPlayer) {
              this.tryMove(moveX, moveY);
              this.setDrawXY(oldX, oldY);
            }
          }
          this.makeHitWarnings();
        }

        let targetPlayerOffline =
          Object.values(this.game.offlinePlayers).indexOf(this.targetPlayer) !==
          -1;
        if (!this.aggro || targetPlayerOffline) {
          let p = this.nearestPlayer();
          if (p !== false) {
            let [distance, player] = p;
            if (
              distance <= 4 &&
              (targetPlayerOffline ||
                distance < this.playerDistance(this.targetPlayer))
            ) {
              if (player !== this.targetPlayer) {
                this.targetPlayer = player;
                this.facePlayer(player);
                if (player === this.game.players[this.game.localPlayerID])
                  this.alertTicks = 1;
                this.makeHitWarnings();
              }
            }
          }
        }
      }
    }
  };

  draw = (delta: number) => {
    if (this.dead) return;
    Game.ctx.save();
    Game.ctx.globalAlpha = this.alpha;
    if (!this.dead) {
      this.updateDrawXY(delta);
      this.frame += 0.1 * delta;
      if (this.frame >= 4) this.frame = 0;

      if (this.hasShadow)
        Game.drawMob(
          0,
          0,
          1,
          1,
          this.x - this.drawX,
          this.y - this.drawY,
          1,
          1,
          this.room.shadeColor,
          this.shadeAmount(),
        );
      Game.drawMob(
        this.tileX + Math.floor(this.frame),
        this.tileY,
        1,
        2,
        this.x - this.drawX,
        this.y - this.drawYOffset - this.drawY - this.jumpY,
        1,
        2,
        this.softShadeColor,
        this.shadeAmount(),
      );
    }
    if (!this.cloned) {
      if (!this.seenPlayer) {
        this.drawSleepingZs(delta);
      }
      if (this.alertTicks > 0) {
        this.drawExclamation(delta);
      }
    }
    Game.ctx.restore();
  };
}


--- src/entity/enemy/skullEnemy.ts ---
import { Direction, Game } from "../../game";
import { Room } from "../../room";
import { Player } from "../../player";
import { Item } from "../../item/item";
import { astar } from "../../astarclass";
import { SpikeTrap } from "../../tile/spiketrap";
import { ImageParticle } from "../../particle/imageParticle";
import { Enemy } from "./enemy";

export class SkullEnemy extends Enemy {
  frame: number;
  ticks: number;
  seenPlayer: boolean;
  aggro: boolean;
  ticksSinceFirstHit: number;
  flashingFrame: number;
  targetPlayer: Player;
  readonly REGEN_TICKS = 5;
  drop: Item;
  static difficulty: number = 2;
  static tileX: number = 5;
  static tileY: number = 8;
  constructor(room: Room, game: Game, x: number, y: number, drop?: Item) {
    super(room, game, x, y);
    this.ticks = 0;
    this.frame = 0;
    this.health = 2;
    this.maxHealth = 2;
    this.tileX = 5;
    this.tileY = 8;
    this.seenPlayer = false;
    this.aggro = false;
    this.ticksSinceFirstHit = 0;
    this.flashingFrame = 0;
    this.deathParticleColor = "#ffffff";
    this.name = "skeleton";
    this.forwardOnlyAttack = true;
    if (drop) this.drop = drop;
    if (Random.rand() < this.dropChance) {
      this.getDrop(["weapon", "consumable", "gem", "tool", "coin"]);
    }
  }

  hit = (): number => {
    return 1;
  };

  hurt = (
    playerHitBy: Player,
    damage: number,
    type: "none" | "poison" | "blood" | "heal" = "none",
  ) => {
    this.handleEnemyCase(playerHitBy);

    let hitShield = false;
    let shieldHealth = 0;
    if (this.shielded) {
      shieldHealth = this.shield.health;
      if (shieldHealth > 0) {
        this.shield.hurt(damage);
        hitShield = true;
      }
    }
    this.ticksSinceFirstHit = 0;
    if (this.health == 2) this.unconscious = false;
    this.health -= damage;
    this.maxHealth -= shieldHealth;
    this.startHurting();

    this.healthBar.hurt();
    this.createDamageNumber(damage, type);
    this.playHitSound();

    if (this.health == 1) {
      this.unconscious = true;

      ImageParticle.spawnCluster(this.room, this.x + 0.5, this.y + 0.5, 3, 28);
    } else {
      this.healthBar.hurt();
    }
    if (this.health <= 0) {
      ImageParticle.spawnCluster(this.room, this.x + 0.5, this.y + 0.5, 0, 24);
      this.kill();
    } else this.hurtCallback();
  };

  behavior = () => {
    this.lastX = this.x;
    this.lastY = this.y;

    if (!this.dead) {
      if (this.skipNextTurns > 0) {
        this.skipNextTurns--;
        this.ticks++;

        return;
      }

      if (this.health <= 1) {
        this.unconscious = true;
        this.ticksSinceFirstHit++;
        if (this.ticksSinceFirstHit >= this.REGEN_TICKS) {
          this.healthBar.hurt();
          this.health = 2;
          this.unconscious = false;
        }
        this.ticks++;

        return;
      }

      this.ticks++;
      if (!this.seenPlayer) {
        this.lookForPlayer();
      } else if (this.seenPlayer) {
        if (this.room.playerTicked === this.targetPlayer) {
          this.alertTicks = Math.max(0, this.alertTicks - 1);
          let oldX = this.x;
          let oldY = this.y;

          let disablePositions = Array<astar.Position>();
          for (const e of this.room.entities) {
            if (e !== this) {
              disablePositions.push({ x: e.x, y: e.y } as astar.Position);
            }
          }
          for (let xx = this.x - 1; xx <= this.x + 1; xx++) {
            for (let yy = this.y - 1; yy <= this.y + 1; yy++) {
              if (
                this.room.roomArray[xx][yy] instanceof SpikeTrap &&
                (this.room.roomArray[xx][yy] as SpikeTrap).on
              ) {
                disablePositions.push({ x: xx, y: yy } as astar.Position);
              }
            }
          }
          let grid = [];
          for (let x = 0; x < this.room.roomX + this.room.width; x++) {
            grid[x] = [];
            for (let y = 0; y < this.room.roomY + this.room.height; y++) {
              if (this.room.roomArray[x] && this.room.roomArray[x][y])
                grid[x][y] = this.room.roomArray[x][y];
              else grid[x][y] = false;
            }
          }
          let moves = astar.AStar.search(
            grid,
            this,
            this.targetPlayer,
            disablePositions,
            false,
            false,
            true,
            this.direction,
            undefined,
            undefined,
          );
          if (moves.length > 0) {
            let moveX = moves[0].pos.x;
            let moveY = moves[0].pos.y;
            let oldDir = this.direction;
            let player = this.targetPlayer;

            this.facePlayer(player);

            if (moveX > oldX) this.direction = Direction.RIGHT;
            else if (moveX < oldX) this.direction = Direction.LEFT;
            else if (moveY > oldY) this.direction = Direction.DOWN;
            else if (moveY < oldY) this.direction = Direction.UP;

            if (oldDir == this.direction) {
              let hitPlayer = false;
              for (const i in this.game.players) {
                if (
                  this.game.rooms[this.game.players[i].levelID] === this.room &&
                  this.game.players[i].x === moveX &&
                  this.game.players[i].y === moveY
                ) {
                  this.game.players[i].hurt(this.hit(), this.name);
                  this.drawX = 0.5 * (this.x - this.game.players[i].x);
                  this.drawY = 0.5 * (this.y - this.game.players[i].y);
                  if (
                    this.game.players[i] ===
                    this.game.players[this.game.localPlayerID]
                  )
                    this.game.shakeScreen(10 * this.drawX, 10 * this.drawY);
                }
              }
              if (!hitPlayer) {
                this.tryMove(moveX, moveY);
                this.setDrawXY(oldX, oldY);

                if (this.x > oldX) this.direction = Direction.RIGHT;
                else if (this.x < oldX) this.direction = Direction.LEFT;
                else if (this.y > oldY) this.direction = Direction.DOWN;
                else if (this.y < oldY) this.direction = Direction.UP;
              }
            }
          }

          if (this.direction == Direction.LEFT) {
            disablePositions.push({
              x: this.x,
              y: this.y + 1,
            } as astar.Position);
            disablePositions.push({
              x: this.x,
              y: this.y - 1,
            } as astar.Position);
          }
          if (this.direction == Direction.RIGHT) {
            disablePositions.push({
              x: this.x,
              y: this.y + 1,
            } as astar.Position);
            disablePositions.push({
              x: this.x,
              y: this.y - 1,
            } as astar.Position);
          }
          if (this.direction == Direction.DOWN) {
            disablePositions.push({
              x: this.x + 1,
              y: this.y,
            } as astar.Position);
            disablePositions.push({
              x: this.x - 1,
              y: this.y,
            } as astar.Position);
          }
          if (this.direction == Direction.UP) {
            disablePositions.push({
              x: this.x + 1,
              y: this.y,
            } as astar.Position);
            disablePositions.push({
              x: this.x - 1,
              y: this.y,
            } as astar.Position);
          }
          this.makeHitWarnings();
        }

        let targetPlayerOffline =
          Object.values(this.game.offlinePlayers).indexOf(this.targetPlayer) !==
          -1;
        if (!this.aggro || targetPlayerOffline) {
          let p = this.nearestPlayer();
          if (p !== false) {
            let [distance, player] = p;
            if (
              distance <= 4 &&
              (targetPlayerOffline ||
                distance < this.playerDistance(this.targetPlayer))
            ) {
              if (player !== this.targetPlayer) {
                this.targetPlayer = player;
                this.facePlayer(player);
                if (player === this.game.players[this.game.localPlayerID])
                  this.alertTicks = 1;
                this.makeHitWarnings();
              }
            }
          }
        }
      }
    }
  };

  draw = (delta: number) => {
    if (this.dead) return;
    Game.ctx.save();
    Game.ctx.globalAlpha = this.alpha;
    if (!this.dead) {
      this.updateDrawXY(delta);
      this.tileX = 5;
      this.tileY = 8;

      if (this.health <= 1 || this.dying) {
        this.tileX = 3;
        this.tileY = 0;
        if (this.ticksSinceFirstHit >= 3) {
          this.flashingFrame += 0.1 * delta;
          if (Math.floor(this.flashingFrame) % 2 === 0) {
            this.tileX = 2;
          }
        }
      }

      this.frame += 0.1 * delta;
      if (this.frame >= 4) this.frame = 0;

      if (this.hasShadow)
        Game.drawMob(
          0,
          0,
          1,
          1,
          this.x - this.drawX,
          this.y - this.drawY,
          1,
          1,
          this.room.shadeColor,
          this.shadeAmount(),
        );
      Game.drawMob(
        this.tileX + (this.tileX === 5 ? Math.floor(this.frame) : 0),
        this.tileY + this.direction * 2,
        1,
        2,
        this.x - this.drawX,
        this.y - this.drawYOffset - this.drawY - this.jumpY,
        1,
        2,
        this.softShadeColor,
        this.shadeAmount(),
      );
    }
    if (!this.cloned) {
      if (!this.seenPlayer) {
        this.drawSleepingZs(delta);
      }
      if (this.alertTicks > 0) {
        this.drawExclamation(delta);
      }
    }
    Game.ctx.restore();
  };
}


--- src/entity/enemy/spawner.ts ---
import { Game } from "../../game";
import { Room } from "../../room";
import { Floor } from "../../tile/floor";
import { HitWarning } from "../../hitWarning";
import { SkullEnemy } from "./skullEnemy";
import { EnemySpawnAnimation } from "../../projectile/enemySpawnAnimation";
import { KnightEnemy } from "./knightEnemy";
import { Enemy } from "./enemy";
import { Random } from "../../random";
import { EnergyWizardEnemy } from "./energyWizard";
import { ZombieEnemy } from "./zombieEnemy";
import { BishopEnemy } from "./bishopEnemy";
import { CrabEnemy } from "./crabEnemy";
import { ChargeEnemy } from "./chargeEnemy";
import { BigKnightEnemy } from "./bigKnightEnemy";
import { BigSkullEnemy } from "./bigSkullEnemy";
import { FrogEnemy } from "./frogEnemy";
import { FireWizardEnemy } from "./fireWizard";
import { QueenEnemy } from "./queenEnemy";
import { ArmoredzombieEnemy } from "./armoredzombieEnemy";
import { RookEnemy } from "./rookEnemy";
import { RoomType } from "../../room";
import { ArmoredSkullEnemy } from "./armoredSkullEnemy";

export class Spawner extends Enemy {
  ticks: number;
  seenPlayer: boolean;
  enemySpawnType: number;
  enemyTable: number[];
  spawnFrequency: number;
  spawnOffset: number;
  static tileX: number = 6;
  static tileY: number = 4;

  constructor(
    room: Room,
    game: Game,
    x: number,
    y: number,
    enemyTable: number[] = [0, 1, 2, 3, 4, 5, 6, 8, 9, 10, 11, 12, 13, 14, 16],
  ) {
    super(room, game, x, y);
    this.ticks = 0;
    this.health = 4;
    this.maxHealth = 4;
    this.tileX = 6;
    this.tileY = 4;
    this.seenPlayer = true;
    this.spawnFrequency = 4;
    this.room.currentSpawnerCount++;
    this.enemyTable = enemyTable.filter((t) => t !== 7);
    const randSpawnType = Game.randTable(this.enemyTable, Random.rand);
    this.enemySpawnType = randSpawnType;
    this.spawnOffset = 0;

    if (Random.rand() < 0.15) {
      switch (this.enemySpawnType) {
        case 0:
          this.getDrop(["consumable"]);
          break;
        case 1:
          this.getDrop(["gem"]);
          break;
        case 2:
          this.getDrop(["consumable"]);
          break;
        case 3:
          this.getDrop(["gem"]);
          break;
        case 4:
          this.getDrop(["gem"]);
          break;
        case 5:
          this.getDrop(["consumable"]);
          break;
        case 6:
          this.getDrop(["gem"]);
          break;
        case 7:
          this.getDrop(["gem"]);
          break;
        case 8:
          this.getDrop(["gem"]);
          break;
        case 9:
          this.getDrop(["equipment", "weapon", "tool"]);
          break;
        case 10:
          this.getDrop(["weapon"]);
          break;
        case 11:
          this.getDrop(["weapon"]);
          break;
        case 12:
          this.getDrop(["weapon"]);
          break;
        case 13:
          this.getDrop(["weapon"]);
          break;
        case 14:
          this.getDrop(["weapon"]);
          break;
        case 16:
          this.getDrop(["weapon", "equipment"]);
          break;
      }
    } else {
      this.getDrop(["consumable", "tool"]);
    }
    this.name = "reaper";
  }

  hit = (): number => {
    return 1;
  };

  setSpawnFrequency = () => {
    this.spawnFrequency = Math.min(12, 4 * this.room.currentSpawnerCount);
    const spawners = this.room.entities.filter((e) => e instanceof Spawner);
    this.spawnOffset = (spawners.indexOf(this) + 1) * 4;
  };

  behavior = () => {
    this.setSpawnFrequency();
    let shouldSpawn = true;
    this.lastX = this.x;
    this.lastY = this.y;
    if (!this.dead) {
      if (this.skipNextTurns > 0) {
        this.skipNextTurns--;
        return;
      }
      this.tileX = 6;
      if ((this.ticks + this.spawnOffset) % this.spawnFrequency === 0) {
        let positions = this.room
          .getEmptyTiles()
          .filter(
            (t) => Math.abs(t.x - this.x) <= 1 && Math.abs(t.y - this.y) <= 1,
          );
        if (this.enemySpawnType === 8) {
          const offLimits = [
            { x: this.x, y: this.y },
            { x: this.x + 1, y: this.y + 1 },
            { x: this.x - 1, y: this.y - 1 },
            { x: this.x + 1, y: this.y - 1 },
            { x: this.x - 1, y: this.y + 1 },
          ];
          positions = positions.filter(
            (t) => !offLimits.some((o) => o.x === t.x && o.y === t.y),
          );
        }
        if (positions.length > 0) {
          this.tileX = 7;

          const position = Game.randTable(positions, Random.rand);

          let spawned;
          switch (this.enemySpawnType) {
            case 1:
              spawned = new CrabEnemy(
                this.room,
                this.game,
                position.x,
                position.y,
              );
              break;
            case 2:
              spawned = new FrogEnemy(
                this.room,
                this.game,
                position.x,
                position.y,
              );
              break;
            case 3:
              spawned = new ZombieEnemy(
                this.room,
                this.game,
                position.x,
                position.y,
              );
              break;
            case 4:
              spawned = new SkullEnemy(
                this.room,
                this.game,
                position.x,
                position.y,
              );
              break;
            case 5:
              spawned = new EnergyWizardEnemy(
                this.room,
                this.game,
                position.x,
                position.y,
              );
              break;
            case 6:
              spawned = new ChargeEnemy(
                this.room,
                this.game,
                position.x,
                position.y,
              );
              break;
            case 7:
              spawned = new RookEnemy(
                this.room,
                this.game,
                position.x,
                position.y,
              );
              break;
            case 8:
              spawned = new BishopEnemy(
                this.room,
                this.game,
                position.x,
                position.y,
              );
              break;
            case 9:
              spawned = new ArmoredzombieEnemy(
                this.room,
                this.game,
                position.x,
                position.y,
              );
              break;
            case 10:
              if (this.room.type !== RoomType.BIGDUNGEON) {
                spawned = new SkullEnemy(
                  this.room,
                  this.game,
                  position.x,
                  position.y,
                );
                break;
              }
              spawned = new BigSkullEnemy(
                this.room,
                this.game,
                position.x,
                position.y,
              );
              for (let xx = 0; xx < 2; xx++) {
                for (let yy = 0; yy < 2; yy++) {
                  this.room.roomArray[position.x + xx][position.y + yy] =
                    new Floor(this.room, position.x + xx, position.y + yy); // remove any walls
                }
              }
              break;
            case 11:
              spawned = new QueenEnemy(
                this.room,
                this.game,
                position.x,
                position.y,
              );
              break;
            case 12:
              spawned = new KnightEnemy(
                this.room,
                this.game,
                position.x,
                position.y,
              );
              break;
            case 13:
              if (this.room.type !== RoomType.BIGDUNGEON) {
                spawned = new KnightEnemy(
                  this.room,
                  this.game,
                  position.x,
                  position.y,
                );
                break;
              }

              spawned = new BigKnightEnemy(
                this.room,
                this.game,
                position.x,
                position.y,
              );
              for (let xx = 0; xx < 2; xx++) {
                for (let yy = 0; yy < 2; yy++) {
                  this.room.roomArray[position.x + xx][position.y + yy] =
                    new Floor(this.room, position.x + xx, position.y + yy); // remove any walls
                }
              }
              break;
            case 14:
              spawned = new ZombieEnemy(
                this.room,
                this.game,
                position.x,
                position.y,
              );
              break;
            case 15:
              spawned = new FireWizardEnemy(
                this.room,
                this.game,
                position.x,
                position.y,
              );
              break;
            case 16:
              spawned = new ArmoredSkullEnemy(
                this.room,
                this.game,
                position.x,
                position.y,
              );
              break;
          }

          if (shouldSpawn) {
            this.room.projectiles.push(
              new EnemySpawnAnimation(
                this.room,
                spawned,
                position.x,
                position.y,
              ),
            );
            this.room.hitwarnings.push(
              new HitWarning(this.game, position.x, position.y, this.x, this.y),
            );
          }
        }
      }
      this.ticks++;
    }
  };

  uniqueKillBehavior = () => {
    this.room.currentSpawnerCount--;
  };

  draw = (delta: number) => {
    Game.ctx.save();
    Game.ctx.globalAlpha = this.alpha;
    if (!this.dead) {
      this.updateDrawXY(delta);
      this.frame += 0.1 * delta;
      if (this.frame >= 4) this.frame = 0;

      if (this.hasShadow)
        Game.drawMob(
          0,
          0,
          1,
          1,
          this.x - this.drawX,
          this.y - this.drawY,
          1,
          1,
          this.room.shadeColor,
          this.shadeAmount(),
        );
      Game.drawMob(
        this.tileX,
        this.tileY,
        1,
        2,
        this.x - this.drawX,
        this.y - this.drawYOffset - this.drawY,
        1,
        2,
        this.softShadeColor,
        this.shadeAmount(),
      );
    }
    if (!this.dying) {
      if (!this.seenPlayer) {
        this.drawSleepingZs(delta);
      }
      if (this.alertTicks > 0) {
        this.drawExclamation(delta);
      }
    }
    Game.ctx.restore();
  };
}


--- src/entity/enemy/wizardEnemy.ts ---
import { Game } from "../../game";
import { Room } from "../../room";
import { Floor } from "../../tile/floor";
import { Bones } from "../../tile/bones";
import { DeathParticle } from "../../particle/deathParticle";
import { WizardTeleportParticle } from "../../particle/wizardTeleportParticle";
import { WizardFireball } from "../../projectile/wizardFireball";
import { Random } from "../../random";
import { Item } from "../../item/item";
import { Enemy } from "./enemy";
import { LightSource } from "../../lightSource";

export enum WizardState {
  idle,
  attack,
  justAttacked,
  teleport,
}

export abstract class WizardEnemy extends Enemy {
  static difficulty: number = 3;
  ticks: number;
  state: WizardState;
  frame: number;
  seenPlayer: boolean;
  projectileColor: [number, number, number];
  readonly ATTACK_RADIUS = 5;
  static tileX: number = 6;
  static tileY: number = 0;

  constructor(room: Room, game: Game, x: number, y: number, drop?: Item) {
    super(room, game, x, y);
    this.ticks = 0;
    this.health = 1;
    this.tileX = 6;
    this.tileY = 0;
    this.frame = 0;
    this.state = WizardState.attack;
    this.seenPlayer = false;
    this.alertTicks = 0;
    this.name = "wizard bomber";
    if (drop) this.drop = drop;
    if (Random.rand() < this.dropChance) {
      this.getDrop([
        "weapon",
        "equipment",
        "consumable",
        "gem",
        "tool",
        "coin",
      ]);
    }
  }

  newLightSource = (
    x: number,
    y: number,
    radius: number,
    color: [number, number, number],
    brightness: number,
  ) => {
    this.lightSource = new LightSource(x, y, radius, color, brightness);
  };

  addLightSource = (lightSource: LightSource) => {
    this.room.lightSources.push(lightSource);
  };

  removeLightSource = (lightSource: LightSource) => {
    this.room.lightSources = this.room.lightSources.filter(
      (ls) => ls !== lightSource,
    );
  };

  hit = (): number => {
    return 1;
  };

  withinAttackingRangeOfPlayer = (): boolean => {
    let withinRange = false;
    for (const i in this.game.players) {
      if (
        (this.x - this.game.players[i].x) ** 2 +
          (this.y - this.game.players[i].y) ** 2 <=
        this.ATTACK_RADIUS ** 2
      ) {
        withinRange = true;
      }
    }
    return withinRange;
  };

  shuffle = (a) => {
    let j, x, i;
    for (i = a.length - 1; i > 0; i--) {
      j = Math.floor(Random.rand() * (i + 1));
      x = a[i];
      a[i] = a[j];
      a[j] = x;
    }
    return a;
  };

  behavior = () => {
    this.lastX = this.x;
    this.lastY = this.y;
    if (!this.dead) {
      if (this.skipNextTurns > 0) {
        this.skipNextTurns--;
        return;
      }
      if (!this.seenPlayer) this.lookForPlayer();
      else if (this.seenPlayer) {
        this.alertTicks = Math.max(0, this.alertTicks - 1);
        switch (this.state) {
          case WizardState.attack:
            const nearestPlayerInfo = this.nearestPlayer();
            if (nearestPlayerInfo !== false) {
              const [distance, targetPlayer] = nearestPlayerInfo;
              const attackLength = 20;

              const offsets = this.calculateProjectileOffsets(
                targetPlayer.x,
                targetPlayer.y,
                10,
              );

              this.attemptProjectilePlacement(
                [
                  { x: -1, y: 0 },
                  { x: -2, y: 0 },
                  { x: 1, y: 0 },
                  { x: 2, y: 0 },
                  { x: 0, y: -1 },
                  { x: 0, y: -2 },
                  { x: 0, y: 1 },
                  { x: 0, y: 2 },
                ],
                WizardFireball,
                false,
              );
            }
            this.state = WizardState.justAttacked;
            break;
          case WizardState.justAttacked:
            this.state = WizardState.idle;
            break;
          case WizardState.teleport:
            let oldX = this.x;
            let oldY = this.y;
            let min = 100000;
            let bestPos;
            let emptyTiles = this.shuffle(this.room.getEmptyTiles());
            emptyTiles = emptyTiles.filter(
              (tile) =>
                !this.room.projectiles.some(
                  (projectile) =>
                    projectile.x === tile.x && projectile.y === tile.y,
                ),
            );

            let optimalDist = Game.randTable(
              [2, 2, 3, 3, 3, 3, 3],
              Random.rand,
            );
            // pick a random player to target
            let player_ids = [];
            for (const i in this.game.players) player_ids.push(i);
            let target_player_id = Game.randTable(player_ids, Random.rand);
            for (let t of emptyTiles) {
              let newPos = t;
              let dist =
                Math.abs(newPos.x - this.game.players[target_player_id].x) +
                Math.abs(newPos.y - this.game.players[target_player_id].y);
              if (Math.abs(dist - optimalDist) < Math.abs(min - optimalDist)) {
                min = dist;
                bestPos = newPos;
              }
            }
            if (bestPos) {
              this.tryMove(bestPos.x, bestPos.y);
              this.drawX = this.x - oldX;
              this.drawY = this.y - oldY;
              this.frame = 0; // trigger teleport animation
              this.room.particles.push(new WizardTeleportParticle(oldX, oldY));
              if (this.withinAttackingRangeOfPlayer()) {
                this.state = WizardState.attack;
              } else {
                this.state = WizardState.idle;
              }
            }
            break;
          case WizardState.idle:
            this.state = WizardState.teleport;
            break;
        }
      }
    }
  };

  draw = (delta: number) => {
    if (this.dead) return;
    Game.ctx.save();
    Game.ctx.globalAlpha = this.alpha;
    if (!this.dead) {
      this.updateDrawXY(delta);

      if (this.state === WizardState.attack) this.tileX = 7;
      else this.tileX = 6;

      if (this.hasShadow)
        Game.drawMob(
          0,
          0,
          1,
          1,
          this.x - this.drawX,
          this.y - this.drawY,
          1,
          1,
          this.room.shadeColor,
          this.shadeAmount(),
        );
      if (this.frame >= 0) {
        Game.drawMob(
          Math.floor(this.frame) + 6,
          2,
          1,
          2,
          this.x,
          this.y - 1.5,
          1,
          2,
          this.softShadeColor,
          this.shadeAmount(),
        );
        this.frame += 0.2 * delta;
        if (this.frame > 11) this.frame = -1;
      } else {
        Game.drawMob(
          this.tileX,
          this.tileY,
          1,
          2,
          this.x - this.drawX,
          this.y - 1.3 - this.drawY,
          1,
          2,
          this.softShadeColor,
          this.shadeAmount(),
        );
      }
      if (!this.seenPlayer) {
        this.drawSleepingZs(delta);
      }
      if (this.alertTicks > 0) {
        this.drawExclamation(delta);
      }
    }
    Game.ctx.restore();
  };
}


--- src/entity/enemy/zombieEnemy.ts ---
import { Entity, EntityDirection } from "../entity";
import { Direction, Game } from "../../game";
import { Room } from "../../room";
import { Player } from "../../player";
import { HitWarning } from "../../hitWarning";
import { GenericParticle } from "../../particle/genericParticle";
import { Coin } from "../../item/coin";
import { RedGem } from "../../item/redgem";
import { Item } from "../../item/item";
import { Spear } from "../../weapon/spear";
import { DualDagger } from "../../weapon/dualdagger";
import { GreenGem } from "../../item/greengem";
import { Random } from "../../random";
import { astar } from "../../astarclass";
import { SpikeTrap } from "../../tile/spiketrap";
import { Pickaxe } from "../../weapon/pickaxe";
import { ImageParticle } from "../../particle/imageParticle";
import { Enemy } from "./enemy";

export class ZombieEnemy extends Enemy {
  frame: number;
  ticks: number;
  seenPlayer: boolean;
  aggro: boolean;
  targetPlayer: Player;
  drop: Item;
  dir: Direction;
  static difficulty: number = 1;
  static tileX: number = 17;
  static tileY: number = 8;
  constructor(room: Room, game: Game, x: number, y: number, drop?: Item) {
    super(room, game, x, y);
    this.ticks = 0;
    this.frame = 0;
    this.health = 1;
    this.maxHealth = 1;
    this.tileX = 17;
    this.tileY = 8;
    this.seenPlayer = false;
    this.aggro = false;
    this.dir = Direction.DOWN;
    this.name = "zombie";
    this.forwardOnlyAttack = true;
    this.drawMoveSpeed = 0.2;
    this.jumpHeight = 0.35;

    if (drop) this.drop = drop;
    if (Random.rand() < this.dropChance) {
      this.getDrop(["consumable", "gem", "tool", "coin"]);
    }
  }

  hit = (): number => {
    return 1;
  };

  behavior = () => {
    // Store the current position
    this.lastX = this.x;
    this.lastY = this.y;

    // If the enemy is not dead
    if (!this.dead) {
      // Skip turns if necessary
      if (this.skipNextTurns > 0) {
        this.skipNextTurns--;
        return;
      }

      // Increment the tick counter
      this.ticks++;

      // If the enemy has not seen the player yet
      if (!this.seenPlayer) this.lookForPlayer();
      else if (this.seenPlayer) {
        // If the target player has taken their turn
        if (this.room.playerTicked === this.targetPlayer) {
          // Decrement alert ticks
          this.alertTicks = Math.max(0, this.alertTicks - 1);

          // Store the old position
          let oldX = this.x;
          let oldY = this.y;

          // Create a list of positions to avoid
          let disablePositions = Array<astar.Position>();
          for (const e of this.room.entities) {
            if (e !== this) {
              disablePositions.push({ x: e.x, y: e.y } as astar.Position);
            }
          }
          for (let xx = this.x - 1; xx <= this.x + 1; xx++) {
            for (let yy = this.y - 1; yy <= this.y + 1; yy++) {
              if (
                this.room.roomArray[xx][yy] instanceof SpikeTrap &&
                (this.room.roomArray[xx][yy] as SpikeTrap).on
              ) {
                // Don't walk on active spike traps
                disablePositions.push({ x: xx, y: yy } as astar.Position);
              }
            }
          }

          // Create a grid of the room
          let grid = [];
          for (let x = 0; x < this.room.roomX + this.room.width; x++) {
            grid[x] = [];
            for (let y = 0; y < this.room.roomY + this.room.height; y++) {
              if (this.room.roomArray[x] && this.room.roomArray[x][y])
                grid[x][y] = this.room.roomArray[x][y];
              else grid[x][y] = false;
            }
          }

          // Find a path to the target player
          let moves = astar.AStar.search(
            grid,
            this,
            this.targetPlayer,
            disablePositions,
            false,
            false,
            true,
            this.direction,
          );

          // If there are moves available
          if (moves.length > 0) {
            let moveX = moves[0].pos.x;
            let moveY = moves[0].pos.y;
            let oldDir = this.direction;
            let player = this.targetPlayer;

            // Face the target player
            this.facePlayer(player);

            // Determine the new direction based on the move
            if (moveX > oldX) this.direction = Direction.RIGHT;
            else if (moveX < oldX) this.direction = Direction.LEFT;
            else if (moveY > oldY) this.direction = Direction.DOWN;
            else if (moveY < oldY) this.direction = Direction.UP;

            // If the direction hasn't changed, attempt to move or attack
            if (oldDir == this.direction) {
              let hitPlayer = false;
              for (const i in this.game.players) {
                if (
                  this.game.rooms[this.game.players[i].levelID] === this.room &&
                  this.game.players[i].x === moveX &&
                  this.game.players[i].y === moveY
                ) {
                  // Attack the player if they are in the way
                  this.game.players[i].hurt(this.hit(), this.name);
                  this.drawX = 0.5 * (this.x - this.game.players[i].x);
                  this.drawY = 0.5 * (this.y - this.game.players[i].y);
                  if (
                    this.game.players[i] ===
                    this.game.players[this.game.localPlayerID]
                  )
                    this.game.shakeScreen(10 * this.drawX, 10 * this.drawY);
                }
              }
              if (!hitPlayer) {
                // Move to the new position
                this.tryMove(moveX, moveY);
                this.setDrawXY(oldX, oldY);

                if (this.x > oldX) this.direction = Direction.RIGHT;
                else if (this.x < oldX) this.direction = Direction.LEFT;
                else if (this.y > oldY) this.direction = Direction.DOWN;
                else if (this.y < oldY) this.direction = Direction.UP;
              }
            }
          }

          // Add positions to avoid based on the current direction
          if (this.direction == Direction.LEFT) {
            disablePositions.push({
              x: this.x,
              y: this.y + 1,
            } as astar.Position);
            disablePositions.push({
              x: this.x,
              y: this.y - 1,
            } as astar.Position);
          }
          if (this.direction == Direction.RIGHT) {
            disablePositions.push({
              x: this.x,
              y: this.y + 1,
            } as astar.Position);
            disablePositions.push({
              x: this.x,
              y: this.y - 1,
            } as astar.Position);
          }
          if (this.direction == Direction.DOWN) {
            disablePositions.push({
              x: this.x + 1,
              y: this.y,
            } as astar.Position);
            disablePositions.push({
              x: this.x - 1,
              y: this.y,
            } as astar.Position);
          }
          if (this.direction == Direction.UP) {
            disablePositions.push({
              x: this.x + 1,
              y: this.y,
            } as astar.Position);
            disablePositions.push({
              x: this.x - 1,
              y: this.y,
            } as astar.Position);
          }
          // Make hit warnings
          this.makeHitWarnings();
        }

        // Check if the target player is offline
        let targetPlayerOffline =
          Object.values(this.game.offlinePlayers).indexOf(this.targetPlayer) !==
          -1;
        // If the enemy is not aggro or the target player is offline, find a new target player
        if (!this.aggro || targetPlayerOffline) {
          let p = this.nearestPlayer();
          if (p !== false) {
            let [distance, player] = p;
            if (
              distance <= 4 &&
              (targetPlayerOffline ||
                distance < this.playerDistance(this.targetPlayer))
            ) {
              if (player !== this.targetPlayer) {
                this.targetPlayer = player;
                this.facePlayer(player);
                if (player === this.game.players[this.game.localPlayerID])
                  this.alertTicks = 1;
                this.makeHitWarnings();
              }
            }
          }
        }
      }
    }
  };

  draw = (delta: number) => {
    if (this.dead) return;
    //this.updateShadeColor(delta);
    Game.ctx.globalAlpha = this.alpha;
    this.updateDrawXY(delta);
    this.frame += 0.1 * delta;
    if (this.frame >= 4) this.frame = 0;
    if (this.hasShadow)
      Game.drawMob(
        0,
        0,
        1,
        1,
        this.x - this.drawX,
        this.y - this.drawY,
        1,
        1,
        this.shadeColor,
        this.shadeAmount(),
      );
    Game.drawMob(
      this.tileX + Math.floor(this.frame),
      this.tileY + this.direction * 2,
      1,
      2,
      this.x - this.drawX,
      this.y - this.drawYOffset - this.drawY - this.jumpY,
      1,
      2,
      this.softShadeColor,
      this.shadeAmount(),
    );

    if (!this.cloned) {
      if (!this.seenPlayer) {
        this.drawSleepingZs(delta);
      }
      if (this.alertTicks > 0) {
        this.drawExclamation(delta);
      }
    }
    Game.ctx.globalAlpha = 1;
  };
}


--- src/entity/entity.ts ---
import { Direction, Game } from "../game";
import { Room } from "../room";
import { Bones } from "../tile/bones";
import { Player } from "../player";
import { Floor } from "../tile/floor";
import { HealthBar } from "../healthbar";
import { Drawable } from "../drawable";
import { Item } from "../item/item";
import { GameConstants } from "../gameConstants";
import { HitWarning } from "../hitWarning";
import { Projectile } from "../projectile/projectile";
import { Utils } from "../utils";
import { globalEventBus } from "../eventBus";
import type { LightSource } from "../lightSource";
import { EVENTS } from "../events";
import { DamageNumber } from "../particle/damageNumber";
import { DownLadder } from "../tile/downLadder";
import { Door } from "../tile/door";
import { Wall } from "../tile/wall";
import { Lighting } from "../lighting";

import { DropTable } from "../item/dropTable";
import { Weapon } from "../weapon/weapon";
import { EnemyShield } from "../projectile/enemyShield";
import { Sound } from "../sound";
import { ImageParticle } from "../particle/imageParticle";
import { Enemy } from "./enemy/enemy";
import { Particle } from "../particle/particle";
import { DeathParticle } from "../particle/deathParticle";

export enum EntityDirection {
  DOWN,
  UP,
  RIGHT,
  LEFT,
}

export enum EntityType {
  ENEMY,
  FRIENDLY,
  RESOURCE,
  PROP,
  CHEST,
}

export interface entityData {
  name: string;
  location: { x: number; y: number };
}

export interface bloomData {
  blurAmount: number;
  color: string;
  xOffset: number;
  yOffset: number;
  size: number;
  alpha: number;
}

export class Entity extends Drawable {
  room: Room;
  x: number;
  y: number;
  w: number;
  h: number;
  direction: Direction;
  drawX: number;
  drawY: number;
  dead: boolean;
  game: Game;
  health: number;
  maxHealth: number;
  protected tileX: number;
  protected tileY: number;
  protected hasShadow: boolean;
  skipNextTurns: number;
  //TODO: change these to functions? for enemies that switch states
  destroyable: boolean; // can the player destroy this enemy?
  pushable: boolean; // can the player push this enemy? (true for crates/barrels, false for regular mobs)
  chainPushable: boolean; // can the player pushing another enemy push this enemy? (default true)
  interactable: boolean; // can the player interact
  protected deathParticleColor: string;
  healthBar: HealthBar;
  drop: Item;
  protected sleepingZFrame = 0;
  alertTicks: number;
  protected exclamationFrame: number;
  lastX: number;
  lastY: number;
  protected hitBy: Player;
  protected crushX: number;
  protected crushY: number;
  protected crushVertical: boolean;
  protected crushed: boolean;
  protected rumbling: boolean;
  protected animationSpeed: number;
  drawYOffset: number;
  name: string;
  protected orthogonalAttack: boolean;
  protected diagonalAttack: boolean;
  protected forwardOnlyAttack: boolean;
  protected attackRange: number;
  protected diagonalAttackRange: number;
  lightSource: LightSource;
  drawMoveSpeed: number;
  unconscious: boolean;
  hitWarnings: HitWarning[];
  imageParticleX: number = 0;
  imageParticleY: number = 26;
  dropChance: number = 0.02;
  isEnemy: boolean;
  shielded: boolean;
  //shieldHealth: number;
  frame: number;
  shield: EnemyShield;
  shieldedBefore: boolean;
  //shadeColor: string;
  shadeMultiplier: number = 1;
  hurting: boolean;
  hurtFrame: number;
  softShadeColor: string;
  shadeColor: string;
  dying: boolean;
  dyingFrame: number;
  alpha: number;
  cloned: boolean;
  hasBloom: boolean;
  bloomColor: string = "#FFFFFF";
  bloomAlpha: number = 1;
  softBloomAlpha: number = 1;
  bloomSize: number = 1;
  bloomOffsetY: number = 0;
  target: { x: number; y: number };
  moving: boolean;

  private _imageParticleTiles: { x: number; y: number };
  hitSound: () => void;

  constructor(room: Room, game: Game, x: number, y: number) {
    super();

    this.room = room;
    this.x = x;
    this.y = y;
    this.w = 1;
    this.h = 1;
    this.game = game;
    this.drawX = 0;
    this.drawY = 0;
    this.health = 1;
    this.maxHealth = 1;
    this.tileX = 0;
    this.tileY = 0;
    this.hasShadow = false;
    this.skipNextTurns = 0;
    this.direction = Direction.DOWN;
    this.destroyable = true;
    this.pushable = false;
    this.chainPushable = true;
    this.interactable = false;
    this.healthBar = new HealthBar();
    this.alertTicks = 0;
    this.exclamationFrame = 0;
    this.lastX = x;
    this.lastY = y;
    this.hitBy = null;
    this.crushX = 1;
    this.crushY = 1;
    this.crushVertical = false;
    this.crushed = false;
    this.rumbling = false;
    this.animationSpeed = 0.1;
    this.drawYOffset = 1.175;
    this.hitWarnings = [];
    this.orthogonalAttack = false;
    this.diagonalAttack = false;
    this.forwardOnlyAttack = false;
    this.attackRange = 1;
    this.diagonalAttackRange = 1;
    this.drawMoveSpeed = 0.3;
    this.unconscious = false;
    this.dropChance = 0.02;
    this.isEnemy = false;
    this.shielded = false;
    this.shield = null;
    this.frame = 0;
    this.shieldedBefore = false;
    this._imageParticleTiles = { x: 0, y: 0 };
    this.hitSound = null;
    this.shadeColor = this.room.shadeColor;
    this.hurting = false;
    this.hurtFrame = 0;
    this.softShadeColor = "#000000";
    this.dying = false;
    this.dyingFrame = 30;
    this.alpha = 1;
    this.cloned = false;
    this.dead = false;
    this.hasBloom = false;
    this.bloomColor = "#FFFFFF";
    this.moving = false;
  }

  static add<
    T extends new (
      room: Room,
      game: Game,
      x: number,
      y: number,
      ...rest: any[]
    ) => Entity,
  >(this: T, room: Room, game: Game, x: number, y: number, ...rest: any[]) {
    room.entities.push(new this(room, game, x, y, ...rest));
  }

  static cloneEntity(original: Entity): Entity {
    const { room, game, x, y } = original;

    // Create a new instance using the constructor
    const cloned = new (original.constructor as typeof Entity)(
      room,
      game,
      x,
      y,
    );

    // Assign other properties
    cloned.cloned = true;
    cloned.dead = false;
    cloned.dying = true;
    cloned.drawableY = original.drawableY;
    cloned.tileX = original.tileX;
    cloned.tileY = original.tileY;
    cloned.frame = original.frame;
    cloned.isEnemy = original.isEnemy;
    cloned.hasShadow = original.hasShadow;
    cloned.skipNextTurns = original.skipNextTurns;
    cloned.direction = original.direction;
    cloned.drawX = original.drawX;
    cloned.drawY = original.drawY;
    cloned.alpha = original.alpha;
    cloned.shadeColor = original.shadeColor;
    cloned.shadeMultiplier = original.shadeMultiplier;
    cloned.softShadeColor = original.softShadeColor;
    cloned.hasBloom = original.hasBloom;
    cloned.bloomColor = original.bloomColor;
    cloned.bloomAlpha = 1;
    cloned.softBloomAlpha = 1;
    cloned.removeLightSource(cloned.lightSource);
    cloned.room.updateLighting();

    // Add the cloned entity to deadEntities
    room.deadEntities.push(cloned);

    return cloned;
  }

  /**
   * Clones the current entity without adding it to deadEntities.
   */
  clone(): Entity {
    const cloned = Entity.cloneEntity(this);
    cloned.dead = false; // Explicitly set as not dead
    cloned.dying = true; // Ensure the clone is in a dying state

    return cloned;
  }

  get imageParticleTiles() {
    return this._imageParticleTiles;
  }

  applyShield = (shieldHealth: number = 1) => {
    if (!this.shieldedBefore) {
      this.shield = new EnemyShield(this, this.x, this.y, shieldHealth);
      this.shielded = true;
      this.shieldedBefore = true;
      this.health += shieldHealth;
      this.maxHealth += shieldHealth;
      this.shadeColor = "purple";
      this.shadeMultiplier = 0.5;
      this.hasBloom = true;
      this.bloomColor = "#2E0854";
      this.bloomAlpha = 1;
    }
  };

  removeShield = () => {
    if (this.shield) {
      this.health -= this.shield.health;
      this.maxHealth -= this.shield.health;
      this.shield.remove();
      this.shadeColor = this.room.shadeColor;
      this.shadeMultiplier = 1;
      this.hasBloom = false;
      this.bloomAlpha = 0;
    }
  };

  getDrop = (useCategory: string[] = [], force: boolean = false) => {
    DropTable.getDrop(this, false, useCategory, force);
    //make monsters drop degraded weapons
    if (this.drop instanceof Weapon && this.type === EntityType.ENEMY) {
      this.drop.durability = Math.floor(
        Random.rand() * 0.31 * this.drop.durabilityMax,
      );
      this.drop.durabilityMax;
    }
  };

  addLightSource = (lightSource: LightSource) => {
    this.room.lightSources.push(lightSource);
  };

  removeLightSource = (lightSource: LightSource) => {
    this.room.lightSources = this.room.lightSources.filter(
      (ls) => ls !== lightSource,
    );
    this.lightSource = null;
    this.room.updateLighting();
  };

  behavior = () => {};

  hit = (): number => {
    return 0;
  };

  hurtCallback = () => {};

  get type() {
    return EntityType.ENEMY;
  }

  pointIn = (x: number, y: number): boolean => {
    return (
      x >= this.x && x < this.x + this.w && y >= this.y && y < this.y + this.h
    );
  };

  createDamageNumber = (
    damage: number,
    type: "none" | "poison" | "blood" | "heal" = "none",
  ) => {
    let color = "red";
    let outlineColor = GameConstants.OUTLINE;
    if (type === "poison") color = "green";
    if (type === "blood") {
      color = "#8B0000";
      outlineColor = "red";
    }
    if (type === "heal") {
      color = "#B8A4FF";
      outlineColor = GameConstants.OUTLINE;
    }
    this.room.particles.push(
      new DamageNumber(this.room, this.x, this.y, damage, color, outlineColor),
    );
  };

  updateDrawXY = (delta: number) => {
    //putting this here bc i'm lazy
    this.updateHurtFrame(delta);
    this.animateDying(delta);
    this.updateShadeColor(delta);
    //this.updateBloom(delta);

    if (!this.doneMoving()) {
      this.drawX *= 0.9 ** delta;
      this.drawY *= 0.9 ** delta;

      this.drawX = Math.abs(this.drawX) < 0.01 ? 0 : this.drawX;
      this.drawY = Math.abs(this.drawY) < 0.01 ? 0 : this.drawY;
    }
  };

  setDrawXY = (x: number, y: number) => {
    this.drawX += this.x - x;
    this.drawY += this.y - y;
  };

  readonly getPlayer = () => {
    const maxDistance = 138291380921; // pulled this straight outta my ass
    let closestDistance = maxDistance;
    let closestPlayer = null;
    for (const i in this.game.players) {
      if (this.game.rooms[this.game.players[i].levelID] === this.room) {
        let distance = this.playerDistance(this.game.players[i]);
        if (distance < closestDistance) {
          closestDistance = distance;
          closestPlayer = this.game.players[i];
        }
      }
    }

    if (closestDistance === maxDistance) return false;
    else return closestPlayer;
  };

  hurt = (
    playerHitBy: Player,
    damage: number,
    type: "none" | "poison" | "blood" | "heal" = "none",
  ) => {
    this.handleEnemyCase(playerHitBy);

    let hitShield = false;
    let shieldHealth = 0;
    if (this.shielded) {
      shieldHealth = this.shield.health;
      if (shieldHealth > 0) {
        this.shield.hurt(damage);
        hitShield = true;
      }
    }
    /*
    this.shadeColor = "red";
    setTimeout(() => {
      this.shadeColor = this.room.shadeColor;
    }, 100);
    */

    this.health -= damage;
    this.maxHealth -= shieldHealth;

    this.startHurting();
    this.createDamageNumber(damage, type);
    this.playHitSound();

    this.healthBar.hurt();

    if (type === "none" || this.health <= 0 || !this.isEnemy) {
      this.createHitParticles();
    }

    if (this.health <= 0) {
      this.kill();
      this.bloomAlpha = 0;
    } else this.hurtCallback();
  };

  startHurting = () => {
    this.hurting = true;
    this.hurtFrame += 15;
    this.shadeColor = "#FF0000";
    this.shadeMultiplier = 1.5;
  };

  stopHurting = () => {
    this.hurting = false;
    this.hurtFrame = 0;
    this.shadeColor = "#000000";
  };

  interact = (player: Player) => {};

  handleEnemyCase = (playerHitBy?: Player) => {};

  playHitSound = () => {
    if (this.hitSound) Sound.delayPlay(this.hitSound, 250);
  };

  createHitParticles = () => {
    ImageParticle.spawnCluster(
      this.room,
      this.x + 0.5,
      this.y + 0.5,
      this.imageParticleX,
      this.imageParticleY,
    );
  };

  protected dropLoot = () => {
    let coordX: number;
    let coordY: number;
    if (this.crushed) {
      coordX = this.lastX;
      coordY = this.lastY;
    } else {
      coordX = this.x;
      coordY = this.y;
    }
    if (this.drop) {
      this.drop.level = this.room;
      if (!this.room.roomArray[coordX][coordY].isSolid()) {
        this.drop.x = coordX;
        this.drop.y = coordY;
      }
      this.room.items.push(this.drop);
      this.drop.onDrop();
    }
  };

  kill = () => {
    if (this.cloned) return;
    this.emitEnemyKilled();
    this.removeLightSource(this.lightSource);

    const deadEntity = this.clone();

    this.room.deadEntities.push(deadEntity);
    this.dead = true;
    //this.room.entities = this.room.entities.filter((e) => e !== this);
    this.dropLoot();
    this.uniqueKillBehavior();
  };

  uniqueKillBehavior = () => {};

  killNoBones = () => {
    this.dead = true;
    this.dropLoot();
  };

  updateHurtFrame = (delta: number) => {
    if (this.hurting) {
      this.hurtFrame -= delta;
      if (this.hurtFrame < 0) {
        this.stopHurting();
      }
    }
  };

  shadeAmount = () => {
    let softVis = this.room.softVis[this.x][this.y] * 1;

    if (this.shadeMultiplier > 1)
      return Math.min(1, softVis * this.shadeMultiplier);
    return this.room.softVis[this.x][this.y];
  };

  updateShadeColor = (delta: number) => {
    if (this.shadeMultiplier > 1) this.shadeMultiplier -= 0.01 * delta;
    if (this.shadeMultiplier < 1) this.shadeMultiplier = 1;
    let updated = false;

    // Convert hex color to RGB
    const hexToRgb = (hex: string): [number, number, number] => {
      const bigint = parseInt(hex.slice(1), 16);
      const r = (bigint >> 16) & 255;
      const g = (bigint >> 8) & 255;
      const b = bigint & 255;
      return [r, g, b];
    };
    // Convert RGB to hex color
    const rgbToHex = (rgb: [number, number, number]): string => {
      const [r, g, b] = rgb;
      return (
        "#" +
        ((1 << 24) + (r << 16) + (g << 8) + b)
          .toString(16)
          .slice(1)
          .toUpperCase()
      );
    };

    const [softR, softG, softB] = hexToRgb(this.softShadeColor);
    const [targetR, targetG, targetB] = hexToRgb(this.shadeColor);

    // Calculate differences
    let diffR = softR - targetR;
    let diffG = softG - targetG;
    let diffB = softB - targetB;

    let flagR = false;
    let flagG = false;
    let flagB = false;
    if (Math.abs(diffR) > 1) flagR = true;
    if (Math.abs(diffG) > 1) flagG = true;
    if (Math.abs(diffB) > 1) flagB = true;

    if (!flagR && !flagG && !flagB) {
      return this.softShadeColor;
    }

    let softShadeRgb = [softR, softG, softB];

    // Apply smoothing similar to fadeLighting
    if (flagR) {
      diffR *= 0.1 * delta;
      softShadeRgb[0] = this.room.clamp(Math.round(softR - diffR), 0, 255);
      updated = true;
    }

    if (flagG) {
      diffG *= 0.1 * delta;
      softShadeRgb[1] = this.room.clamp(Math.round(softG - diffG), 0, 255);
      updated = true;
    }

    if (flagB) {
      diffB *= 0.1 * delta;
      softShadeRgb[2] = this.room.clamp(Math.round(softB - diffB), 0, 255);
      updated = true;
    }

    if (updated) {
      this.softShadeColor = rgbToHex(softShadeRgb as [number, number, number]);
    }

    return this.softShadeColor;
  };

  emitEnemyKilled = () => {
    globalEventBus.emit(EVENTS.ENEMY_KILLED, {
      enemyId: this.name,
    });
  };

  doneMoving = (): boolean => {
    let EPSILON = 0.01;
    return Math.abs(this.drawX) < EPSILON && Math.abs(this.drawY) < EPSILON;
  };

  nearestPlayer = (): [number, Player] | false => {
    const maxDistance = 138291380921; // pulled this straight outta my ass
    let closestDistance = maxDistance;
    let closestPlayer = null;
    for (const i in this.game.players) {
      if (this.game.rooms[this.game.players[i].levelID] === this.room) {
        let distance = this.playerDistance(this.game.players[i]);
        if (distance < closestDistance) {
          closestDistance = distance;
          closestPlayer = this.game.players[i];
        }
      }
    }

    if (closestDistance === maxDistance) return false;
    else return [closestDistance, closestPlayer];
  };

  playerDistance = (player: Player): number => {
    return Math.max(Math.abs(this.x - player.x), Math.abs(this.y - player.y));
  };

  facePlayer = (player: Player) => {
    let dx = player.x - this.x;
    let dy = player.y - this.y;
    if (Math.abs(dx) === Math.abs(dy)) {
      // just moved, already facing player
    } else if (Math.abs(dx) > Math.abs(dy)) {
      if (dx > 0) this.direction = Direction.RIGHT;
      if (dx < 0) this.direction = Direction.LEFT;
    } else {
      if (dy > 0) this.direction = Direction.DOWN;
      if (dy < 0) this.direction = Direction.UP;
    }
  };

  animateDying = (delta: number) => {
    if (this.cloned) {
      //this.frame = 0;
      this.dyingFrame -= delta / 3;
      this.alpha = Math.max(0, this.alpha - delta / 50);

      if (this.dyingFrame <= 0) {
        this.dead = true;
        this.dying = false;
        this.uniqueKillBehavior();
        this.room.clearDeadStuff();
      }
    }
  };

  draw = (delta: number) => {
    if (!this.dead) {
      Game.ctx.globalAlpha = this.alpha;
      if (this.shielded)
        if (this.hasShadow) {
          Game.drawFX(
            0,
            0,
            1,
            1,
            this.x - this.drawX,
            this.y - this.drawY,
            1,
            1,
            this.shadeColor,
            this.shadeAmount(),
          );
        }
      Game.drawMob(
        0,
        0,
        1,
        1,
        this.x - this.drawX,
        this.y - this.drawY,
        1,
        1,
        this.room.shadeColor,
        this.shadeAmount(),
      );
      Game.drawMob(
        this.tileX,
        this.tileY + this.direction * 2,
        1,
        2,
        this.x - this.drawX,
        this.y - this.drawYOffset - this.drawY,
        1,
        2,
        this.shadeColor,
        this.shadeAmount(),
      );
    }
    /*if (this.crushed) {
      this.crushAnim(delta);
    }*/
    Game.ctx.globalAlpha = 1;
  };

  tick = () => {
    this.behavior();
    if (this.shielded) this.shield.updateLightSourcePos();
  };

  emitEntityData = (): void => {
    globalEventBus.emit("EntityData", {
      name: this.name,
      location: { x: this.x, y: this.y },
    });
  };

  drawTopLayer = (delta: number) => {
    //this.updateDrawXY(delta);

    this.drawableY = this.y - this.drawY;

    this.healthBar.draw(
      delta,
      this.health,
      this.maxHealth,
      this.x,
      this.y,
      true,
    );
  };

  drawSleepingZs = (delta: number, offsetX = 0, offsetY = 0) => {
    this.sleepingZFrame += delta;

    let numZs = 2;
    let t = this.sleepingZFrame * 0.01; // 0 <= t < 1
    t -= Math.floor(t);
    //let whichway = Math.floor(this.sleepingZFrame * 0.02 / numZs) % 2;
    for (let off = numZs - 1; off >= 0; off--) {
      let yoff = (t + off) * 7;
      let alpha = Math.min(1 - (t + off) / numZs, (2 * (t + off)) / numZs);

      let xoff = 0;
      if (off === 0) xoff = 1;
      if (t >= 0.33 && t < 0.66) xoff = off;
      if (t >= 0.33 && t < 0.66) xoff = off;

      let width = Game.measureText("Z").width;
      if (GameConstants.ALPHA_ENABLED) Game.ctx.globalAlpha = alpha;
      Game.fillTextOutline(
        "Z",
        (this.x + 0.5) * GameConstants.TILESIZE - width / 2 + xoff + offsetX,
        (this.y - 0.6) * GameConstants.TILESIZE - yoff + offsetY,
        GameConstants.OUTLINE,
        "white",
      );
      Game.ctx.globalAlpha = 1;
    }
  };

  drawExclamation = (delta: number, offsetX = 0, offsetY = 0) => {
    this.exclamationFrame += delta;

    let yoff: number | false = 0;
    let yoffs: Array<number | false> = [0, -1, -2, -3, -5, -7, -4];
    if (this.exclamationFrame > yoffs.length) yoff = yoffs[yoffs.length - 1];
    else yoff = yoffs[this.exclamationFrame];

    let width = Game.measureText("!").width;
    Game.ctx.globalAlpha = 1;
    if (yoff !== false) {
      Game.fillTextOutline(
        "!",
        (this.x + 0.5) * GameConstants.TILESIZE - width / 2 + offsetX,
        (this.y - 0.75) * GameConstants.TILESIZE + yoff + offsetY,
        GameConstants.OUTLINE,
        GameConstants.WARNING_RED,
      );
    }
  };

  crush = () => {
    this.crushed = true;
    let player: Player;
    for (let i in this.game.players) {
      player = this.game.players[i];
    }
    if (this.x == player.x) {
      this.crushVertical = true;
    }
    this.kill();
  };

  crushAnim = (delta: number) => {
    if (this.crushVertical && this.crushY >= 0) {
      this.crushY *= 0.95;
    } else if (this.crushX >= 0) {
      this.crushX *= 0.95;
    }
  };
  //set rumbling in the tick function for the enemies
  //create variables for the rumbling x and y offsets
  //return the rumbling x and y offsets
  //add the rumbling x and y offsets to the enemy's x and y in the draw function
  rumble = (rumbling: boolean, frame: number, direction?: Direction) => {
    let rumbleOffset = { x: 0, y: 0 };

    if (rumbling) {
      const isOddFrame = Math.floor(frame) % 2 === 1;
      const offset = isOddFrame ? 0.0325 : 0;

      if (direction === Direction.LEFT || direction === Direction.RIGHT) {
        rumbleOffset.y = offset;
      } else if (
        direction === Direction.UP ||
        direction === Direction.DOWN ||
        !direction
      ) {
        rumbleOffset.x = offset;
      }
      this.animationSpeed = 0.2;
    }
    return rumbleOffset;
  };

  attemptProjectilePlacement = (
    offsets: { x: number; y: number }[],
    projectileClass: new (parent: Entity, x: number, y: number) => Projectile,
    collide: boolean = false,
    clearPath: boolean = true,
    targetingPlayer: boolean = false,
  ) => {
    for (const offset of offsets) {
      const targetX = this.x + offset.x;
      const targetY = this.y + offset.y;

      if (
        !this.isValidProjectilePosition(targetX, targetY, collide, clearPath)
      ) {
        if (targetingPlayer) break;
        continue;
      }

      this.placeProjectile(projectileClass, targetX, targetY);

      if (targetingPlayer) break;
    }
  };

  private isValidProjectilePosition = (
    x: number,
    y: number,
    collide: boolean,
    clearPath: boolean,
  ): boolean => {
    if (!this.isWithinRoomBounds(x, y)) return false;
    if (clearPath && !this.isPathClear(this.x, this.y, x, y)) return false;
    if (collide && this.isEntityColliding(x, y)) return false;

    const targetTile = this.room.roomArray[x][y];
    return targetTile && !targetTile.isSolid() && !targetTile.isDoor;
  };

  private isEntityColliding = (x: number, y: number): boolean => {
    return this.room.entities.some(
      (entity) => entity.x === x && entity.y === y,
    );
  };

  private placeProjectile = (
    projectileClass: new (
      parent: Entity,
      x: number,
      y: number,
      color?: [number, number, number],
    ) => Projectile,
    x: number,
    y: number,
    color?: [number, number, number],
  ) => {
    this.room.projectiles.push(new projectileClass(this, x, y, color));
  };

  isPathClear = (
    startX: number,
    startY: number,
    endX: number,
    endY: number,
  ): boolean => {
    const dx = Math.sign(endX - startX);
    const dy = Math.sign(endY - startY);
    let x = startX;
    let y = startY;

    while (x !== endX || y !== endY) {
      x += dx;
      y += dy;
      if (
        !this.isWithinRoomBounds(x, y) ||
        this.room.roomArray[x][y]?.isSolid()
      ) {
        return false;
      }
    }

    return true;
  };

  calculateProjectileOffsets(
    targetX: number,
    targetY: number,
    attackLength: number,
  ): { x: number; y: number }[] {
    const dx = targetX - this.x;
    const dy = targetY - this.y;
    let offsets = [];

    // Normalize the direction
    const stepX = dx !== 0 ? Math.sign(dx) : 0;
    const stepY = dy !== 0 ? Math.sign(dy) : 0;

    // Generate offsets for the full attackLength
    for (let i = 1; i <= attackLength; i++) {
      offsets.push({ x: i * stepX, y: i * stepY });
    }

    return offsets;
  }

  getLuminance = (): number => {
    if (this.room.roomArray[this.x][this.y]) {
      return this.room.vis[this.x][this.y];
    }
    return null;
  };

  getAverageLuminance = (): number => {
    let total = 0;
    let count = 0;
    for (let x = this.x - 2; x <= this.x + 2; x++) {
      if (this.room.roomArray[x] && this.room.roomArray[x][this.y]) {
        for (let y = this.y - 2; y <= this.y + 2; y++) {
          if (this.room.vis[x][y]) {
            total += this.room.vis[x][y];
            count++;
          }
        }
      }
    }
    return total / count;
  };

  getOpenTile = (): { x: number; y: number } => {
    let x, y;
    do {
      x = Math.floor(Random.rand() * 3 + this.x - 1);
      y = Math.floor(Random.rand() * 3 + this.y - 1);
    } while (
      (x === this.x && y === this.y) ||
      this.room.roomArray[x][y].isSolid() ||
      this.room.roomArray[x][y] instanceof DownLadder ||
      this.room.roomArray[x][y] instanceof Door ||
      this.room.roomArray[x][y] instanceof Wall ||
      this.room.entities.some((e) => e.x === x && e.y === y)
    );

    if (!x || !y) return { x: this.x, y: this.y };
    return { x, y };
  };

  makeHitWarnings = () => {
    const cullFactor = 0.45;
    const player: Player = this.getPlayer();
    const orthogonal = this.orthogonalAttack;
    const diagonal = this.diagonalAttack;
    const forwardOnly = this.forwardOnlyAttack;
    const direction = this.direction;
    const orthoRange = this.attackRange;
    const diagRange = this.diagonalAttackRange;

    const generateOffsets = (
      isOrthogonal: boolean,
      range: number,
    ): number[][] => {
      const baseOffsets = isOrthogonal
        ? [
            [-1, 0],
            [1, 0],
            [0, -1],
            [0, 1],
          ]
        : [
            [-1, -1],
            [1, 1],
            [1, -1],
            [-1, 1],
          ];
      return baseOffsets.flatMap(([dx, dy]) =>
        Array.from({ length: range }, (_, i) => [(i + 1) * dx, (i + 1) * dy]),
      );
    };

    const directionOffsets = {
      [Direction.LEFT]: [-1, 0],
      [Direction.RIGHT]: [1, 0],
      [Direction.UP]: [0, -1],
      [Direction.DOWN]: [0, 1],
    };

    let offsets: number[][] = [];
    if (forwardOnly) {
      const [dx, dy] = directionOffsets[direction];
      offsets = Array.from({ length: orthoRange }, (_, i) => [
        (i + 1) * dx,
        (i + 1) * dy,
      ]);
    } else {
      if (orthogonal) offsets.push(...generateOffsets(true, orthoRange));
      if (diagonal) offsets.push(...generateOffsets(false, diagRange));
    }

    const warningCoordinates = offsets
      .map(([dx, dy]) => ({
        x: dx,
        y: dy,
        distance: Utils.distance(dx, dy, player.x - this.x, player.y - this.y),
      }))
      .sort((a, b) => a.distance - b.distance);

    const keepCount = Math.ceil(warningCoordinates.length * (1 - cullFactor));
    const culledWarnings = warningCoordinates.slice(0, keepCount);

    culledWarnings.forEach(({ x, y }) => {
      const targetX = this.x + x;
      const targetY = this.y + y;
      if (this.isWithinRoomBounds(targetX, targetY)) {
        const hitWarning = new HitWarning(
          this.game,
          targetX,
          targetY,
          this.x,
          this.y,
          true,
          false,
          this,
        );
        this.room.hitwarnings.push(hitWarning);
        //this.hitWarnings.push(hitWarning);
      }
    });
  };

  isWithinRoomBounds = (x: number, y: number): boolean => {
    const xInBounds =
      x >= this.room.roomX && x < this.room.roomX + this.room.width;
    const yInBounds =
      y >= this.room.roomY && y < this.room.roomY + this.room.height;
    const tileExists =
      this.room.roomArray[x] && this.room.roomArray[x][y] !== undefined;

    return xInBounds && yInBounds && tileExists;
  };
}


--- src/entity/object/barrel.ts ---
import { Entity } from "../entity";
import { Room } from "../../room";
import { Game } from "../../game";
import { EntityType } from "../entity";
import { ImageParticle } from "../../particle/imageParticle";
import { WeaponFragments } from "../../item/weaponFragments";
import { Coin } from "../../item/coin";

export class Barrel extends Entity {
  constructor(room: Room, game: Game, x: number, y: number) {
    super(room, game, x, y);
    this.room = room;
    this.health = 1;
    this.tileX = 1;
    this.tileY = 0;
    this.hasShadow = false;
    this.pushable = true;
    this.name = "barrel";
    this.imageParticleX = 3;
    this.imageParticleY = 25;
    if (Random.rand() < 0.1) {
      this.drop = new WeaponFragments(this.room, this.x, this.y);
    } else {
      this.drop = new Coin(this.room, this.x, this.y);
    }
  }

  get type() {
    return EntityType.PROP;
  }

  killNoBones = () => {
    this.kill();
  };

  draw = (delta: number) => {
    if (this.dead) return;
    Game.ctx.save();

    //this.updateShadeColor(delta);
    Game.ctx.globalAlpha = this.alpha;
    if (!this.dead) {
      this.updateDrawXY(delta);
      Game.drawObj(
        this.tileX,
        this.tileY,
        1,
        2,
        this.x - this.drawX,
        this.y - this.drawYOffset - this.drawY,
        1,
        2,
        this.room.shadeColor,
        this.shadeAmount(),
      );
    }
    Game.ctx.restore();
  };

  drawTopLayer = (delta: number) => {
    this.drawableY = this.y;
  };
}


--- src/entity/object/block.ts ---
import { Entity } from "../entity";
import { Room } from "../../room";
import { Game } from "../../game";
import { Heart } from "../../item/heart";
import { LevelConstants } from "../../levelConstants";
import { GenericParticle } from "../../particle/genericParticle";
import { EntityType } from "../entity";
import { ImageParticle } from "../../particle/imageParticle";
import { Sound } from "../../sound";

export class Block extends Entity {
  constructor(room: Room, game: Game, x: number, y: number) {
    super(room, game, x, y);
    this.room = room;
    this.health = 1;
    this.tileX = 10;
    this.tileY = 2;
    this.hasShadow = false;
    this.chainPushable = true;
    this.pushable = true;
    this.name = "block";
    this.imageParticleX = 0;
    this.imageParticleY = 25;
  }

  get type() {
    return EntityType.PROP;
  }

  kill = () => {
    Sound.breakRock();
    this.dead = true;

    ImageParticle.spawnCluster(
      this.room,
      this.x + 0.5,
      this.y + 0.5,
      this.imageParticleX,
      this.imageParticleY,
    );
  };

  killNoBones = () => {
    this.kill();
  };

  draw = (delta: number) => {
    if (this.dead) return;
    Game.ctx.save();
    Game.ctx.globalAlpha = this.alpha;
    if (!this.dead) {
      this.updateDrawXY(delta);
      Game.drawObj(
        this.tileX,
        this.tileY,
        1,
        2,
        this.x - this.drawX,
        this.y - this.drawYOffset - this.drawY,
        1,
        2,
        this.room.shadeColor,
        this.shadeAmount(),
      );
    }
    Game.ctx.restore();
  };

  drawTopLayer = (delta: number) => {
    this.drawableY = this.y;
  };
}


--- src/entity/object/bomb.ts ---
import { Entity } from "../entity";
import { Room } from "../../room";
import { Game } from "../../game";
import { Heart } from "../../item/heart";
import { LevelConstants } from "../../levelConstants";
import { GenericParticle } from "../../particle/genericParticle";
import { EntityType } from "../entity";
import { ImageParticle } from "../../particle/imageParticle";
import { Candle } from "../../item/candle";
import { Random } from "../../random";
import { Coin } from "../../item/coin";
import { Sound } from "../../sound";
import { LightSource } from "../../lightSource";
import { WizardFireball } from "../../projectile/wizardFireball";
import { WizardEnemy } from "../enemy/wizardEnemy";
import { Lighting } from "../../lighting";
import { PlayerFireball } from "../../projectile/playerFireball";
import { Player } from "../../player";
import { Explosion } from "../../projectile/explosion";
import { Utils } from "../../utils";

export class Bomb extends Entity {
  fuseLength: number = 4;
  lit: boolean = false;
  playerHitBy: Player | null = null;
  fuseSound: HTMLAudioElement;
  soundPaused: boolean = false;
  constructor(room: Room, game: Game, x: number, y: number) {
    super(room, game, x, y);
    this.room = room;
    this.health = 1;
    this.tileX = 15;
    this.tileY = 4;
    this.hasShadow = false;
    this.chainPushable = false;
    this.name = "bomb";
    this.frame = 0;
    this.hasBloom = false;
    this.bloomColor = "yellow";
    this.bloomAlpha = 0;
    this.bloomSize = 1;
    this.bloomOffsetY = -1;
    this.health = 1;
    this.hitSound = Sound.potSmash;
    this.imageParticleX = 0;
    this.imageParticleY = 29;
    this.createLightSource();
    this.playerHitBy = null;
    this.fuseSound = Sound.fuseLoopSound;
    this.soundPaused = false;
  }

  get type() {
    return EntityType.PROP;
  }

  killNoBones = () => {
    this.kill();
  };

  uniqueKillBehavior = () => {
    if (this.cloned) return;

    //this.room.addEntity(new Explosion(this.room, this.game, this.x, this.y));
  };

  tick = () => {
    if (this.lit) {
      this.fuseLength--;
      //if (this.fuseLength < 3 && this.fuseLength > 0)
      if (this.fuseLength <= 0) {
        // Sound.playFuse();
        this.fuseLength = 0;
        Sound.stopSound(this.fuseSound);
        this.explode();
        Sound.playBomb();
      }
    }
  };

  createLightSource = () => {
    if (!this.lit) return;
    this.lightSource = new LightSource(
      this.x + 0.5,
      this.y + 0.5,
      3,
      [200, 200, 30],
      0.75,
    );
    this.addLightSource(this.lightSource);
    this.bloomAlpha = 1;
    this.hasBloom = true;
  };

  hurt = (playerHitBy: Player, damage: number) => {
    if (!this.lit) {
      this.lit = true;
      this.createLightSource();
      this.playerHitBy = playerHitBy;
      Sound.playFuse();
    }
  };

  explode = () => {
    Sound.stopSound(this.fuseSound);
    for (let x = this.x - 2; x < this.x + 3; x++) {
      for (let y = this.y - 2; y < this.y + 3; y++) {
        if (
          this.room.pointExists(x, y) &&
          !this.room.roomArray[x][y].isSolid() &&
          Utils.distance(this.x, this.y, x, y) < 2.5
        ) {
          const explosion = new Explosion(this, x, y, this.playerHitBy);
          this.room.projectiles.push(explosion);
        }
      }
    }
    this.health = 0;
    Lighting.momentaryLight(
      this.room,
      this.x,
      this.y,
      7,
      [200, 200, 50],
      250,
      50,
      0,
    );

    console.log("screen shake");
    GenericParticle.spawnCluster(
      this.room,
      this.x + 0.5,
      this.y + 0.5,
      "white",
    );
    this.kill();

    setTimeout(() => {
      this.game.shakeScreen(
        (Random.rand() - 0.5) * 5,
        (Random.rand() - 0.5) * 0,
        false,
      );
    }, 100);

    this.game.shakeScreen(0, 20, false);
  };

  draw = (delta: number) => {
    if (this.dead) return;
    this.frame += delta;
    if (this.health === 0) {
      this.frame = 0;
    }
    if (this.frame > 20) this.frame = 0;
    this.bloomAlpha = (this.frame / 10) % 2 === 0 ? 1 : 0.5;
    Game.ctx.save();
    Game.ctx.globalAlpha = this.alpha;
    if (!this.dead) {
      this.updateDrawXY(delta);
      if (this.lit) {
        Game.drawObj(
          this.tileX +
            6 -
            Math.min(3, this.fuseLength) * 2 +
            (Math.floor(this.frame / 10) % 2),
          this.tileY,
          1,
          2,
          this.x - this.drawX,
          this.y - this.drawYOffset - this.drawY,
          1,
          2,
          this.room.shadeColor,
          this.shadeAmount(),
        );
      } else {
        Game.drawObj(
          this.tileX - 1,
          this.tileY,
          1,
          2,
          this.x - this.drawX,
          this.y - this.drawYOffset - this.drawY,
          1,
          2,
          this.room.shadeColor,
          this.shadeAmount(),
        );
      }
    }
    Game.ctx.restore();
  };

  drawTopLayer = (delta: number) => {
    this.drawableY = this.y;
  };
}


--- src/entity/object/chest.ts ---
import { Game } from "../../game";
import { Room } from "../../room";
import { Entity } from "../entity";
import { Coin } from "../../item/coin";
import { EntityType } from "../entity";
import { Random } from "../../random";
import { Player } from "../../player";
import { ChestLayer } from "./chestLayer";
import { ImageParticle } from "../../particle/imageParticle";
import { Sound } from "../../sound";

export class Chest extends Entity {
  frame: number;
  opening: boolean;
  dropX: number;
  dropY: number;
  layer: ChestLayer;
  constructor(room: Room, game: Game, x: number, y: number) {
    super(room, game, x, y);

    this.tileX = 4;
    this.tileY = 0;
    this.health = 3;
    this.name = "chest";
    this.frame = 0;
    this.opening = false;
    this.dropX = 0;
    this.dropY = 0;
    this.drop = null;
    this.destroyable = false;
    this.pushable = false;
    this.chainPushable = false;
    this.interactable = true;
    this.imageParticleX = 3;
    this.imageParticleY = 26;
    /*
    this.layer = new ChestLayer(
      this.room,
      this.game,
      this.x,
      this.y,
    );
    this.room.entities.push(this.layer);
    */
  }

  get type() {
    return EntityType.CHEST;
  }

  interact = (playerHitBy: Player) => {
    //this.healthBar.hurt();
    this.health -= 1;
    if (this.health === 2 && !this.opening) this.open();

    if (this.health === 1) {
      this.drop.onPickup(playerHitBy);
      this.destroyable = true;
    }
    if (this.health <= 0) {
      this.kill();
    } else this.hurtCallback();
  };

  private open = () => {
    this.tileX = 0;
    this.tileY = 2;

    this.opening = true;
    Sound.chest();

    if (this.drop === null) this.getDrop(["consumable", "gem", "coin"]);
    if (this.drop.name === "coin") {
      const stack = Math.ceil(Random.rand() * 5);
      this.drop.stackCount = stack;
      this.drop.stack = stack;
    }
    this.dropLoot();
    this.drop.animateFromChest();
  };

  rollDrop = (): number => {
    return Game.randTable([1, 1, 1, 1, 1, 1, 1, 2, 3, 4, 5, 2, 2], Random.rand);
  };

  killNoBones = () => {
    this.kill();
  };

  draw = (delta: number) => {
    if (this.dead) return;
    Game.ctx.save();
    Game.ctx.globalAlpha = this.alpha;

    if (this.opening) {
      if (this.tileX <= 6) {
        this.tileX += 0.15 * delta;
      } else {
        this.opening = false;
      }
    }

    if (!this.dead) {
      this.updateDrawXY(delta);
      Game.drawObj(
        Math.floor(this.tileX),
        Math.floor(this.tileY),
        1,
        2,
        this.x - this.drawX,
        this.y - this.drawYOffset - this.drawY,
        1,
        2,
        this.room.shadeColor,
        this.shadeAmount(),
      );
    }
    Game.ctx.restore();
  };

  drawTopLayer = (delta: number) => {
    this.drawableY = this.y - 1;
  };
}


--- src/entity/object/crate.ts ---
import { Entity } from "../entity";
import { Room } from "../../room";
import { Game } from "../../game";
import { Heart } from "../../item/heart";
import { LevelConstants } from "../../levelConstants";
import { GenericParticle } from "../../particle/genericParticle";
import { EntityType } from "../entity";
import { ImageParticle } from "../../particle/imageParticle";
import { WeaponFragments } from "../../item/weaponFragments";
import { Coin } from "../../item/coin";

export class Crate extends Entity {
  constructor(room: Room, game: Game, x: number, y: number) {
    super(room, game, x, y);
    this.room = room;
    this.health = 1;
    this.maxHealth = 1;
    this.tileX = 0;
    this.tileY = 0;
    this.hasShadow = false;
    this.pushable = true;
    this.name = "crate";
    this.imageParticleX = 3;
    this.imageParticleY = 26;
    if (Random.rand() < 0.1) {
      this.drop = new WeaponFragments(this.room, this.x, this.y, 10);
    } else {
      this.drop = new Coin(this.room, this.x, this.y);
    }
  }

  get type() {
    return EntityType.PROP;
  }

  killNoBones = () => {
    this.kill();
  };

  draw = (delta: number) => {
    if (this.dead) return;
    Game.ctx.save();
    Game.ctx.globalAlpha = this.alpha;
    if (!this.dead) {
      this.updateDrawXY(delta);
      Game.drawObj(
        this.tileX,
        this.tileY,
        1,
        2,
        this.x - this.drawX,
        this.y - this.drawYOffset - this.drawY,
        1,
        2,
        this.room.shadeColor,
        this.shadeAmount(),
      );
    }
    Game.ctx.restore();
  };

  drawTopLayer = (delta: number) => {
    this.drawableY = this.y;
  };
}


--- src/entity/object/mushrooms.ts ---
import { Entity } from "../entity";
import { Room } from "../../room";
import { Game } from "../../game";
import { Heart } from "../../item/heart";
import { LevelConstants } from "../../levelConstants";
import { GenericParticle } from "../../particle/genericParticle";
import { Shrooms } from "../../item/shrooms";
import { EntityType } from "../entity";
import { ImageParticle } from "../../particle/imageParticle";

export class Mushrooms extends Entity {
  constructor(room: Room, game: Game, x: number, y: number) {
    super(room, game, x, y);
    this.room = room;
    this.health = 1;
    this.tileX = 9;
    this.tileY = 2;
    this.hasShadow = false;
    this.chainPushable = false;
    this.name = "mushrooms";
    this.imageParticleX = 0;
    this.imageParticleY = 30;
  }

  get type() {
    return EntityType.PROP;
  }

  killNoBones = () => {
    this.kill();
  };

  draw = (delta: number) => {
    if (this.dead) return;
    Game.ctx.save();

    Game.ctx.globalAlpha = this.alpha;
    if (!this.dead) {
      this.updateDrawXY(delta);
      Game.drawObj(
        this.tileX,
        this.tileY,
        1,
        2,
        this.x - this.drawX,
        this.y - this.drawYOffset - this.drawY,
        1,
        2,
        this.room.shadeColor,
        this.shadeAmount(),
      );
    }
    Game.ctx.restore();
  };

  drawTopLayer = (delta: number) => {
    this.drawableY = this.y;
  };
}


--- src/entity/object/pot.ts ---
import { Entity } from "../entity";
import { Room } from "../../room";
import { Game } from "../../game";
import { Heart } from "../../item/heart";
import { LevelConstants } from "../../levelConstants";
import { GenericParticle } from "../../particle/genericParticle";
import { EntityType } from "../entity";
import { ImageParticle } from "../../particle/imageParticle";
import { Candle } from "../../item/candle";
import { Random } from "../../random";
import { Coin } from "../../item/coin";
import { Sound } from "../../sound";

export class Pot extends Entity {
  constructor(room: Room, game: Game, x: number, y: number) {
    super(room, game, x, y);
    this.room = room;
    this.health = 1;
    this.tileX = 11;
    this.tileY = 0;
    this.hasShadow = false;
    this.chainPushable = false;
    this.name = "pot";

    this.hitSound = Sound.potSmash;
    this.imageParticleX = 0;
    this.imageParticleY = 29;

    let dropProb = Random.rand();
    if (dropProb < 0.025) this.drop = new Heart(this.room, this.x, this.y);
    else this.drop = new Coin(this.room, this.x, this.y);
  }

  get type() {
    return EntityType.PROP;
  }

  killNoBones = () => {
    this.kill();
  };

  draw = (delta: number) => {
    if (this.dead) return;
    Game.ctx.save();
    Game.ctx.globalAlpha = this.alpha;
    if (!this.dead) {
      this.updateDrawXY(delta);
      Game.drawObj(
        this.tileX,
        this.tileY,
        1,
        2,
        this.x - this.drawX,
        this.y - this.drawYOffset - this.drawY,
        1,
        2,
        this.room.shadeColor,
        this.shadeAmount(),
      );
    }
    Game.ctx.restore();
  };

  drawTopLayer = (delta: number) => {
    this.drawableY = this.y;
  };
}


--- src/entity/object/pottedPlant.ts ---
import { Entity } from "../entity";
import { Room } from "../../room";
import { Game } from "../../game";
import { Heart } from "../../item/heart";
import { LevelConstants } from "../../levelConstants";
import { GenericParticle } from "../../particle/genericParticle";
import { Item } from "../../item/item";
import { Coin } from "../../item/coin";
import { EntityType } from "../entity";
import { ImageParticle } from "../../particle/imageParticle";
import { Random } from "../../random";
import { Sound } from "../../sound";

export class PottedPlant extends Entity {
  drop: Item;
  constructor(room: Room, game: Game, x: number, y: number, drop?: Item) {
    super(room, game, x, y);
    this.room = room;
    this.health = 2;
    this.tileX = 3;
    this.tileY = 0;
    this.hasShadow = false;
    this.chainPushable = false;
    this.name = "plant";
    this.imageParticleX = 0;
    this.imageParticleY = 28;
    if (drop) this.drop = drop;
    else {
      let dropProb = Random.rand();
      if (dropProb < 0.025) this.drop = new Heart(this.room, this.x, this.y);
      else this.drop = new Coin(this.room, this.x, this.y);
    }
  }

  get type() {
    return EntityType.PROP;
  }

  killNoBones = () => {
    this.dead = true;
  };

  uniqueKillBehavior = () => {
    ImageParticle.spawnCluster(this.room, this.x + 0.5, this.y + 0.5, 0, 29);
  };

  draw = (delta: number) => {
    if (this.dead) return;
    Game.ctx.save();
    Game.ctx.globalAlpha = this.alpha;
    if (!this.dead) {
      this.updateDrawXY(delta);
      if (this.health <= 1 || this.dying) this.tileX = 2;
      Game.drawObj(
        this.tileX,
        this.tileY,
        1,
        2,
        this.x - this.drawX,
        this.y - this.drawYOffset - this.drawY,
        1,
        2,
        this.room.shadeColor,
        this.shadeAmount(),
      );
    }
    Game.ctx.restore();
  };

  drawTopLayer = (delta: number) => {
    this.drawableY = this.y;
  };

  dropLoot = () => {
    this.drop.level = this.room;
    this.drop.x = this.x;
    this.drop.y = this.y;
    this.room.items.push(this.drop);
  };
}


--- src/entity/object/pumpkin.ts ---
import { Entity } from "../entity";
import { Room } from "../../room";
import { Game } from "../../game";
import { Heart } from "../../item/heart";
import { LevelConstants } from "../../levelConstants";
import { GenericParticle } from "../../particle/genericParticle";
import { Shrooms } from "../../item/shrooms";
import { EntityType } from "../entity";
import { LightSource } from "../../lightSource";
import { Spellbook } from "../../weapon/spellbook";
import { Random } from "../../random";
import { Candle } from "../../item/candle";
import { ImageParticle } from "../../particle/imageParticle";

export class Pumpkin extends Entity {
  constructor(room: Room, game: Game, x: number, y: number) {
    super(room, game, x, y);
    this.room = room;
    this.health = 1;
    this.tileX = 15;
    this.tileY = 2;
    this.hasShadow = false;
    this.chainPushable = false;
    this.name = "pumpkin";
    this.drop = new Candle(this.room, this.x, this.y);
    this.imageParticleX = 0;
    this.imageParticleY = 25;
    this.bloomColor = "#FFA500";
    this.hasBloom = true;
    this.bloomAlpha = 1;
    this.softBloomAlpha = 0;
    this.lightSource = new LightSource(
      this.x + 0.5,
      this.y + 0.5,
      5,
      [200, 30, 1],
      3,
    );
    this.addLightSource(this.lightSource);
  }

  get type() {
    return EntityType.PROP;
  }

  killNoBones = () => {
    this.kill();
  };

  uniqueKillBehavior = () => {
    this.removeLightSource(this.lightSource);
  };

  draw = (delta: number) => {
    if (this.dead) return;
    Game.ctx.save();
    Game.ctx.globalAlpha = this.alpha;
    if (!this.dead) {
      this.updateDrawXY(delta);
      Game.drawObj(
        this.tileX,
        this.tileY,
        1,
        2,
        this.x - this.drawX,
        this.y - this.drawYOffset - this.drawY,
        1,
        2,
        this.room.shadeColor,
        this.shadeAmount(),
      );
    }
    Game.ctx.restore();
  };

  drawTopLayer = (delta: number) => {
    this.drawableY = this.y;
  };
}


--- src/entity/object/tombStone.ts ---
import { Entity } from "../entity";
import { Room } from "../../room";
import { Game } from "../../game";
import { Heart } from "../../item/heart";
import { LevelConstants } from "../../levelConstants";
import { GenericParticle } from "../../particle/genericParticle";
import { EntityType } from "../entity";
import { SkullEnemy } from "../enemy/skullEnemy";
import { Random } from "../../random";
import { EnemySpawnAnimation } from "../../projectile/enemySpawnAnimation";
import { Player } from "../../player";
import { Item } from "../../item/item";
import { Spellbook } from "../../weapon/spellbook";
import { Sound } from "../../sound";
import { ImageParticle } from "../../particle/imageParticle";
import { LightSource } from "../../lightSource";

export class TombStone extends Entity {
  skinType: number;

  constructor(
    room: Room,
    game: Game,
    x: number,
    y: number,
    skinType: number,
    drop?: Item,
  ) {
    super(room, game, x, y);
    this.skinType = skinType;
    this.room = room;
    this.health = 2;
    this.maxHealth = 2;
    this.tileX = 11 + this.skinType;
    this.tileY = 2;
    this.hasShadow = false;
    this.pushable = false;
    this.destroyable = true;
    this.skinType = skinType;
    this.chainPushable = false;
    this.name = "tombstone";
    let dropProb = Random.rand();
    if (dropProb < 0.05) this.drop = new Spellbook(this.room, this.x, this.y);
    this.hasBloom = true;
    this.bloomColor = "#05FF05";
    this.bloomAlpha = 1;
    this.softBloomAlpha = 0;
    this.lightSource = new LightSource(
      this.x + 0.5,
      this.y + 0.5,
      7,
      [5, 150, 5],
      1,
    );
    this.addLightSource(this.lightSource);
  }

  get type() {
    return EntityType.PROP;
  }

  kill = () => {
    this.removeLightSource(this.lightSource);
    this.dead = true;
    this.dropLoot();
  };

  hurt = (playerHitBy: Player, damage: number) => {
    this.healthBar.hurt();
    ImageParticle.spawnCluster(this.room, this.x + 0.5, this.y + 0.5, 0, 25);

    //Sound.delayPlay(Sound.hurt, 0);

    this.health -= 1;
    if (this.health === 1) {
      const positions = this.room
        .getEmptyTiles()
        .filter(
          (t) => Math.abs(t.x - this.x) <= 1 && Math.abs(t.y - this.y) <= 1,
        );
      if (positions.length > 0) {
        for (let position of positions) {
          for (const i in this.game.players) {
            const playerX = this.game.players[i].x;
            const playerY = this.game.players[i].y;
            if (
              (playerX !== position.x && playerY === position.y) ||
              (playerX === position.x && playerY !== position.y)
            ) {
              this.room.entities.push(
                new SkullEnemy(this.room, this.game, position.x, position.y),
              );
            }
          }
        }
        Sound.delayPlay(Sound.skeleSpawn, 50);
      }
      this.tileX += 2;
      //draw half broken tombstone based on skintype after it takes one damage
    }
    if (this.health <= 0) {
      this.kill();
      Sound.delayPlay(Sound.breakRock, 50);
    } else {
      this.hurtCallback();
      //Sound.delayPlay(Sound.hit, 0);
    }
  };

  draw = (delta: number) => {
    if (this.dead) return;
    Game.ctx.save();
    Game.ctx.globalAlpha = this.alpha;
    if (!this.dead) {
      Game.drawObj(
        this.tileX,
        this.tileY,
        1,
        2,
        this.x - this.drawX,
        this.y - this.drawYOffset - this.drawY,
        1,
        2,
        this.room.shadeColor,
        this.shadeAmount(),
      );
    }
    Game.ctx.restore();
  };

  drawTopLayer = (delta: number) => {
    this.drawableY = this.y;

    this.updateDrawXY(delta);
  };
}


--- src/entity/object/vendingMachine.ts ---
import { Player } from "../../player";
import { Game } from "../../game";
import { Room } from "../../room";
import { Entity } from "../entity";
import { Item } from "../../item/item";
import { Key } from "../../item/key";
import { Coin } from "../../item/coin";
import { Coal } from "../../item/coal";
import { GreenGem } from "../../item/greengem";
import { GameConstants } from "../../gameConstants";
import { Shotgun } from "../../weapon/shotgun";
import { Dagger } from "../../weapon/dagger";
import { Armor } from "../../item/armor";
import { Heart } from "../../item/heart";
import { Spear } from "../../weapon/spear";
import { Gold } from "../../item/gold";
import { BlueGem } from "../../item/bluegem";
import { DualDagger } from "../../weapon/dualdagger";
import { Lantern } from "../../item/lantern";
import { RedGem } from "../../item/redgem";
import { EntityType } from "../entity";
import { Random } from "../../random";
import { Warhammer } from "../../weapon/warhammer";
import { Torch } from "../../item/torch";
import { Spellbook } from "../../weapon/spellbook";

let OPEN_TIME = 150;
let FILL_COLOR = "#5a595b";
let OUTLINE_COLOR = "#292c36";
let FULL_OUTLINE = "white";

export class VendingMachine extends Entity {
  playerOpened: Player;
  open = false;
  openTime = 0;
  costItems: Array<Item>;
  item: Item;
  isInf = false;
  quantity = 1;
  buyAnimAmount = 0;

  constructor(room: Room, game: Game, x: number, y: number, item: Item) {
    super(room, game, x, y);

    this.destroyable = false;
    this.pushable = false;
    this.chainPushable = false;
    this.interactable = true;

    this.costItems = [];

    this.item = item;
    this.name = "vending machine";
    if (this.item instanceof Shotgun) {
      let g = new BlueGem(room, 0, 0);
      g.stackCount = Game.randTable([7], Random.rand);
      this.costItems = [g];
    } else if (this.item instanceof Heart) {
      let c = new Coin(room, 0, 0);
      c.stackCount = 10;
      this.costItems = [c];
      this.quantity = 3;
    } else if (this.item instanceof Spear) {
      let g = new GreenGem(room, 0, 0);
      g.stackCount = Game.randTable([5], Random.rand);
      this.costItems = [g];
    } else if (this.item instanceof Armor) {
      let g = new GreenGem(room, 0, 0);
      g.stackCount = Game.randTable([5], Random.rand);
      this.costItems = [g];
    } else if (this.item instanceof DualDagger) {
      let g = new BlueGem(room, 0, 0);
      g.stackCount = Game.randTable([5], Random.rand);
      this.costItems = [g];
    } else if (this.item instanceof Lantern) {
      let c = new Coin(room, 0, 0);
      c.stackCount = Game.randTable([50], Random.rand);
      this.costItems = [c];
    } else if (this.item instanceof Warhammer) {
      let g = new RedGem(room, 0, 0);
      g.stackCount = Game.randTable([5], Random.rand);
      this.costItems = [g];
    } else if (this.item instanceof Spellbook) {
      let g = new RedGem(room, 0, 0);
      g.stackCount = Game.randTable([7], Random.rand);
      this.costItems = [g];
    } else if (this.item instanceof Torch) {
      let g = new RedGem(room, 0, 0);
      g.stackCount = Game.randTable([1], Random.rand);
      this.costItems = [g];
    }
  }

  static isPointInVendingMachineBounds = (
    x: number,
    y: number,
    shop: VendingMachine,
  ): boolean => {
    // First check if this is the currently open vending machine
    if (!shop.open || shop !== shop.playerOpened?.openVendingMachine)
      return false;

    const OPEN_TIME = 200; // Match the constant from drawTopLayer
    const s = Math.min(18, (18 * (Date.now() - shop.openTime)) / OPEN_TIME); // size of box
    const b = 2; // border
    const g = -2; // gap
    const ob = 1; // outer border

    // Calculate total width and height of the UI
    const width = (shop.costItems.length + 2) * (s + 2 * b + g) - g;
    const height = s + 2 * b + g - g;

    // Calculate center position (matches drawTopLayer positioning)
    const cx = (shop.x + 0.5) * GameConstants.TILESIZE;
    const cy = (shop.y - 1.5) * GameConstants.TILESIZE;

    // Calculate bounds
    const left = Math.round(cx - 0.5 * width) - ob;
    const right =
      Math.round(cx - 0.5 * width) - ob + Math.round(width + 2 * ob);
    const top = Math.round(cy - 0.5 * height) - ob;
    const bottom =
      Math.round(cy - 0.5 * height) - ob + Math.round(height + 2 * ob);

    // Check if point is within bounds
    return x >= left && x <= right && y >= top && y <= bottom;
  };

  get type() {
    return EntityType.PROP;
  }

  interact = (player: Player) => {
    if (this.isInf || this.quantity > 0) {
      if (this.open) this.playerOpened.openVendingMachine = null;
      this.open = true;
      this.playerOpened = player;
      this.openTime = Date.now();
      if (
        this.playerOpened.openVendingMachine &&
        this.playerOpened.openVendingMachine !== this
      )
        this.playerOpened.openVendingMachine.close();
      this.playerOpened.openVendingMachine = this;
    }
  };

  close = () => {
    this.open = false;
    this.playerOpened.openVendingMachine = null;
  };

  space = () => {
    if (this.open) {
      // Check if player can pay
      for (const i of this.costItems) {
        if (!this.playerOpened.inventory.hasItemCount(i)) {
          let numOfItem = 0;
          this.playerOpened.inventory.items.forEach((item) => {
            if (item instanceof i.constructor) numOfItem++;
          });
          const difference = this.costItems[0].stackCount - numOfItem;
          const pluralLetter = this.costItems[0].stackCount > 1 ? "s" : "";

          this.game.pushMessage(
            `You need ${difference} more ${(this.costItems[0].constructor as any).itemName}${pluralLetter} to buy that. `,
          );
          return;
        }
      }

      // Create the new item instance
      let newItem = new (this.item.constructor as { new (): Item })();
      newItem = newItem.constructor(this.room, this.x, this.y);

      // **Attempt to add the item directly to the player's inventory**
      const addedSuccessfully = this.playerOpened.inventory.addItem(newItem);

      if (!addedSuccessfully) {
        // If adding the item failed, refund the cost items
        for (const i of this.costItems) {
          this.playerOpened.inventory.addItem(i);
        }
        this.game.pushMessage(
          "Your inventory is full. Cannot purchase the item.",
        );
        return;
      }

      // Subtract the cost items from player's inventory
      for (const i of this.costItems) {
        this.playerOpened.inventory.subtractItemCount(i);
      }

      const cost = this.costItems[0].stackCount;
      const pluralLetter = cost > 1 ? "s" : "";

      // Decrement the quantity of items available in the vending machine, if not infinite
      if (!this.isInf) {
        this.quantity--;
        if (this.quantity <= 0) this.close();
      }

      // Notify the player of the successful purchase
      this.game.pushMessage(
        `Purchased ${(newItem.constructor as any).itemName} for ${cost} ${(this.costItems[0].constructor as any).itemName}${pluralLetter}`,
      );
      this.game.pushMessage(`${this.quantity} available to buy.`);

      // Handle visual feedback and screen shake
      this.buyAnimAmount = 0.99;
      if (this.playerOpened === this.game.players[this.game.localPlayerID])
        this.game.shakeScreen(0, 4);
    }
  };

  draw = (delta: number) => {
    let tileX = 19;
    if (!this.isInf && this.quantity === 0) tileX = 20;
    Game.drawObj(
      tileX,
      0,
      1,
      2,
      this.x,
      this.y - 1,
      1,
      2,
      this.room.shadeColor,
      this.shadeAmount(),
    );
  };

  drawTopLayer = (delta: number) => {
    if (this.open && this.playerOpened.inventory.isOpen) {
      this.close();
      return;
    }
    this.drawableY = this.y;

    if (
      this.open &&
      this.playerOpened === this.game.players[this.game.localPlayerID]
    ) {
      let s = Math.min(18, (18 * (Date.now() - this.openTime)) / OPEN_TIME); // size of box
      let b = 2; // border
      let g = -2; // gap
      let hg = 3; // highlighted growth
      let ob = 1; // outer border
      let width = (this.costItems.length + 2) * (s + 2 * b + g) - g;
      let height = s + 2 * b + g - g;

      let cx = (this.x + 0.5) * GameConstants.TILESIZE;
      let cy = (this.y - 1.5) * GameConstants.TILESIZE;

      Game.ctx.fillStyle = FULL_OUTLINE;
      Game.ctx.fillRect(
        Math.round(cx - 0.5 * width) - ob,
        Math.round(cy - 0.5 * height) - ob,
        Math.round(width + 2 * ob),
        Math.round(height + 2 * ob),
      );
      for (let x = 0; x < this.costItems.length + 2; x++) {
        Game.ctx.fillStyle = OUTLINE_COLOR;
        Game.ctx.fillRect(
          Math.round(cx - 0.5 * width + x * (s + 2 * b + g)),
          Math.round(cy - 0.5 * height),
          Math.round(s + 2 * b),
          Math.round(s + 2 * b),
        );
        if (x !== this.costItems.length) {
          Game.ctx.fillStyle = FILL_COLOR;
          Game.ctx.fillRect(
            Math.round(cx - 0.5 * width + x * (s + 2 * b + g) + b),
            Math.round(cy - 0.5 * height + b),
            Math.round(s),
            Math.round(s),
          );
        }
      }

      if (Date.now() - this.openTime >= OPEN_TIME) {
        for (let i = 0; i < this.costItems.length + 2; i++) {
          let drawX = Math.round(
            cx -
              0.5 * width +
              i * (s + 2 * b + g) +
              b +
              Math.floor(0.5 * s) -
              0.5 * GameConstants.TILESIZE,
          );
          let drawY = Math.round(
            cy -
              0.5 * height +
              b +
              Math.floor(0.5 * s) -
              0.5 * GameConstants.TILESIZE,
          );

          let drawXScaled = drawX / GameConstants.TILESIZE;
          let drawYScaled = drawY / GameConstants.TILESIZE;

          if (i < this.costItems.length) {
            let a = 1;
            if (!this.playerOpened.inventory.hasItemCount(this.costItems[i]))
              a = 0.15;
            this.costItems[i].drawIcon(delta, drawXScaled, drawYScaled, a);
          } else if (i === this.costItems.length) {
            Game.drawFX(2, 0, 1, 1, drawXScaled, drawYScaled, 1, 1);
          } else if (i === this.costItems.length + 1) {
            this.item.drawIcon(
              delta,
              drawXScaled,
              drawYScaled,
              1,
              this.quantity,
            );
          }
        }
      }
      this.buyAnimAmount *= this.buyAnimAmount;
      if (GameConstants.ALPHA_ENABLED)
        Game.ctx.globalAlpha = this.buyAnimAmount;
      Game.ctx.fillStyle = FULL_OUTLINE;
      Game.ctx.fillRect(
        Math.round(cx - 0.5 * width) - ob,
        Math.round(cy - 0.5 * height) - ob,
        Math.round(width + 2 * ob),
        Math.round(height + 2 * ob),
      );
      Game.ctx.globalAlpha = 1.0;
    }
  };
}


--- src/entity/resource/coalResource.ts ---
import { Item } from "../../item/item";
import { Game } from "../../game";
import { Key } from "../../item/key";
import { Room } from "../../room";
import { Heart } from "../../item/heart";
import { Armor } from "../../item/armor";
import { Resource } from "./resource";
import { GenericParticle } from "../../particle/genericParticle";
import { Coal } from "../../item/coal";
import { Sound } from "../../sound";
import { Inventory } from "../../inventory";
import { Weapon } from "../../weapon/weapon";
import { Pickaxe } from "../../weapon/pickaxe";
import { Player } from "../../player";
import { ItemState, ItemType } from "../../gameState";

export class CoalResource extends Resource {
  constructor(room: Room, game: Game, x: number, y: number) {
    super(room, game, x, y);

    this.tileX = 12;
    this.tileY = 0;
    this.health = 1;
    this.name = "coal";
    this.drop = new Coal(this.room, this.x, this.y);
  }
}


--- src/entity/resource/emeraldResource.ts ---
import { Item } from "../../item/item";
import { Game } from "../../game";
import { Key } from "../../item/key";
import { Room } from "../../room";
import { Heart } from "../../item/heart";
import { Armor } from "../../item/armor";
import { GreenGem } from "../../item/greengem";
import { Resource } from "./resource";
import { GenericParticle } from "../../particle/genericParticle";
import { Sound } from "../../sound";

export class EmeraldResource extends Resource {
  constructor(room: Room, game: Game, x: number, y: number) {
    super(room, game, x, y);

    this.tileX = 14;
    this.tileY = 0;
    this.health = 3;
    this.name = "emerald";
    this.drop = new GreenGem(this.room, this.x, this.y);
  }
}


--- src/entity/resource/goldResource.ts ---
import { Item } from "../../item/item";
import { Game } from "../../game";
import { Key } from "../../item/key";
import { Room } from "../../room";
import { Heart } from "../../item/heart";
import { Armor } from "../../item/armor";
import { Resource } from "./resource";
import { GenericParticle } from "../../particle/genericParticle";
import { Gold } from "../../item/gold";
import { Sound } from "../../sound";

export class GoldResource extends Resource {
  constructor(room: Room, game: Game, x: number, y: number) {
    super(room, game, x, y);

    this.tileX = 13;
    this.tileY = 0;
    this.health = 2;
    this.name = "gold";
    this.drop = new Gold(this.room, this.x, this.y);
  }
}


--- src/entity/resource/resource.ts ---
import { Item } from "../../item/item";
import { Game } from "../../game";
import { Key } from "../../item/key";
import { Room } from "../../room";
import { Heart } from "../../item/heart";
import { Armor } from "../../item/armor";
import { Entity } from "../entity";
import { LevelConstants } from "../../levelConstants";
import { GreenGem } from "../../item/greengem";
import { Player } from "../../player";
import { Pickaxe } from "../../weapon/pickaxe";
import { Spellbook } from "../../weapon/spellbook";
import { EntityType } from "../entity";
import { Sound } from "../../sound";

export class Resource extends Entity {
  constructor(room: Room, game: Game, x: number, y: number) {
    super(room, game, x, y);

    this.tileX = 12;
    this.tileY = 0;
    this.health = 1;
    this.chainPushable = false;
    this.name = "resource";
  }

  get type() {
    return EntityType.RESOURCE;
  }

  hurt = (playerHitBy: Player, damage: number) => {
    if (
      (playerHitBy !== null &&
        playerHitBy.inventory.getWeapon().canMine === true) ||
      playerHitBy === null
    ) {
      this.healthBar.hurt();
      this.health -= damage;
      Sound.mine();
    } else {
      this.game.pushMessage("Your weapon fails to damage the rock.");
      this.hurtCallback();
    }
    if (this.health <= 0) {
      this.kill();
    }
  };

  kill = () => {
    Sound.breakRock();
    this.dead = true;
    this.dropLoot();
  };

  killNoBones = () => {
    this.kill();
  };

  draw = (delta: number) => {
    if (!this.dead) {
      Game.drawObj(
        this.tileX,
        this.tileY,
        1,
        2,
        this.x - this.drawX,
        this.y - 1 - this.drawY,
        1,
        2,
        this.room.shadeColor,
        this.shadeAmount(),
      );
    }
  };

  drawTopLayer = (delta: number) => {
    this.drawableY = this.y;
  };
}


--- src/entity/resource/rockResource.ts ---
import { Room } from "../../room";
import { Game } from "../../game";
import { Heart } from "../../item/heart";
import { LevelConstants } from "../../levelConstants";
import { GenericParticle } from "../../particle/genericParticle";
import { Player } from "../../player";
import { Sound } from "../../sound";
import { Stone } from "../../item/stone";
import { Resource } from "./resource";
import { ImageParticle } from "../../particle/imageParticle";

export class Rock extends Resource {
  constructor(room: Room, game: Game, x: number, y: number) {
    super(room, game, x, y);
    this.room = room;
    this.health = 2;
    this.tileX = 8;
    this.tileY = 2;
    this.hasShadow = false;
    this.chainPushable = false;
    this.name = "rock";
    this.drop = new Stone(this.room, this.x, this.y);
  }
}


--- src/environment.ts ---
import { SkinType } from "./tile/tile";
export enum EnvType {
  DUNGEON = 0,
  CAVE = 1,
  FOREST = 2,
  SWAMP = 3,
  GLACIER = 4,
  CASTLE = 5,
}
export class Environment {
  type: EnvType;
  skin: SkinType;
  constructor(type: EnvType) {
    this.type = type;
    this.skin = this.type as unknown as SkinType;
  }
}


--- src/eventBus.ts ---
import { EventEmitter } from "./eventEmitter";

class EventBus {
  private static instance: EventBus;
  private eventEmitter: EventEmitter;

  private constructor() {
    this.eventEmitter = new EventEmitter();
  }

  public static getInstance(): EventBus {
    if (!EventBus.instance) {
      EventBus.instance = new EventBus();
    }
    return EventBus.instance;
  }

  public emit<T>(event: string, data: T): void {
    this.eventEmitter.emit(event, data);
  }

  public on<T>(event: string, callback: (data: T) => void): void {
    this.eventEmitter.on(event, callback);
  }

  public off<T>(event: string, callback: (data: T) => void): void {
    this.eventEmitter.off(event, callback);
  }
}

export const globalEventBus = EventBus.getInstance();


--- src/eventEmitter.ts ---
type EventCallback<T = any> = (data: T) => void;

export class EventEmitter {
  private events: Record<string, EventCallback[]> = {};

  on<T>(event: string, listener: EventCallback<T>): void {
    if (!this.events[event]) {
      this.events[event] = [];
    }
    this.events[event].push(listener);
  }

  off<T>(event: string, listener: EventCallback<T>): void {
    if (!this.events[event]) return;
    this.events[event] = this.events[event].filter((l) => l !== listener);
  }

  emit<T>(event: string, data: T): void {
    if (!this.events[event]) return;
    this.events[event].forEach((listener) => listener(data));
  }

  // New method to remove all listeners for an event
  removeAllListeners(event: string): void {
    delete this.events[event];
  }
}


--- src/events.ts ---
export const EVENTS = {
  KEY_DOWN: "KEY_DOWN",
  KEY_UP: "KEY_UP",
  MOUSE_LEFT_CLICK: "MOUSE_LEFT_CLICK",
  MOUSE_RIGHT_CLICK: "MOUSE_RIGHT_CLICK",
  MOUSE_MOVE: "MOUSE_MOVE",
  TOUCH_START: "TOUCH_START",
  TOUCH_MOVE: "TOUCH_MOVE",
  TOUCH_END: "TOUCH_END",
  TAP: "TAP",
  TAP_HOLD: "TAP_HOLD",
  MOUSE_DOWN: "MOUSE_DOWN",
  MOUSE_UP: "MOUSE_UP",

  // **Additional Custom Events:**
  CHAT_MESSAGE: "ChatMessage",
  ENEMY_SEEN_PLAYER: "EnemySeenPlayer",
  ENEMY_KILLED: "ENEMY_KILLED",
  DAMAGE_DONE: "DAMAGE_DONE",
  DAMAGE_TAKEN: "DAMAGE_TAKEN",
  TURN_PASSED: "TURN_PASSED",
  COIN_COLLECTED: "COIN_COLLECTED",
  ITEM_COLLECTED: "ITEM_COLLECTED",
  LEVEL_GENERATION_STARTED: "LEVEL_GENERATION_STARTED",
  LEVEL_GENERATION_COMPLETED: "LEVEL_GENERATION_COMPLETED",
  // Add other custom events as needed
} as const;

// **TypeScript Interfaces for Event Payloads:**

export interface MouseClickEvent {
  x: number;
  y: number;
}

export interface MouseMoveEvent {
  x: number;
  y: number;
}

export interface KeyEvent {
  key: string;
}

export interface TouchEventData {
  x: number;
  y: number;
}

export interface ChatMessageEvent {
  message: string;
}

export interface EnemySeenPlayerEvent {
  enemyId: string;
  playerId: string;
  // Add other relevant properties
}

export interface EnemyKilledEvent {
  enemyId: string;
}

export interface DamageDoneEvent {
  amount: number;
}

export interface DamageTakenEvent {
  amount: number;
}

export interface CoinCollectedEvent {
  amount: number;
}

export interface ItemCollectedEvent {
  itemId: string;
}

// **Union Type for Events:**
export type AppEvents =
  | typeof EVENTS.KEY_DOWN
  | typeof EVENTS.KEY_UP
  | typeof EVENTS.MOUSE_LEFT_CLICK
  | typeof EVENTS.MOUSE_RIGHT_CLICK
  | typeof EVENTS.MOUSE_MOVE
  | typeof EVENTS.TOUCH_START
  | typeof EVENTS.TOUCH_MOVE
  | typeof EVENTS.TOUCH_END
  | typeof EVENTS.TAP
  | typeof EVENTS.TAP_HOLD
  | typeof EVENTS.MOUSE_DOWN
  | typeof EVENTS.MOUSE_UP
  | typeof EVENTS.CHAT_MESSAGE
  | typeof EVENTS.ENEMY_SEEN_PLAYER
  | typeof EVENTS.ENEMY_KILLED
  | typeof EVENTS.DAMAGE_DONE
  | typeof EVENTS.DAMAGE_TAKEN
  | typeof EVENTS.TURN_PASSED
  | typeof EVENTS.COIN_COLLECTED
  | typeof EVENTS.ITEM_COLLECTED
  | typeof EVENTS.LEVEL_GENERATION_STARTED
  | typeof EVENTS.LEVEL_GENERATION_COMPLETED;
// | Add other events as needed

// **Type Mapping for Event Payloads:**
export type EventPayloads = {
  [EVENTS.KEY_DOWN]: string; // key identifier
  [EVENTS.KEY_UP]: string;
  [EVENTS.MOUSE_LEFT_CLICK]: MouseClickEvent;
  [EVENTS.MOUSE_RIGHT_CLICK]: MouseClickEvent;
  [EVENTS.MOUSE_MOVE]: MouseMoveEvent;
  [EVENTS.TOUCH_START]: TouchEventData;
  [EVENTS.TOUCH_MOVE]: TouchEventData;
  [EVENTS.TOUCH_END]: TouchEventData;
  [EVENTS.TAP]: MouseClickEvent;
  [EVENTS.TAP_HOLD]: MouseClickEvent;
  [EVENTS.MOUSE_DOWN]: MouseClickEvent;
  [EVENTS.MOUSE_UP]: MouseClickEvent;

  [EVENTS.CHAT_MESSAGE]: ChatMessageEvent;
  [EVENTS.ENEMY_SEEN_PLAYER]: EnemySeenPlayerEvent;
  [EVENTS.ENEMY_KILLED]: EnemyKilledEvent;
  [EVENTS.DAMAGE_DONE]: DamageDoneEvent;
  [EVENTS.DAMAGE_TAKEN]: DamageTakenEvent;
  [EVENTS.TURN_PASSED]: void;
  [EVENTS.COIN_COLLECTED]: CoinCollectedEvent;
  [EVENTS.ITEM_COLLECTED]: ItemCollectedEvent;
  [EVENTS.LEVEL_GENERATION_STARTED]: void;
  [EVENTS.LEVEL_GENERATION_COMPLETED]: void;
  // | Add other event payloads as needed
};


--- src/game.ts ---
import { GameConstants } from "./gameConstants";
import { EnemyType, Room, RoomType } from "./room";
import { Player } from "./player";
import { Door, DoorType } from "./tile/door";
import { Sound } from "./sound";
import { LevelConstants } from "./levelConstants";
import { LevelGenerator } from "./levelGenerator";
import { Input, InputEnum } from "./input";
import { DownLadder } from "./tile/downLadder";
import { TextBox } from "./textbox";
import { GameState, loadGameState } from "./gameState";
import { DoorDir } from "./tile/door";
import { Enemy } from "./entity/enemy/enemy";
import { TutorialListener } from "./tutorialListener";
import { MouseCursor } from "./mouseCursor";
import { PostProcessor } from "./postProcess";
import { globalEventBus } from "./eventBus";
import { ReverbEngine } from "./reverb";
import { Level } from "./level";
import { statsTracker } from "./stats";
import { EVENTS } from "./events";
import { UpLadder } from "./tile/upLadder";

export enum LevelState {
  IN_LEVEL,
  TRANSITIONING,
  TRANSITIONING_LADDER,
  LEVEL_GENERATION,
}

export enum Direction {
  DOWN,
  UP,
  RIGHT,
  LEFT,
  DOWN_RIGHT,
  UP_LEFT,
  UP_RIGHT,
  DOWN_LEFT,
  CENTER,
}

export class ChatMessage {
  message: string;
  timestamp: number;
  constructor(message: string) {
    this.message = message;
    this.timestamp = Date.now();
  }
}

let getShadeCanvasKey = (
  set: HTMLImageElement,
  sX: number,
  sY: number,
  sW: number,
  sH: number,
  opacity: number,
  shadeColor: string,
): string => {
  return (
    set.src +
    "," +
    sX +
    "," +
    sY +
    "," +
    sW +
    "," +
    sH +
    "," +
    opacity +
    "," +
    shadeColor
  );
};

// fps counter
const times = [];
let fps = 60;

export class Game {
  static ctx: CanvasRenderingContext2D;
  static shade_canvases: Record<string, HTMLCanvasElement>;
  prevLevel: Room; // for transitions
  room: Room;
  rooms: Array<Room>;
  level: Level;
  levels: Array<Level>;
  levelgen: LevelGenerator;
  readonly localPlayerID = "localplayer";
  players: Record<string, Player>;
  offlinePlayers: Record<string, Player>;
  levelState: LevelState;
  transitionStartTime: number;
  transitionX: number;
  transitionY: number;
  upwardTransition: boolean;
  sideTransition: boolean;
  sideTransitionDirection: number;
  transition: boolean;
  transitioningLadder: UpLadder | DownLadder;
  screenShakeX: number;
  screenShakeY: number;
  shakeAmountX: number;
  shakeAmountY: number;
  shakeFrame: number;
  screenShakeCutoff: number;
  chat: Array<ChatMessage>;
  chatOpen: boolean;
  chatTextBox: TextBox;
  previousFrameTimestamp: number;
  player: Player;

  static inputReceived = false;

  loginMessage: string = "";
  username: string;
  usernameTextBox: TextBox;
  passwordTextBox: TextBox;
  worldCodes: Array<string>;
  private selectedWorldCode: number;
  tutorialActive: boolean;
  static scale;
  static tileset: HTMLImageElement;
  static objset: HTMLImageElement;
  static mobset: HTMLImageElement;
  static itemset: HTMLImageElement;
  static fxset: HTMLImageElement;
  static fontsheet: HTMLImageElement;
  isMobile: boolean;
  started: boolean;
  startedFadeOut: boolean;
  screenShakeActive: boolean;
  encounteredEnemies: Array<number>;
  paused: boolean;
  private startScreenAlpha = 1;
  static delta: number;
  currentDepth: number;
  previousDepth: number;

  static text_rendering_canvases: Record<string, HTMLCanvasElement>;
  static readonly letters = "abcdefghijklmnopqrstuvwxyz1234567890,.!?:'()[]%-/";
  static readonly letter_widths = [
    4, 4, 4, 4, 3, 3, 4, 4, 1, 4, 4, 3, 5, 5, 4, 4, 4, 4, 4, 3, 4, 5, 5, 5, 5,
    3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 1, 1, 4, 1, 1, 2, 2, 2, 2, 5, 3, 3,
  ];
  static readonly letter_height = 6;
  static letter_positions = [];

  // [min, max] inclusive
  static rand = (min: number, max: number, rand): number => {
    if (max < min) return min;
    return Math.floor(rand() * (max - min + 1) + min);
  };

  static randTable = (table: any[], rand): any => {
    return table[Game.rand(0, table.length - 1, rand)];
  };
  tutorialListener: TutorialListener;

  private focusTimeout: number | null = null;
  private readonly FOCUS_TIMEOUT_DURATION = 15000; // 5 seconds
  private wasMuted = false;
  private wasStarted = false;

  constructor() {
    window.addEventListener("load", () => {
      let canvas = document.getElementById("gameCanvas");
      Game.ctx = (canvas as HTMLCanvasElement).getContext("2d", {
        alpha: false,
      }) as CanvasRenderingContext2D;

      // Create TextBox instances and associate them with HTML elements
      const usernameElement = document.createElement("input");
      usernameElement.type = "text";
      usernameElement.autocomplete = "off";
      usernameElement.autocapitalize = "off";
      usernameElement.style.position = "absolute";
      usernameElement.style.left = "-1000px"; // Position off-screen
      //const passwordElement = document.createElement("input");
      //passwordElement.type = "password";
      //passwordElement.style.position = "absolute";
      //passwordElement.style.left = "-1000px"; // Position off-screen
      const chatElement = document.createElement("input");
      chatElement.type = "text";
      chatElement.style.position = "absolute";
      chatElement.style.left = "-1000px"; // Position off-screen
      //document.body.appendChild(usernameElement);
      //document.body.appendChild(passwordElement);
      document.body.appendChild(chatElement);

      document.addEventListener(
        "click",
        () => {
          usernameElement.focus();
        },
        { once: true },
      );

      this.chat = [];
      this.chatTextBox = new TextBox(chatElement);
      this.chatTextBox.setEnterCallback(() => {
        if (this.chatTextBox.text.length > 0) {
          this.chat.push(new ChatMessage(this.chatTextBox.text));
          this.chatTextBox.clear();
        } else {
          this.chatOpen = false;
        }
      });
      this.chatTextBox.setEscapeCallback(() => {
        this.chatOpen = false;
      });
      this.worldCodes = [];
      this.selectedWorldCode = 0;

      Game.shade_canvases = {};
      Game.text_rendering_canvases = {};

      let resourcesLoaded = 0;
      const NUM_RESOURCES = 6;

      Game.tileset = new Image();
      Game.tileset.onload = () => {
        resourcesLoaded++;
      };
      Game.tileset.src = "res/tileset.png";
      Game.objset = new Image();
      Game.objset.onload = () => {
        resourcesLoaded++;
      };
      Game.objset.src = "res/objset.png";
      Game.mobset = new Image();
      Game.mobset.onload = () => {
        resourcesLoaded++;
      };
      Game.mobset.src = "res/mobset.png";
      Game.itemset = new Image();
      Game.itemset.onload = () => {
        resourcesLoaded++;
      };
      Game.itemset.src = "res/itemset.png";
      Game.fxset = new Image();
      Game.fxset.onload = () => {
        resourcesLoaded++;
      };
      Game.fxset.src = "res/fxset.png";
      Game.fontsheet = new Image();
      Game.fontsheet.onload = () => {
        resourcesLoaded++;
      };
      Game.fontsheet.src = "res/font.png";

      this.levelState = LevelState.LEVEL_GENERATION;

      let checkResourcesLoaded = () => {
        if (resourcesLoaded < NUM_RESOURCES) {
          window.setTimeout(checkResourcesLoaded, 500);
        } else {
          // proceed with constructor

          Game.scale = GameConstants.SCALE;

          document.addEventListener(
            "touchstart",
            function (e) {
              if (e.target == canvas) {
                e.preventDefault();
              }
            },
            false,
          );
          document.addEventListener(
            "touchend",
            function (e) {
              if (e.target == canvas) {
                e.preventDefault();
              }
            },
            false,
          );
          document.addEventListener(
            "touchmove",
            function (e) {
              if (e.target == canvas) {
                e.preventDefault();
              }
            },
            false,
          );

          document.addEventListener("touchstart", Input.handleTouchStart, {
            passive: false,
          });
          document.addEventListener("touchmove", Input.handleTouchMove, {
            passive: false,
          });
          document.addEventListener("touchend", Input.handleTouchEnd, {
            passive: false,
          });

          Input.keyDownListener = (key: string) => {
            this.keyDownListener(key);
          };

          window.requestAnimationFrame(this.run);
          this.onResize();
          window.addEventListener("resize", this.onResize);
          window.addEventListener("orientationchange", () => {
            // Small delay to ensure new dimensions are available
            setTimeout(this.onResize, 100);
          });

          //Sound.playMusic(); // loops forever

          this.players = {};
          this.offlinePlayers = {};
          this.chatOpen = false;

          this.screenShakeX = 0;
          this.screenShakeY = 0;
          this.shakeAmountX = 0;
          this.shakeAmountY = 0;
          this.shakeFrame = (3 * Math.PI) / 2;
          this.screenShakeCutoff = 0;
          this.tutorialActive = false;
          this.screenShakeActive = false;
          this.levels = [];
          this.encounteredEnemies = [];
          this.newGame();
        }
      };
      checkResourcesLoaded();
    });
    ReverbEngine.initialize();

    Sound.loadSounds();

    this.started = false;
    this.tutorialListener = null;

    this.setupEventListeners();

    globalEventBus.on(EVENTS.LEVEL_GENERATION_STARTED, () => {
      this.levelState = LevelState.LEVEL_GENERATION;
    });
    globalEventBus.on(EVENTS.LEVEL_GENERATION_COMPLETED, () => {
      this.levelState = LevelState.IN_LEVEL;
    });

    // Add focus/blur event listeners
    window.addEventListener("blur", this.handleWindowBlur);
    window.addEventListener("focus", this.handleWindowFocus);
  }

  updateDepth = (depth: number) => {
    this.previousDepth = this.currentDepth;
    this.currentDepth = depth;
    this.players[this.localPlayerID].depth = depth;
  };

  updateLevel = () => {
    this.level = this.levels[this.currentDepth];
    if (this.level.rooms.length > 0) this.rooms = this.level.rooms;
  };

  setPlayer = () => {
    this.player = this.players[this.localPlayerID];
  };

  newGame = () => {
    statsTracker.resetStats();
    this.currentDepth = 0;
    this.encounteredEnemies = [];
    this.levels = [];
    let gs = new GameState();
    gs.seed = (Random.rand() * 4294967296) >>> 0;
    gs.randomState = (Random.rand() * 4294967296) >>> 0;
    loadGameState(this, [this.localPlayerID], gs, true);
    this.levelState = LevelState.LEVEL_GENERATION;
  };

  keyDownListener = (key: string) => {
    Game.inputReceived = true;
    if (!this.started) {
      this.startedFadeOut = true;
      return;
    }
    if (!this.chatOpen) {
      switch (key.toUpperCase()) {
        case "M":
          Sound.audioMuted = !Sound.audioMuted;
          const message = Sound.audioMuted ? "Audio muted" : "Audio unmuted";
          this.pushMessage(message);
          break;
        case "C":
          this.chatOpen = true;
          break;
        case "/":
          this.chatOpen = true;
          this.chatTextBox.clear();
          this.chatTextBox.handleKeyPress(key);
          break;
        case "A":
        case "ARROWLEFT":
          this.players[this.localPlayerID].inputHandler(InputEnum.LEFT);
          break;
        case "D":
        case "ARROWRIGHT":
          this.players[this.localPlayerID].inputHandler(InputEnum.RIGHT);
          break;
        case "W":
        case "ARROWUP":
          this.players[this.localPlayerID].inputHandler(InputEnum.UP);
          break;
        case "S":
        case "ARROWDOWN":
          this.players[this.localPlayerID].inputHandler(InputEnum.DOWN);
          break;
        case " ":
          this.players[this.localPlayerID].inputHandler(InputEnum.SPACE);
          break;
        case "I":
          this.players[this.localPlayerID].inputHandler(InputEnum.I);
          break;
        case "Q":
          this.players[this.localPlayerID].inputHandler(InputEnum.Q);
          break;
        case "1":
          LevelGenerator.ANIMATION_CONSTANT = 1;
          break;
        case "2":
          LevelGenerator.ANIMATION_CONSTANT = 2;
          break;
        case "3":
          LevelGenerator.ANIMATION_CONSTANT = 5;
          break;
        case "4":
          LevelGenerator.ANIMATION_CONSTANT = 10000;
          break;
        case "0":
          LevelGenerator.ANIMATION_CONSTANT = 0;
          break;
      }
    } else {
      this.chatTextBox.handleKeyPress(key);
    }
  };

  changeLevel = (player: Player, newLevel: Room) => {
    if (this.tutorialListener === null) {
      this.tutorialListener = new TutorialListener(this);
    }

    player.levelID = this.levels[player.depth].rooms.indexOf(newLevel);
    if (this.players[this.localPlayerID] === player) {
      //this.level.exitLevel();

      this.room = newLevel;
    }
    this.level = this.room.level;
    newLevel.enterLevel(player);
  };

  changeLevelThroughLadder = (
    player: Player,
    ladder: UpLadder | DownLadder,
  ) => {
    player.map.saveOldMap();
    if (ladder instanceof DownLadder && !ladder.linkedLevel) ladder.generate();

    const newRoom = ladder.linkedLevel;

    if (this.players[this.localPlayerID] === player) {
      player.levelID = newRoom.id;
      if (ladder instanceof UpLadder) {
        this.players[this.localPlayerID].levelID =
          newRoom.level.rooms.indexOf(newRoom);
      }
    }

    this.updateDepth(newRoom.depth);

    this.levelState = LevelState.TRANSITIONING_LADDER;
    this.transitionStartTime = Date.now();
    this.transitioningLadder = ladder;
  };

  changeLevelThroughDoor = (player: Player, door: Door, side?: number) => {
    door.linkedDoor.room.entered = true;
    player.levelID = door.room.id;

    if (this.players[this.localPlayerID] === player) {
      this.levelState = LevelState.TRANSITIONING;
      this.transitionStartTime = Date.now();
      const hasDir = door.doorDir !== door.linkedDoor.doorDir;

      let oldX = this.players[this.localPlayerID].x;
      let oldY = this.players[this.localPlayerID].y;

      this.prevLevel = this.room;
      this.prevLevel.exitLevel();

      //this.level.exitLevel();
      this.room = door.room;

      door.room.enterLevelThroughDoor(player, door, side);

      this.transitionX =
        (this.players[this.localPlayerID].x - oldX) * GameConstants.TILESIZE;
      this.transitionY =
        (this.players[this.localPlayerID].y - oldY) * GameConstants.TILESIZE;

      this.upwardTransition = false;
      this.sideTransition = false;
      this.sideTransitionDirection = side;
      if (
        door instanceof Door &&
        [Direction.RIGHT, Direction.LEFT].includes(door.doorDir) &&
        hasDir
      )
        this.sideTransition = true;
      else if (
        door instanceof Door &&
        door.doorDir === Direction.DOWN &&
        hasDir
      )
        this.upwardTransition = true;
    } else {
      door.room.enterLevelThroughDoor(player, door, side);
    }
    player.map.saveMapData();
  };

  run = (timestamp: number) => {
    if (this.paused) {
      // Still request next frame even when paused to maintain loop
      window.requestAnimationFrame(this.run);
      return;
    }

    if (!this.previousFrameTimestamp) {
      this.previousFrameTimestamp = timestamp;
      window.requestAnimationFrame(this.run);
      return;
    }

    // Calculate elapsed time in milliseconds
    let elapsed = timestamp - this.previousFrameTimestamp;

    // Normalize delta to 60 FPS
    let delta = (elapsed * 60) / 1000.0;

    // Define minimum and maximum delta values
    const deltaMin = 1 / 10; // 600fps
    const deltaMax = 8; //7.5fps
    // Cap delta within [deltaMin, deltaMax]
    if (Game.delta) delta = Game.delta;
    if (delta < deltaMin) {
      delta = deltaMin;
    } else if (delta > deltaMax) {
      delta = deltaMax;
    }
    // Update FPS tracking
    while (times.length > 0 && times[0] <= timestamp - 1000) {
      times.shift();
    }
    times.push(timestamp);
    fps = times.length;

    // Update game logic
    if (
      Math.floor(timestamp / (1000 / 60)) >
      Math.floor(this.previousFrameTimestamp / (1000 / 60))
    ) {
      this.update();
    }
    //delta = 0.1;
    // Render the frame with capped delta
    this.draw(delta * GameConstants.ANIMATION_SPEED * 1);

    // Request the next frame
    window.requestAnimationFrame(this.run);

    // Update the previous frame timestamp
    this.previousFrameTimestamp = timestamp;
  };

  update = () => {
    Input.checkIsTapHold();

    if (
      Input.lastPressTime !== 0 &&
      Date.now() - Input.lastPressTime > GameConstants.KEY_REPEAT_TIME
    ) {
      Input.onKeydown({
        repeat: false,
        key: Input.lastPressKey,
      } as KeyboardEvent);
    }

    if (this.levelState === LevelState.TRANSITIONING) {
      if (
        Date.now() - this.transitionStartTime >=
        LevelConstants.LEVEL_TRANSITION_TIME
      ) {
        this.levelState = LevelState.IN_LEVEL;
      }
    }
    if (this.levelState === LevelState.TRANSITIONING_LADDER) {
      if (
        Date.now() - this.transitionStartTime >=
        LevelConstants.LEVEL_TRANSITION_TIME_LADDER
      ) {
        this.levelState = LevelState.IN_LEVEL;
        this.players[this.localPlayerID].map.saveMapData();
      }
    }
    if (this.levelState !== LevelState.LEVEL_GENERATION) {
      for (const i in this.players) {
        this.players[i].update();
        this.levels[this.players[i].depth].rooms[
          this.players[i].levelID
        ].update();

        if (this.players[i].dead) {
          for (const j in this.players) {
            this.players[j].dead = true;
          }
        }
      }
    }
  };

  lerp = (a: number, b: number, t: number): number => {
    return (1 - t) * a + t * b;
  };

  pushMessage = (message: string) => {
    this.chat.push(new ChatMessage(message));
  };

  commandHandler = (command: string): void => {
    const player = this.room.game.players[0];
    command = command.toLowerCase();
    switch (command) {
      case "devmode":
        GameConstants.DEVELOPER_MODE = !GameConstants.DEVELOPER_MODE;
        console.log(`Developer mode is now ${GameConstants.DEVELOPER_MODE}`);
        break;
      case "new":
        this.newGame();
        break;
      case "dev":
        GameConstants.DEVELOPER_MODE = !GameConstants.DEVELOPER_MODE;
        console.log(`Developer mode is now ${GameConstants.DEVELOPER_MODE}`);
        this.newGame();
        break;
      case "kill":
        for (const i in this.players) {
          this.players[i].dead = true;
        }
        break;
      case "killall":
        for (const i in this.players) {
          this.players[i].game.room.entities.forEach((e) => {
            e.kill();
          });
        }
        break;
      case "bomb":
        this.room.addBombs(1, () => Random.rand());
        break;
      case "col":
        GameConstants.SET_COLOR_LAYER_COMPOSITE_OPERATION(false);
        break;
      case "scl":
        GameConstants.SET_SCALE();
        this.onResize();
        break;
      case "shd":
        GameConstants.SET_COLOR_LAYER_COMPOSITE_OPERATION(false, true);
        break;
      case "smooth":
        GameConstants.SMOOTH_LIGHTING = !GameConstants.SMOOTH_LIGHTING;
        break;
      case "rooms":
        GameConstants.drawOtherRooms = !GameConstants.drawOtherRooms;
      default:
        if (command.startsWith("new ")) {
          this.room.addNewEnemy(command.slice(4) as EnemyType);
        }
        break;
    }
  };

  private setupEventListeners(): void {
    //console.log("Setting up event listeners");
    globalEventBus.on("ChatCommand", this.commandHandler.bind(this));
  }

  maxScale = () => {
    for (let i = GameConstants.MIN_SCALE; i <= GameConstants.MAX_SCALE; i++) {
      if (window.innerWidth / i < 130) {
        return i;
      }
    }
    return GameConstants.MAX_SCALE;
  };

  onResize = () => {
    // Determine device pixel ratio
    const dpr = window.devicePixelRatio;
    // Define scale adjustment based on device pixel ratio
    let scaleOffset = 0;
    //if (dpr > 1.5) {
    // High DPI devices like MacBook Air
    //scaleOffset = 2;
    //} else {
    // Standard DPI devices
    //   scaleOffset = 0;
    //}

    // Calculate maximum possible scale based on window size
    let maxWidthScale = Math.floor(
      window.innerWidth / GameConstants.DEFAULTWIDTH,
    );
    let maxHeightScale = Math.floor(
      window.innerHeight / GameConstants.DEFAULTHEIGHT,
    );
    const zoomLevel =
      Math.round((window.outerWidth / window.innerWidth) * 20) / 20;

    this.isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
    if (this.isMobile) {
      if (!GameConstants.isMobile) this.pushMessage("Mobile detected");
      GameConstants.SHADE_LEVELS = 35;
      GameConstants.isMobile = true;
      LevelConstants.LIGHTING_ANGLE_STEP = 2;
      LevelConstants.LIGHTING_MAX_DISTANCE = 7;

      // Use smaller scale for mobile devices based on screen size
      // Adjust max scale with scaleOffset
      const integerScale = GameConstants.MAX_SCALE + scaleOffset;
      Game.scale = Math.min(maxWidthScale, maxHeightScale, integerScale); // Cap at 3 + offset for mobile
    } else {
      GameConstants.isMobile = false;
      // For desktop, use standard scaling logic
      // Ensure GameConstants.SCALE is an integer. If not, round it.
      const integerScale = GameConstants.SCALE + scaleOffset;
      Game.scale = Math.min(maxWidthScale, maxHeightScale, integerScale);
    }

    // Handle case where scale would be 0
    if (Game.scale === 0) {
      // Recalculate max scales without flooring to check for minimum scale
      maxWidthScale = window.innerWidth / GameConstants.DEFAULTWIDTH;
      maxHeightScale = window.innerHeight / GameConstants.DEFAULTHEIGHT;
      // Ensure Game.scale is at least 1 and an integer
      Game.scale = Math.max(
        1,
        Math.min(maxWidthScale, maxHeightScale, 1 + scaleOffset),
      );
    }

    // Apply device pixel ratio negation by setting scale to compensate for DPI
    const NEGATE_DPR_FACTOR = 1;
    Game.scale *= NEGATE_DPR_FACTOR / window.devicePixelRatio;
    console.log(window.devicePixelRatio);

    //Game.scale = Math.ceil(Math.min(Game.scale, this.maxScale()));
    //GameConstants.SCALE = Game.scale;

    // Calculate screen width and height in tiles, ensuring integer values
    LevelConstants.SCREEN_W = Math.floor(
      window.innerWidth / Game.scale / GameConstants.TILESIZE,
    );
    LevelConstants.SCREEN_H = Math.floor(
      window.innerHeight / Game.scale / GameConstants.TILESIZE,
    );

    // Calculate canvas width and height in pixels
    GameConstants.WIDTH = Math.floor(window.innerWidth / Game.scale);
    GameConstants.HEIGHT = Math.floor(window.innerHeight / Game.scale);

    // Set canvas width and height attributes
    Game.ctx.canvas.setAttribute("width", `${GameConstants.WIDTH}`);
    Game.ctx.canvas.setAttribute("height", `${GameConstants.HEIGHT}`);

    // Set CSS styles for scaling, applying negated DPR factor
    Game.ctx.canvas.setAttribute(
      "style",
      `width: ${GameConstants.WIDTH * Game.scale}px; height: ${
        GameConstants.HEIGHT * Game.scale
      }px;
      display: block;
      margin: 0 auto;
      image-rendering: optimizeSpeed; /* Older versions of FF */
      image-rendering: -moz-crisp-edges; /* FF 6.0+ */
      image-rendering: -webkit-optimize-contrast; /* Safari */
      image-rendering: -o-crisp-edges; /* OS X & Windows Opera (12.02+) */
      image-rendering: pixelated; /* Future-browsers */
      -ms-interpolation-mode: nearest-neighbor; /* IE */
      `,
    );

    // Optional: Log the new scale and canvas size for debugging
  };

  shakeScreen = (shakeX: number, shakeY: number, clamp: boolean = false) => {
    let finalX = clamp ? Math.max(-3, Math.min(3, shakeX)) : shakeX;
    let finalY = clamp ? Math.max(-3, Math.min(3, shakeY)) : shakeY;

    this.screenShakeActive = true;
    this.screenShakeX += finalX;
    this.screenShakeY += finalY;
    this.shakeAmountX += Math.abs(finalX);
    this.shakeAmountY += Math.abs(finalY);
    if (finalX < 0 || finalY < 0) this.shakeFrame = (3 * Math.PI) / 2;
    if (finalX > 0 || finalY > 0) this.shakeFrame = Math.PI / 2;
    this.screenShakeCutoff = Date.now();
  };

  drawRooms = (delta: number, skipLocalPlayer: boolean = false) => {
    if (!GameConstants.drawOtherRooms) {
      this.room.draw(delta);
      this.room.drawEntities(delta, true);
    } else if (GameConstants.drawOtherRooms) {
      // Create a sorted copy of the rooms array based on roomY + height
      const sortedRooms = this.levels[this.currentDepth].rooms
        .slice()
        .sort((a, b) => {
          const aPosition = a.roomY + a.height;
          const bPosition = b.roomY + b.height;
          return aPosition - bPosition; // Ascending order
        });

      for (const room of sortedRooms) {
        if (room.active || (room.entered && room.onScreen)) {
          room.draw(delta);
          room.drawEntities(delta, skipLocalPlayer);
          //room.drawShade(delta); // this used to come after the color layer
        }
      }
    }
  };

  drawRoomShadeAndColor = (delta: number) => {
    for (const room of this.levels[this.currentDepth].rooms) {
      if (room.active || room.entered) {
        room.drawShadeLayer();
        room.drawColorLayer();
        room.drawBloomLayer(delta);
      }
    }
    for (const room of this.levels[this.currentDepth].rooms) {
      if (room.active && room.entered) {
        room.drawOverShade(delta);
      }
    }
  };

  static measureText = (text: string): { width: number; height: number } => {
    let w = 0;
    for (const letter of text.toLowerCase()) {
      if (letter === " ") w += 4;
      else
        for (let i = 0; i < Game.letters.length; i++) {
          if (Game.letters[i] === letter) {
            w += Game.letter_widths[i] + 1;
          }
        }
    }
    return { width: w, height: Game.letter_height };
  };

  static fillText = (text: string, x: number, y: number, maxWidth?: number) => {
    x = Math.round(x);
    y = Math.round(y);

    if (Game.letter_positions.length === 0) {
      // calculate letter positions
      for (let i = 0; i < Game.letter_widths.length; i++) {
        if (i === 0) Game.letter_positions[0] = 0;
        else
          Game.letter_positions[i] =
            Game.letter_positions[i - 1] + Game.letter_widths[i - 1] + 2;
      }
    } else {
      let dimensions = Game.measureText(text);
      if (dimensions.width > 0) {
        let key = text + Game.ctx.fillStyle;

        if (!Game.text_rendering_canvases[key]) {
          Game.text_rendering_canvases[key] = document.createElement("canvas");
          Game.text_rendering_canvases[key].width = dimensions.width;
          Game.text_rendering_canvases[key].height = dimensions.height;
          let bx = Game.text_rendering_canvases[key].getContext("2d");

          let letter_x = 0;
          for (const letter of text.toLowerCase()) {
            if (letter === " ") letter_x += 4;
            else
              for (let i = 0; i < Game.letters.length; i++) {
                if (Game.letters[i] === letter) {
                  bx.drawImage(
                    Game.fontsheet,
                    Game.letter_positions[i] + 1,
                    0,
                    Game.letter_widths[i],
                    Game.letter_height,
                    letter_x,
                    0,
                    Game.letter_widths[i],
                    Game.letter_height,
                  );
                  letter_x += Game.letter_widths[i] + 1;
                }
              }
          }
          bx.fillStyle = Game.ctx.fillStyle;
          bx.globalCompositeOperation = "source-in";
          bx.fillRect(
            0,
            0,
            Game.text_rendering_canvases[key].width,
            Game.text_rendering_canvases[key].height,
          );
          Game.ctx.drawImage(Game.text_rendering_canvases[key], x, y);
        } else {
          Game.ctx.drawImage(Game.text_rendering_canvases[key], x, y);
        }
      }
    }
  };

  static fillTextOutline = (
    text: string,
    x: number,
    y: number,
    outlineColor: string,
    fillColor: string,
  ) => {
    Game.ctx.fillStyle = outlineColor;
    for (let xx = -1; xx <= 1; xx++) {
      for (let yy = -1; yy <= 1; yy++) {
        Game.fillText(text, x + xx, y + yy);
      }
    }
    Game.ctx.fillStyle = fillColor;
    Game.fillText(text, x, y);
  };

  drawStuff = (delta: number) => {
    this.room.drawShadeLayer();
    this.room.drawColorLayer();
    this.room.drawBloomLayer(delta);
    //this.room.drawShade(delta);
    this.room.drawOverShade(delta);
  };

  drawStartScreen = (delta: number) => {
    let startString = "Welcome to Turnarchist";

    Game.ctx.globalAlpha = this.startScreenAlpha;
    if (!this.started && !this.startedFadeOut) {
      this.startScreenAlpha = 1;
      if (this.startScreenAlpha <= 0) this.startScreenAlpha = 0;
    } else if (!this.started && this.startedFadeOut) {
      this.startScreenAlpha -= delta * 0.025;
      if (this.startScreenAlpha <= 0) {
        this.startScreenAlpha = 0;
        this.started = true;
        Sound.playAmbient();
      }
    }

    Game.ctx.fillStyle = "black";
    Game.ctx.fillRect(0, 0, GameConstants.WIDTH, GameConstants.HEIGHT);
    Game.ctx.fillStyle = LevelConstants.LEVEL_TEXT_COLOR;

    Game.fillText(
      startString,
      GameConstants.WIDTH / 2 - Game.measureText(startString).width / 2,
      GameConstants.HEIGHT / 2 - Game.letter_height + 2,
    );
    let restartButton = "Press space or click to start";
    if (this.isMobile) restartButton = "Tap to start";
    Game.fillText(
      restartButton,
      GameConstants.WIDTH / 2 - Game.measureText(restartButton).width / 2,
      GameConstants.HEIGHT / 2 + Game.letter_height + 5,
    );

    Game.ctx.globalAlpha = 1;
  };

  draw = (delta: number) => {
    Game.ctx.save(); // Save the current canvas state

    // Reset transformations to ensure the black background covers the entire canvas
    Game.ctx.setTransform(1, 0, 0, 1, 0, 0);

    Game.ctx.globalAlpha = 1;
    Game.ctx.globalCompositeOperation = "source-over";
    Game.ctx.fillStyle = "black";
    Game.ctx.fillRect(0, 0, GameConstants.WIDTH, GameConstants.HEIGHT);

    //if (this.room) Game.ctx.fillStyle = this.room.shadeColor;
    //else Game.ctx.fillStyle = "black";
    //Game.ctx.fillRect(0, 0, GameConstants.WIDTH, GameConstants.HEIGHT);

    if (this.levelState === LevelState.TRANSITIONING) {
      this.screenShakeX = 0;
      this.screenShakeY = 0;
      this.screenShakeActive = false;

      let levelOffsetX = Math.floor(
        this.lerp(
          (Date.now() - this.transitionStartTime) /
            LevelConstants.LEVEL_TRANSITION_TIME,
          0,
          -this.transitionX,
        ),
      );
      let levelOffsetY = Math.floor(
        this.lerp(
          (Date.now() - this.transitionStartTime) /
            LevelConstants.LEVEL_TRANSITION_TIME,
          0,
          -this.transitionY,
        ),
      );
      let playerOffsetX = levelOffsetX - this.transitionX;
      let playerOffsetY = levelOffsetY - this.transitionY;

      let playerCX =
        (this.players[this.localPlayerID].x -
          this.players[this.localPlayerID].drawX +
          0.5) *
        GameConstants.TILESIZE;
      let playerCY =
        (this.players[this.localPlayerID].y -
          this.players[this.localPlayerID].drawY +
          0.5) *
        GameConstants.TILESIZE;

      Game.ctx.translate(
        -Math.round(playerCX + playerOffsetX - 0.5 * GameConstants.WIDTH),
        -Math.round(playerCY + playerOffsetY - 0.5 * GameConstants.HEIGHT),
      );

      let extraTileLerp = Math.floor(
        this.lerp(
          (Date.now() - this.transitionStartTime) /
            LevelConstants.LEVEL_TRANSITION_TIME,
          0,
          GameConstants.TILESIZE,
        ),
      );

      let newLevelOffsetX = playerOffsetX;
      let newLevelOffsetY = playerOffsetY;

      if (this.sideTransition) {
        if (this.sideTransitionDirection > 0) {
          levelOffsetX += extraTileLerp;
          newLevelOffsetX += extraTileLerp + GameConstants.TILESIZE;
        } else {
          levelOffsetX -= extraTileLerp;
          newLevelOffsetX -= extraTileLerp + GameConstants.TILESIZE;
        }
      } else if (this.upwardTransition) {
        levelOffsetY -= extraTileLerp;
        newLevelOffsetY -= extraTileLerp + GameConstants.TILESIZE;
      } else {
        levelOffsetY += extraTileLerp;
        newLevelOffsetY += extraTileLerp + GameConstants.TILESIZE;
      }

      let ditherFrame = Math.floor(
        (7 * (Date.now() - this.transitionStartTime)) /
          LevelConstants.LEVEL_TRANSITION_TIME,
      );

      Game.ctx.translate(levelOffsetX, levelOffsetY);
      if (!GameConstants.drawOtherRooms) {
        this.prevLevel.draw(delta);
        this.prevLevel.drawEntities(delta);
        this.prevLevel.drawColorLayer();
        this.prevLevel.drawShade(delta);
        this.prevLevel.drawOverShade(delta);

        /*
        for (
          let x = this.prevLevel.roomX - 1;
          x <= this.prevLevel.roomX + this.prevLevel.width;
          x++
        ) {
          for (
            let y = this.prevLevel.roomY - 1;
            y <= this.prevLevel.roomY + this.prevLevel.height;
            y++
          ) {
            Game.drawFX(7 - ditherFrame, 10, 1, 1, x, y, 1, 1);
          }
        }
      
      */
      }
      Game.ctx.translate(-levelOffsetX, -levelOffsetY);

      Game.ctx.translate(newLevelOffsetX, newLevelOffsetY);

      if (GameConstants.drawOtherRooms) {
        this.drawRooms(delta, true);

        Game.ctx.translate(-newLevelOffsetX, -newLevelOffsetY);
        Game.ctx.translate(playerOffsetX, playerOffsetY);
        this.players[this.localPlayerID].draw(delta); // draw the translation

        Game.ctx.translate(-playerOffsetX, -playerOffsetY);
        Game.ctx.translate(newLevelOffsetX, newLevelOffsetY);

        this.drawRoomShadeAndColor(delta);
      }

      for (
        let x = this.room.roomX - 1;
        x <= this.room.roomX + this.room.width;
        x++
      ) {
        for (
          let y = this.room.roomY - 1;
          y <= this.room.roomY + this.room.height;
          y++
        ) {
          //Game.drawFX(ditherFrame, 10, 1, 1, x, y, 1, 1);
        }
      }

      //this.drawStuff(delta);

      Game.ctx.translate(-newLevelOffsetX, -newLevelOffsetY);

      Game.ctx.translate(
        Math.round(playerCX + playerOffsetX - 0.5 * GameConstants.WIDTH),
        Math.round(playerCY + playerOffsetY - 0.5 * GameConstants.HEIGHT),
      );

      this.players[this.localPlayerID].drawGUI(delta);

      //for (const i in this.players) this.players[i].updateDrawXY(delta);
    } else if (this.levelState === LevelState.TRANSITIONING_LADDER) {
      let playerCX =
        (this.players[this.localPlayerID].x -
          this.players[this.localPlayerID].drawX +
          0.5) *
        GameConstants.TILESIZE;
      let playerCY =
        (this.players[this.localPlayerID].y -
          this.players[this.localPlayerID].drawY +
          0.5) *
        GameConstants.TILESIZE;

      Game.ctx.translate(
        -Math.round(playerCX - 0.5 * GameConstants.WIDTH),
        -Math.round(playerCY - 0.5 * GameConstants.HEIGHT),
      );

      let deadFrames = 6;
      let ditherFrame = Math.floor(
        ((7 * 2 + deadFrames) * (Date.now() - this.transitionStartTime)) /
          LevelConstants.LEVEL_TRANSITION_TIME_LADDER,
      );

      if (ditherFrame < 7) {
        this.drawRooms(delta);
        this.drawRoomShadeAndColor(delta);

        if (!GameConstants.drawOtherRooms) {
          for (
            let x = this.room.roomX - 1;
            x <= this.room.roomX + this.room.width;
            x++
          ) {
            for (
              let y = this.room.roomY - 1;
              y <= this.room.roomY + this.room.height;
              y++
            ) {
              Game.drawFX(7 - ditherFrame, 10, 1, 1, x, y, 1, 1);
            }
          }
        }
      } else if (ditherFrame >= 7 + deadFrames) {
        if (this.transitioningLadder) {
          this.prevLevel = this.room;
          this.room.exitLevel();
          this.room = this.transitioningLadder.linkedLevel;

          //this.players[this.localPlayerID].levelID = this.room.id;
          this.room.enterLevel(this.players[this.localPlayerID]);
          this.transitioningLadder = null;
        }

        this.drawRooms(delta);
        this.drawRoomShadeAndColor(delta);

        //        this.room.draw(delta);
        //        this.room.drawEntities(delta);
        //        this.drawStuff(delta);
        if (!GameConstants.drawOtherRooms) {
          for (
            let x = this.room.roomX - 1;
            x <= this.room.roomX + this.room.width;
            x++
          ) {
            for (
              let y = this.room.roomY - 1;
              y <= this.room.roomY + this.room.height;
              y++
            ) {
              Game.drawFX(ditherFrame - (7 + deadFrames), 10, 1, 1, x, y, 1, 1);
            }
          }
        }
      }
      Game.ctx.translate(
        Math.round(playerCX - 0.5 * GameConstants.WIDTH),
        Math.round(playerCY - 0.5 * GameConstants.HEIGHT),
      );

      this.players[this.localPlayerID].drawGUI(delta);
      //for (const i in this.players) this.players[i].updateDrawXY(delta);
    } else if (this.levelState === LevelState.LEVEL_GENERATION) {
      this.levelgen.draw(delta);
    } else if (this.levelState === LevelState.IN_LEVEL) {
      // Start of Selection

      this.drawScreenShake(delta);

      let playerDrawX = this.players[this.localPlayerID].drawX;
      let playerDrawY = this.players[this.localPlayerID].drawY;

      let cameraX = Math.round(
        (this.players[this.localPlayerID].x - playerDrawX + 0.5) *
          GameConstants.TILESIZE -
          0.5 * GameConstants.WIDTH -
          this.screenShakeX,
      );
      let cameraY = Math.round(
        (this.players[this.localPlayerID].y - playerDrawY + 0.5) *
          GameConstants.TILESIZE -
          0.5 * GameConstants.HEIGHT -
          this.screenShakeY,
      );

      Game.ctx.translate(-cameraX, -cameraY);
      this.drawRooms(delta);
      this.drawRoomShadeAndColor(delta);

      //      this.room.draw(delta);
      //      this.room.drawEntities(delta);

      // this.drawStuff(delta);

      Game.ctx.translate(cameraX, cameraY);

      this.room.drawTopLayer(delta);
      this.players[this.localPlayerID].drawGUI(delta);
      //for (const i in this.players) this.players[i].updateDrawXY(delta);
    }
    let CHAT_X = 10;
    let CHAT_BOTTOM_Y = GameConstants.HEIGHT - Game.letter_height - 32;
    let CHAT_OPACITY = 0.5;
    if (this.chatOpen) {
      Game.ctx.fillStyle = "black";
      if (GameConstants.ALPHA_ENABLED) Game.ctx.globalAlpha = 0.75;
      Game.ctx.fillRect(0, 0, GameConstants.WIDTH, GameConstants.HEIGHT);

      Game.ctx.globalAlpha = 1;
      Game.ctx.fillStyle = "white";
      Game.fillText(this.chatTextBox.text, CHAT_X, CHAT_BOTTOM_Y);
      const cursorX = Game.measureText(
        this.chatTextBox.text.substring(0, this.chatTextBox.cursor),
      ).width;
      Game.ctx.fillRect(CHAT_X + cursorX, CHAT_BOTTOM_Y, 1, Game.letter_height);
    }
    for (let i = 0; i < this.chat.length; i++) {
      Game.ctx.fillStyle = "white";
      if (this.chat[i][0] === "/") Game.ctx.fillStyle = GameConstants.GREEN;
      let y =
        CHAT_BOTTOM_Y - (this.chat.length - 1 - i) * (Game.letter_height + 1);
      if (this.chatOpen) y -= Game.letter_height + 1;

      let age = Date.now() - this.chat[i].timestamp;
      if (this.chatOpen) {
        Game.ctx.globalAlpha = 1;
      } else {
        if (age <= GameConstants.CHAT_APPEAR_TIME) {
          if (GameConstants.ALPHA_ENABLED) Game.ctx.globalAlpha = CHAT_OPACITY;
        } else if (
          age <=
          GameConstants.CHAT_APPEAR_TIME + GameConstants.CHAT_FADE_TIME
        ) {
          if (GameConstants.ALPHA_ENABLED)
            Game.ctx.globalAlpha =
              CHAT_OPACITY *
              (1 -
                (age - GameConstants.CHAT_APPEAR_TIME) /
                  GameConstants.CHAT_FADE_TIME);
        } else {
          Game.ctx.globalAlpha = 0;
        }
      }
      Game.fillText(this.chat[i].message, CHAT_X, y);
    }

    // game version
    if (GameConstants.ALPHA_ENABLED) Game.ctx.globalAlpha = 0.1;
    Game.ctx.fillStyle = LevelConstants.LEVEL_TEXT_COLOR;
    Game.fillText(
      GameConstants.VERSION,
      GameConstants.WIDTH - Game.measureText(GameConstants.VERSION).width - 1,
      1,
    );
    Game.ctx.globalAlpha = 1;

    // fps
    if (GameConstants.ALPHA_ENABLED) Game.ctx.globalAlpha = 0.1;
    Game.ctx.fillStyle = LevelConstants.LEVEL_TEXT_COLOR;
    Game.fillText(fps + "fps", 1, 1);
    Game.ctx.globalAlpha = 1;
    if (!this.started && this.levelState !== LevelState.LEVEL_GENERATION) {
      this.drawStartScreen(delta * 10);
    }

    MouseCursor.getInstance().draw(delta, this.isMobile);
    Game.ctx.restore(); // Restore the canvas state
  };

  drawScreenShake = (delta: number) => {
    if (!this.screenShakeActive) {
      this.resetScreenShake();
      return;
    }

    this.shakeAmountX *= 0.8 ** delta;
    this.shakeAmountY *= 0.8 ** delta;
    this.screenShakeX = Math.sin(this.shakeFrame * Math.PI) * this.shakeAmountX;
    this.screenShakeY = Math.sin(this.shakeFrame * Math.PI) * this.shakeAmountY;
    this.shakeFrame += 0.15 * delta;

    if (
      Math.abs(this.shakeAmountX) < 0.5 &&
      Math.abs(this.shakeAmountY) < 0.5
    ) {
      this.resetScreenShake();
    }
  };

  private resetScreenShake = () => {
    this.shakeAmountX = 0;
    this.shakeAmountY = 0;
    this.shakeFrame = 0;
    this.screenShakeX = 0;
    this.screenShakeY = 0;
    this.screenShakeActive = false;
  };

  static drawHelper = (
    set: HTMLImageElement,
    sX: number,
    sY: number,
    sW: number,
    sH: number,
    dX: number,
    dY: number,
    dW: number,
    dH: number,
    shadeColor = "black",
    shadeOpacity = 0,
    entity: boolean = false,
  ) => {
    Game.ctx.save(); // Save the current canvas state

    // Snap to nearest shading increment
    let divisor = entity ? 10 : 1;
    shadeOpacity =
      Math.round(
        shadeOpacity * Math.max(GameConstants.SHADE_LEVELS / divisor, 12),
      ) / Math.max(GameConstants.SHADE_LEVELS / divisor, 12);

    // Include shadeColor in the cache key
    let key = getShadeCanvasKey(set, sX, sY, sW, sH, shadeOpacity, shadeColor);

    if (!Game.shade_canvases[key]) {
      Game.shade_canvases[key] = document.createElement("canvas");
      Game.shade_canvases[key].width = Math.round(sW * GameConstants.TILESIZE);
      Game.shade_canvases[key].height = Math.round(sH * GameConstants.TILESIZE);
      let shCtx = Game.shade_canvases[key].getContext("2d");

      shCtx.clearRect(
        0,
        0,
        Game.shade_canvases[key].width,
        Game.shade_canvases[key].height,
      );

      shCtx.globalCompositeOperation = "source-over";
      shCtx.drawImage(
        set,
        Math.round(sX * GameConstants.TILESIZE),
        Math.round(sY * GameConstants.TILESIZE),
        Math.round(sW * GameConstants.TILESIZE),
        Math.round(sH * GameConstants.TILESIZE),
        0,
        0,
        Math.round(sW * GameConstants.TILESIZE),
        Math.round(sH * GameConstants.TILESIZE),
      );

      shCtx.globalAlpha = shadeOpacity;
      shCtx.fillStyle = shadeColor;
      shCtx.fillRect(
        0,
        0,
        Game.shade_canvases[key].width,
        Game.shade_canvases[key].height,
      );
      shCtx.globalAlpha = 1.0;

      shCtx.globalCompositeOperation = "destination-in";
      shCtx.drawImage(
        set,
        Math.round(sX * GameConstants.TILESIZE),
        Math.round(sY * GameConstants.TILESIZE),
        Math.round(sW * GameConstants.TILESIZE),
        Math.round(sH * GameConstants.TILESIZE),
        0,
        0,
        Math.round(sW * GameConstants.TILESIZE),
        Math.round(sH * GameConstants.TILESIZE),
      );
    }

    Game.ctx.drawImage(
      Game.shade_canvases[key],
      Math.round(dX * GameConstants.TILESIZE),
      Math.round(dY * GameConstants.TILESIZE),
      Math.round(dW * GameConstants.TILESIZE),
      Math.round(dH * GameConstants.TILESIZE),
    );

    Game.ctx.restore(); // Restore the canvas state
  };

  static drawTile = (
    sX: number,
    sY: number,
    sW: number,
    sH: number,
    dX: number,
    dY: number,
    dW: number,
    dH: number,
    shadeColor = "black",
    shadeOpacity = 0,
  ) => {
    Game.drawHelper(
      Game.tileset,
      sX,
      sY,
      sW,
      sH,
      dX,
      dY,
      dW,
      dH,
      shadeColor,
      shadeOpacity,
    );
  };

  static drawObj = (
    sX: number,
    sY: number,
    sW: number,
    sH: number,
    dX: number,
    dY: number,
    dW: number,
    dH: number,
    shadeColor = "black",
    shadeOpacity = 0,
  ) => {
    Game.drawHelper(
      Game.objset,
      sX,
      sY,
      sW,
      sH,
      dX,
      dY,
      dW,
      dH,
      shadeColor,
      shadeOpacity,
      true,
    );
  };

  static drawMob = (
    sX: number,
    sY: number,
    sW: number,
    sH: number,
    dX: number,
    dY: number,
    dW: number,
    dH: number,
    shadeColor = "black",
    shadeOpacity = 0,
  ) => {
    Game.drawHelper(
      Game.mobset,
      sX,
      sY,
      sW,
      sH,
      dX,
      dY,
      dW,
      dH,
      shadeColor,
      shadeOpacity,
      true,
    );
  };

  static drawItem = (
    sX: number,
    sY: number,
    sW: number,
    sH: number,
    dX: number,
    dY: number,
    dW: number,
    dH: number,
    shadeColor = "black",
    shadeOpacity = 0,
  ) => {
    Game.drawHelper(
      Game.itemset,
      sX,
      sY,
      sW,
      sH,
      dX,
      dY,
      dW,
      dH,
      shadeColor,
      shadeOpacity,
      true,
    );
  };

  static drawFX = (
    sX: number,
    sY: number,
    sW: number,
    sH: number,
    dX: number,
    dY: number,
    dW: number,
    dH: number,
    shadeColor = "black",
    shadeOpacity = 0,
  ) => {
    Game.drawHelper(
      Game.fxset,
      sX,
      sY,
      sW,
      sH,
      dX,
      dY,
      dW,
      dH,
      shadeColor,
      shadeOpacity,
      true,
    );
  };

  private handleWindowBlur = () => {
    // Start a timeout when window loses focus
    this.focusTimeout = window.setTimeout(() => {
      // Store current state
      this.wasMuted = Sound.audioMuted;
      this.wasStarted = this.started;

      // Mute audio and pause game
      Sound.audioMuted = true;
      this.started = false;
      this.paused = true;

      // Optional: Show a message in chat
      this.pushMessage("Game paused - window inactive");
    }, this.FOCUS_TIMEOUT_DURATION);
  };

  private handleWindowFocus = () => {
    // Clear the timeout if it exists
    if (this.focusTimeout) {
      clearTimeout(this.focusTimeout);
      this.focusTimeout = null;
    }

    // If game was paused due to inactivity, restore previous state
    if (this.paused) {
      Sound.audioMuted = this.wasMuted;
      this.started = this.wasStarted;
      this.paused = false;

      // Optional: Show a message in chat
      this.pushMessage("Game resumed");
    }
  };

  destroy() {
    window.removeEventListener("blur", this.handleWindowBlur);
    window.removeEventListener("focus", this.handleWindowFocus);
    if (this.focusTimeout) {
      clearTimeout(this.focusTimeout);
    }
  }
}

let game = new Game();


--- src/gameConstants.ts ---
import { Armor } from "./item/armor";
import { Backpack } from "./item/backpack";
import { Candle } from "./item/candle";
import { Coal } from "./item/coal";
import { EntitySpawner } from "./item/entitySpawner";
import { GodStone } from "./item/godStone";
import { Heart } from "./item/heart";
import { Key } from "./item/key";
import { Lantern } from "./item/lantern";
import { Torch } from "./item/torch";
import { WeaponBlood } from "./item/weaponBlood";
import { WeaponFragments } from "./item/weaponFragments";
import { WeaponPoison } from "./item/weaponPoison";
import { LevelConstants } from "./levelConstants";
import { Dagger } from "./weapon/dagger";
import { DualDagger } from "./weapon/dualdagger";
import { Spear } from "./weapon/spear";
import { Spellbook } from "./weapon/spellbook";
import { Warhammer } from "./weapon/warhammer";
import { Hammer } from "./item/hammer";
import { SpellbookPage } from "./item/spellbookPage";
import { BombItem } from "./item/bombItem";
import { BestiaryBook } from "./item/bestiaryBook";

export class GameConstants {
  static readonly VERSION = "v1.0.5"; //"v0.6.3";
  static DEVELOPER_MODE = false;
  static isMobile = false;

  static readonly FPS = 120;
  static readonly ALPHA_ENABLED = true;
  static SHADE_LEVELS = 50;
  static ENTITY_SHADE_LEVELS = 10;

  static readonly TILESIZE = 16;
  static SCALE = 6;
  static readonly MAX_SCALE = 10;
  static readonly MIN_SCALE = 1;

  static readonly SWIPE_THRESH = 25 ** 2; // (size of swipe threshold circle)^2
  static readonly HOLD_THRESH = 250; // milliseconds

  static readonly KEY_REPEAT_TIME = 500; // millseconds
  static readonly MOVEMENT_COOLDOWN = 150; // milliseconds

  static readonly CHAT_APPEAR_TIME = 2500;
  static readonly CHAT_FADE_TIME = 500;
  static ANIMATION_SPEED = 1;

  static readonly DEFAULTWIDTH = GameConstants.TILESIZE;
  static readonly DEFAULTHEIGHT = GameConstants.TILESIZE;
  static WIDTH = LevelConstants.SCREEN_W * GameConstants.TILESIZE;
  static HEIGHT = LevelConstants.SCREEN_H * GameConstants.TILESIZE;

  static drawOtherRooms = true;

  static readonly SCRIPT_FONT_SIZE = 16;
  static readonly FONT_SIZE = 7;
  static readonly BIG_FONT_SIZE = 15;

  static readonly RED = "#ac3232";
  static readonly WARNING_RED = "#ff0000";
  static readonly GREEN = "#6abe30";
  static readonly ARMOR_GREY = "#9badb7";
  static readonly OUTLINE = "#222034";
  static readonly HIT_ENEMY_TEXT_COLOR = "#76428a";
  static readonly HEALTH_BUFF_COLOR = "#d77bba";
  static readonly MISS_COLOR = "#639bff";

  static CUSTOM_SHADER_COLOR_ENABLED = false;

  static COLOR_LAYER_COMPOSITE_OPERATION = "soft-light"; //"soft-light";
  static SHADE_LAYER_COMPOSITE_OPERATION = "screen"; //"soft-light";
  static USE_OPTIMIZED_SHADING = false;
  static SMOOTH_LIGHTING = false;
  static ctxBlurEnabled = true;
  static BLUR_ENABLED = true;

  static readonly COLOR_LAYER_COMPOSITE_OPERATIONS = [
    "soft-light",
    //"addition",
    //"darken",
    "overlay",
    //"hue",
    //"source-over",
    //"screen",
    "multiply",
    //"difference",
    //"exclusion",
    //"luminosity",
    //"color-dodge",
    //"color-burn",
    //"hard-light",
    //"soft-light",
    //"lighten",
  ];

  static readonly SET_COLOR_LAYER_COMPOSITE_OPERATION = (
    shade?: boolean,
    back: boolean = false,
  ) => {
    let operation = shade
      ? GameConstants.SHADE_LAYER_COMPOSITE_OPERATION
      : GameConstants.COLOR_LAYER_COMPOSITE_OPERATION;
    const currentIndex =
      GameConstants.COLOR_LAYER_COMPOSITE_OPERATIONS.indexOf(operation);
    let nextIndex;

    if (back) {
      // Decrement the index to move backward in the operations array
      nextIndex =
        (currentIndex -
          1 +
          GameConstants.COLOR_LAYER_COMPOSITE_OPERATIONS.length) %
        GameConstants.COLOR_LAYER_COMPOSITE_OPERATIONS.length;
    } else {
      // Increment the index to move forward in the operations array
      nextIndex =
        (currentIndex + 1) %
        GameConstants.COLOR_LAYER_COMPOSITE_OPERATIONS.length;
    }

    operation = GameConstants.COLOR_LAYER_COMPOSITE_OPERATIONS[nextIndex];

    if (shade) {
      GameConstants.SHADE_LAYER_COMPOSITE_OPERATION = operation;
    } else {
      GameConstants.COLOR_LAYER_COMPOSITE_OPERATION = operation;
    }

    console.log(`Color layer composite operation set to ${operation}`);
  };

  static readonly TOGGLE_USE_OPTIMIZED_SHADING = () => {
    GameConstants.USE_OPTIMIZED_SHADING = !GameConstants.USE_OPTIMIZED_SHADING;
  };

  static readonly SET_SCALE = () => {
    GameConstants.SCALE++;
    if (GameConstants.SCALE > GameConstants.MAX_SCALE) {
      GameConstants.SCALE = GameConstants.MIN_SCALE;
    }
  };

  static readonly INCREASE_SCALE = () => {
    if (GameConstants.SCALE < GameConstants.MAX_SCALE) {
      GameConstants.SCALE++;
      if (GameConstants.SCALE > GameConstants.MAX_SCALE) {
        GameConstants.SCALE = GameConstants.MIN_SCALE;
      }
    }
  };

  static readonly DECREASE_SCALE = () => {
    if (GameConstants.SCALE > GameConstants.MIN_SCALE) {
      GameConstants.SCALE--;
      if (GameConstants.SCALE < GameConstants.MIN_SCALE) {
        GameConstants.SCALE = GameConstants.MAX_SCALE;
      }
    }
  };

  static readonly STARTING_INVENTORY = [Dagger, Torch];
  static readonly STARTING_DEV_INVENTORY = [
    Dagger,
    Warhammer,
    DualDagger,
    Torch,
    GodStone,
    Candle,
    Spear,
    WeaponPoison,
    WeaponBlood,
    Spellbook,
    Armor,
    Heart,
    Backpack,
    Hammer,
    Coal,
    Coal,

    Coal,
    Coal,
    Coal,
    Coal,

    WeaponFragments,
    WeaponFragments,
    WeaponFragments,
  ];
}


--- src/gameState.ts ---
import { Barrel } from "./entity/object/barrel";
import { BigSkullEnemy } from "./entity/enemy/bigSkullEnemy";
import { ChargeEnemy, ChargeEnemyState } from "./entity/enemy/chargeEnemy";
import { Chest } from "./entity/object/chest";
import { CoalResource } from "./entity/resource/coalResource";
import { Crate } from "./entity/object/crate";
import { EmeraldResource } from "./entity/resource/emeraldResource";
import { Entity, EntityDirection } from "./entity/entity";
import { GoldResource } from "./entity/resource/goldResource";
import { KnightEnemy } from "./entity/enemy/knightEnemy";
import { PottedPlant } from "./entity/object/pottedPlant";
import { Pot } from "./entity/object/pot";
import { SkullEnemy } from "./entity/enemy/skullEnemy";
import { CrabEnemy } from "./entity/enemy/crabEnemy";
import { Spawner } from "./entity/enemy/spawner";
import { VendingMachine } from "./entity/object/vendingMachine";
import { WizardEnemy, WizardState } from "./entity/enemy/wizardEnemy";
import { ZombieEnemy } from "./entity/enemy/zombieEnemy";
import { Direction, Game } from "./game";
import { HitWarning } from "./hitWarning";
import { Inventory } from "./inventory";
import { Armor } from "./item/armor";
import { BlueGem } from "./item/bluegem";
import { Candle } from "./item/candle";
import { Coal } from "./item/coal";
import { Coin } from "./item/coin";
import { Equippable } from "./item/equippable";
import { Gold } from "./item/gold";
import { GoldenKey } from "./item/goldenKey";
import { GreenGem } from "./item/greengem";
import { Heart } from "./item/heart";
import { Item } from "./item/item";
import { Key } from "./item/key";
import { Lantern } from "./item/lantern";
import { RedGem } from "./item/redgem";
import { Torch } from "./item/torch";
import { Room } from "./room";
import { LevelGenerator } from "./levelGenerator";
import { Player, PlayerDirection } from "./player";
import { EnemySpawnAnimation } from "./projectile/enemySpawnAnimation";
import { Projectile } from "./projectile/projectile";
import { WizardFireball } from "./projectile/wizardFireball";
import { Random } from "./random";
import { Dagger } from "./weapon/dagger";
import { DualDagger } from "./weapon/dualdagger";
import { Shotgun } from "./weapon/shotgun";
import { Spear } from "./weapon/spear";
import { Weapon } from "./weapon/weapon";
import { Pickaxe } from "./weapon/pickaxe";
import { Backpack } from "./item/backpack";
import { TutorialListener } from "./tutorialListener";
import { DoorType } from "./tile/door";
import { Mushrooms } from "./entity/object/mushrooms";
import { Pumpkin } from "./entity/object/pumpkin";
import { Block } from "./entity/object/block";
import { EnergyWizardEnemy } from "./entity/enemy/energyWizard";
import { Level } from "./level";
import { globalEventBus } from "./eventBus";
import { EVENTS } from "./events";

export class HitWarningState {
  x: number;
  y: number;
  dead: boolean;

  constructor(hw: HitWarning) {
    this.x = hw.x;
    this.y = hw.y;
    this.dead = hw.dead;
  }
}

let loadHitWarning = (hws: HitWarningState, game: Game): HitWarning => {
  let hw = new HitWarning(game, hws.x, hws.y, hws.x, hws.y);
  hw.dead = hws.dead;
  return hw;
};

export enum ProjectileType {
  SPAWN,
  WIZARD,
}

export class ProjectileState {
  type: ProjectileType;
  x: number;
  y: number;
  dead: boolean;
  levelID: number;
  enemySpawn: EnemyState;
  wizardState: number;
  wizardParentID: number;

  constructor(projectile: Projectile, game: Game) {
    this.x = projectile.x;
    this.y = projectile.y;
    this.dead = projectile.dead;
    if (projectile instanceof EnemySpawnAnimation) {
      this.type = ProjectileType.SPAWN;
      this.levelID = game.rooms.indexOf(projectile.room);
      this.enemySpawn = new EnemyState(projectile.enemy, game);
    }
    if (projectile instanceof WizardFireball) {
      this.type = ProjectileType.WIZARD;
      this.wizardState = projectile.state;
      this.levelID = game.rooms.indexOf(projectile.parent.room);
      this.wizardParentID = projectile.parent.room.entities.indexOf(
        projectile.parent,
      );
    }
  }
}

let loadProjectile = (ps: ProjectileState, game: Game): Projectile => {
  if (ps.type === ProjectileType.SPAWN) {
    let level = game.rooms[ps.levelID];
    let enemy = loadEnemy(ps.enemySpawn, game);
    let p = new EnemySpawnAnimation(level, enemy, ps.x, ps.y);
    p.dead = ps.dead;
    return p;
  }
  if (ps.type === ProjectileType.WIZARD) {
    let wizard = game.rooms[ps.levelID].entities[
      ps.wizardParentID
    ] as EnergyWizardEnemy;
    let p = new WizardFireball(wizard, ps.x, ps.y);
    p.state = ps.wizardState;
    return p;
  }
};

export enum EnemyType {
  BARREL,
  BIGSKULL,
  CHARGE,
  CHEST,
  COAL,
  CRATE,
  EMERALD,
  GOLD,
  KNIGHT,
  PLANT,
  SKULL,
  CRAB,
  SPAWNER,
  VENDINGMACHINE,
  WIZARD,
  ZOMBIE,
}

export class EnemyState {
  type: EnemyType;
  levelID: number;
  x: number;
  y: number;
  health: number;
  direction: Direction;
  dead: boolean;
  skipNextTurns: number;
  hasDrop: boolean;
  drop: ItemState;
  alertTicks: number;
  ticks: number;
  seenPlayer: boolean;
  targetPlayerID: string;
  // skeleton
  ticksSinceFirstHit: number;
  // big skeleton
  drops: Array<ItemState>;
  // charge enemy
  startX: number;
  startY: number;
  targetX: number;
  targetY: number;
  visualTargetX: number;
  visualTargetY: number;
  chargeEnemyState: ChargeEnemyState;
  // spawner
  enemySpawnType: number;
  // vending machine
  isPlayerOpened: boolean;
  playerOpenedID: string;
  open: boolean;
  costItems: Array<ItemState>;
  item: ItemState;
  isInf: boolean;
  quantity: number;
  // wizard
  wizardState: WizardState;

  constructor(enemy: Entity, game: Game) {
    this.levelID = game.rooms.indexOf(enemy.room);
    this.x = enemy.x;
    this.y = enemy.y;
    this.health = enemy.health;
    this.direction = enemy.direction;
    this.dead = enemy.dead;
    this.skipNextTurns = enemy.skipNextTurns;
    this.hasDrop = false;
    if (enemy.drop) {
      this.hasDrop = true;
      this.drop = new ItemState(enemy.drop, game);
    }
    this.alertTicks = enemy.alertTicks;
    if (enemy instanceof Barrel) this.type = EnemyType.BARREL;
    if (enemy instanceof BigSkullEnemy) {
      this.type = EnemyType.BIGSKULL;
      this.ticks = enemy.ticks;
      this.ticksSinceFirstHit = enemy.ticksSinceFirstHit;
      this.seenPlayer = enemy.seenPlayer;
      if (enemy.seenPlayer) {
        this.targetPlayerID = Object.keys(game.players).find(
          (key) => game.players[key] === enemy.targetPlayer,
        );
        if (!this.targetPlayerID)
          this.targetPlayerID = Object.keys(game.offlinePlayers).find(
            (key) => game.offlinePlayers[key] === enemy.targetPlayer,
          );
      }
      this.drops = [];
      for (const d of enemy.drops) this.drops.push(new ItemState(d, game));
    }
    if (enemy instanceof ChargeEnemy) {
      this.type = EnemyType.CHARGE;
      this.ticks = enemy.ticks;
      this.chargeEnemyState = enemy.state;
      this.startX = enemy.startX;
      this.startY = enemy.startY;
      this.targetX = enemy.targetX;
      this.targetY = enemy.targetY;
      this.visualTargetX = enemy.visualTargetX;
      this.visualTargetY = enemy.visualTargetY;
    }
    if (enemy instanceof Chest) this.type = EnemyType.CHEST;
    if (enemy instanceof CoalResource) this.type = EnemyType.COAL;
    if (enemy instanceof Crate) this.type = EnemyType.CRATE;
    if (enemy instanceof EmeraldResource) this.type = EnemyType.EMERALD;
    if (enemy instanceof GoldResource) this.type = EnemyType.GOLD;
    if (enemy instanceof KnightEnemy) {
      this.type = EnemyType.KNIGHT;
      this.ticks = enemy.ticks;
      this.seenPlayer = enemy.seenPlayer;
      if (enemy.seenPlayer) {
        this.targetPlayerID = Object.keys(game.players).find(
          (key) => game.players[key] === enemy.targetPlayer,
        );
        if (!this.targetPlayerID)
          this.targetPlayerID = Object.keys(game.offlinePlayers).find(
            (key) => game.offlinePlayers[key] === enemy.targetPlayer,
          );
      }
    }
    if (enemy instanceof PottedPlant) this.type = EnemyType.PLANT;
    if (enemy instanceof Pot) this.type = EnemyType.PLANT;
    if (enemy instanceof SkullEnemy) {
      this.type = EnemyType.SKULL;
      this.ticks = enemy.ticks;
      this.ticksSinceFirstHit = enemy.ticksSinceFirstHit;
      this.seenPlayer = enemy.seenPlayer;
      if (enemy.seenPlayer) {
        this.targetPlayerID = Object.keys(game.players).find(
          (key) => game.players[key] === enemy.targetPlayer,
        );
        if (!this.targetPlayerID)
          this.targetPlayerID = Object.keys(game.offlinePlayers).find(
            (key) => game.offlinePlayers[key] === enemy.targetPlayer,
          );
      }
    }
    if (enemy instanceof CrabEnemy) {
      this.type = EnemyType.CRAB;
      this.ticks = enemy.ticks;
      this.seenPlayer = enemy.seenPlayer;
      if (enemy.seenPlayer) {
        this.targetPlayerID = Object.keys(game.players).find(
          (key) => game.players[key] === enemy.targetPlayer,
        );
        if (!this.targetPlayerID)
          this.targetPlayerID = Object.keys(game.offlinePlayers).find(
            (key) => game.offlinePlayers[key] === enemy.targetPlayer,
          );
      }
    }
    if (enemy instanceof Spawner) {
      this.type = EnemyType.SPAWNER;
      this.ticks = enemy.ticks;
      this.seenPlayer = enemy.seenPlayer;
      this.enemySpawnType = enemy.enemySpawnType;
    }
    if (enemy instanceof VendingMachine) {
      this.type = EnemyType.VENDINGMACHINE;
      this.isPlayerOpened = false;
      if (enemy.playerOpened) {
        this.isPlayerOpened = true;
        this.playerOpenedID = Object.keys(game.players).find(
          (key) => game.players[key] === enemy.playerOpened,
        );
        if (!this.playerOpenedID)
          this.playerOpenedID = Object.keys(game.offlinePlayers).find(
            (key) => game.offlinePlayers[key] === enemy.playerOpened,
          );
      }
      this.open = enemy.open;
      this.costItems = [];
      for (const item of enemy.costItems)
        this.costItems.push(new ItemState(item, game));
      this.item = new ItemState(enemy.item, game);
      this.isInf = enemy.isInf;
      this.quantity = enemy.quantity;
    }
    if (enemy instanceof WizardEnemy) {
      this.type = EnemyType.WIZARD;
      this.ticks = enemy.ticks;
      this.wizardState = enemy.state;
      this.seenPlayer = enemy.seenPlayer;
    }
    if (enemy instanceof ZombieEnemy) {
      this.type = EnemyType.ZOMBIE;
      this.ticks = enemy.ticks;
      this.seenPlayer = enemy.seenPlayer;
      if (enemy.seenPlayer) {
        this.targetPlayerID = Object.keys(game.players).find(
          (key) => game.players[key] === enemy.targetPlayer,
        );
        if (!this.targetPlayerID)
          this.targetPlayerID = Object.keys(game.offlinePlayers).find(
            (key) => game.offlinePlayers[key] === enemy.targetPlayer,
          );
      }
    }
  }
}

let loadEnemy = (es: EnemyState, game: Game): Entity => {
  let enemy;
  let level = game.rooms[es.levelID];
  if (es.type === EnemyType.BARREL) enemy = new Barrel(level, game, es.x, es.y);
  if (es.type === EnemyType.BIGSKULL) {
    enemy = new BigSkullEnemy(level, game, es.x, es.y);
    enemy.ticks = es.ticks;
    enemy.ticksSinceFirstHit = es.ticksSinceFirstHit;
    enemy.seenPlayer = es.seenPlayer;
    if (es.seenPlayer) {
      enemy.targetPlayer = game.players[es.targetPlayerID];
      if (!enemy.targetPlayer)
        enemy.targetPlayer = game.offlinePlayers[es.targetPlayerID];
    }
    enemy.drops = [];
    for (const d of es.drops) enemy.drops.push(loadItem(d, game));
  }
  if (es.type === EnemyType.CHARGE) {
    enemy = new ChargeEnemy(level, game, es.x, es.y);
    enemy.ticks = es.ticks;
    enemy.state = es.chargeEnemyState;
    enemy.startX = es.startX;
    enemy.startY = es.startY;
    enemy.targetX = es.targetX;
    enemy.targetY = es.targetY;
    enemy.visualTargetX = es.visualTargetX;
    enemy.visualTargetY = es.visualTargetY;
  }
  if (es.type === EnemyType.CHEST) enemy = new Chest(level, game, es.x, es.y);
  if (es.type === EnemyType.COAL)
    enemy = new CoalResource(level, game, es.x, es.y);
  if (es.type === EnemyType.CRATE) enemy = new Crate(level, game, es.x, es.y);
  if (es.type === EnemyType.EMERALD)
    enemy = new EmeraldResource(level, game, es.x, es.y);
  if (es.type === EnemyType.GOLD)
    enemy = new GoldResource(level, game, es.x, es.y);
  if (es.type === EnemyType.KNIGHT) {
    enemy = new KnightEnemy(level, game, es.x, es.y);
    enemy.ticks = es.ticks;
    enemy.seenPlayer = es.seenPlayer;
    if (es.seenPlayer) {
      enemy.targetPlayer = game.players[es.targetPlayerID];
      if (!enemy.targetPlayer)
        enemy.targetPlayer = game.offlinePlayers[es.targetPlayerID];
    }
  }
  if (es.type === EnemyType.PLANT)
    enemy = new PottedPlant(level, game, es.x, es.y);
  if (es.type === EnemyType.PLANT) enemy = new Pot(level, game, es.x, es.y);
  if (es.type === EnemyType.SKULL) {
    enemy = new SkullEnemy(level, game, es.x, es.y);
    enemy.ticks = es.ticks;
    enemy.ticksSinceFirstHit = es.ticksSinceFirstHit;
    enemy.seenPlayer = es.seenPlayer;
    if (es.seenPlayer) {
      enemy.targetPlayer = game.players[es.targetPlayerID];
      if (!enemy.targetPlayer)
        enemy.targetPlayer = game.offlinePlayers[es.targetPlayerID];
    }
  }
  if (es.type === EnemyType.CRAB) {
    enemy = new CrabEnemy(level, game, es.x, es.y);
    enemy.ticks = es.ticks;
    enemy.seenPlayer = es.seenPlayer;
    if (es.seenPlayer) {
      enemy.targetPlayer = game.players[es.targetPlayerID];
      if (!enemy.targetPlayer)
        enemy.targetPlayer = game.offlinePlayers[es.targetPlayerID];
    }
  }
  if (es.type === EnemyType.SPAWNER) {
    enemy = new Spawner(level, game, es.x, es.y, [es.enemySpawnType]);
    enemy.ticks = es.ticks;
    enemy.seenPlayer = es.seenPlayer;
    enemy.enemySpawnType = es.enemySpawnType;
  }
  if (es.type === EnemyType.VENDINGMACHINE) {
    let item = loadItem(es.item, game);
    enemy = new VendingMachine(level, game, es.x, es.y, item);
    if (es.isPlayerOpened) {
      enemy.playerOpened = game.players[es.playerOpenedID];
      if (!enemy.playerOpened)
        enemy.playerOpened = game.offlinePlayers[es.playerOpenedID];
    }
    enemy.open = es.open;
    enemy.costItems = [];
    for (const item of es.costItems) enemy.costItems.push(loadItem(item, game));
    enemy.isInf = es.isInf;
    enemy.quantity = es.quantity;
  }
  if (es.type === EnemyType.WIZARD) {
    enemy = new EnergyWizardEnemy(level, game, es.x, es.y);
    enemy.ticks = es.ticks;
    enemy.state = es.wizardState;
    enemy.seenPlayer = es.seenPlayer;
  }
  if (es.type === EnemyType.ZOMBIE) {
    enemy = new ZombieEnemy(level, game, es.x, es.y);
    enemy.ticks = es.ticks;
    enemy.seenPlayer = es.seenPlayer;
    if (es.seenPlayer) {
      enemy.targetPlayer = game.players[es.targetPlayerID];
      if (!enemy.targetPlayer)
        enemy.targetPlayer = game.offlinePlayers[es.targetPlayerID];
    }
  }

  enemy.x = es.x;
  enemy.y = es.y;
  enemy.health = es.health;
  enemy.direction = es.direction;
  enemy.dead = es.dead;
  enemy.skipNextTurns = es.skipNextTurns;
  if (es.hasDrop) enemy.drop = loadItem(es.drop, game);
  enemy.alertTicks = es.alertTicks;

  return enemy;
};

export class LevelState {
  levelID: number;
  entered: boolean;
  enemies: Array<EnemyState>;
  items: Array<ItemState>;
  projectiles: Array<ProjectileState>;
  hitwarnings: Array<HitWarningState>;

  constructor(level: Room, game: Game) {
    this.levelID = game.rooms.indexOf(level);
    this.entered = level.entered;
    this.enemies = [];
    this.items = [];
    this.projectiles = [];
    this.hitwarnings = [];
    for (const enemy of level.entities)
      this.enemies.push(new EnemyState(enemy, game));
    for (const item of level.items) this.items.push(new ItemState(item, game));
    for (const projectile of level.projectiles)
      this.projectiles.push(new ProjectileState(projectile, game));
    for (const hw of level.hitwarnings)
      this.hitwarnings.push(new HitWarningState(hw));
  }
}

let loadLevel = (level: Room, levelState: LevelState, game: Game) => {
  level.entered = levelState.entered;
  level.entities = [];
  level.items = [];
  level.projectiles = [];
  level.hitwarnings = [];
  for (const enemy of levelState.enemies)
    level.entities.push(loadEnemy(enemy, game));
  for (const item of levelState.items) level.items.push(loadItem(item, game));
  for (const projectile of levelState.projectiles)
    level.projectiles.push(loadProjectile(projectile, game));
  for (const hw of levelState.hitwarnings)
    level.hitwarnings.push(loadHitWarning(hw, game));
};
//use the other one
export enum ItemType {
  ARMOR,
  BLUEGEM,
  CANDLE,
  COAL,
  COIN,
  GOLD,
  GOLDENKEY,
  GREENGEM,
  KEY,
  LANTERN,
  REDGEM,
  TORCH,
  DAGGER,
  DUALDAGGER,
  SHOTGUN,
  SPEAR,
  PICKAXE,
  BACKPACK,
  SPELLBOOK,
  WEAPON_FRAGMENTS,
  WARHAMMER,
  HAMMER,
  WEAPON_POISON,
  WEAPON_BLOOD,
  HEART,
  MUSHROOMS,
  STONE,
  BLUE_POTION,
}

export class ItemState {
  type: ItemType;
  x: number;
  y: number;
  levelID: number;
  stackCount: number;
  pickedUp: boolean;
  equipped: boolean;

  constructor(item: Item, game: Game) {
    if (item instanceof Armor) this.type = ItemType.ARMOR;
    if (item instanceof BlueGem) this.type = ItemType.BLUEGEM;
    if (item instanceof Candle) this.type = ItemType.CANDLE;
    if (item instanceof Coal) this.type = ItemType.COAL;
    if (item instanceof Coin) this.type = ItemType.COIN;
    if (item instanceof Gold) this.type = ItemType.GOLD;
    if (item instanceof GoldenKey) this.type = ItemType.GOLDENKEY;
    if (item instanceof GreenGem) this.type = ItemType.GREENGEM;
    if (item instanceof Heart) this.type = ItemType.HEART;
    if (item instanceof Key) this.type = ItemType.KEY;
    if (item instanceof Lantern) this.type = ItemType.LANTERN;
    if (item instanceof RedGem) this.type = ItemType.REDGEM;
    if (item instanceof Torch) this.type = ItemType.TORCH;
    if (item instanceof Dagger) this.type = ItemType.DAGGER;
    if (item instanceof DualDagger) this.type = ItemType.DUALDAGGER;
    if (item instanceof Shotgun) this.type = ItemType.SHOTGUN;
    if (item instanceof Spear) this.type = ItemType.SPEAR;
    if (item instanceof Pickaxe) this.type = ItemType.PICKAXE;
    if (item instanceof Backpack) this.type = ItemType.BACKPACK;

    this.equipped = item instanceof Equippable && item.equipped;
    this.x = item.x;
    this.y = item.y;
    this.levelID = game.rooms.indexOf(item.level);
    if (this.levelID === -1) this.levelID = 0;
    this.stackCount = item.stackCount;
    this.pickedUp = item.pickedUp;
  }
}

let loadItem = (i: ItemState, game: Game, player?: Player): Item => {
  let level = game.rooms[i.levelID];
  let item;
  if (i.type === ItemType.ARMOR) item = new Armor(level, i.x, i.y);
  if (i.type === ItemType.BLUEGEM) item = new BlueGem(level, i.x, i.y);
  if (i.type === ItemType.CANDLE) item = new Candle(level, i.x, i.y);
  if (i.type === ItemType.COAL) item = new Coal(level, i.x, i.y);
  if (i.type === ItemType.COIN) item = new Coin(level, i.x, i.y);
  if (i.type === ItemType.GOLD) item = new Gold(level, i.x, i.y);
  if (i.type === ItemType.GOLDENKEY) item = new GoldenKey(level, i.x, i.y);
  if (i.type === ItemType.GREENGEM) item = new GreenGem(level, i.x, i.y);
  if (i.type === ItemType.HEART) item = new Heart(level, i.x, i.y);
  if (i.type === ItemType.KEY) item = new Key(level, i.x, i.y);
  if (i.type === ItemType.LANTERN) item = new Lantern(level, i.x, i.y);
  if (i.type === ItemType.REDGEM) item = new RedGem(level, i.x, i.y);
  if (i.type === ItemType.TORCH) item = new Torch(level, i.x, i.y);
  if (i.type === ItemType.DAGGER) {
    item = new Dagger(level, i.x, i.y);
  }
  if (i.type === ItemType.DUALDAGGER) {
    item = new DualDagger(level, i.x, i.y);
  }
  if (i.type === ItemType.SHOTGUN) {
    item = new Shotgun(level, i.x, i.y);
  }
  if (i.type === ItemType.SPEAR) {
    item = new Spear(level, i.x, i.y);
  }
  if (i.type === ItemType.PICKAXE) {
    item = new Pickaxe(level, i.x, i.y);
  }
  if (i.type === ItemType.BACKPACK) {
    item = new Backpack(level, i.x, i.y);
  }
  if (i.equipped) item.equipped = true;
  if (item instanceof Equippable) item.setWielder(player);
  item.stackCount = i.stackCount;
  item.pickedUp = i.pickedUp;
  return item;
};

export class InventoryState {
  isOpen: boolean;
  cols: number;
  rows: number;
  selX: number;
  selY: number;
  equipAnimAmount: Array<number>;
  isWeaponEquipped: boolean;
  weaponI: number;
  coins: number;
  items: Array<ItemState>;

  constructor(inventory: Inventory, game: Game) {
    this.isOpen = inventory.isOpen;
    this.cols = inventory.cols;
    this.rows = inventory.rows;
    this.equipAnimAmount = inventory.equipAnimAmount.map((x) => x);
    this.isWeaponEquipped = false;
    if (inventory.weapon) {
      this.isWeaponEquipped = true;
      this.weaponI = inventory.items.indexOf(inventory.weapon);
    }
    this.coins = inventory.coins;
    this.selX = inventory.selX;
    this.selY = inventory.selY;
    this.items = Array<ItemState>();
    for (const item of inventory.items) {
      this.items.push(new ItemState(item, game));
    }
  }
}

let loadInventory = (inventory: Inventory, i: InventoryState, game: Game) => {
  inventory.clear();
  inventory.isOpen = i.isOpen;
  inventory.cols = i.cols;
  inventory.rows = i.rows;
  inventory.selX = i.selX;
  inventory.selY = i.selY;
  inventory.equipAnimAmount = i.equipAnimAmount.map((x) => x);
  inventory.coins = i.coins;
  for (const item of i.items)
    inventory.items.push(loadItem(item, game, inventory.player));

  if (i.isWeaponEquipped)
    inventory.weapon = inventory.items[i.weaponI] as Weapon;
};

export class PlayerState {
  x: number;
  y: number;
  dead: boolean;
  levelID: number;
  direction: Direction;
  health: number;
  maxHealth: number;
  lastTickHealth: number;
  inventory: InventoryState;
  hasOpenVendingMachine: boolean;
  openVendingMachineLevelID: number;
  openVendingMachineID: number;
  sightRadius: number;

  constructor(player: Player, game: Game) {
    this.x = player.x;
    this.y = player.y;
    this.dead = player.dead;
    this.levelID = player.levelID;
    this.direction = player.direction;
    this.health = player.health;
    this.maxHealth = player.maxHealth;
    this.lastTickHealth = player.lastTickHealth;
    this.inventory = new InventoryState(player.inventory, game);
    this.hasOpenVendingMachine = false;
    if (player.openVendingMachine) {
      this.hasOpenVendingMachine = true;
      this.openVendingMachineLevelID = game.rooms.indexOf(
        player.openVendingMachine.room,
      );
      this.openVendingMachineID =
        player.openVendingMachine.room.entities.indexOf(
          player.openVendingMachine,
        );
    }
    this.sightRadius = player.sightRadius;
  }
}

let loadPlayer = (id: string, p: PlayerState, game: Game): Player => {
  let player = new Player(game, p.x, p.y, id === game.localPlayerID);
  player.dead = p.dead;

  player.levelID = p.levelID;
  if (player.levelID < game.levelgen.currentFloorFirstLevelID) {
    // catch up to the current level
    player.levelID = game.levelgen.currentFloorFirstLevelID;
    player.x =
      game.rooms[player.levelID].roomX +
      Math.floor(game.rooms[player.levelID].width / 2);
    player.y =
      game.rooms[player.levelID].roomY +
      Math.floor(game.rooms[player.levelID].height / 2);
  }
  player.direction = p.direction;
  player.health = p.health;
  player.maxHealth = p.maxHealth;
  player.lastTickHealth = p.lastTickHealth;
  loadInventory(player.inventory, p.inventory, game);
  if (p.hasOpenVendingMachine) {
    player.openVendingMachine = game.rooms[p.openVendingMachineLevelID]
      .entities[p.openVendingMachineID] as VendingMachine;
  }
  player.sightRadius = p.sightRadius;

  return player;
};

export class GameState {
  seed: number;
  randomState: number;
  depth: number;
  players: Record<string, PlayerState>;
  offlinePlayers: Record<string, PlayerState>;
  levels: Array<LevelState>;

  constructor() {
    this.seed = 0;
    this.randomState = 0;
    this.depth = 0;
    this.players = {};
    this.offlinePlayers = {};
    this.levels = [];
  }
}

export const createGameState = (game: Game): GameState => {
  let gs = new GameState();
  gs.seed = game.levelgen.seed; // random state for generating levels
  gs.randomState = Random.state; // current random state
  gs.depth = game.level.depth;
  for (const i in game.players)
    gs.players[i] = new PlayerState(game.players[i], game);
  for (const i in game.offlinePlayers) {
    gs.offlinePlayers[i] = new PlayerState(game.offlinePlayers[i], game);
  }
  for (let level of game.rooms) {
    level.catchUp();
    gs.levels.push(new LevelState(level, game));
  }
  return gs;
};

export const loadGameState = (
  game: Game,
  activeUsernames: Array<string>,
  gameState: GameState,
  newWorld: boolean,
) => {
  game.rooms = Array<Room>();

  game.levelgen = new LevelGenerator();
  game.levelgen.setSeed(gameState.seed);
  if (newWorld) gameState.depth = 0;
  globalEventBus.emit(EVENTS.LEVEL_GENERATION_STARTED, {});
  game.levelgen.generateFirstNFloors(game, gameState.depth).then(() => {
    globalEventBus.emit(EVENTS.LEVEL_GENERATION_COMPLETED, {});
    if (!newWorld) {
      if (gameState.players) {
        for (const i in gameState.players) {
          if (activeUsernames.includes(i))
            game.players[i] = loadPlayer(i, gameState.players[i], game);
          else
            game.offlinePlayers[i] = loadPlayer(i, gameState.players[i], game);
        }
      }
      if (gameState.offlinePlayers) {
        for (const i in gameState.offlinePlayers) {
          if (i === game.localPlayerID)
            game.players[i] = loadPlayer(i, gameState.offlinePlayers[i], game);
          else if (activeUsernames.includes(i))
            game.players[i] = loadPlayer(i, gameState.offlinePlayers[i], game);
          else
            game.offlinePlayers[i] = loadPlayer(
              i,
              gameState.offlinePlayers[i],
              game,
            );
        }
      }
      for (let levelState of gameState.levels) {
        for (let i = 0; i < game.rooms.length; i++) {
          if (i === levelState.levelID) {
            loadLevel(game.rooms[i], levelState, game);
          }
        }
      }
      if (
        !(game.localPlayerID in gameState.players) &&
        !(game.localPlayerID in gameState.offlinePlayers)
      ) {
        // we're not in the gamestate, create a new player
        game.players[game.localPlayerID] = new Player(game, 0, 0, true);
        game.players[game.localPlayerID].levelID =
          game.levelgen.currentFloorFirstLevelID;
        game.players[game.localPlayerID].x =
          game.rooms[game.levelgen.currentFloorFirstLevelID].roomX +
          Math.floor(
            game.rooms[game.levelgen.currentFloorFirstLevelID].width / 2,
          );
        game.players[game.localPlayerID].y =
          game.rooms[game.levelgen.currentFloorFirstLevelID].roomY +
          Math.floor(
            game.rooms[game.levelgen.currentFloorFirstLevelID].height / 2,
          );
        game.room = game.rooms[game.levelgen.currentFloorFirstLevelID];

        game.room.enterLevel(game.players[game.localPlayerID]);
      } else {
        game.room = game.rooms[game.players[game.localPlayerID].levelID];
      }
    } else {
      // stub game state, start a new world
      game.players[game.localPlayerID] = new Player(game, 0, 0, true);
      game.room = game.rooms[game.players[game.localPlayerID].levelID];
      game.room.enterLevel(game.players[game.localPlayerID]);
    }
    Random.setState(gameState.randomState);
    game.room.updateLighting();
    let p = game.players[game.localPlayerID];
    game.room.items.push(new Key(game.room, p.x - 1, p.y + 1));

    //choose one door to lock
    let locked = false;
    game.room.doors.forEach((door) => {
      if (!locked) {
        door.lock();
        locked = true;
      }
    });

    game.chat = [];
  });
};


--- src/guiButton.ts ---
export class guiButton {
  toggleable: boolean;
  toggled: boolean;
  x: number;
  y: number;
  width: number;
  height: number;
  text: string;
  onClick: () => void;
  constructor(
    x: number,
    y: number,
    width: number,
    height: number,
    text: string,
    onClick: () => void,
    toggleable: boolean = false,
  ) {
    this.toggleable = toggleable;
    this.toggled = false;
    this.x = x;
    this.y = y;
    this.width = width;
    this.height = height;
    this.text = text;
    this.onClick = onClick;
  }
}


--- src/healthbar.ts ---
import { Game } from "./game";
import { GameConstants } from "./gameConstants";
import { LevelConstants } from "./levelConstants";

export class HealthBar {
  hurtTimer: number;

  constructor() {
    this.hurtTimer = 0;
  }

  hurt = () => {
    this.hurtTimer = Date.now();
  };

  draw = (
    delta: number,
    hearts: number,
    maxHearts: number,
    x: number,
    y: number,
    flashing: boolean,
  ) => {
    let t = Date.now() - this.hurtTimer;
    if (t <= LevelConstants.HEALTH_BAR_TOTALTIME) {
      let fullHearts = Math.floor(hearts);

      let halfHearts = Math.ceil(hearts - fullHearts);

      let emptyHearts = maxHearts - fullHearts - halfHearts;

      // I wouldn't normally use magic numbers here, but these are hardcoded based on the tileset
      //   (which isn't really parameterizable)
      let drawWidth = Math.round(
        Math.min(
          9,
          Math.min(0.05 * (LevelConstants.HEALTH_BAR_TOTALTIME - t), 0.05 * t),
        ),
      );
      let drawHeight =
        Math.round(
          Math.min(
            0.5,
            Math.min(
              0.003 * (LevelConstants.HEALTH_BAR_TOTALTIME - t),
              0.003 * t,
            ),
          ) * 16,
        ) / 16.0;
      let width = (drawWidth * (maxHearts - 1) + 8) / 16.0;
      let xxStart = 0.5 + -width / 2;
      for (let i = 0; i < Math.ceil(0.5 * maxHearts); i++) {
        let tileX = 0;
        if (!flashing) tileX = 1.5;
        else if (i < fullHearts) tileX = 0;
        else if (i < fullHearts + halfHearts) tileX = 0.5;
        else tileX = 1;
        let xx = (drawWidth * i) / 16.0 + xxStart;
        Game.drawFX(
          tileX,
          8,
          0.5,
          0.5,
          x + xx,
          y - 1 - drawHeight / 2,
          0.5,
          drawHeight,
        );
        xx += 9.0 / 16.0;

        let j = maxHearts - i - 1;
        if (j !== i) {
          let tileX = 0;
          if (!flashing) tileX = 1.5;
          else if (j < fullHearts) tileX = 0;
          else if (j < fullHearts + halfHearts) tileX = 0.5;
          else tileX = 1;
          let xx = (drawWidth * j) / 16.0 + xxStart;
          Game.drawFX(
            tileX,
            8,
            0.5,
            0.5,
            x + xx,
            y - 1 - drawHeight / 2,
            0.5,
            drawHeight,
          );
          xx += 9.0 / 16.0;
        }
      }
    }
  };
}


--- src/hitWarning.ts ---
import { Game } from "./game";
import { Drawable } from "./drawable";
import { Room } from "./room";
import { Entity } from "./entity/entity";
import { Utils } from "./utils";

enum Direction {
  North,
  NorthEast,
  East,
  SouthEast,
  South,
  SouthWest,
  West,
  NorthWest,
  Center,
}

export class HitWarning extends Drawable {
  x: number;
  y: number;
  dead: boolean;
  static frame = 0;
  private game: Game;
  parent: Entity | null = null;
  private _pointerDir: Direction | null = null;
  private _pointerOffset: { x: number; y: number } | null = null;
  private tileX: number;
  private tileY: number;
  private eX: number;
  private eY: number;
  private offsetY: number;
  private pointerOffset: { x: number; y: number };
  private isEnemy: Boolean;
  private dirOnly: Boolean;
  private alpha: number = 0;
  private ticks: number;
  private tickedForDeath = false;

  constructor(
    game: Game,
    x: number,
    y: number,
    eX?: number,
    eY?: number,
    isEnemy?: Boolean,
    dirOnly: Boolean = false,
    parent: Entity | null = null,
  ) {
    super();
    this.x = x;
    this.y = y;
    this.dead = false;
    this.game = game;
    this.parent = parent;
    this.tileX = 0;
    this.tileY = 22;
    this.eX = eX;
    this.eY = eY;
    this.offsetY = 0.2;
    this.dirOnly = dirOnly;

    this.isEnemy = isEnemy !== undefined ? isEnemy : true;
    this.pointerOffset = this.getPointerOffset();
    this.removeOverlapping();
  }

  tick = () => {
    if (this.tickedForDeath) this.dead = true;
    this.tickedForDeath = true;
  };

  static updateFrame = (delta: number) => {
    HitWarning.frame += 0.125 * delta;
    if (HitWarning.frame >= 2) HitWarning.frame = 0;
  };

  removeOverlapping = () => {
    for (const entity of this.game.room.entities) {
      if (
        entity.x === this.x &&
        entity.y === this.y &&
        entity.pushable === false
      ) {
        this.dead = true;
        break;
      }
    }
    for (const door of this.game.room.doors) {
      if (door.x === this.x && door.y === this.y) {
        this.dead = true;
        break;
      }
    }
  };

  private getPointerDir(): Direction {
    if (this._pointerDir === null) {
      const dx = this.eX - this.x;
      const dy = this.eY - this.y;

      if (dx === 0 && dy === 0) {
        this._pointerDir = Direction.Center;
      } else if (dx === 0) {
        this._pointerDir = dy < 0 ? Direction.South : Direction.North;
      } else if (dy === 0) {
        this._pointerDir = dx < 0 ? Direction.East : Direction.West;
      } else if (dx < 0) {
        this._pointerDir = dy < 0 ? Direction.SouthEast : Direction.NorthEast;
      } else {
        this._pointerDir = dy < 0 ? Direction.SouthWest : Direction.NorthWest;
      }

      this.tileX = 0 + 2 * this._pointerDir;
    }
    return this._pointerDir;
  }

  private getPointerOffset(): { x: number; y: number } {
    if (this._pointerOffset === null) {
      const offsets = {
        [Direction.North]: { x: 0, y: 0.5 },
        [Direction.South]: { x: 0, y: -0.6 },
        [Direction.West]: { x: 0.6, y: 0 },
        [Direction.East]: { x: -0.6, y: 0 },
        [Direction.NorthEast]: { x: -0.5, y: 0.5 },
        [Direction.NorthWest]: { x: 0.5, y: 0.5 },
        [Direction.SouthEast]: { x: -0.5, y: -0.5 },
        [Direction.SouthWest]: { x: 0.5, y: -0.5 },
        [Direction.Center]: { x: 0, y: -0.25 },
      };

      this._pointerOffset = offsets[this.getPointerDir()];
    }
    return this._pointerOffset;
  }

  fadeHitwarnings = (delta: number) => {
    if (!this.tickedForDeath) {
      if (this.alpha < 1) this.alpha += 0.03 * delta;
      if (this.alpha > 1) this.alpha = 1;
    } else {
      if (this.alpha > 0) this.alpha -= 0.03 * delta;
      if (this.alpha < 0) this.alpha = 0;
    }
  };

  draw = (delta: number) => {
    this.fadeHitwarnings(delta);
    if (
      Math.abs(this.x - this.game.players[this.game.localPlayerID].x) <= 1 &&
      Math.abs(this.y - this.game.players[this.game.localPlayerID].y) <= 1
    ) {
      Game.ctx.globalAlpha = this.alpha;
      if (
        this.isEnemy &&
        Utils.distance(
          this.x,
          this.y,
          this.game.players[this.game.localPlayerID].x,
          this.game.players[this.game.localPlayerID].y,
        ) <= 1
      ) {
        // Red Arrow that only renders one square away

        Game.drawFX(
          this.tileX + Math.floor(HitWarning.frame),
          this.tileY,
          1,
          1,
          this.x + this.pointerOffset.x,
          this.y + this.pointerOffset.y - this.offsetY,
          1,
          1,
        );
      }
      if (false) {
        // removed for now because unneeded and overlaps poorly with top layer x
        // Red X that only renders one square away
        Game.drawFX(
          18 + Math.floor(HitWarning.frame),
          5,
          1,
          1,
          this.x,
          this.y - this.offsetY + 0,
          1,
          1,
        );
      }
      Game.ctx.globalAlpha = 1;
    }
  };

  drawTopLayer = (delta: number) => {
    this.fadeHitwarnings(delta);

    Game.ctx.globalAlpha = this.alpha;

    if (this.isEnemy && this.getPointerDir() !== Direction.North) {
      //white arrow top layer
      Game.drawFX(
        this.tileX + Math.floor(HitWarning.frame),
        this.tileY + 1,
        1,
        1,
        this.x + this.pointerOffset.x,
        this.y + this.pointerOffset.y - this.offsetY,
        1,
        1,
      );
    }
    if (
      Utils.distance(
        this.x,
        this.y,
        this.game.players[this.game.localPlayerID].x,
        this.game.players[this.game.localPlayerID].y,
      ) <= 1
    ) {
      if (!this.dirOnly) {
        // Red X that renders 1 square away for top layer
        Game.drawFX(
          18 + Math.floor(HitWarning.frame),
          6,
          1,
          1,
          this.x,
          this.y - this.offsetY + 0,
          1,
          1,
        );
      }
    }
    Game.ctx.globalAlpha = 1;
  };
}


--- src/input.ts ---
import { GameConstants } from "./gameConstants";
import { Game } from "./game";
import { MouseCursor } from "./mouseCursor";

export enum InputEnum {
  I,
  M,
  M_UP,
  Q,
  LEFT,
  RIGHT,
  UP,
  DOWN,
  SPACE,
  COMMA,
  PERIOD,
  LEFT_CLICK,
  RIGHT_CLICK,
  MOUSE_MOVE,
  NUMBER_1,
  NUMBER_2,
  NUMBER_3,
  NUMBER_4,
  NUMBER_5,
  NUMBER_6,
  NUMBER_7,
  NUMBER_8,
  NUMBER_9,
  MINUS,
  EQUALS,
  ESCAPE,
}

export const Input = {
  _pressed: {},

  isTapHold: false,
  tapStartTime: null,
  IS_TAP_HOLD_THRESH: 300,
  keyDownListener: function (key: string) {},
  iListener: function () {},
  mListener: function () {},
  mUpListener: function () {},
  qListener: function () {},
  leftListener: function () {},
  rightListener: function () {},
  upListener: function () {},
  downListener: function () {},
  aListener: function () {
    Input.leftListener();
  },
  dListener: function () {
    Input.rightListener();
  },
  wListener: function () {
    Input.upListener();
  },
  sListener: function () {
    Input.downListener();
  },
  spaceListener: function () {},
  leftSwipeListener: function () {},
  rightSwipeListener: function () {},
  upSwipeListener: function () {},
  downSwipeListener: function () {},
  tapListener: function () {},
  commaListener: function () {},
  periodListener: function () {},
  numKeyListener: function (num: number) {},
  equalsListener: function () {},
  minusListener: function () {},
  escapeListener: function () {},
  mouseLeftClickListeners: [],
  mouseRightClickListeners: [],
  mouseMoveListeners: [],
  mouseDownListeners: [],
  mouseUpListeners: [],

  touchStartListeners: [],
  touchEndListeners: [],

  mouseX: 0,
  mouseY: 0,
  mouseDown: false,

  lastPressTime: 0,
  lastPressKey: "",

  SPACE: "Space",
  LEFT: "ArrowLeft",
  UP: "ArrowUp",
  RIGHT: "ArrowRight",
  DOWN: "ArrowDown",
  W: "KeyW",
  A: "KeyA",
  S: "KeyS",
  D: "KeyD",
  M: "KeyM",
  N: "KeyN",
  I: "KeyI",
  Q: "KeyQ",
  NUMBER_1: "Digit1",
  NUMBER_2: "Digit2",
  NUMBER_3: "Digit3",
  NUMBER_4: "Digit4",
  NUMBER_5: "Digit5",
  NUMBER_6: "Digit6",
  NUMBER_7: "Digit7",
  NUMBER_8: "Digit8",
  NUMBER_9: "Digit9",
  COMMA: "Comma",
  PERIOD: "Period",
  MINUS: "Minus",
  EQUALS: "Equal",
  ESCAPE: "Escape",

  isDown: function (keyCode: string) {
    return this._pressed[keyCode];
  },

  onKeydown: (event: KeyboardEvent) => {
    if (event.repeat) return; // ignore repeat keypresses
    if (event.key) Input.keyDownListener(event.key);
    if (event.cancelable && event.key != "F12" && event.key != "F5")
      event.preventDefault();
    Input.lastPressTime = Date.now();
    Input.lastPressKey = event.key;
    Input._pressed[event.code] = true;
    switch (event.code) {
      case Input.LEFT:
        Input.leftListener();
        break;
      case Input.A:
        Input.aListener();
        break;
      case Input.RIGHT:
        Input.rightListener();
        break;
      case Input.D:
        Input.dListener();
        break;
      case Input.UP:
        Input.upListener();
        break;
      case Input.W:
        Input.wListener();
        break;
      case Input.DOWN:
        Input.downListener();
        break;
      case Input.S:
        Input.sListener();
        break;
      case Input.SPACE:
        Input.spaceListener();
        break;
      case Input.M:
        Input.mListener();
        break;
      case Input.I:
        Input.iListener();
        break;
      case Input.Q:
        Input.qListener();
        break;
      case Input.COMMA:
        Input.commaListener();
        break;
      case Input.PERIOD:
        Input.periodListener();
        break;
      case Input.NUMBER_1:
      case Input.NUMBER_2:
      case Input.NUMBER_3:
      case Input.NUMBER_4:
      case Input.NUMBER_5:
      case Input.NUMBER_6:
      case Input.NUMBER_7:
      case Input.NUMBER_8:
      case Input.NUMBER_9:
        Input.numKeyListener(parseInt(event.code.slice(-1)));
        break;
      case Input.EQUALS:
        Input.equalsListener();
        break;
      case Input.MINUS:
        Input.minusListener();
        break;
      case Input.ESCAPE:
        Input.escapeListener();
        break;
    }
  },

  onKeyup: function (event: KeyboardEvent) {
    delete this._pressed[event.code];
    if (event.key === this.lastPressKey) {
      this.lastPressTime = 0;
      this.lastPressKey = 0;
    }
    if (event.code === Input.M) Input.mUpListener();
  },

  mouseLeftClickListener: function (x: number, y: number) {
    for (let i = 0; i < Input.mouseLeftClickListeners.length; i++)
      Input.mouseLeftClickListeners[i](x, y);
  },

  mouseRightClickListener: function (x: number, y: number) {
    for (let i = 0; i < Input.mouseRightClickListeners.length; i++)
      Input.mouseRightClickListeners[i](x, y);
  },

  mouseMoveListener: function (x: number, y: number) {
    for (let i = 0; i < Input.mouseMoveListeners.length; i++)
      Input.mouseMoveListeners[i](x, y);
  },

  mouseDownListener: function (x: number, y: number, button: number) {
    for (let i = 0; i < Input.mouseDownListeners.length; i++)
      Input.mouseDownListeners[i](x, y, button);
  },

  mouseUpListener: function (x: number, y: number, button: number) {
    for (let i = 0; i < Input.mouseUpListeners.length; i++)
      Input.mouseUpListeners[i](x, y, button);
  },

  mouseClickListener: function (event: MouseEvent) {
    if (event.button === 0 || event.button === 2) {
      let rect = window.document
        .getElementById("gameCanvas")
        .getBoundingClientRect();
      let x = event.clientX - rect.left;
      let y = event.clientY - rect.top;
      let scaledX = Math.floor(x / Game.scale);
      let scaledY = Math.floor(y / Game.scale);

      if (event.button === 0) {
        Input.mouseLeftClickListener(scaledX, scaledY);
      } else if (event.button === 2) {
        Input.mouseRightClickListener(scaledX, scaledY);
      }
    }
  },

  updateMousePos: function (event: MouseEvent) {
    Game.inputReceived = true;

    let rect = window.document
      .getElementById("gameCanvas")
      .getBoundingClientRect();
    let x = event.clientX - rect.left;
    let y = event.clientY - rect.top;

    Input.mouseX = Math.floor(x / Game.scale);
    Input.mouseY = Math.floor(y / Game.scale);

    Input.mouseMoveListener(Input.mouseX, Input.mouseY);
  },

  handleMouseDown: function (event: MouseEvent) {
    if (Input.mouseDown) return; // Prevent multiple triggers
    MouseCursor.getInstance().startClickAnim();
    Input.mouseDown = true;
    Input.mouseDownStartTime = Date.now();
    Input.isMouseHold = false;
    Input.mouseDownListener(Input.mouseX, Input.mouseY, event.button);

    // Start checking for hold
    if (!Input._holdCheckInterval) {
      Input._holdCheckInterval = setInterval(Input.checkIsMouseHold, 16); // Check every frame
    }
  },

  handleMouseUp: function (event: MouseEvent) {
    Input.mouseDown = false;
    Input.mouseDownStartTime = null;
    Input.mouseUpListener(Input.mouseX, Input.mouseY, event.button);

    // Clear hold check interval
    if (Input._holdCheckInterval) {
      clearInterval(Input._holdCheckInterval);
      Input._holdCheckInterval = null;
    }

    // Clear isMouseHold after a short delay to ensure click handler sees it
    setTimeout(() => {
      Input.isMouseHold = false;
    }, 50);
  },

  _holdCheckInterval: null,

  checkIsMouseHold: function () {
    if (!Input.mouseDown || Input.mouseDownStartTime === null) return;

    if (Date.now() >= Input.mouseDownStartTime + Input.HOLD_THRESH) {
      if (!Input.isMouseHold) {
        Input.isMouseHold = true;
        // Call the hold callback if one is registered
        if (Input.holdCallback) {
          Input.holdCallback();
        }
      }
    }
  },

  getTouches: function (evt) {
    Game.inputReceived = true;

    return (
      evt.touches || evt.originalEvent.touches // browser API
    ); // jQuery
  },

  xDown: null,
  yDown: null,
  currentX: 0,
  currentY: 0,
  swiped: false,

  handleTouchStart: function (evt: TouchEvent) {
    //console.log("handleTouchStart triggered");
    Game.inputReceived = true;

    evt.preventDefault();

    const firstTouch = Input.getTouches(evt)[0];
    Input.xDown = firstTouch.clientX;
    Input.yDown = firstTouch.clientY;
    Input.currentX = firstTouch.clientX;
    Input.currentY = firstTouch.clientY;

    Input.tapStartTime = Date.now();

    Input.updateMousePos({
      clientX: Input.currentX,
      clientY: Input.currentY,
    } as MouseEvent);

    Input.swiped = false;

    // Unify with mouseDown logic, but force button=0 (left-click equivalent)
    Input.mouseDown = true;
    Input.mouseDownStartTime = Date.now();
    Input.isMouseHold = false;
    Input.mouseDownListener(Input.mouseX, Input.mouseY, 0);

    if (!Input._holdCheckInterval) {
      Input._holdCheckInterval = setInterval(Input.checkIsMouseHold, 16);
      // console.log("_holdCheckInterval started");
    }
  },

  handleTouchMove: function (evt) {
    //console.log("handleTouchMove triggered");
    evt.preventDefault();

    Input.currentX = evt.touches[0].clientX;
    Input.currentY = evt.touches[0].clientY;

    Input.updateMousePos({
      clientX: Input.currentX,
      clientY: Input.currentY,
    } as MouseEvent);

    if (Input.swiped) return;

    var xDiff = Input.xDown - Input.currentX;
    var yDiff = Input.yDown - Input.currentY;

    // we have not swiped yet
    // check if we've swiped
    if (xDiff ** 2 + yDiff ** 2 >= GameConstants.SWIPE_THRESH) {
      if (Math.abs(xDiff) > Math.abs(yDiff)) {
        /*most significant*/
        if (xDiff > 0) {
          Input.leftSwipeListener();
        } else {
          Input.rightSwipeListener();
        }
        Input.swiped = true;
      } else {
        if (yDiff > 0) {
          Input.upSwipeListener();
        } else {
          Input.downSwipeListener();
        }
        Input.swiped = true;
      }
    }
  },

  handleTouchEnd: function (evt: TouchEvent) {
    //console.log("handleTouchEnd triggered");
    evt.preventDefault();

    if (!Input.isTapHold && !Input.swiped) Input.tapListener();
    Input.isTapHold = false;
    Input.tapStartTime = null;

    //if (Input.swiped) return;

    // Also unify with mouseUp logic, again forcing button=0
    Input.mouseDown = false;
    Input.mouseDownStartTime = null;
    Input.mouseUpListener(Input.mouseX, Input.mouseY, 0);

    if (Input._holdCheckInterval) {
      clearInterval(Input._holdCheckInterval);
      Input._holdCheckInterval = null;
      //console.log("_holdCheckInterval cleared");
    }
    setTimeout(() => {
      Input.isMouseHold = false;
      //console.log("isMouseHold reset");
    }, 50);
  },

  checkIsTapHold: function () {
    if (
      Input.tapStartTime !== null &&
      Date.now() >= Input.tapStartTime + Input.IS_TAP_HOLD_THRESH
    )
      Input.isTapHold = true;
  },

  set isMouseHold(value: boolean) {
    //console.log(`isMouseHold set to: ${value}`);
    this._isMouseHold = value;
  },

  get isMouseHold() {
    return this._isMouseHold;
  },

  _isMouseHold: false,

  mouseDownStartTime: null,
  HOLD_THRESH: 200, // Adjust this value as needed

  holdCallback: null as (() => void) | null,
};
window.addEventListener(
  "keyup",
  function (event) {
    Input.onKeyup(event);
  },
  false,
);
window.addEventListener(
  "keydown",
  function (event) {
    Input.onKeydown(event);
  },
  false,
);
window.addEventListener(
  "touchstart",
  function (event) {
    Input.handleTouchStart(event);
  },
  false,
);
window.addEventListener(
  "touchend",
  function (event) {
    Input.handleTouchEnd(event);
  },
  false,
);
window.document
  .getElementById("gameCanvas")
  .addEventListener("click", (event) => Input.mouseClickListener(event), false);
window.document
  .getElementById("gameCanvas")
  .addEventListener("mousemove", (event) => Input.updateMousePos(event), false);
window.document
  .getElementById("gameCanvas")
  .addEventListener(
    "mousedown",
    (event) => Input.handleMouseDown(event),
    false,
  );
window.document
  .getElementById("gameCanvas")
  .addEventListener("mouseup", (event) => Input.handleMouseUp(event), false);
window.document
  .getElementById("gameCanvas")
  .addEventListener("contextmenu", (event) => event.preventDefault(), false);

window.document
  .getElementById("gameCanvas")
  .addEventListener(
    "touchstart",
    (event) => Input.handleTouchStart(event),
    false,
  );
window.document
  .getElementById("gameCanvas")
  .addEventListener("touchend", (event) => Input.handleTouchEnd(event), false);


--- src/inventory.ts ---
import { Item } from "./item/item";
import { LevelConstants } from "./levelConstants";
import { Game } from "./game";
import { GameConstants } from "./gameConstants";
import { Equippable } from "./item/equippable";
import { Armor } from "./item/armor";
import { Coin } from "./item/coin";
import { Weapon } from "./weapon/weapon";
import { Room } from "./room";
import { Usable } from "./item/usable";
import { Player } from "./player";
import { MouseCursor } from "./mouseCursor";
import { Input } from "./input";

let OPEN_TIME = 100; // milliseconds
// Dark gray color used for the background of inventory slots
let FILL_COLOR = "#5a595b";
// Very dark blue-gray color used for outlines and borders
let OUTLINE_COLOR = "#292c36";
// Light blue color used to indicate equipped items
let EQUIP_COLOR = "#85a8e6";
// White color used for the outer border of the inventory
let FULL_OUTLINE = "white";

export class Inventory {
  player: Player;
  items: Array<Item | null>;
  rows = 4;
  cols = 5;
  selX = 0;
  selY = 0;
  game: Game;
  isOpen: boolean = false;
  openTime: number = Date.now();
  coins: number = 0;
  equipAnimAmount: Array<number>;
  weapon: Weapon | null = null;
  private _expansion: number = 0;
  grabbedItem: Item | null = null;
  private _mouseDownStartX: number | null = null;
  private _mouseDownStartY: number | null = null;
  private _mouseDownItem: Item | null = null;
  private _wasHoldDetected: boolean = false;
  private _isDragging: boolean = false;
  private _dragStartItem: Item | null = null;
  private _dragStartSlot: number | null = null;
  private itemEquipAnimations: Map<Item, number> = new Map();

  // New state for using items on other items
  private usingItem: Usable | null = null;
  private usingItemIndex: number | null = null;
  mostRecentInput: "mouse" | "keyboard" = "keyboard";

  // Static variables for inventory button position
  private buttonY: number;
  private buttonX: number;

  constructor(game: Game, player: Player) {
    this.game = game;
    this.player = player;

    this.buttonX =
      (Math.round(GameConstants.WIDTH / 2) + 3) / GameConstants.TILESIZE;
    this.buttonY = 10;

    Input.mouseDownListeners.push((x, y, button) =>
      this.handleMouseDown(x, y, button),
    );
    Input.mouseUpListeners.push((x, y, button) =>
      this.handleMouseUp(x, y, button),
    );

    Input.holdCallback = () => this.onHoldDetected();

    this.items = new Array<Item | null>(
      (this.rows + this._expansion) * this.cols,
    ).fill(null);
    this.equipAnimAmount = new Array<number>(
      (this.rows + this._expansion) * this.cols,
    ).fill(0);
    let a = (i: Item | null) => {
      if (i === null) return;
      if (i instanceof Equippable) {
        i.setWielder(this.player);
      }
      if (i instanceof Weapon && this.weapon === null) {
        i.toggleEquip();
        this.weapon = i;
        //this.player.weapon = this.weapon;
      }

      this.addItem(i);
    };
    let startingInv = GameConstants.DEVELOPER_MODE
      ? GameConstants.STARTING_DEV_INVENTORY
      : GameConstants.STARTING_INVENTORY;

    startingInv.forEach((item) => {
      a(new item({ game: this.game } as Room, 0, 0));
    });
  }

  clear = () => {
    this.items.fill(null);
    this.equipAnimAmount.fill(0);
  };

  get isDragging() {
    return this._isDragging;
  }

  open = () => {
    this.isOpen = !this.isOpen;
    if (this.isOpen) this.openTime = Date.now();
    if (!this.isOpen) {
      this.selY = 0;
      this.usingItem = null;
      this.usingItemIndex = null;
    }
  };

  toggleOpen = () => {
    if (this.isOpen) {
      this.close();
    } else {
      this.open();
    }
  };

  close = () => {
    this.isOpen = false;
    if (this.selY > 0) {
      this.selY = 0;
    }
    this.usingItem = null;
    this.usingItemIndex = null;
  };

  left = () => {
    if (this.selX > 0) {
      this.selX--;
    }
  };

  right = () => {
    if (this.selX < this.cols - 1) {
      this.selX++;
    }
  };

  up = () => {
    if (this.selY > 0) {
      this.selY--;
    }
  };

  down = () => {
    if (this.selY < this.rows + this._expansion - 1) {
      this.selY++;
    }
  };

  space = () => {
    this.itemUse();
  };

  itemAtSelectedSlot = (): Item | null => {
    let index = this.selX + this.selY * this.cols;
    if (index < 0 || index >= this.items.length) {
      return null;
    }
    return this.items[index];
  };

  getIndexOfItem = (item: Item): number => {
    if (item === null) return -1;
    return this.items.indexOf(item);
  };

  itemUse = () => {
    let index = this.selX + this.selY * this.cols;
    if (index < 0 || index >= this.items.length) return;
    const item = this.items[index];

    if (this.usingItem) {
      // Attempt to use 'usingItem' on the currently selected item
      if (item === null) {
        // Clicked on empty slot; cancel the using state
        this.usingItem = null;
        this.usingItemIndex = null;
        return;
      }
      // Attempt to use on other
      if (item instanceof Item) {
        this.usingItem.useOnOther(this.player, item);
      }
      // Exit tryingToUse state
      this.usingItem = null;
      this.usingItemIndex = null;
    } else {
      // Not in tryingToUse state
      if (item instanceof Usable) {
        if (item.canUseOnOther) {
          // Enter tryingToUse state
          this.usingItem = item;
          this.usingItemIndex = index;
        } else {
          // Use normally
          item.onUse(this.player);
          // Optionally remove the item
          // this.items[index] = null;
        }
      } else if (item instanceof Equippable) {
        // Existing equipping logic
        item.toggleEquip();
        if (item instanceof Weapon) {
          this.weapon = item.equipped ? item : null;
        }
        if (item.equipped) {
          this.items.forEach((i, idx) => {
            if (
              i instanceof Equippable &&
              i !== item &&
              !item.coEquippable(i)
            ) {
              i.equipped = false;
              this.equipAnimAmount[idx] = 0;
            }
          });
        }
      }
    }
  };

  mouseLeftClick = () => {
    this.mostRecentInput = "mouse";
    const { x, y } = MouseCursor.getInstance().getPosition();
    const bounds = this.isPointInInventoryBounds(x, y);

    // Only close inventory if clicking outside
    //if (!this.isPointInInventoryBounds(x, y) && this.open) {
    //this.close();
    //}
  };

  mouseRightClick = () => {
    this.mostRecentInput = "mouse";
    const { x, y } = MouseCursor.getInstance().getPosition();
    const bounds = this.isPointInInventoryBounds(x, y);

    if (bounds.inBounds) {
      this.drop();
    }
  };

  leftQuickbar = () => {
    this.mostRecentInput = "keyboard";

    this.left();
  };

  rightQuickbar = () => {
    this.mostRecentInput = "keyboard";
    this.right();
  };

  spaceQuickbar = () => {
    this.mostRecentInput = "keyboard";
    this.itemUse();
  };

  handleNumKey = (num: number) => {
    this.mostRecentInput = "keyboard";
    if (num <= 5) {
      this.selX = Math.max(0, Math.min(num - 1, this.cols - 1));
      this.selY = 0;
      this.itemUse();
    } else {
      if (GameConstants.DEVELOPER_MODE) {
        switch (num) {
          case 6:
            GameConstants.SET_COLOR_LAYER_COMPOSITE_OPERATION(false, true);
            break;
          case 7:
            GameConstants.SET_COLOR_LAYER_COMPOSITE_OPERATION(false);
            break;
        }
      }
      {
        switch (num) {
          case 9:
            GameConstants.ctxBlurEnabled = !GameConstants.ctxBlurEnabled;
            this.game.pushMessage(
              "Custom shade color is now " +
                (GameConstants.ctxBlurEnabled ? "on" : "off"),
            );
            break;
          case 8:
            GameConstants.BLUR_ENABLED = !GameConstants.BLUR_ENABLED;
            break;
        }
      }
    }
  };

  mouseMove = () => {
    this.mostRecentInput = "mouse";
    const { x, y } = MouseCursor.getInstance().getPosition();
    const bounds = this.isPointInInventoryBounds(x, y);

    if (bounds.inBounds) {
      const s = this.isOpen
        ? Math.min(18, (18 * (Date.now() - this.openTime)) / OPEN_TIME)
        : 18;
      const b = 2;
      const g = -2;

      const oldSelX = this.selX;
      const oldSelY = this.selY;

      this.selX = Math.max(
        0,
        Math.min(
          Math.floor((x - bounds.startX) / (s + 2 * b + g)),
          this.cols - 1,
        ),
      );
      this.selY = this.isOpen
        ? Math.max(
            0,
            Math.min(
              Math.floor((y - bounds.startY) / (s + 2 * b + g)),
              this.rows + this._expansion - 1,
            ),
          )
        : 0;

      if (oldSelX !== this.selX || oldSelY !== this.selY) {
        // Optional: Handle selection change
      }
    }
  };

  moveItemToSlot = (
    item: Item | null,
    index: number,
    otherItem: Item | null,
    otherIndex: number,
  ) => {
    if (item === null) return;

    // Preserve animation states before moving
    const itemAnim = this.equipAnimAmount[index];
    const otherAnim = otherItem ? this.equipAnimAmount[otherIndex] : 0;

    if (otherItem === null) {
      this.items[index] = item;
      this.equipAnimAmount[index] = this.itemEquipAnimations.get(item) ?? 0;
    } else {
      this.items[index] = otherItem;
      this.items[otherIndex] = item;
      this.equipAnimAmount[index] =
        this.itemEquipAnimations.get(otherItem) ?? 0;
      this.equipAnimAmount[otherIndex] =
        this.itemEquipAnimations.get(item) ?? 0;
    }
  };

  grabItem = (item: Item) => {
    if (item === null) {
      return;
    }
    if (this.grabbedItem !== null) {
      return;
    }

    // Remove the item from its slot when grabbed
    const index = this.getIndexOfItem(item);

    if (index !== -1) {
      this.items[index] = null;
      this.grabbedItem = item;
    } else {
    }
  };

  releaseItem = () => {
    if (this.grabbedItem === null) {
      return;
    }

    const targetIndex = this.selX + this.selY * this.cols;
    const existingItem = this.items[targetIndex];

    // If target slot is empty, place item there
    if (existingItem === null) {
      this.items[targetIndex] = this.grabbedItem;
    } else {
      // Swap items
      this.items[targetIndex] = this.grabbedItem;
    }

    this.grabbedItem = null;
  };

  drawDraggedItem = (delta: number) => {
    if (this.grabbedItem === null) return;
    const { x, y } = MouseCursor.getInstance().getPosition();

    const drawX = Math.round(x - 0.5 * GameConstants.TILESIZE);
    const drawY = Math.round(y - 0.5 * GameConstants.TILESIZE);
    const drawXScaled = drawX / GameConstants.TILESIZE;
    const drawYScaled = drawY / GameConstants.TILESIZE;
    this.grabbedItem.drawIcon(delta, drawXScaled, drawYScaled);
  };

  drop = () => {
    let index = this.selX + this.selY * this.cols;
    if (index < 0 || index >= this.items.length) return;
    const item = this.items[index];
    if (item === null) return;
    this.dropItem(item, index);
  };

  dropItem = (item: Item, index: number) => {
    item.level = this.game.levels[this.player.depth].rooms[this.player.levelID];
    item.x = this.player.x;
    item.y = this.player.y;
    item.alpha = 1;
    item.pickedUp = false;
    item.dropFromInventory();
    this.equipAnimAmount[index] = 0;
    item.drawableY = this.player.y;
    this.game.levels[this.player.depth].rooms[this.player.levelID].items.push(
      item,
    );
    this.items[index] = null;
  };

  dropFromInventory = () => {
    // Intentionally left blank or implement if needed
  };

  hasItem = <T extends Item>(itemType: new (...args: any[]) => T): T | null => {
    return this.items.find((i): i is T => i instanceof itemType) || null;
  };

  hasItemCount = (item: Item | null): boolean => {
    if (item === null) return false;
    if (item instanceof Coin) return this.coinCount() >= item.stackCount;
    return this.items.some(
      (i) =>
        i !== null &&
        i.constructor === item.constructor &&
        i.stackCount >= item.stackCount,
    );
  };

  subtractItemCount = (item: Item | null) => {
    if (item === null) return;
    if (item instanceof Coin) {
      this.subtractCoins(item.stackCount);
      return;
    }
    this.items.forEach((i, idx) => {
      if (i === null) return;
      if (i.constructor === item.constructor) {
        i.stackCount -= item.stackCount;
        if (i.stackCount <= 0) {
          this.items[idx] = null;
        }
      }
    });
  };

  coinCount = (): number => {
    return this.coins;
  };

  subtractCoins = (n: number) => {
    this.coins = Math.max(0, this.coins - n);
  };

  addCoins = (n: number) => {
    this.coins += n;
  };

  isFull = (): boolean => {
    return (
      this.items.filter((i) => i !== null).length >=
      (this.rows + this._expansion) * this.cols
    );
  };

  addItem = (item: Item | null): boolean => {
    if (item === null) return false;
    if (item instanceof Coin) {
      this.coins += item.stack;
      return true;
    }
    if (item instanceof Equippable) {
      item.setWielder(this.player);
    }
    if (item.stackable) {
      for (let i = 0; i < this.items.length; i++) {
        if (
          this.items[i] !== null &&
          this.items[i]!.constructor === item.constructor
        ) {
          this.items[i]!.stackCount += item.stackCount;
          return true;
        }
      }
    }
    if (!this.isFull()) {
      for (let i = 0; i < this.items.length; i++) {
        if (this.items[i] === null) {
          this.items[i] = item;
          return true;
        }
      }
    }
    return false;
  };

  removeItem = (item: Item | null) => {
    if (item === null) return;
    const index = this.items.indexOf(item);
    if (index !== -1) {
      this.items[index] = null;
    }
  };

  getArmor = (): Armor | null => {
    return (
      this.items.find((i): i is Armor => i instanceof Armor && i.equipped) ||
      null
    );
  };

  hasWeapon = (): boolean => {
    return this.weapon !== null;
  };

  getWeapon = (): Weapon | null => {
    return this.weapon;
  };

  tick = () => {
    this.items.forEach((i) => {
      if (i !== null) i.tickInInventory();
    });

    // Check for drag initiation
    this.checkForDragStart();
  };

  textWrap = (text: string, x: number, y: number, maxWidth: number): number => {
    // Returns y value for next line
    if (text === "") return y;
    let words = text.split(" ");
    let line = "";

    while (words.length > 0) {
      if (Game.measureText(line + words[0]).width > maxWidth) {
        Game.fillText(line, x, y);
        line = "";
        y += 8;
      } else {
        if (line !== "") line += " ";
        line += words[0];
        words.splice(0, 1);
      }
    }
    if (line.trim() !== "") {
      Game.fillText(line, x, y);
      y += 8;
    }
    return y;
  };

  drawCoins = (delta: number) => {
    let coinTileX = 19;
    if (this.coins === 2) coinTileX = 20;
    else if (this.coins >= 3) coinTileX = 21;
    let coinX = GameConstants.WIDTH / GameConstants.TILESIZE - 2.25;
    let coinY = GameConstants.HEIGHT / GameConstants.TILESIZE - 1.25;
    if (GameConstants.WIDTH < 170) {
      //coinX -= 1.25;
      coinY -= 1.25;
    }

    Game.drawItem(coinTileX, 0, 1, 2, coinX, coinY - 1, 1, 2);

    const countText = `${this.coins}`;
    const width = Game.measureText(countText).width;
    const countX = 10;
    const countY = 9;

    Game.fillTextOutline(
      countText,
      coinX * GameConstants.TILESIZE + countX,
      coinY * GameConstants.TILESIZE + countY,
      GameConstants.OUTLINE,
      "white",
    );
    /*
    const turnCountText = `${this.player.turnCount}`;
    Game.fillTextOutline(
      turnCountText,
      coinX * GameConstants.TILESIZE + countX,
      coinY * GameConstants.TILESIZE + countY - 15,
      GameConstants.OUTLINE,
      "white",
    );
    */
  };

  pointInside = (x: number, y: number): boolean => {
    const s = Math.min(18, (18 * (Date.now() - this.openTime)) / OPEN_TIME); // size of box
    const b = 2; // border
    const g = -2; // gap
    const hg = 3 + Math.round(0.5 * Math.sin(Date.now() * 0.01) + 0.5); // highlighted growth
    const ob = 1; // outer border
    const width = this.cols * (s + 2 * b + g) - g;
    const height = (this.rows + this._expansion) * (s + 2 * b + g) - g;

    const startX = Math.round(0.5 * GameConstants.WIDTH - 0.5 * width) - ob;
    const startY = this.isOpen
      ? Math.round(0.5 * GameConstants.HEIGHT - 0.5 * height) - ob
      : GameConstants.HEIGHT - (s + 2 * b) - 5 - ob;
    const checkHeight = this.isOpen ? height + 2 * ob : s + 2 * b + 2 * ob;

    return (
      x >= startX &&
      x <= startX + width + 2 * ob &&
      y >= startY &&
      y <= startY + checkHeight
    );
  };

  drawQuickbar = (delta: number) => {
    const { x, y } = MouseCursor.getInstance().getPosition();
    const isInBounds = this.isPointInInventoryBounds(x, y).inBounds;

    const s = 18; // size of box
    const b = 2; // border
    const g = -2; // gap
    const hg = 1; // + Math.round(0.5 * Math.sin(Date.now() * 0.01) + 0.5); // highlighted growth
    const ob = 1; // outer border
    const width = Math.floor(this.cols * (s + 2 * b + g) - g);
    const height = Math.floor(s + 2 * b);
    const startX = Math.round(0.5 * GameConstants.WIDTH - 0.5 * width);
    const startY = Math.floor(GameConstants.HEIGHT - height - 2);

    // Draw main background
    /*
    Game.ctx.fillStyle = FULL_OUTLINE;
    Game.ctx.fillRect(startX - ob, startY - 1, width + 2, height + 2);
    */
    //Game.ctx.globalCompositeOperation = "xor";

    // Draw highlighted background for selected item only if mouse is in bounds
    if (isInBounds || this.mostRecentInput === "keyboard") {
      /*
      Game.ctx.fillRect(
        Math.floor(startX + this.selX * (s + 2 * b + g) - hg - ob),
        Math.floor(startY - hg - ob),
        Math.floor(s + 2 * b + 2 * hg + 2 * ob),
        Math.floor(s + 2 * b + 2 * hg + 2 * ob),
      );
      */
    }

    // Draw individual item slots
    for (let xIdx = 0; xIdx < this.cols; xIdx++) {
      // Skip drawing normal background and icon if this is the selected slot
      const idx = xIdx;

      // Draw slot background
      if (xIdx !== this.selX) {
        Game.ctx.fillStyle = FILL_COLOR;
        Game.ctx.fillRect(
          Math.floor(startX + xIdx * (s + 2 * b + g) + b),
          Math.floor(startY + b),
          Math.floor(s),
          Math.floor(s),
        );

        Game.ctx.clearRect(
          Math.floor(startX + xIdx * (s + 2 * b + g) + b + 1),
          Math.floor(startY + b + 1),
          Math.floor(s - 2),
          Math.floor(s - 2),
        );

        // Draw equip animation (this should always show)
        Game.ctx.fillStyle = EQUIP_COLOR;
        Game.ctx.globalAlpha = 0.3;
        const yOff = Math.floor(s * (1 - this.equipAnimAmount[idx]));
        Game.ctx.fillRect(
          Math.floor(startX + xIdx * (s + 2 * b + g) + b),
          Math.floor(startY + b + yOff),
          Math.floor(s),
          Math.floor(s - yOff),
        );
        Game.ctx.globalAlpha = 1;
        /*
        Game.ctx.clearRect(
          Math.floor(startX + xIdx * (s + 2 * b + g) + b + 1),
          Math.floor(startY + b + 1),
          Math.floor(s - 2),
          Math.floor(s - 2),
        );
        */
      }

      // Draw item icon if exists
      if (idx < this.items.length && this.items[idx] !== null) {
        const drawX =
          startX +
          xIdx * (s + 2 * b + g) +
          b +
          Math.floor(0.5 * s) -
          0.5 * GameConstants.TILESIZE;
        const drawY =
          startY + b + Math.floor(0.5 * s) - 0.5 * GameConstants.TILESIZE;
        const drawXScaled = drawX / GameConstants.TILESIZE;
        const drawYScaled = drawY / GameConstants.TILESIZE;
        this.items[idx]?.drawIcon(delta, drawXScaled, drawYScaled);
      }
    }

    // Draw selection box only if mouse is in bounds
    if (true) {
      const selStartX = Math.floor(startX + this.selX * (s + 2 * b + g));
      const selStartY = Math.floor(startY);
      /*
      // Outer selection box (dark)
      Game.ctx.fillStyle = OUTLINE_COLOR;
      Game.ctx.fillRect(
        selStartX - hg,
        selStartY - hg,
        s + 2 * b + 2 * hg,
        s + 2 * b + 2 * hg,
      );
      */

      // Inner selection box (light grey)
      Game.ctx.fillStyle = FILL_COLOR;
      Game.ctx.fillRect(
        Math.floor(selStartX + b - hg),
        Math.floor(selStartY + b - hg),
        Math.floor(s + 2 * hg),
        Math.floor(s + 2 * hg),
      );

      Game.ctx.clearRect(
        Math.floor(startX + this.selX * (s + 2 * b + g) + b),
        Math.floor(startY + b),
        Math.floor(s),
        Math.floor(s),
      );

      // Draw equip animation for selected slot with highlight
      const idx = this.selX;
      Game.ctx.fillStyle = EQUIP_COLOR;
      Game.ctx.globalAlpha = 0.3;
      const yOff = (s + 2 * hg) * (1 - this.equipAnimAmount[idx]);
      Game.ctx.fillRect(
        Math.round(startX + this.selX * (s + 2 * b + g) + b - hg),
        Math.round(startY + b + yOff - hg),
        Math.round(s + 2 * hg),
        Math.round(s + 2 * hg - yOff),
      );
      Game.ctx.globalAlpha = 1;

      /*
      Game.ctx.clearRect(
        Math.floor(startX + this.selX * (s + 2 * b + g) + b),
        Math.floor(startY + b),
        Math.floor(s),
        Math.floor(s),
      );
      */
      this.drawUsingItem(delta, startX, startY, s, b, g);

      // Redraw the selected item
      if (idx < this.items.length && this.items[idx] !== null) {
        const drawX =
          selStartX + b + Math.floor(0.5 * s) - 0.5 * GameConstants.TILESIZE;
        const drawY =
          selStartY + b + Math.floor(0.5 * s) - 0.5 * GameConstants.TILESIZE;
        const drawXScaled = drawX / GameConstants.TILESIZE;
        const drawYScaled = drawY / GameConstants.TILESIZE;

        this.items[idx]?.drawIcon(delta, drawXScaled, drawYScaled);
      }
      this.drawUsingItem(delta, startX, startY, s, b, g);
    }
    this.drawUsingItem(delta, startX, startY, s, b, g);
  };

  drawUsingItem = (
    delta: number,
    startX: number,
    startY: number,
    s: number,
    b: number,
    g: number,
  ) => {
    // Highlight the usingItem's slot if in using state and it's different from current selection
    Game.ctx.globalCompositeOperation = "source-over";
    if (this.usingItem && this.usingItemIndex !== null) {
      const usingX = this.usingItemIndex % this.cols;
      const usingY = Math.floor(this.usingItemIndex / this.cols);
      const highlightStartX = startX + usingX * (s + 2 * b + g);
      const highlightStartY = startY + usingY * (s + 2 * b + g);

      Game.ctx.strokeStyle = "yellow"; // Choose a distinct color for using item
      Game.ctx.lineWidth = 2;
      Game.ctx.strokeRect(
        highlightStartX,
        highlightStartY,
        s + 2 * b,
        s + 2 * b,
      );
      Game.ctx.lineWidth = 1; // Reset line width
    }
  };

  updateEquipAnimAmount = (delta: number) => {
    this.equipAnimAmount.forEach((amount, idx) => {
      const item = this.items[idx];
      if (item instanceof Equippable) {
        let targetAmount = item.equipped ? 1 : 0;
        let currentAmount = this.itemEquipAnimations.get(item) ?? amount;

        currentAmount += 0.2 * delta * (targetAmount - currentAmount);
        currentAmount = Math.max(0, Math.min(1, currentAmount));

        this.itemEquipAnimations.set(item, currentAmount);
        this.equipAnimAmount[idx] = currentAmount;
      } else {
        this.equipAnimAmount[idx] = 0;
        if (item) this.itemEquipAnimations.delete(item);
      }
    });
  };

  draw = (delta: number) => {
    Game.ctx.imageSmoothingEnabled = false;
    Game.ctx.imageSmoothingQuality = "low";
    const { x, y } = MouseCursor.getInstance().getPosition();
    const isInBounds = this.isPointInInventoryBounds(x, y).inBounds;
    const s = Math.floor(
      Math.min(18, (18 * (Date.now() - this.openTime)) / OPEN_TIME),
    ); // size of box
    const b = 2; // border
    const g = -2; // gap
    const hg = 3 + Math.round(0.5 * Math.sin(Date.now() * 0.01) + 0.5); // highlighted growth
    const invRows = Math.floor(this.rows + this._expansion);
    const ob = 1; // outer border
    const width = Math.floor(this.cols * (s + 2 * b + g) - g);
    const height = Math.floor(invRows * (s + 2 * b + g) - g);
    const mainBgX = Math.round(0.5 * GameConstants.WIDTH - 0.5 * width) - ob;
    const mainBgY = Math.round(0.5 * GameConstants.HEIGHT - 0.5 * height) - ob;

    // Draw coins and quickbar (these are always visible)
    this.drawCoins(delta);
    this.drawQuickbar(delta);
    this.updateEquipAnimAmount(delta);
    this.drawInventoryButton(delta);

    if (this.isOpen) {
      // Draw semi-transparent background for full inventory
      Game.ctx.fillStyle = "rgba(0, 0, 0, 0.8)";
      Game.ctx.fillRect(0, 0, GameConstants.WIDTH, GameConstants.HEIGHT);

      Game.ctx.globalAlpha = 1;

      // Define dimensions and styling variables (similar to drawQuickbar)
      const s = Math.floor(
        Math.min(18, (18 * (Date.now() - this.openTime)) / OPEN_TIME),
      ); // size of box
      const b = 2; // border
      const g = -2; // gap
      const hg = Math.floor(
        3 + Math.round(0.5 * Math.sin(Date.now() * 0.01) + 0.5),
      ); // highlighted growth
      const invRows = this.rows + this._expansion;
      const ob = 1; // outer border
      const width = Math.floor(this.cols * (s + 2 * b + g) - g);
      const height = Math.floor(invRows * (s + 2 * b + g) - g);

      // Draw main inventory background (similar to drawQuickbar)
      Game.ctx.fillStyle = FULL_OUTLINE;
      const mainBgX = Math.round(0.5 * GameConstants.WIDTH - 0.5 * width) - ob;
      const mainBgY =
        Math.round(0.5 * GameConstants.HEIGHT - 0.5 * height) - ob;
      Game.ctx.fillRect(mainBgX, mainBgY, width + 2 * ob, height + 2 * ob);

      // Draw highlighted background for selected item only if mouse is in bounds
      if (isInBounds || this.mostRecentInput === "keyboard") {
        const highlightX =
          Math.round(
            0.5 * GameConstants.WIDTH -
              0.5 * width +
              this.selX * (s + 2 * b + g),
          ) -
          hg -
          ob;
        const highlightY =
          Math.round(
            0.5 * GameConstants.HEIGHT -
              0.5 * height +
              this.selY * (s + 2 * b + g),
          ) -
          hg -
          ob;

        Game.ctx.fillRect(
          highlightX,
          highlightY,
          s + 2 * b + 2 * hg + 2 * ob,
          s + 2 * b + 2 * hg + 2 * ob,
        );
      }

      // Draw individual inventory slots (similar to drawQuickbar, but for all rows)
      for (let xIdx = 0; xIdx < this.cols; xIdx++) {
        for (let yIdx = 0; yIdx < this.rows + this._expansion; yIdx++) {
          // Draw slot outline
          const slotX = Math.round(
            0.5 * GameConstants.WIDTH - 0.5 * width + xIdx * (s + 2 * b + g),
          );
          const slotY = Math.round(
            0.5 * GameConstants.HEIGHT - 0.5 * height + yIdx * (s + 2 * b + g),
          );
          Game.ctx.fillStyle = OUTLINE_COLOR;
          Game.ctx.fillRect(slotX, slotY, s + 2 * b, s + 2 * b);

          // Draw slot background
          Game.ctx.fillStyle = FILL_COLOR;
          Game.ctx.fillRect(slotX + b, slotY + b, s, s);

          // Draw equip animation (unique to full inventory view)
          const idx = xIdx + yIdx * this.cols;
          Game.ctx.fillStyle = EQUIP_COLOR;
          const yOff = Math.round(s * (1 - this.equipAnimAmount[idx]));
          Game.ctx.fillRect(slotX + b, slotY + b + yOff, s, s - yOff);

          // Draw item icon if exists
          if (idx < this.items.length && this.items[idx] !== null) {
            const drawX = Math.round(
              0.5 * GameConstants.WIDTH -
                0.5 * width +
                xIdx * (s + 2 * b + g) +
                b +
                Math.floor(0.5 * s) -
                0.5 * GameConstants.TILESIZE,
            );
            const drawY = Math.round(
              0.5 * GameConstants.HEIGHT -
                0.5 * height +
                yIdx * (s + 2 * b + g) +
                b +
                Math.floor(0.5 * s) -
                0.5 * GameConstants.TILESIZE,
            );
            const drawXScaled = drawX / GameConstants.TILESIZE;
            const drawYScaled = drawY / GameConstants.TILESIZE;

            this.items[idx]?.drawIcon(delta, drawXScaled, drawYScaled);
          }
        }
      }

      // Draw item icons after animation delay (similar to drawQuickbar, but for all items)
      if (Date.now() - this.openTime >= OPEN_TIME) {
        this.items.forEach((item, idx) => {
          if (item === null) return;
          const x = idx % this.cols;
          const y = Math.floor(idx / this.cols);

          const drawX = Math.round(
            0.5 * GameConstants.WIDTH -
              0.5 * width +
              x * (s + 2 * b + g) +
              b +
              Math.floor(0.5 * s) -
              0.5 * GameConstants.TILESIZE,
          );
          const drawY = Math.round(
            0.5 * GameConstants.HEIGHT -
              0.5 * height +
              y * (s + 2 * b + g) +
              b +
              Math.floor(0.5 * s) -
              0.5 * GameConstants.TILESIZE,
          );

          const drawXScaled = drawX / GameConstants.TILESIZE;
          const drawYScaled = drawY / GameConstants.TILESIZE;

          item.drawIcon(delta, drawXScaled, drawYScaled);
        });

        // Draw selection box and related elements only if mouse is in bounds
        if (isInBounds || this.mostRecentInput === "keyboard") {
          // Draw selection box
          Game.ctx.fillStyle = OUTLINE_COLOR;
          Game.ctx.fillRect(
            Math.round(
              0.5 * GameConstants.WIDTH -
                0.5 * width +
                this.selX * (s + 2 * b + g) -
                hg,
            ),
            Math.round(
              0.5 * GameConstants.HEIGHT -
                0.5 * height +
                this.selY * (s + 2 * b + g) -
                hg,
            ),
            s + 2 * b + 2 * hg,
            s + 2 * b + 2 * hg,
          );

          const slotX = Math.round(
            0.5 * GameConstants.WIDTH -
              0.5 * width +
              this.selX * (s + 2 * b + g) +
              b -
              hg,
          );
          const slotY = Math.round(
            0.5 * GameConstants.HEIGHT -
              0.5 * height +
              this.selY * (s + 2 * b + g) +
              b -
              hg,
          );
          Game.ctx.fillStyle = FILL_COLOR;
          Game.ctx.fillRect(slotX, slotY, s + 2 * hg, s + 2 * hg);

          // Draw equip animation for selected item (unique to full inventory view)
          const idx = this.selX + this.selY * this.cols;
          if (idx < this.items.length && this.items[idx] !== null) {
            Game.ctx.fillStyle = EQUIP_COLOR;
            const yOff = Math.round(
              (s + 2 * hg) * (1 - this.equipAnimAmount[idx]),
            );
            Game.ctx.fillRect(
              Math.round(
                0.5 * GameConstants.WIDTH -
                  0.5 * width +
                  this.selX * (s + 2 * b + g) +
                  b -
                  hg,
              ),
              Math.round(
                0.5 * GameConstants.HEIGHT -
                  0.5 * height +
                  this.selY * (s + 2 * b + g) +
                  b -
                  hg +
                  yOff,
              ),
              s + 2 * hg,
              s + 2 * hg - yOff,
            );

            // Redraw selected item icon (similar to drawQuickbar)
            const drawX = Math.round(
              0.5 * GameConstants.WIDTH -
                0.5 * width +
                this.selX * (s + 2 * b + g) +
                b +
                Math.floor(0.5 * s) -
                0.5 * GameConstants.TILESIZE,
            );
            const drawY = Math.round(
              0.5 * GameConstants.HEIGHT -
                0.5 * height +
                this.selY * (s + 2 * b + g) +
                b +
                Math.floor(0.5 * s) -
                0.5 * GameConstants.TILESIZE,
            );

            const drawXScaled = drawX / GameConstants.TILESIZE;
            const drawYScaled = drawY / GameConstants.TILESIZE;

            this.items[idx]?.drawIcon(delta, drawXScaled, drawYScaled);
          }

          // **Move drawUsingItem here, after the main selection box**
        }

        // **Ensure drawUsingItem is not called again here**
        // this.drawUsingItem(delta, mainBgX, mainBgY, s, b, g);
      }

      // **Ensure drawUsingItem is not called again here**
      // this.drawUsingItem(delta, mainBgX, mainBgY, s, b, g);
      // Draw item description and action text (unique to full inventory view)
      const selectedIdx = this.selX + this.selY * this.cols;

      if (selectedIdx < this.items.length && this.items[selectedIdx] !== null) {
        const item = this.items[selectedIdx]!;
        Game.ctx.fillStyle = "white";

        // Determine action text
        let topPhrase = "";
        if (item instanceof Equippable) {
          topPhrase = item.equipped ? "[SPACE] to unequip" : "[SPACE] to equip";
        }
        if (item instanceof Usable) {
          topPhrase = "[SPACE] to use";
        }

        // Draw action text
        const actionTextWidth = Game.measureText(topPhrase).width;
        Game.fillText(
          topPhrase,
          Math.round(0.5 * (GameConstants.WIDTH - actionTextWidth)),
          5,
        );

        // Draw item description
        const lines = item.getDescription().split("\n");
        let nextY = Math.round(
          0.5 * GameConstants.HEIGHT -
            0.5 * height +
            (this.rows + this.expansion) * (s + 2 * b + g) +
            b +
            5,
        );
        lines.forEach((line) => {
          nextY = this.textWrap(line, 5, nextY, GameConstants.WIDTH - 10);
        });
      }
    }
    if (this.isOpen) {
      this.drawUsingItem(delta, mainBgX + 1, mainBgY + 1, s, b, g);
    }

    this.drawDraggedItem(delta);
  };

  isPointInInventoryBounds = (
    x: number,
    y: number,
  ): { inBounds: boolean; startX: number; startY: number } => {
    const s = this.isOpen
      ? Math.min(18, (18 * (Date.now() - this.openTime)) / OPEN_TIME)
      : 18;
    const b = 2; // border
    const g = -2; // gap
    const hg = 3 + Math.round(0.5 * Math.sin(Date.now() * 0.01) + 0.5); // highlighted growth
    const ob = 1; // outer border
    const width = this.cols * (s + 2 * b + g) - g;

    let startX: number;
    let startY: number;
    let height: number;

    if (this.isOpen) {
      // Full inventory bounds
      height = (this.rows + this._expansion) * (s + 2 * b + g) - g;
      startX = Math.round(0.5 * GameConstants.WIDTH - 0.5 * width);
      startY = Math.round(0.5 * GameConstants.HEIGHT - 0.5 * height);
    } else {
      // Quickbar bounds
      height = s + 2 * b;
      startX = Math.round(0.5 * GameConstants.WIDTH - 0.5 * width);
      startY = Math.round(GameConstants.HEIGHT - height - 5);
    }

    const inBounds =
      x >= startX - ob &&
      x <= startX + width + ob &&
      y >= startY - ob &&
      y <= startY + height + ob;

    return {
      inBounds,
      startX,
      startY,
    };
  };
  isPointInQuickbarBounds = (
    x: number,
    y: number,
  ): { inBounds: boolean; startX: number; startY: number } => {
    const s = this.isOpen
      ? Math.min(18, (18 * (Date.now() - this.openTime)) / OPEN_TIME)
      : 18;
    const b = 2; // border
    const g = -2; // gap
    const width = this.cols * (s + 2 * b + g) - g;
    const startX = Math.round(0.5 * GameConstants.WIDTH - 0.5 * width);
    const startY = Math.round(GameConstants.HEIGHT - (s + 2 * b) - 5);
    const quickbarHeight = s + 2 * b;

    const inBounds =
      x >= startX &&
      x <= startX + width &&
      y >= startY &&
      y <= startY + quickbarHeight;

    return {
      inBounds,
      startX,
      startY,
    };
  };

  isPointInInventoryButton = (x: number, y: number): boolean => {
    const tX = x / GameConstants.TILESIZE;
    const tY = y / GameConstants.TILESIZE;
    return (
      tX >= this.buttonX &&
      tX <= this.buttonX + 1 &&
      tY >= this.buttonY &&
      tY <= this.buttonY + 1
    );
  };

  /**
   * Draws the inventory button to the canvas.
   * Added `ctx.save()` at the beginning and `ctx.restore()` at the end
   * to ensure canvas state is preserved.
   */
  drawInventoryButton = (delta: number) => {
    Game.ctx.save(); // Save the current canvas state
    this.buttonX = GameConstants.WIDTH / GameConstants.TILESIZE - 1.25;
    this.buttonY = GameConstants.HEIGHT / GameConstants.TILESIZE - 1.25;
    if (GameConstants.WIDTH < 145) {
      //this.buttonX -= 1;
      this.buttonY -= 1.25;
    }
    Game.drawFX(0, 0, 1, 1, this.buttonX, this.buttonY, 1, 1);

    Game.ctx.restore(); // Restore the canvas state
  };

  getQuickbarStartX = () => {
    const s = 18; // size of box
    const b = 2; // border
    const g = -2; // gap
    const width = Math.floor(this.cols * (s + 2 * b + g) - g);
    return Math.round(0.5 * GameConstants.WIDTH - 0.5 * width);
  };

  handleMouseDown = (x: number, y: number, button: number) => {
    // Ignore if not left click
    if (button !== 0) return;

    const bounds = this.isPointInInventoryBounds(x, y);
    if (bounds.inBounds) {
      const selectedItem = this.itemAtSelectedSlot();
      if (selectedItem !== null) {
        this._dragStartItem = selectedItem;
        this._dragStartSlot = this.selX + this.selY * this.cols;
      }
    }
  };

  /**
   * Unified method to initiate dragging.
   */
  initiateDrag = () => {
    if (this._dragStartItem === null || this._isDragging) {
      return;
    }

    this._isDragging = true;
    this.grabbedItem = this._dragStartItem;

    // Remove item from original slot
    if (this._dragStartSlot !== null) {
      this.items[this._dragStartSlot] = null;
    }
  };

  /**
   * Handle hold detection for both mouse and touch.
   */
  onHoldDetected = () => {
    this.initiateDrag();
  };

  /**
   * Continuously check for mouse hold during tick.
   */
  checkForDragStart = () => {
    if (Input.mouseDown && Input.isMouseHold) {
      this.initiateDrag();
    } else if (Input.isTapHold) {
      this.initiateDrag();
    }
  };

  handleMouseUp = (x: number, y: number, button: number) => {
    // Ignore if not left click
    if (button !== 0) return;

    const invBounds = this.isPointInInventoryBounds(x, y);
    const quickbarBounds = this.isPointInQuickbarBounds(x, y);
    const isValidDropZone = this.isOpen
      ? invBounds.inBounds
      : quickbarBounds.inBounds;

    if (isValidDropZone) {
      if (this._isDragging && this.grabbedItem !== null) {
        // We were dragging, place the item
        const targetSlot = this.selX + this.selY * this.cols;
        this.placeItemInSlot(targetSlot);
      } else if (this._dragStartItem !== null) {
        // We had an item but weren't dragging (quick click)
        this.itemUse();
      }
    } else if (this.grabbedItem !== null) {
      // Drop the item in the world
      this.dropItem(this.grabbedItem, this._dragStartSlot);

      this.grabbedItem = null;
      this.items[this._dragStartSlot] = null;
    }

    // Reset all drag/hold state
    this._isDragging = false;
    this._dragStartItem = null;
    this._dragStartSlot = null;
    this.grabbedItem = null;
  };

  placeItemInSlot = (targetSlot: number) => {
    if (this.grabbedItem === null) return;

    const existingItem = this.items[targetSlot];

    // If target slot is empty
    if (existingItem === null) {
      this.items[targetSlot] = this.grabbedItem;
    } else {
      // Swap items
      if (this._dragStartSlot !== null) {
        this.items[this._dragStartSlot] = existingItem;
      }
      this.items[targetSlot] = this.grabbedItem;
    }

    this.grabbedItem = null;
  };

  get expansion(): number {
    return this._expansion;
  }

  set expansion(value: number) {
    if (value !== this._expansion) {
      const oldTotalSlots = (this.rows + this._expansion) * this.cols;
      this._expansion = value;
      const newTotalSlots = (this.rows + this._expansion) * this.cols;

      // Resize items array
      if (newTotalSlots > oldTotalSlots) {
        this.items.push(...Array(newTotalSlots - oldTotalSlots).fill(null));
        this.equipAnimAmount.push(
          ...Array(newTotalSlots - oldTotalSlots).fill(0),
        );
      } else if (newTotalSlots < oldTotalSlots) {
        this.items.length = newTotalSlots;
        this.equipAnimAmount.length = newTotalSlots;
      }
    }
  }

  expandInventory(additionalRows: number) {
    this.expansion += additionalRows;
  }
}


--- src/item/armor.ts ---
import { Game } from "../game";
import { LevelConstants } from "../levelConstants";
import { Room } from "../room";
import { Equippable } from "./equippable";

export class Armor extends Equippable {
  health: number;
  rechargeTurnCounter: number;
  readonly RECHARGE_TURNS = 25;
  static itemName = "armor";

  constructor(level: Room, x: number, y: number) {
    super(level, x, y);
    this.health = 1;
    this.rechargeTurnCounter = -1;
    this.tileX = 5;
    this.tileY = 0;
  }

  coEquippable = (other: Equippable): boolean => {
    if (other instanceof Armor) return false;
    return true;
  };

  getDescription = (): string => {
    return (
      "ENCHANTED ARMOR\nA magic suit of armor. Absorbs one hit and regenerates after " +
      this.RECHARGE_TURNS +
      " turns."
    );
  };

  tickInInventory = () => {
    if (this.rechargeTurnCounter > 0) {
      this.rechargeTurnCounter--;
      if (this.rechargeTurnCounter === 0) {
        this.rechargeTurnCounter = -1;
        this.health = 1;
      }
    }
  };

  hurt = (damage: number) => {
    if (this.health <= 0) return;
    this.health -= Math.max(damage, 1);
    this.rechargeTurnCounter = this.RECHARGE_TURNS + 1;
  };

  drawGUI = (delta: number, playerHealth: number) => {
    if (this.rechargeTurnCounter === -1)
      Game.drawFX(
        5,
        2,
        0.75,
        0.75,
        playerHealth * 0.75 + 0.1,
        LevelConstants.SCREEN_H - 1,
        0.75,
        0.75,
      );
    else {
      let rechargeProportion =
        1 - this.rechargeTurnCounter / this.RECHARGE_TURNS;

      if (rechargeProportion < 0.5)
        Game.drawFX(
          7,
          2,
          0.75,
          0.75,
          playerHealth * 0.75 + 0.1,
          LevelConstants.SCREEN_H - 1,
          0.75,
          0.75,
        );
      else
        Game.drawFX(
          8,
          2,
          0.75,
          0.75,
          playerHealth * 0.75 + 0.1,
          LevelConstants.SCREEN_H - 1,
          0.75,
          0.75,
        );
    }
  };
}


--- src/item/backpack.ts ---
import { Item } from "./item";
import { Player } from "../player";
import { Game } from "../game";
import { Sound } from "../sound";
import { Room } from "../room";
import { Usable } from "./usable";
import { Inventory } from "../inventory";

export class Backpack extends Usable {
  static itemName = "backpack";

  constructor(level: Room, x: number, y: number) {
    super(level, x, y);

    this.tileX = 4;
    this.tileY = 0;
    this.offsetY = 0;
  }

  onUse = (player: Player) => {
    if (this.level.game.rooms[player.levelID] === this.level.game.room)
      Sound.heal();
    player.inventory.removeItem(this);
    player.inventory.expansion += 1;
    this.level.game.pushMessage(
      "You equip the backpack, increasing the amount you can carry.",
    );
    //this.level.items = this.level.items.filter((x) => x !== this); // removes itself from the level
  };
  getDescription = () => {
    return "BACKPACK\nA normal looking backpack. Increases the amount you can carry. ";
  };
}


--- src/item/bluegem.ts ---
import { Item } from "./item";
import { Player } from "../player";
import { Game } from "../game";
import { Room } from "../room";
import { TextParticle } from "../particle/textParticle";
import { GameConstants } from "../gameConstants";

export class BlueGem extends Item {
  static itemName = "zircon";

  constructor(level: Room, x: number, y: number) {
    super(level, x, y);

    this.tileX = 13;
    this.tileY = 0;

    this.stackable = true;
  }

  getDescription = (): string => {
    return "ZIRCON";
  };
}


--- src/item/bombItem.ts ---
import { Item } from "./item";
import { Player } from "../player";
import { Game } from "../game";
import { Sound } from "../sound";
import { Room } from "../room";
import { Usable } from "./usable";
//import { Bomb } from "../entity/object/bomb";

export class BombItem extends Usable {
  static itemName = "bomb";

  constructor(level: Room, x: number, y: number) {
    super(level, x, y);
    this.tileX = 20;
    this.tileY = 2;
    this.offsetY = -0.3;
    this.name = BombItem.itemName;
    this.description = "explodes";
  }

  onUse = (player: Player) => {
    const { Bomb } = require("../entity/object/bomb");
    Bomb.add(player.game.room, player.game, player.x, player.y);
    player.inventory.removeItem(this);
    Sound.mine();
  };
}


--- src/item/candle.ts ---
import { Item } from "./item";
import { Game } from "../game";
import { Room } from "../room";
import { Equippable } from "./equippable";
import { Torch } from "./torch";
import { Lantern } from "./lantern";
import { Inventory } from "../inventory";
import { Player } from "../player";
import { Light } from "./light";

export class Candle extends Light {
  static itemName = "candle";
  constructor(level: Room, x: number, y: number) {
    super(level, x, y);
    this.fuel = 50; //how many turns before it burns out
    this.tileX = 27;
    this.tileY = 0;
    this.name = "candle";
    this.fuelCap = 50;
    this.radius = 4;
    this.stackable = true;
    this.maxBrightness = 2;
    this.maxBrightness = 0.25;
  }
}


--- src/item/coal.ts ---
import { Item } from "./item";
import { Player } from "../player";
import { Game } from "../game";
import { Room } from "../room";
import { TextParticle } from "../particle/textParticle";
import { GameConstants } from "../gameConstants";
import { Usable } from "./usable";
import { Lantern } from "./lantern";
import { Light } from "./light";

export class Coal extends Usable {
  static itemName = "coal";
  constructor(level: Room, x: number, y: number) {
    super(level, x, y);

    this.tileX = 17;
    this.tileY = 0;
    this.stackable = true;
    this.stackCount = Math.ceil(Random.rand() * 7 + 3);
    this.name = Coal.itemName;
    this.description = "A piece of coal. Fuels lantern.";
    this.canUseOnOther = true;
  }
  onUse = (player: Player) => {
    let l = player.inventory.hasItem(Lantern);
    if (l instanceof Lantern) {
      if (l.fuel <= l.fuelCap - 50) {
        player.game.pushMessage("You add some fuel to your lantern.");
        this.stackCount -= 1;
        if (this.stackCount <= 0) {
          player.inventory.removeItem(this);
        }
      }
    }
  };

  useOnOther = (player: Player, other: Item) => {
    if (other instanceof Light) {
      if (other.canRefuel && other.fuel <= 0 && other.broken) {
        let amountToRefuel = Math.min(this.stackCount * 25, other.fuelCap);
        other.fuel += amountToRefuel;
        this.stackCount -= amountToRefuel / 25;
        other.broken = false;
        this.level.game.pushMessage(
          `You add refuel your ${other.name} with ${amountToRefuel / 25} coal.`,
        );

        if (this.stackCount <= 0) player.inventory.removeItem(this);
      }
    }
  };
}


--- src/item/coin.ts ---
import { Item } from "./item";
import { Game } from "../game";
import { Room } from "../room";
import { Sound } from "../sound";

export class Coin extends Item {
  stack: number;
  static itemName = "coin";
  //checked: boolean;
  constructor(level: Room, x: number, y: number) {
    super(level, x, y);

    this.tileX = 19;
    this.tileY = 0;
    this.stack = 1;
    this.stackable = true;
    this.name = Coin.itemName;
  }
  onDrop = () => {
    const coinList = []; //array to store coin objects
    for (const item of this.level.items) {
      if (item instanceof Coin) coinList.push(item);
    }
    for (const otherCoin of coinList) {
      if (
        this !== otherCoin &&
        this.x === otherCoin.x &&
        this.y === otherCoin.y
      ) {
        this.stack += otherCoin.stack;
        this.level.items = this.level.items.filter((x) => x !== otherCoin);
      }
      if (this.stack === 2) this.tileX = 20;
      else if (this.stack >= 3) this.tileX = 21;
    }
  };
  get distanceToBottomRight() {
    return Math.sqrt(
      (this.x + this.w - window.innerWidth) ** 2 +
        (this.y + this.h - window.innerHeight) ** 2,
    );
  }

  pickupSound = () => {
    if (this.level === this.level.game.room) Sound.pickupCoin();
  };
}


--- src/item/dropTable.ts ---
import { Entity } from "../entity/entity";
import { Armor } from "./armor";
import { BlueGem } from "./bluegem";
import { Candle } from "./candle";
import { Coin } from "./coin";
import { GreenGem } from "./greengem";
import { Heart } from "./heart";
import { Item } from "./item";
import { RedGem } from "./redgem";
import { WeaponFragments } from "./weaponFragments";
import { Spear } from "../weapon/spear";
import { Warhammer } from "../weapon/warhammer";
import { DualDagger } from "../weapon/dualdagger";
import { WeaponPoison } from "./weaponPoison";
import { WeaponBlood } from "./weaponBlood";
import { Gold } from "./gold";
import { Stone } from "./stone";
import { Pickaxe } from "../weapon/pickaxe";
import { Hammer } from "./hammer";
import { Coal } from "./coal";
import { Torch } from "./torch";
import { Lantern } from "./lantern";
import { Spellbook } from "../weapon/spellbook";
import { SpellbookPage } from "./spellbookPage";
import { Backpack } from "./backpack";
import { BombItem } from "./bombItem";

interface Drop {
  itemType: string;
  dropWeight: number;
  category: string[];
  minDepth?: number;
}

export const ItemTypeMap: { [key: string]: typeof Item } = {
  dualdagger: DualDagger,
  warhammer: Warhammer,
  spear: Spear,
  spellbook: Spellbook,

  armor: Armor,

  pickaxe: Pickaxe,
  hammer: Hammer,

  heart: Heart,
  weaponpoison: WeaponPoison,
  weaponblood: WeaponBlood,

  coin: Coin,

  weaponfragments: WeaponFragments,
  spellbookPage: SpellbookPage,

  backpack: Backpack,

  candle: Candle,
  torch: Torch,
  lantern: Lantern,

  redgem: RedGem,
  bluegem: BlueGem,
  greengem: GreenGem,
  gold: Gold,
  stone: Stone,
  coal: Coal,
  bomb: BombItem,
};

export class DropTable {
  static drops: Drop[] = [
    // Weapons
    { itemType: "dualdagger", dropWeight: 1, category: ["weapon", "melee"] },
    { itemType: "warhammer", dropWeight: 2, category: ["weapon", "melee"] },
    { itemType: "spear", dropWeight: 5, category: ["weapon", "melee"] },
    { itemType: "spellbook", dropWeight: 1, category: ["weapon", "magic"] },

    // Equipment
    { itemType: "armor", dropWeight: 8, category: ["equipment"] },

    // Tools
    { itemType: "pickaxe", dropWeight: 3, category: ["tool"] },
    { itemType: "hammer", dropWeight: 3, category: ["tool"] },

    // Consumables
    { itemType: "heart", dropWeight: 5, category: ["consumable"] },
    { itemType: "weaponpoison", dropWeight: 1, category: ["consumable"] },
    { itemType: "weaponblood", dropWeight: 1, category: ["consumable"] },

    { itemType: "coin", dropWeight: 100, category: ["coin"] },

    {
      itemType: "weaponfragments",
      dropWeight: 5,
      category: ["consumable", "melee"],
    },
    {
      itemType: "spellbookPage",
      dropWeight: 2,
      category: ["consumable", "magic"],
    },

    // Upgrades
    { itemType: "backpack", dropWeight: 5, category: ["upgrade"] },

    // Light sources
    { itemType: "candle", dropWeight: 10, category: ["light"] },
    { itemType: "torch", dropWeight: 5, category: ["light"] },
    { itemType: "lantern", dropWeight: 2, category: ["light"] },

    // Gems and minerals
    { itemType: "redgem", dropWeight: 5, category: ["gem", "resource"] },
    { itemType: "bluegem", dropWeight: 5, category: ["gem", "resource"] },
    { itemType: "greengem", dropWeight: 5, category: ["gem", "resource"] },
    { itemType: "gold", dropWeight: 5, category: ["gem", "resource"] },
    { itemType: "stone", dropWeight: 5, category: ["gem", "resource"] },
    {
      itemType: "coal",
      dropWeight: 15,
      category: ["fuel", "lantern", "resource"],
    },
    { itemType: "bomb", dropWeight: 10, category: ["bomb", "weapon"] },
  ];

  static getDrop = (
    entity: Entity,
    uniqueTable: boolean = false,
    useCategory: string[] = ["coin"],
    force: boolean = false,
    currentDepth: number = 0,
  ) => {
    let filteredDropsByCategory: Drop[] = [];
    let filteredDropsByItem: Drop[] = [];
    let filteredDropsByDepth: Drop[] = [];

    const allCategories = Array.from(
      new Set(this.drops.flatMap((drop) => drop.category)),
    );
    const allItemTypes = Object.keys(ItemTypeMap);

    const allDepth = this.drops.map((drop) => drop.minDepth);

    // Separate categories and specific item names from useCategory
    const categories = useCategory.filter((cat) => allCategories.includes(cat));
    const specificItems = useCategory.filter((item) =>
      allItemTypes.includes(item),
    );
    const itemsByDepth = this.drops.filter(
      (drop) => drop.minDepth === undefined || drop.minDepth <= currentDepth,
    );

    // Get drops from specified categories
    if (categories.length > 0) {
      filteredDropsByCategory = itemsByDepth.filter((drop) =>
        drop.category.some((cat) => categories.includes(cat)),
      );
    }

    // Get specific drops by item name
    if (specificItems.length > 0) {
      filteredDropsByItem = itemsByDepth.filter((drop) =>
        specificItems.includes(drop.itemType),
      );
    }

    // Combine and remove duplicates
    const combinedDropsMap: { [key: string]: Drop } = {};

    filteredDropsByCategory.forEach((drop) => {
      combinedDropsMap[drop.itemType] = drop;
    });

    filteredDropsByItem.forEach((drop) => {
      combinedDropsMap[drop.itemType] = drop;
    });

    let combinedDrops = Object.values(combinedDropsMap);

    // If no categories or specific items matched, use items by depth
    if (combinedDrops.length === 0) {
      combinedDrops = itemsByDepth;
    }

    if (combinedDrops.length === 0) {
      if (force) {
        combinedDrops = itemsByDepth;
        if (combinedDrops.length === 0) return null;
      } else return null;
    }

    const totalWeight = combinedDrops.reduce(
      (acc, drop) => acc + drop.dropWeight,
      0,
    );

    const randomWeight = Math.floor(Random.rand() * totalWeight);

    let cumulativeWeight = 0;
    for (const drop of combinedDrops) {
      cumulativeWeight += drop.dropWeight;

      if (randomWeight <= cumulativeWeight) {
        this.addNewItem(drop.itemType, entity);
        return;
      }
    }

    if (force && combinedDrops.length > 0) {
      this.addNewItem(combinedDrops[0].itemType, entity);
      return;
    }

    return null;
  };

  static addNewItem = (itemType: string, entity: Entity): void => {
    const ItemClass = ItemTypeMap[itemType];
    if (!ItemClass) {
      console.error(`Item type "${itemType}" is not recognized.`);
      return;
    }
    entity.drop = ItemClass.add(entity.room, entity.x, entity.y);
    //console.log(
    //  `Drop for ${entity.constructor.name}:`,
    //  entity.drop.constructor.name,
    //);
  };
}


--- src/item/equippable.ts ---
import { Item } from "./item";
import { Game } from "../game";
import { Room } from "../room";
import { Player } from "../player";

export class Equippable extends Item {
  wielder: Player;
  equipped: boolean;
  equipTick: boolean = false;

  constructor(level: Room, x: number, y: number) {
    super(level, x, y);
    this.equipped = false;
  }

  setWielder = (wielder: Player) => {
    this.wielder = wielder;
  };

  coEquippable = (other: Equippable): boolean => {
    return true;
  };

  toggleEquip = () => {
    this.equipped = !this.equipped;
    if (this.broken) {
      this.equipped = false;
      let pronoun = this.name.endsWith("s") ? "them" : "it";
      this.level.game.pushMessage(
        "You'll have to fix your " +
          this.name +
          " before you can use " +
          pronoun +
          ".",
      );
    }
  };

  drawEquipped = (delta: number, x: number, y: number) => {
    Game.drawItem(this.tileX, this.tileY, 1, 2, x, y - 1, this.w, this.h);
  };

  degrade = (degradeAmount: number = 1) => {
    this.durability -= degradeAmount;
    if (this.durability <= 0) this.break();
  };

  break = () => {
    this.durability = 0;
    this.broken = true;
    this.toggleEquip();
    //this.wielder.inventory.removeItem(this);
    //this.wielder = null;
  };

  onDrop = () => {};

  dropFromInventory = () => {
    this.wielder = null;
    this.equipped = false;
  };
}


--- src/item/godStone.ts ---
import { Item } from "./item";
import { Player } from "../player";
import { Game } from "../game";
import { Room, RoomType } from "../room";
import { TextParticle } from "../particle/textParticle";
import { GameConstants } from "../gameConstants";
import { Usable } from "./usable";
import { DownLadder } from "../tile/downLadder";

export class GodStone extends Usable {
  room: Room;
  count: number;
  constructor(level: Room, x: number, y: number) {
    super(level, x, y);
    this.room = level;
    this.count = 0;
    this.tileX = 31;
    this.tileY = 0;

    this.stackable = true;
  }
  onUse = (player: Player): void => {
    this.teleportToExit(player);
  };
  teleportToExit = (player: Player): void => {
    let downLadders = this.room.game.rooms.filter(
      (room) => room.type === RoomType.DOWNLADDER,
    );
    console.log("downLadders", downLadders);
    const room = downLadders[downLadders.length - 1];
    this.room.game.rooms.forEach((room) => {
      room.entered = true;
      room.calculateWallInfo();
    });
    room.game.changeLevelThroughDoor(player, room.doors[0], 1);
    player.x = room.roomX + 2;
    player.y = room.roomY + 3;
  };
  getDescription = (): string => {
    return "YOU SHOULD NOT HAVE THIS";
  };
}


--- src/item/gold.ts ---
import { Item } from "./item";
import { Player } from "../player";
import { Game } from "../game";
import { Room } from "../room";
import { TextParticle } from "../particle/textParticle";
import { GameConstants } from "../gameConstants";

export class Gold extends Item {
  static itemName = "gold";
  constructor(level: Room, x: number, y: number) {
    super(level, x, y);

    this.tileX = 18;
    this.tileY = 0;
    this.name = Gold.itemName;
    this.stackable = true;
    this.description = "A bar of gold";
  }
}


--- src/item/goldenKey.ts ---
import { Item } from "./item";
import { Equippable } from "./equippable";
import { Room } from "../room";

export class GoldenKey extends Equippable {
  static itemName = "goldenKey";
  constructor(level: Room, x: number, y: number) {
    super(level, x, y);

    this.tileX = 6;
    this.tileY = 0;
  }

  getDescription = (): string => {
    return "GOLD KEY\nA heavy gold key.";
  };
}


--- src/item/greengem.ts ---
import { Item } from "./item";
import { Player } from "../player";
import { Game } from "../game";
import { Room } from "../room";
import { TextParticle } from "../particle/textParticle";
import { GameConstants } from "../gameConstants";

export class GreenGem extends Item {
  static itemName = "peridot";
  constructor(level: Room, x: number, y: number) {
    super(level, x, y);

    this.tileX = 11;
    this.tileY = 0;

    this.stackable = true;
  }

  getDescription = (): string => {
    return "PERIDOT";
  };
}


--- src/item/hammer.ts ---
import { Item } from "./item";
import { Player } from "../player";
import { Game } from "../game";
import { Sound } from "../sound";
import { Room } from "../room";
import { Usable } from "./usable";
import { Weapon } from "../weapon/weapon";
import { Dagger } from "../weapon/dagger";
import { WeaponFragments } from "./weaponFragments";

export class Hammer extends Usable {
  static itemName = "hammer";
  constructor(level: Room, x: number, y: number) {
    super(level, x, y);
    this.tileX = 21;
    this.tileY = 2;
    this.offsetY = -0.3;
    this.canUseOnOther = true;
    this.description = "useful for breaking weapons down into fragments";
    this.name = Hammer.itemName;
  }

  onUse = (player: Player) => {
    player.health = Math.min(player.maxHealth, player.health + 1);
    if (this.level.game.rooms[player.levelID] === this.level.game.room)
      Sound.heal();

    //this.level.items = this.level.items.filter((x) => x !== this); // removes itself from the level
  };

  useOnOther = (player: Player, other: Item) => {
    if (other instanceof Weapon && other.name !== "dagger") {
      other.disassemble();
    } else if (other.name === "dagger") {
      this.level.game.pushMessage(
        `You probably shouldn't disassemble your dagger...`,
      );
    } else if (other.name === "hammer" && other !== this) {
      let hammer = other as Hammer;
      hammer.disassemble(player);
      this.level.game.pushMessage(`I only needed one of those anyways...`);
    }
  };

  disassemble = (player: Player) => {
    let inventoryX = this.x;
    let inventoryY = this.y;
    let numFragments = Math.ceil(Random.rand() * 5 + 5);
    player.inventory.removeItem(this);
    player.inventory.addItem(
      new WeaponFragments(this.level, inventoryX, inventoryY, numFragments),
    );
  };
}


--- src/item/heart.ts ---
import { Item } from "./item";
import { Player } from "../player";
import { Game } from "../game";
import { Sound } from "../sound";
import { Room } from "../room";
import { Usable } from "./usable";

export class Heart extends Usable {
  static itemName = "health potion";

  constructor(level: Room, x: number, y: number) {
    super(level, x, y);
    this.tileX = 8;
    this.tileY = 0;
    this.offsetY = -0.3;
    this.name = Heart.itemName;
    this.description = "restores 1 health";
  }

  onUse = (player: Player) => {
    if (player.health < player.maxHealth) {
      player.health = Math.min(player.maxHealth, player.health + 1);
      if (this.level.game.rooms[player.levelID] === this.level.game.room)
        Sound.heal();
      player.inventory.removeItem(this);
    }

    //this.level.items = this.level.items.filter((x) => x !== this); // removes itself from the level
  };
}


--- src/item/item.ts ---
import { Game } from "../game";
import { GameConstants } from "../gameConstants";
import { Player } from "../player";
import { Room } from "../room";
import { Sound } from "../sound";
import { Drawable } from "../drawable";
import { Utils } from "../utils";

// Item class extends Drawable class and represents an item in the game
export class Item extends Drawable {
  // Item properties
  x: number; // x-coordinate of the item
  y: number; // y-coordinate of the item
  w: number; // width of the item
  h: number; // height of the item
  offsetY: number; // offset of the item on the y-axis
  tileX: number; // x-coordinate of the tile where the item is located
  tileY: number; // y-coordinate of the tile where the item is located
  frame: number; // frame number for animation
  level: Room; // level where the item is located
  stackable: boolean; // whether the item is stackable or not
  stackCount: number; // number of items in the stack
  pickedUp: boolean; // whether the item has been picked up or not
  alpha: number; // alpha value for transparency
  scaleFactor: number; // scale factor for size adjustment
  name: string;
  startY: number;
  randomOffset: number;
  durability: number;
  durabilityMax: number;
  broken: boolean;
  description: string;
  drawOffset: number;
  pickupOffsetY: number;
  static itemName: string;
  inChest: boolean;
  chestOffsetY: number;
  sineAnimateFactor: number;
  stack: number;

  // Constructor for the Item class
  constructor(level: Room, x: number, y: number) {
    super();

    // Initialize properties
    this.level = level;
    this.x = x;
    this.y = y;
    this.drawableY = y;
    this.w = 1;
    this.h = 2;
    this.tileX = 0;
    this.tileY = 0;
    this.frame = 0;
    this.stackable = false;
    this.stackCount = 1;
    this.pickedUp = false;
    this.alpha = 1;
    this.scaleFactor = 5;
    this.offsetY = -0.25;
    this.name = "";
    this.startY = y;
    this.randomOffset = Random.rand();
    this.durability = 50;
    this.durabilityMax = 50;
    this.broken = false;
    this.description = "";
    this.drawOffset = 0;
    this.pickupOffsetY = 1;
    this.chestOffsetY = 0;
    this.sineAnimateFactor = 1;
  }

  static add<
    T extends new (room: Room, x: number, y: number, ...rest: any[]) => Item,
  >(this: T, room: Room, x: number, y: number, ...rest: any[]) {
    return new this(room, x, y, ...rest);
  }

  // Empty tick function to be overridden by subclasses
  tick = () => {};
  // Empty tick function for inventory behavior to be overridden by subclasses
  tickInInventory = () => {};

  // Function to get description of the item, to be overridden by subclasses
  getDescription = (): string => {
    const stackText = this.stackable ? `\nAmount: ${this.stackCount}` : "";
    return `${this.name} \n${this.description} \n${stackText}`;
  };

  animateFromChest = () => {
    this.chestOffsetY = 0.5;
    this.alpha = 0;
    this.inChest = true;
    this.sineAnimateFactor = 0;
  };

  // Function to play sound when item is picked up
  pickupSound = () => {
    if (this.level === this.level.game.room) Sound.genericPickup();
  };

  // Empty function to be called when item is dropped, to be overridden by subclasses
  onDrop = () => {};
  // Function to be called when item is picked up
  onPickup = (player: Player) => {
    if (!this.pickedUp) {
      this.startY = player.y;

      this.drawableY = this.y;
      this.alpha = 1;
      this.pickedUp = player.inventory.addItem(this);
      if (this.pickedUp) this.pickupSound();
    }
  };

  dropFromInventory = () => {
    this.setDrawOffset();
  };

  // Function to get the amount of shade at the item's location
  shadeAmount = () => {
    if (!this.x || !this.y) return 0;
    else return this.level.softVis[this.x][this.y];
  };

  drawStatus = (x: number, y: number) => {};

  drawBrokenSymbol = (x: number, y: number) => {
    if (this.broken) {
      Game.drawFX(
        5,
        0,
        1,
        1,
        x - 0.5 / GameConstants.TILESIZE,
        y - 0.5 / GameConstants.TILESIZE,
        1,
        1,
      );
    }
  };

  // Function to draw the item
  draw = (delta: number) => {
    Game.ctx.save();
    if (!this.pickedUp) {
      Game.ctx.globalAlpha = this.alpha;
      if (this.alpha < 1) this.alpha += 0.01 * delta;
      this.drawableY = this.y;
      if (this.inChest) {
        this.chestOffsetY -= Math.abs(this.chestOffsetY + 0.5) * 0.035 * delta;

        if (this.chestOffsetY < -0.47) {
          this.chestOffsetY = -0.5;
        }
      }
      if (this.sineAnimateFactor < 1 && this.chestOffsetY < -0.45)
        this.sineAnimateFactor += 0.2 * delta;
      if (this.scaleFactor > 0) this.scaleFactor *= 0.5 ** delta;
      else this.scaleFactor = 0;
      const scale = 1 / (this.scaleFactor + 1);
      Game.ctx.imageSmoothingEnabled = false;

      Game.drawItem(0, 0, 1, 1, this.x, this.y, 1, 1);
      this.frame += (delta * (Math.PI * 2)) / 60;
      Game.drawItem(
        this.tileX,
        this.tileY,
        1,
        2,
        this.x + this.w * (scale * -0.5 + 0.5) + this.drawOffset,
        this.y +
          this.sineAnimateFactor * Math.sin(this.frame) * 0.07 -
          1 +
          this.offsetY +
          this.h * (scale * -0.5 + 0.5) +
          this.chestOffsetY,
        this.w * scale,
        this.h * scale,
        this.level.shadeColor,
        this.shadeAmount(),
      );
    }
    Game.ctx.restore();
  };

  setDrawOffset = () => {
    const itemsOnTile = this.level.items.filter(
      (item) => item.x === this.x && item.y === this.y,
    );
    if (itemsOnTile.length > 1) {
      itemsOnTile.forEach((item) => {
        item.drawOffset =
          (-itemsOnTile.length / 2 + itemsOnTile.indexOf(item) + 1) /
          itemsOnTile.length;
      });
    }
  };

  degrade = () => {
    this.durability -= 1;
  };

  // Function to draw the top layer of the item
  drawTopLayer = (delta: number) => {
    if (this.pickedUp) {
      this.pickupOffsetY += (4.5 - this.pickupOffsetY) * 0.1 * delta;

      //this.x += (Math.sin(Date.now() / 50) * delta) / 10;
      this.alpha *= 0.9 ** delta;
      if (Math.abs(this.alpha) < 0.01) {
        this.drawOffset = 0;
        this.pickupOffsetY = 1;

        this.level.items = this.level.items.filter((x) => x !== this);
      }

      if (GameConstants.ALPHA_ENABLED)
        Game.ctx.globalAlpha = Math.max(0, this.alpha);

      Game.drawItem(
        this.tileX,
        this.tileY,
        1,
        2,
        this.x,
        this.y - this.pickupOffsetY,
        this.w,
        this.h,
      );

      Game.ctx.globalAlpha = 1.0;
    }
  };
  // Function to draw the item's icon
  drawIcon = (delta: number, x: number, y: number, opacity = 1, count?) => {
    if (GameConstants.ALPHA_ENABLED) Game.ctx.globalAlpha = opacity;
    this.drawDurability(x, y);
    let shake = 0;
    if (this.durability <= 1 && !this.broken)
      shake =
        Math.round(Math.sin(Date.now() / 25) + 1 / 2) /
        2 /
        GameConstants.TILESIZE;

    Game.drawItem(
      this.tileX,
      this.tileY,
      1,
      2,
      x + shake,
      y - 1,
      this.w,
      this.h,
    );
    Game.ctx.globalAlpha = 1;

    let countToUse = count ? count : this.stackCount;
    let countText = countToUse <= 1 ? "" : "" + countToUse;
    let width = Game.measureText(countText).width;
    let countX = 16 - width;
    let countY = 10;

    Game.fillTextOutline(
      countText,
      x * GameConstants.TILESIZE + countX,
      y * GameConstants.TILESIZE + countY,
      GameConstants.OUTLINE,
      "white",
    );
    this.drawStatus(x, y);
    this.drawBrokenSymbol(x, y);
  };

  // Function to draw the item's durability bar with color transitioning from green to red
  drawDurability = (x: number, y: number) => {
    if (this.durability < this.durabilityMax) {
      // Calculate durability ratio (1 = full, 0 = broken)
      const durabilityRatio = this.durability / this.durabilityMax;

      // Map durability ratio to hue (120 = green, 0 = red)
      let color = Utils.hsvToHex(
        120 * durabilityRatio, // Hue from 120 (green) to 0 (red)
        1, // Full saturation
        1, // Full value
      );

      const iconWidth = GameConstants.TILESIZE;
      const barWidth = Math.ceil(durabilityRatio * iconWidth); // Round to nearest pixel
      const barHeight = 2; // 2 pixels tall

      // Calculate the position of the durability bar
      const barX = Math.ceil(x * GameConstants.TILESIZE); // Round to nearest pixel
      const barY = Math.ceil(
        y * GameConstants.TILESIZE + GameConstants.TILESIZE - 2,
      ); // Round to nearest pixel

      // Set the fill style for the durability bar
      Game.ctx.fillStyle = color;
      Game.ctx.imageSmoothingEnabled = false;

      // Draw the durability bar
      Game.ctx.fillRect(barX, barY, barWidth, barHeight);

      // Reset settings
      Game.ctx.fillStyle = "white";
    }
  };
}


--- src/item/key.ts ---
import { Item } from "./item";
import { Equippable } from "./equippable";
import { Room } from "../room";
import { Sound } from "../sound";
import { Player } from "../player";

export class Key extends Item {
  static itemName = "key";
  constructor(level: Room, x: number, y: number) {
    super(level, x, y);

    this.tileX = 1;
    this.tileY = 0;
  }

  getDescription = (): string => {
    return "KEY\nAn iron key.";
  };

  onPickup = (player: Player) => {
    if (!this.pickedUp) {
      this.pickedUp = player.inventory.addItem(this);
      if (this.pickedUp) Sound.keyPickup();
    }
  };
}


--- src/item/lantern.ts ---
import { Item } from "./item";
import { Game } from "../game";
import { Room } from "../room";
import { Equippable } from "./equippable";
import { Candle } from "./candle";
import { Torch } from "./torch";
import { Coal } from "./coal";
import { Light } from "./light";

export class Lantern extends Light {
  fuelCap: number;
  static itemName = "lantern";
  constructor(level: Room, x: number, y: number) {
    super(level, x, y);
    this.fuel = 0;
    this.tileX = 29;
    this.tileY = 0;
    this.fuelCap = 250;
    this.name = "lantern";
    this.canRefuel = true;
    this.maxBrightness = 20;
    this.minBrightness = 5;
    this.radius = 7;
    this.broken = this.fuel <= 0 ? true : false;
  }

  getDescription = () => {
    const percentage = Math.round((this.fuel / this.fuelCap) * 100);
    return `LANTERN - Fuel: ${percentage}%, Capacity: ${this.fuelCap / 50}`;
  };
}


--- src/item/light.ts ---
import { Game } from "../game";
import { Room } from "../room";
import { Equippable } from "./equippable";
import { GameConstants } from "../gameConstants";
import { Utils } from "../utils";

export abstract class Light extends Equippable {
  fuel: number;
  fuelCap: number;
  radius: number;
  maxBrightness: number;
  minBrightness: number;
  canRefuel: boolean = false;
  constructor(level: Room, x: number, y: number) {
    super(level, x, y);

    this.tileX = 28;
    this.tileY = 0;
    this.fuel = 0;
    this.fuelCap = 250;
    this.maxBrightness = 5;
    this.minBrightness = 2;
    this.radius = 6;
    this.equipped = false;
  }

  updateLighting = () => {
    this.wielder.game.rooms[this.wielder.levelID].updateLighting();
  };

  get fuelPercentage() {
    return this.fuel / this.fuelCap;
  }

  isIgnited = () => {
    if (this.fuel > 0 && this.equipped) {
      return true;
    }
    return false;
  };

  setRadius = () => {
    this.wielder.sightRadius = this.radius + this.fuelPercentage * this.radius;
  };

  setBrightness = () => {
    this.wielder.lightBrightness =
      this.minBrightness + this.fuelPercentage * this.maxBrightness;
  };

  toggleEquip = () => {
    if (this.fuel > 0) {
      this.equipped = !this.equipped;
      if (this.isIgnited()) {
        //this.setRadius();
        this.setBrightness();
        this.wielder.lightEquipped = true;
      } else {
        //this.resetRadius();
        this.resetBrightness();
        this.wielder.lightEquipped = false;
      }
    } else {
      this.wielder.game.pushMessage(
        "I'll need some fuel before I can use this",
      );
    }

    this.updateLighting();
  };

  coEquippable = (other: Light): boolean => {
    return !(other instanceof Light);
  };

  resetRadius = () => {
    this.wielder.sightRadius = this.wielder.defaultSightRadius;
  };

  resetBrightness = () => {
    this.wielder.lightBrightness = 0.5;
  };

  burn = () => {
    // Handle active burning
    if (this.isIgnited()) {
      this.fuel--;
      this.setRadius();
      this.setBrightness();
    }

    // Handle depleted fuel
    if (this.fuel <= 0) {
      if (this.stackable) {
        this.stackCount--;
        this.fuel = this.fuelCap;
      }

      // Check if item should be removed after stack reduction
      if (this.equipped) {
        if (
          (this.stackable && this.stackCount <= 0) ||
          (!this.stackable && !this.canRefuel)
        ) {
          this.resetRadius();
          this.wielder.lightEquipped = false;
          this.wielder.inventory.removeItem(this);
          this.wielder.game.pushMessage(`${this.name} depletes.`);
        } else if (this.canRefuel) {
          this.wielder.game.pushMessage(`${this.name} depletes.`);
          this.equipped = false;
          this.resetRadius();
          this.wielder.lightEquipped = false;
          this.broken = true;
        }

        this.updateLighting();
      }
    }
  };

  drawDurability = (x: number, y: number) => {
    if (this.fuel < this.fuelCap) {
      // Calculate durability ratio (1 = full, 0 = broken)
      const durabilityRatio = this.fuel / this.fuelCap;

      // Map durability ratio to hue (120 = green, 0 = red)
      let color = Utils.hsvToHex(
        120 * durabilityRatio, // Hue from 120 (green) to 0 (red)
        1, // Full saturation
        1, // Full value
      );

      const iconWidth = GameConstants.TILESIZE;
      const barWidth = durabilityRatio * iconWidth;
      const barHeight = 2; // 2 pixels tall

      // Calculate the position of the durability bar
      const barX = x * GameConstants.TILESIZE;
      const barY = y * GameConstants.TILESIZE + GameConstants.TILESIZE - 2;

      // Set the fill style for the durability bar
      Game.ctx.fillStyle = color;
      // Set the interpolation mode to nearest neighbor
      Game.ctx.imageSmoothingEnabled = false;

      // Draw the durability bar
      Game.ctx.fillRect(barX, barY, barWidth, barHeight);

      // Reset fill style to default
      Game.ctx.fillStyle = "white";
    }
  };

  tickInInventory = () => {
    this.burn();
  };

  getDescription = () => {
    return `${this.name}: ${Math.ceil(this.fuelPercentage * 100)}%`;
  };
}


--- src/item/redgem.ts ---
import { Item } from "./item";
import { Player } from "../player";
import { Game } from "../game";
import { Room } from "../room";
import { TextParticle } from "../particle/textParticle";
import { GameConstants } from "../gameConstants";

export class RedGem extends Item {
  static itemName = "garnet";
  constructor(level: Room, x: number, y: number) {
    super(level, x, y);

    this.tileX = 12;
    this.tileY = 0;

    this.stackable = true;
  }

  getDescription = (): string => {
    return "GARNET";
  };
}


--- src/item/spellbookPage.ts ---
import { Item } from "./item";
import { Player } from "../player";
import { Sound } from "../sound";
import { Room } from "../room";
import { Usable } from "./usable";
import { Equippable } from "./equippable";

export class SpellbookPage extends Usable {
  static itemName = "weapon fragments";
  constructor(level: Room, x: number, y: number, stackCount?: number) {
    super(level, x, y);
    this.tileX = 25;
    this.tileY = 2;
    this.offsetY = -0.3;
    this.name = "spellbook pages";
    this.canUseOnOther = true;
    this.stackable = true;
    this.stackCount = stackCount || Math.ceil(Random.rand() * 3);
    this.description = "Can be used to restore power to a depleted spellbook";
  }

  onUse = (player: Player) => {
    player.health = Math.min(player.maxHealth, player.health + 1);
    if (this.level.game.rooms[player.levelID] === this.level.game.room)
      Sound.heal();
    player.inventory.removeItem(this);

    //this.level.items = this.level.items.filter((x) => x !== this); // removes itself from the level
  };

  useOnOther = (player: Player, other: Item) => {
    if (
      other instanceof Equippable &&
      other.broken &&
      other.name === "spellbook"
    ) {
      let repairAmount = Math.min(
        other.durabilityMax - other.durability,
        this.stackCount,
      );
      other.durability += repairAmount;
      this.stackCount -= repairAmount;
      other.broken = false;
      this.level.game.pushMessage(
        `You feel your ${other.name}'s power return as you add ${repairAmount} pages to it.`,
      );
      if (this.stackCount <= 0) player.inventory.removeItem(this);
    }
  };
}


--- src/item/stone.ts ---
import { Item } from "./item";
import { Player } from "../player";
import { Game } from "../game";
import { Room } from "../room";
import { TextParticle } from "../particle/textParticle";
import { GameConstants } from "../gameConstants";

export class Stone extends Item {
  static itemName = "stones";
  constructor(level: Room, x: number, y: number) {
    super(level, x, y);

    this.tileX = 15;
    this.tileY = 0;

    this.stackable = true;
  }

  getDescription = (): string => {
    return "STONE\nSome fragments of stone.";
  };
}


--- src/item/torch.ts ---
import { Room } from "../room";

import { Light } from "./light";

export class Torch extends Light {
  static itemName = "torch";
  constructor(level: Room, x: number, y: number) {
    super(level, x, y);

    this.tileX = 28;
    this.tileY = 0;
    this.name = "torch";
    this.fuelCap = 250;
    this.fuel = 250;
    this.radius = 7;
    this.maxBrightness = 5;
    this.minBrightness = 2;
  }
}


--- src/item/usable.ts ---
import { Item } from "./item";
import { Player } from "../player";
import { Game } from "../game";
import { Sound } from "../sound";
import { Room } from "../room";

export class Usable extends Item {
  user: Player;
  canUseOnOther: boolean;
  constructor(level: Room, x: number, y: number) {
    super(level, x, y);
    this.canUseOnOther = false;
  }
  onUse = (player: Player) => {};
  useOnOther = (player: Player, other: Item) => {};
}


--- src/item/weaponBlood.ts ---
import { Item } from "./item";
import { Player } from "../player";
import { Game } from "../game";
import { Sound } from "../sound";
import { Room } from "../room";
import { Usable } from "./usable";
import { Weapon } from "../weapon/weapon";

export class WeaponBlood extends Usable {
  static itemName = "cursed blood";
  constructor(level: Room, x: number, y: number) {
    super(level, x, y);
    this.tileX = 12;
    this.tileY = 4;
    this.offsetY = -0.3;
    this.canUseOnOther = true;
  }

  onUse = (player: Player) => {
    player.health = Math.min(player.maxHealth, player.health + 1);
    if (this.level.game.rooms[player.levelID] === this.level.game.room)
      Sound.heal();

    //this.level.items = this.level.items.filter((x) => x !== this); // removes itself from the level
  };

  useOnOther = (player: Player, other: Item) => {
    if (other instanceof Weapon) {
      other.applyStatus({ blood: true, poison: false });
      player.inventory.removeItem(this);
      this.level.game.pushMessage(
        `You coat your ${other.name} in cursed blood.`,
      );
    }
  };

  getDescription = () => {
    return "WEAPON BLOOD\nCan be applied to weapons to deal bleed damage";
  };
}


--- src/item/weaponFragments.ts ---
import { Item } from "./item";
import { Player } from "../player";
import { Sound } from "../sound";
import { Room } from "../room";
import { Usable } from "./usable";
import { Equippable } from "./equippable";

export class WeaponFragments extends Usable {
  static itemName = "weapon fragments";
  constructor(level: Room, x: number, y: number, stackCount?: number) {
    super(level, x, y);
    this.tileX = 3;
    this.tileY = 0;
    this.offsetY = -0.3;
    this.name = "weapon fragments";
    this.canUseOnOther = true;
    this.stackable = true;
    this.stackCount = stackCount || Math.ceil(Random.rand() * 10) + 7;
    this.description = "Can be used to repair broken weapons";
  }

  onUse = (player: Player) => {
    player.health = Math.min(player.maxHealth, player.health + 1);
    if (this.level.game.rooms[player.levelID] === this.level.game.room)
      Sound.heal();
    player.inventory.removeItem(this);

    //this.level.items = this.level.items.filter((x) => x !== this); // removes itself from the level
  };

  useOnOther = (player: Player, other: Item) => {
    if (
      other instanceof Equippable &&
      other.durabilityMax - other.durability >= 1 &&
      other.name !== "spellbook"
    ) {
      let repairAmount = Math.min(
        other.durabilityMax - other.durability,
        this.stackCount,
      );
      other.durability += repairAmount;
      this.stackCount -= repairAmount;
      other.broken = false;
      this.level.game.pushMessage(
        `You repair your ${other.name} with ${repairAmount} fragments.`,
      );
      if (this.stackCount <= 0) player.inventory.removeItem(this);
    } else if (other.name === "spellbook") {
      this.level.game.pushMessage(
        "You'll need some book pages to replenish that.",
      );
    }
  };
}


--- src/item/weaponPoison.ts ---
import { Item } from "./item";
import { Player } from "../player";
import { Sound } from "../sound";
import { Room } from "../room";
import { Usable } from "./usable";
import { Weapon } from "../weapon/weapon";

export class WeaponPoison extends Usable {
  static itemName = "weapon poison";
  constructor(level: Room, x: number, y: number) {
    super(level, x, y);
    this.tileX = 11;
    this.tileY = 4;
    this.offsetY = -0.3;
    this.canUseOnOther = true;
  }

  onUse = (player: Player) => {
    player.health = Math.min(player.maxHealth, player.health + 1);
    if (this.level.game.rooms[player.levelID] === this.level.game.room)
      Sound.heal();

    //this.level.items = this.level.items.filter((x) => x !== this); // removes itself from the level
  };

  useOnOther = (player: Player, other: Item) => {
    if (other instanceof Weapon) {
      other.applyStatus({ poison: true, blood: false });
      player.inventory.removeItem(this);
      this.level.game.pushMessage(
        `You apply the poison to your ${other.name}.`,
      );
      console.log(`weapon poison used on ${other.name}`);
    }
  };

  getDescription = () => {
    return "WEAPON POISON\nCan be applied to weapons to deal poison damage";
  };
}


--- src/level.ts ---
import { Room, RoomType } from "./room";
import { Game } from "./game";
import { Entity, EntityType } from "./entity/entity";
import { Item } from "./item/item";
import { DoorType } from "./tile/door";
import { Tile } from "./tile/tile";
import { Enemy } from "./entity/enemy/enemy";
import { LevelParameterGenerator } from "./levelParametersGenerator";
import { Environment } from "./environment";

export interface EnemyParameters {
  enemyTables: Record<number, number[]>;
  maxDepthTable: number;
  minDepths: Record<number, number>;
}

export const enemyMinimumDepth: Record<number, number> = {
  1: 0, // CrabEnemy
  2: 1, // FrogEnemy
  3: 0, // ZombieEnemy
  4: 0, // SkullEnemy
  5: 1, // EnergyWizardEnemy
  6: 2, // ChargeEnemy
  7: 1, // RookEnemy
  8: 1, // BishopEnemy
  9: 1, // ArmoredzombieEnemy
  10: 2, // BigSkullEnemy
  11: 2, // QueenEnemy
  12: 1, // KnightEnemy
  13: 2, // BigKnightEnemy
  14: 2, // FireWizardEnemy
  15: 2, // ArmoredSkullEnemy
};
/*
interface enemySpawnPoolData {
  maxCount: number;
  minCount: number;
}

interface environmentData {
  name: string;
  preferredEnemies: Array<Enemy>;
  preferredEntities: Array<Entity>;
  entityBlacklist: Array<Entity>;
  enemySpawnPoolData: enemySpawnPoolData;
  roomData: roomData;
}

interface entitySpawnData {
  enemy: Enemy;
  spawnChance: number;
  maximumCount: number;
}
*/

export class Level {
  depth: number;
  levelArray: (Tile | null)[][];
  width: number;
  height: number;
  game: Game;
  rooms: Room[];
  environment: Environment;
  exitRoom: Room;
  startRoom: Room;
  //environmentData: environmentData;
  //enemySpawnPool: Array<entitySpawnData>;
  enemyParameters: EnemyParameters;
  constructor(game: Game, depth: number, width: number, height: number) {
    this.game = game;
    this.depth = depth;
    this.width = width;
    this.height = height;
    this.rooms = [];
    this.initializeLevelArray();
    //this.loadRoomsIntoLevelArray();
    //console.log(`level depth: ${this.depth}`);

    this.enemyParameters = this.getEnemyParameters();
    let envType = Math.floor(Random.rand() * 3); //multiply by number of environments to choose from
    this.environment = new Environment(envType);
  }

  setExitRoom() {
    this.exitRoom = this.rooms.find(
      (room) => room.type === RoomType.DOWNLADDER,
    );
  }

  setStartRoom() {
    this.startRoom = this.rooms.find((room) => room.type === RoomType.START);
  }

  setRooms(rooms: Room[]) {
    this.rooms = rooms;
    this.setExitRoom();
    this.setStartRoom();
    this.rooms.filter((room) => room.depth === this.depth);
    rooms.forEach((room) => {
      room.id = this.rooms.indexOf(room);
    });
  }

  initializeLevelArray = () => {
    // Create a 300x300 grid for depth 0
    this.levelArray = [];
    for (let x = 0; x < this.width; x++) {
      this.levelArray[x] = [];
      for (let y = 0; y < this.height; y++) {
        this.levelArray[x][y] = null;
      }
    }
  };

  loadRoomsIntoLevelArray = () => {
    for (let room of this.rooms) {
      for (let x = room.roomX; x < room.roomX + room.width; x++) {
        for (let y = room.roomY; y < room.roomY + room.height; y++) {
          this.levelArray[x][y] = room.roomArray[x][y];
        }
      }
    }
  };

  /**
   * Generates enemy parameters based on the current depth.
   * @param depth The current depth level.
   * @returns An object conforming to the EnemyParameters interface.
   */
  getEnemyParameters(): EnemyParameters {
    let currentDepth = this.depth;
    // Generate the enemy pool based on current depth
    const enemyPoolIds = this.generateEnemyPoolIds(currentDepth);

    // Create enemyTables where each level maps to the enemyPoolIds
    const enemyTables: Record<number, number[]> = {};

    for (let tableDepth = 0; tableDepth <= currentDepth; tableDepth++) {
      // Assign the same pool for all tables up to current depth
      enemyTables[tableDepth] = enemyPoolIds;
    }
    const newEnemies = enemyTables[currentDepth].filter(
      (id) => !this.game.encounteredEnemies.includes(id),
    );
    this.game.encounteredEnemies.push(...newEnemies);
    //console.log(
    //`encounteredEnemies for depth ${this.depth}: ${this.game.encounteredEnemies}`,
    //);

    return {
      enemyTables,
      maxDepthTable: currentDepth,
      minDepths: enemyMinimumDepth,
    };
  }

  /**
   * Generates the enemy pool IDs based on the current depth, introducing up to 2 new enemies each level.
   * @param depth The current depth level.
   * @returns An array of selected enemy IDs.
   */
  generateEnemyPoolIds(depth: number): number[] {
    const availableEnemies = Object.entries(enemyMinimumDepth)
      .filter(([enemyId, minDepth]) => depth >= minDepth)
      .map(([enemyId]) => Number(enemyId));

    // Determine which enemies are new (not yet encountered)
    const newEnemies = availableEnemies.filter(
      (id) => !this.game.encounteredEnemies.includes(id),
    );

    // Decide how many new enemies to introduce (1 or 2)
    const newEnemiesToAddCount = Math.min(newEnemies.length, 2);
    const newEnemiesToAdd = this.getRandomElements(
      newEnemies,
      newEnemiesToAddCount,
    );

    // Add the new enemies to encounteredEnemies
    this.game.encounteredEnemies.push(...newEnemiesToAdd);

    // Log the newly added enemies for debugging
    // console.log(`New enemies introduced at depth ${depth}: ${newEnemiesToAdd}`);

    // Combine encountered enemies to form the enemy pool
    const enemyPoolIds = this.game.encounteredEnemies.slice();

    // Determine the number of enemy types for the current depth
    const numberOfTypes = this.getNumberOfEnemyTypes(depth);

    // Select the final set of enemy IDs for the pool
    const selectedEnemyIds = this.getRandomElements(
      enemyPoolIds,
      numberOfTypes,
    );

    // Ensure uniqueness and limit based on available enemies
    return Array.from(new Set(selectedEnemyIds)).slice(0, numberOfTypes);
  }

  /**
   * Determines the number of enemy types allowed based on the current depth.
   * @param depth The current depth level.
   * @returns The number of enemy types.
   */
  getNumberOfEnemyTypes(depth: number): number {
    // Example logic: depth 0 -> 2 types, depth 1 -> 4, depth 2 -> 6, etc.
    let numberOfTypes = depth === 0 ? 2 : Math.ceil(Math.sqrt(depth + 1)) + 4;
    //console.log(`numberOfTypes: ${numberOfTypes}`);
    return numberOfTypes;
  }

  /**
   * Utility function to get random elements from an array.
   * @param array The array to select from.
   * @param count The number of elements to select.
   * @returns An array of randomly selected elements.
   */
  getRandomElements<T>(array: T[], count: number): T[] {
    const shuffled = [...array];
    for (let i = shuffled.length - 1; i > 0; i--) {
      const j = Math.floor(Random.rand() * (i + 1));
      [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
    }
    return shuffled.slice(0, Math.min(count, shuffled.length));
  }
}


--- src/levelConstants.ts ---
import { GameConstants } from "./gameConstants";

export class LevelConstants {
  static SCREEN_W = 1;
  static SCREEN_H = 1;

  static readonly COMPUTER_TURN_DELAY = 300; // milliseconds
  static readonly TURN_TIME = 3000; // milliseconds
  static readonly LEVEL_TRANSITION_TIME = 300; // milliseconds
  static readonly LEVEL_TRANSITION_TIME_LADDER = 1000; // milliseconds
  static readonly ROOM_COUNT = 50;

  static readonly HEALTH_BAR_FADEIN = 100;
  static readonly HEALTH_BAR_FADEOUT = 350;
  static readonly HEALTH_BAR_TOTALTIME = 1000;

  static readonly SHADED_TILE_CUTOFF = 1;
  static readonly MIN_VISIBILITY = 0; // visibility level of places you've already seen
  static LIGHTING_ANGLE_STEP = 2; // how many degrees between each ray, previously 5
  static LIGHTING_MAX_DISTANCE = 7;
  static readonly LIGHT_RESOLUTION = 0.1; //1 is default

  static readonly LEVEL_TEXT_COLOR = "yellow";
  static readonly AMBIENT_LIGHT_COLOR: [number, number, number] = [12, 15, 12];
  static readonly TORCH_LIGHT_COLOR: [number, number, number] = [120, 35, 10];
}


--- src/levelGenerator.ts ---
import { ChatMessage, Game } from "./game";
import { Room, RoomType } from "./room";
import { Door } from "./tile/door";
import { LevelConstants } from "./levelConstants";
import { Random } from "./random";
import { DownLadder } from "./tile/downLadder";
import {
  LevelParameterGenerator,
  LevelParameters,
} from "./levelParametersGenerator";
import { Level } from "./level";
import { GameConstants } from "./gameConstants";

// animation delays in ms
let ANIMATION_PARTITION_SPLIT_DELAY = 0; // for partition splitting
let ANIMATION_PATHFINDING_DELAY = 0; // for pathfinding
let ANIMATION_LARGE_DELAY = 0; // in between larger steps
if (document.cookie.includes("showgeneration=true")) {
  ANIMATION_PARTITION_SPLIT_DELAY = 10; // for partition splitting
  ANIMATION_PATHFINDING_DELAY = 100; // for pathfinding
  ANIMATION_LARGE_DELAY = 100; // in between larger steps
}

class PartitionConnection {
  x: number;
  y: number;
  other: Partition;

  constructor(x: number, y: number, other: Partition) {
    this.x = x;
    this.y = y;
    this.other = other;
  }
}

class Partition {
  x: number;
  y: number;
  w: number;
  h: number;
  type: RoomType;
  fillStyle: string;
  connections: Array<PartitionConnection>;
  distance: number;
  isTopOpen: boolean;
  isRightOpen: boolean;
  isBottomOpen: boolean;
  isLeftOpen: boolean;
  pathIndex: number;

  constructor(x: number, y: number, w: number, h: number, fillStyle: string) {
    this.x = x;
    this.y = y;
    this.w = w;
    this.h = h;
    this.fillStyle = fillStyle;
    this.type = RoomType.DUNGEON;
    this.connections = [];
    this.distance = 1000;
    this.isTopOpen = true;
    this.isRightOpen = true;
    this.isBottomOpen = true;
    this.isLeftOpen = true;
    this.pathIndex = 0;
  }

  split = async (): Promise<Array<Partition>> => {
    await new Promise((resolve) =>
      setTimeout(
        resolve,
        LevelGenerator.ANIMATION_CONSTANT * ANIMATION_PARTITION_SPLIT_DELAY,
      ),
    );

    // Reset open walls when a partition is split
    this.isTopOpen = true;
    this.isRightOpen = true;
    this.isBottomOpen = true;
    this.isLeftOpen = true;

    // This function generates a random number around the center (0.5) within a certain width (0.6).
    // It uses the Random.rand() function to generate a random number between 0 and 1, subtracts 0.5 to center it around 0,
    // multiplies it by the width to scale it, and then adds the center (0.5) to shift it back to being between 0 and 1.
    let rand_mid = () => {
      let center = 0.5;
      let width = 0.6;
      return (Random.rand() - 0.5) * width + center;
    };

    let sizeRange = () => {
      let sizes = [
        { size: 1, probability: 0.2 },
        { size: 3, probability: 0.6 },
        { size: 10, probability: 0.2 },
      ];
      let rand = Random.rand();
      let sum = 0;
      for (let size of sizes) {
        sum += size.probability;
        if (rand <= sum) return size.size;
      }
      return sizes[sizes.length - 1].size;
    };
    let MIN_SIZE = 4;

    if (this.w > this.h) {
      //if the partitions width is greater than its height
      let w1 = Math.floor(rand_mid() * this.w);
      //choose a random tile within the width of the tiles
      let w2 = this.w - w1 - 1;
      //The remaining border - 1
      if (w1 < MIN_SIZE || w2 < MIN_SIZE) return [this];
      //if either of these are less than the min size: return an array with this Partition
      return [
        new Partition(this.x, this.y, w1, this.h, this.fillStyle),
        new Partition(this.x + w1 + 1, this.y, w2, this.h, this.fillStyle),
      ];
      //return an array with two new partitions
    } else {
      let h1 = Math.floor(rand_mid() * this.h);
      let h2 = this.h - h1 - 1;
      if (h1 < MIN_SIZE || h2 < MIN_SIZE) return [this];
      return [
        new Partition(this.x, this.y, this.w, h1, this.fillStyle),
        new Partition(this.x, this.y + h1 + 1, this.w, h2, this.fillStyle),
      ];
      //identical code for case where height > width
    }
  };

  point_in = (x: number, y: number): boolean => {
    //given the input argument x,y coordinates output boolean
    return (
      x >= this.x && x < this.x + this.w && y >= this.y && y < this.y + this.h
    );

    //only return true if both input x and input y are within the partitions x and y
  };

  point_next_to = (x: number, y: number): boolean => {
    return (
      (x >= this.x - 1 &&
        x < this.x + this.w + 1 &&
        y >= this.y &&
        y < this.y + this.h) ||
      (x >= this.x &&
        x < this.x + this.w &&
        y >= this.y - 1 &&
        y < this.y + this.h + 1)
    );
    //return true if the input x and y are next to any point of the partition
  };

  area = (): number => {
    return this.w * this.h;
    //return the damn area
  };

  overlaps = (other: Partition): boolean => {
    return (
      other.x < this.x + this.w + 1 &&
      other.x + other.w > this.x - 1 &&
      other.y < this.y + this.h + 1 &&
      other.y + other.h > this.y - 1
    );
    //takes another partition instance as argument
    //returns true if any points of each overlap
  };

  setOpenWall = (connection: PartitionConnection) => {
    if (
      connection.y === this.y - 1 &&
      connection.x >= this.x &&
      connection.x < this.x + this.w
    ) {
      this.isTopOpen = false;
    }
    if (
      connection.y === this.y + this.h &&
      connection.x >= this.x &&
      connection.x < this.x + this.w
    ) {
      this.isBottomOpen = false;
    }
    if (
      connection.x === this.x + this.w &&
      connection.y >= this.y &&
      connection.y < this.y + this.h
    ) {
      this.isRightOpen = false;
    }
    if (
      connection.x === this.x - 1 &&
      connection.y >= this.y &&
      connection.y < this.y + this.h
    ) {
      this.isLeftOpen = false;
    }
  };

  get_branch_point = (): { x: number; y: number } => {
    let points = [];
    for (let x = this.x; x < this.x + this.w; x++) {
      //count up from the partitions x to its width
      points.push({ x: x, y: this.y - 1 /*one row above partition*/ });
      points.push({ x: x, y: this.y + this.h /*one row below partition*/ });
    } // pushes the points above and below the partition
    for (let y = this.y; y < this.y + this.h; y++) {
      points.push({ x: this.x - 1, y: y });
      points.push({ x: this.x + this.w, y: y });
    } //pushes points to left and right of the partition
    points = points.filter(
      (p) =>
        !this.connections.some(
          (c) => Math.abs(c.x - p.x) + Math.abs(c.y - p.y) <= 1,
        ),
      //if the sum of the distance between the input x and y values and the partitions x and y values is > 1
      //delete those from the points array
    );
    points.sort(() => 0.5 - Random.rand());
    return points[0]; //return first object of x y points in array points
  };

  draw = (delta: number, levelCenterX: number, levelCenterY: number) => {
    Game.ctx.fillStyle = this.fillStyle;
    Game.ctx.fillRect(
      Math.round(GameConstants.WIDTH / 2 + this.x - levelCenterX),
      Math.round(GameConstants.HEIGHT / 2 + this.y - levelCenterY),
      this.w,
      this.h,
    );

    for (let connection of this.connections) {
      Game.ctx.fillRect(
        Math.round(GameConstants.WIDTH / 2 + connection.x - levelCenterX),
        Math.round(GameConstants.HEIGHT / 2 + connection.y - levelCenterY),
        1,
        1,
      );
    }
  };
} //end of Partition class

let split_partitions = async (
  partitions: Array<Partition>,
  prob: number,
): Promise<Array<Partition>> => {
  for (let partition of partitions) {
    if (Random.rand() < prob) {
      partitions = partitions.filter((p) => p !== partition); // remove partition
      partitions = partitions.concat(await partition.split()); // add splits
    }
  }
  return partitions;
  //takes input partitions array, randomly removes partitions and adds splits, output modified partitions array
};

let split_partition = async (
  partition: Partition,
  prob: number,
): Promise<Array<Partition>> => {
  if (Random.rand() < prob) {
    return await partition.split();
  } else {
    return [partition];
  }
  // Takes a single partition and probability
  // Returns an array with either the split partitions or the original partition
};

let reduce_dimensions = (partition: Partition, params: LevelParameters) => {
  let reduceY = 0;
  let reduceX = 0;
  let translateX = 0;
  let translateY = 0;
  partition.connections.forEach((connection) => {
    if (connection.y === partition.y) reduceY++, translateY++;
    if (connection.y === partition.y + partition.h) reduceY++;
    if (connection.x === partition.x) reduceX++, translateX++;
    if (connection.x === partition.x + partition.w) reduceX++;
  });

  if (partition.w > 7) {
    partition.w -= translateX;
    partition.x += translateX;
  }
  if (partition.h > 7) {
    partition.h -= translateY;
    partition.y += translateY;
  }
};

let get_wall_rooms = (
  partitions: Array<Partition>,
  mapWidth: number,
  mapHeight: number,
): Array<Partition> => {
  return partitions.filter((partition, index) => {
    // Helper function to check if a specific path is clear
    const isPathClear = (
      direction: "left" | "right" | "top" | "bottom",
    ): boolean => {
      switch (direction) {
        case "left":
          for (let y = partition.y; y < partition.y + partition.h; y++) {
            let blocked = partitions.some((other) => {
              if (other === partition) return false;
              // Check if other partition overlaps this y-coordinate and is to the left
              return (
                other.y <= y &&
                y < other.y + other.h &&
                other.x + other.w > 0 &&
                other.x + other.w <= partition.x
              );
            });
            if (!blocked) return true; // Found at least one y without a blocker
          }
          return false;

        case "right":
          for (let y = partition.y; y < partition.y + partition.h; y++) {
            let blocked = partitions.some((other) => {
              if (other === partition) return false;
              // Check if other partition overlaps this y-coordinate and is to the right
              return (
                other.y <= y &&
                y < other.y + other.h &&
                other.x < mapWidth &&
                other.x >= partition.x + partition.w
              );
            });
            if (!blocked) return true;
          }
          return false;

        case "top":
          for (let x = partition.x; x < partition.x + partition.w; x++) {
            let blocked = partitions.some((other) => {
              if (other === partition) return false;
              // Check if other partition overlaps this x-coordinate and is above
              return (
                other.x <= x &&
                x < other.x + other.w &&
                other.y + other.h > 0 &&
                other.y + other.h <= partition.y
              );
            });
            if (!blocked) return true;
          }
          return false;

        case "bottom":
          for (let x = partition.x; x < partition.x + partition.w; x++) {
            let blocked = partitions.some((other) => {
              if (other === partition) return false;
              // Check if other partition overlaps this x-coordinate and is below
              return (
                other.x <= x &&
                x < other.x + other.w &&
                other.y < mapHeight &&
                other.y >= partition.y + partition.h
              );
            });
            if (!blocked) return true;
          }
          return false;

        default:
          return false;
      }
    };

    const hasLeftPath = isPathClear("left");
    const hasRightPath = isPathClear("right");
    const hasTopPath = isPathClear("top");
    const hasBottomPath = isPathClear("bottom");

    // Count the number of open paths
    const openPaths = [
      hasLeftPath,
      hasRightPath,
      hasTopPath,
      hasBottomPath,
    ].filter(Boolean).length;

    // Define wall rooms as those with exactly one open path
    const isWallRoom = openPaths === 1;

    return isWallRoom;
  });
};

let remove_wall_rooms = (
  partitions: Array<Partition>,
  w: number,
  h: number,
  prob: number = 1.0,
): Array<Partition> => {
  // Get all wall rooms
  const wallRooms = get_wall_rooms(partitions, w, h);

  // Remove wall rooms based on probability
  for (const wallRoom of wallRooms) {
    if (Random.rand() < prob) {
      partitions = partitions.filter((p) => p !== wallRoom);
    }
  }

  return partitions;
};

let populate_grid = (
  partitions: Array<Partition>,
  grid: Array<Array<Partition | false>>,
  w: number,
  h: number,
): Array<Array<Partition | false>> => {
  for (let x = 0; x < w; x++) {
    //loop through the horizontal tiles
    grid[x] = []; //empty array at x index
    for (let y = 0; y < h; y++) {
      grid[x][y] = false;
      for (const partition of partitions) {
        if (partition.point_in(x, y)) grid[x][y] = partition;
      }
    }
  }
  return grid;
  //input grid array, partitions array and width and height
  //output grid array that indicates which cells are in which partition
};

let generate_dungeon_candidate = async (
  game: Game,
  partialLevel: PartialLevel,
  map_w: number,
  map_h: number,
  depth: number,
  params: LevelParameters,
) => {
  const {
    minRoomCount,
    maxRoomCount,
    maxRoomArea,
    splitProbabilities,
    wallRemoveProbability,
    softMaxRoomArea,
  } = params;

  partialLevel.partitions = [new Partition(0, 0, map_w, map_h, "white")];
  let grid = [];

  // Use splitProbabilities for splitting
  while (partialLevel.partitions.length < params.maxRoomCount) {
    for (let i = 0; i < splitProbabilities.length; i++) {
      partialLevel.partitions = await split_partitions(
        partialLevel.partitions,
        splitProbabilities[i],
      );
    }
  }
  for (let i = 0; i < 100; i++) {
    partialLevel.partitions.forEach(async (partition) => {
      let roomArea = Random.rand() > 0.95 ? softMaxRoomArea : maxRoomArea; //Random.rand() > 0.95 ? params.softMaxRoomArea : params.maxRoomArea;
      if (partition.area() > roomArea) {
        partialLevel.partitions = partialLevel.partitions.filter(
          (p) => p !== partition,
        );
        partialLevel.partitions = partialLevel.partitions.concat(
          await split_partition(partition, 0.5),
        );
      }
    });
  }

  //visualize_partialLevel.partitions(partialLevel.partitions, map_w, map_h);
  partialLevel.partitions = remove_wall_rooms(
    partialLevel.partitions,
    map_w,
    map_h,
    wallRemoveProbability,
  );

  await new Promise((resolve) =>
    setTimeout(
      resolve,
      LevelGenerator.ANIMATION_CONSTANT * ANIMATION_LARGE_DELAY,
    ),
  );

  // Remove wall rooms based on probability
  /*
  if (partitions.length > params.minRoomCount) {
    for (let i = 0; i < 1; i++) {
      partitions = remove_wall_rooms(partitions, map_w, map_h, wallRemoveProbability);
    }
  }
  
  /*
    partitions = partitions.filter((p) => {
      if (p.area() > maxRoomArea && partitions.length > params.minRoomCount) {
        return false;
      }
      return true;
    });
   
    while (partitions.length > maxRoomCount) {
      partitions.pop();
    }
  */

  // Check if we have any partitions before proceeding
  if (partialLevel.partitions.length === 0) {
    partialLevel.partitions = [];
    return;
  }

  //populate the grid with partitions
  partialLevel.partitions.sort((a, b) => a.area() - b.area());
  // shade each partition's fillStyle based on its area, medium gray for smallest, white for largest
  partialLevel.partitions.forEach((partition) => {
    partition.fillStyle = `rgba(128, 128, 128, ${partition.area() / partialLevel.partitions[0].area()})`;
  });

  await new Promise((resolve) =>
    setTimeout(
      resolve,
      LevelGenerator.ANIMATION_CONSTANT * ANIMATION_LARGE_DELAY,
    ),
  );

  // Make sure we have at least one partition before assigning spawn
  if (partialLevel.partitions.length === 0) {
    partialLevel.partitions = [];
    return;
  }

  let spawn = partialLevel.partitions[0];
  if (!spawn) {
    partialLevel.partitions = [];
    return;
  }

  spawn.type = RoomType.START;
  spawn.fillStyle = "rgb(0, 255, 0)";
  if (partialLevel.partitions.length > 1) {
    partialLevel.partitions[partialLevel.partitions.length - 1].type =
      RoomType.BOSS;
    partialLevel.partitions[partialLevel.partitions.length - 1].fillStyle =
      "red";
  }

  await new Promise((resolve) =>
    setTimeout(
      resolve,
      LevelGenerator.ANIMATION_CONSTANT * ANIMATION_LARGE_DELAY,
    ),
  );

  let connected = [spawn];
  let frontier = [spawn];

  let found_boss = false;

  // connect rooms until we find the boss
  while (frontier.length > 0 && !found_boss) {
    let room = frontier[0];
    if (room !== spawn) room.fillStyle = "green";
    frontier.splice(0, 1);

    let doors_found = 0;
    const num_doors = Math.floor(Random.rand() * 2 + 1);

    let tries = 0;
    const max_tries = 1000;

    while (doors_found < num_doors && tries < max_tries) {
      let point = room.get_branch_point();
      for (const p of partialLevel.partitions) {
        if (
          p !== room &&
          connected.indexOf(p) === -1 &&
          p.point_next_to(point.x, point.y)
        ) {
          room.connections.push(new PartitionConnection(point.x, point.y, p));
          p.connections.push(new PartitionConnection(point.x, point.y, room));

          // Set open walls based on connection
          room.setOpenWall(new PartitionConnection(point.x, point.y, p));
          p.setOpenWall(new PartitionConnection(point.x, point.y, room));

          frontier.push(p);
          connected.push(p);
          doors_found++;
          if (p.type === RoomType.BOSS) {
            found_boss = true;
            p.fillStyle = "rgb(255, 0, 0)";
          }
          break;
        }
      }
      tries++;
    }

    await new Promise((resolve) =>
      setTimeout(
        resolve,
        LevelGenerator.ANIMATION_CONSTANT * ANIMATION_PATHFINDING_DELAY,
      ),
    );
  }

  // remove rooms we haven't connected to yet
  for (const partition of partialLevel.partitions) {
    if (partition.connections.length === 0)
      partialLevel.partitions = partialLevel.partitions.filter(
        (p) => p !== partition,
      );
  }

  await new Promise((resolve) =>
    setTimeout(
      resolve,
      LevelGenerator.ANIMATION_CONSTANT * ANIMATION_LARGE_DELAY,
    ),
  );

  grid = populate_grid(partialLevel.partitions, grid, map_w, map_h); // recalculate with removed rooms

  // make sure we haven't removed all the rooms
  if (partialLevel.partitions.length === 0) {
    partialLevel.partitions = [];
    return; // for now just return an empty list so we can retry
  }

  // make some loops
  let num_loop_doors = Math.floor(Random.rand() * 4 + 4);
  for (let i = 0; i < num_loop_doors; i++) {
    let roomIndex = Math.floor(Random.rand() * partialLevel.partitions.length);
    let room = partialLevel.partitions[roomIndex];

    let found_door = false;

    let tries = 0;
    const max_tries = 10;

    let not_already_connected = partialLevel.partitions.filter(
      (p) => !room.connections.some((c) => c.other === p),
    );

    while (!found_door && tries < max_tries) {
      let point = room.get_branch_point();
      for (const p of not_already_connected) {
        if (p !== room && p.point_next_to(point.x, point.y)) {
          room.connections.push(new PartitionConnection(point.x, point.y, p));
          p.connections.push(new PartitionConnection(point.x, point.y, room));

          // Set open walls based on connection
          room.setOpenWall(new PartitionConnection(point.x, point.y, p));
          p.setOpenWall(new PartitionConnection(point.x, point.y, room));

          found_door = true;
          break;
        }
      }
      tries++;
    }
  }

  // add stair room
  if (!partialLevel.partitions.some((p) => p.type === RoomType.BOSS)) {
    partialLevel.partitions = [];
    return;
  }
  let boss = partialLevel.partitions.find((p) => p.type === RoomType.BOSS);
  let found_stair = false;
  const max_stair_tries = 5;
  const stairRoomWidth = 5;
  const stairRoomHeight = 5;

  for (let stair_tries = 0; stair_tries < max_stair_tries; stair_tries++) {
    let stair = new Partition(
      Game.rand(boss.x - 1, boss.x + boss.w - 2, Random.rand),
      boss.y - stairRoomHeight - 1,
      stairRoomWidth,
      stairRoomHeight,
      "white",
    );
    stair.type = RoomType.DOWNLADDER;
    stair.fillStyle = "blue";
    if (!partialLevel.partitions.some((p) => p.overlaps(stair))) {
      found_stair = true;
      partialLevel.partitions.push(stair);
      stair.connections.push(
        new PartitionConnection(stair.x + 1, stair.y + stairRoomHeight, boss),
      );

      boss.connections.push(
        new PartitionConnection(stair.x + 1, stair.y + stairRoomHeight, stair),
      );

      // Set open walls for stair and boss connection
      stair.setOpenWall(
        new PartitionConnection(stair.x + 1, stair.y + 3, boss),
      );
      boss.setOpenWall(
        new PartitionConnection(stair.x + 1, stair.y + 3, stair),
      );
      break;
    }
  }
  if (!found_stair) {
    console.log("No stair found");
    partialLevel.partitions = [];
    //game.pushMessage("No stair found");
    return;
  }

  // calculate room distances
  frontier = [spawn];
  let seen = [];
  spawn.distance = 0;
  while (frontier.length > 0) {
    let room = frontier[0];
    frontier.splice(0, 1);
    seen.push(room);

    for (let c of room.connections) {
      let other = c.other;
      other.distance = Math.min(other.distance, room.distance + 1);

      if (seen.indexOf(other) === -1) frontier.push(other);
    }
  }
  /*
  // add special rooms
  let added_rope_hole = false;
  for (const p of partialLevel.partitions) {
    if (p.type === RoomType.DUNGEON) {
      if (p.distance > 4 && p.area() <= 30 && Random.rand() < 0) {
        p.type = RoomType.TREASURE;
      } else if (
        !added_rope_hole //&&
        //p.distance > 1 &&
        //p.area() <= 40 &&
        //Random.rand() < 0.5
      ) {
        p.type = RoomType.ROPEHOLE;
        added_rope_hole = true;
        console.log("ADDED ROPEHOLE!!!!!!");
      }
    }
  }
*/
  await new Promise((resolve) =>
    setTimeout(
      resolve,
      10 * LevelGenerator.ANIMATION_CONSTANT * ANIMATION_LARGE_DELAY,
    ),
  );
};

let generate_dungeon = async (
  game: Game,
  partialLevel: PartialLevel,
  map_w: number,
  map_h: number,
  depth: number,
  params: LevelParameters,
) => {
  let passes_checks = false;

  let tries = 0;

  while (!passes_checks) {
    await generate_dungeon_candidate(
      game,
      partialLevel,
      map_w,
      map_h,
      depth,
      params,
    );

    passes_checks = true;
    if (partialLevel.partitions.length < params.minRoomCount) {
      passes_checks = false;
      if (document.cookie.includes("showgeneration=true"))
        game.pushMessage("Not enough rooms");
    } else if (!partialLevel.partitions.some((p) => p.type === RoomType.BOSS)) {
      passes_checks = false;
      if (document.cookie.includes("showgeneration=true"))
        game.pushMessage("Boss room unreachable");
    } else if (
      partialLevel.partitions.find((p) => p.type === RoomType.BOSS).distance < 3
    ) {
      passes_checks = false;
      if (document.cookie.includes("showgeneration=true"))
        game.pushMessage("Boss room too close to spawn");
    }

    tries++;
    //if (tries > 100) break;
  }

  //game.pushMessage("Dungeon passed all checks");

  await new Promise((resolve) =>
    setTimeout(
      resolve,
      10 * LevelGenerator.ANIMATION_CONSTANT * ANIMATION_LARGE_DELAY,
    ),
  );

  console.log("finished generation");
  //partialLevel.partitions.forEach((partition) => reduce_dimensions(partition, params));
};

let generate_cave_candidate = async (
  partialLevel: PartialLevel,
  map_w: number,
  map_h: number,
  num_rooms: number,
) => {
  partialLevel.partitions = [new Partition(0, 0, map_w, map_h, "white")];
  let grid = [];

  for (let i = 0; i < 3; i++)
    partialLevel.partitions = await split_partitions(
      partialLevel.partitions,
      0.75,
    );
  for (let i = 0; i < 3; i++)
    partialLevel.partitions = await split_partitions(
      partialLevel.partitions,
      1,
    );
  for (let i = 0; i < 3; i++)
    partialLevel.partitions = await split_partitions(
      partialLevel.partitions,
      0.5,
    );
  grid = populate_grid(partialLevel.partitions, grid, map_w, map_h);

  partialLevel.partitions.sort((a, b) => a.area() - b.area());

  if (partialLevel.partitions.length === 0) {
    throw new Error("No partitions generated."); // Throw an error if no partitions
  }

  let spawn = partialLevel.partitions[0];
  spawn.type = RoomType.ROPECAVE;
  for (let i = 1; i < partialLevel.partitions.length; i++)
    partialLevel.partitions[i].type = RoomType.CAVE;

  let connected = [spawn];
  let frontier = [spawn];

  // connect rooms until we hit num_rooms
  while (frontier.length > 0 && connected.length < num_rooms) {
    let room = frontier[0];
    frontier.splice(0, 1);

    let doors_found = 0;
    const num_doors = Math.floor(Random.rand() * 2 + 1);

    let tries = 0;
    const max_tries = 1000;

    while (
      doors_found < num_doors &&
      tries < max_tries &&
      connected.length < num_rooms
    ) {
      let point = room.get_branch_point();
      if (!point) {
      }

      for (const p of partialLevel.partitions) {
        if (
          p !== room &&
          connected.indexOf(p) === -1 &&
          p.point_next_to(point.x, point.y)
        ) {
          room.connections.push(new PartitionConnection(point.x, point.y, p));
          p.connections.push(new PartitionConnection(point.x, point.y, room));
          frontier.push(p);
          connected.push(p);
          doors_found++;
          break;
        }
      }
      tries++;
    }
  }

  // remove rooms we haven't connected to yet
  partialLevel.partitions = partialLevel.partitions.filter(
    (partition) => partition.connections.length > 0,
  );
  grid = populate_grid(partialLevel.partitions, grid, map_w, map_h); // recalculate with removed rooms

  // make sure we haven't removed all the rooms
  if (partialLevel.partitions.length === 0) {
    throw new Error("No valid rooms after filtering."); // Throw an error if no valid rooms
  }

  // make some loops
  let num_loop_doors = Math.floor(Random.rand() * 4 + 4);
  for (let i = 0; i < num_loop_doors; i++) {
    let roomIndex = Math.floor(Random.rand() * partialLevel.partitions.length);
    let room = partialLevel.partitions[roomIndex];

    let found_door = false;

    let tries = 0;
    const max_tries = 100;

    let not_already_connected = partialLevel.partitions.filter(
      (p) => !room.connections.some((c) => c.other === p),
    );

    while (!found_door && tries < max_tries) {
      let point = room.get_branch_point();
      if (!point) {
        break; // Skip if no valid branch point found
      }

      for (const p of not_already_connected) {
        if (p !== room && p.point_next_to(point.x, point.y)) {
          room.connections.push(new PartitionConnection(point.x, point.y, p));
          p.connections.push(new PartitionConnection(point.x, point.y, room));
          found_door = true;
          break;
        }
      }
      tries++;
    }
  }

  // calculate room distances
  frontier = [spawn];
  let seen = [];
  spawn.distance = 0;
  while (frontier.length > 0) {
    let room = frontier[0];
    frontier.splice(0, 1);
    seen.push(room);

    for (let c of room.connections) {
      let other = c.other;
      other.distance = Math.min(other.distance, room.distance + 1);

      if (seen.indexOf(other) === -1) frontier.push(other);
    }
  }

  return partialLevel.partitions;
};

let generate_cave = async (
  partialLevel: PartialLevel,
  mapWidth: number,
  mapHeight: number,
): Promise<Array<Partition>> => {
  const numberOfRooms = 5; // don't set this too high or cave generation will time out

  do {
    await generate_cave_candidate(
      partialLevel,
      mapWidth,
      mapHeight,
      numberOfRooms,
    );
  } while (partialLevel.partitions.length < numberOfRooms);

  return partialLevel.partitions;
};

let generate_tutorial = (
  height: number = 7,
  width: number = 7,
): Array<Partition> => {
  let partitions: Array<Partition>;

  partitions = [new Partition(0, 0, height, width, "white")];
  partitions[0].type = RoomType.TUTORIAL;

  return partitions;
};

let visualize_partitions = (
  partitions: Array<Partition>,
  mapWidth: number,
  mapHeight: number,
) => {
  // Create grid with padded spaces
  const grid = Array.from(
    { length: mapHeight },
    () => Array(mapWidth).fill(" . "), // Pad dots with spaces
  );

  // Calculate the maximum number of digits needed
  const maxIndex = partitions.length - 1;
  const padLength = maxIndex.toString().length;

  partitions.forEach((partition, index) => {
    // Pad the index number with spaces to maintain consistent width
    const paddedIndex = index.toString().padStart(padLength, " ");

    for (let x = partition.x; x < partition.x + partition.w; x++) {
      for (let y = partition.y; y < partition.y + partition.h; y++) {
        if (x >= 0 && x < mapWidth && y >= 0 && y < mapHeight) {
          grid[y][x] = ` ${paddedIndex} `; // Pad numbers with spaces
        }
      }
    }
  });

  console.log("Partition Layout:");
  console.log(
    "   " + [...Array(mapWidth)].map((_, i) => i % 10).join("  ") + " X",
  ); // Column headers
  grid.forEach((row, index) => {
    const paddedIndex = index.toString().padStart(2, " ");
    console.log(`${paddedIndex} ${row.join("")}`);
  });
  console.log("Y");
};

let check_overlaps = (partitions: Array<Partition>): boolean => {
  for (let i = 0; i < partitions.length; i++) {
    for (let j = i + 1; j < partitions.length; j++) {
      const a = partitions[i];
      const b = partitions[j];
      if (
        a.x < b.x + b.w &&
        a.x + a.w > b.x &&
        a.y < b.y + b.h &&
        a.y + a.h > b.y
      ) {
        return true;
      }
    }
  }
  return false;
};

export class PartialLevel {
  partitions: Array<Partition>;
}

export class LevelGenerator {
  game: Game;
  seed: number;
  depthReached = 0;
  currentFloorFirstLevelID = 0;
  partialLevel: PartialLevel;
  levelParams: LevelParameters;
  static ANIMATION_CONSTANT = 1;

  private setOpenWallsForPartitions = (
    partitions: Array<Partition>,
    mapWidth: number,
    mapHeight: number,
  ) => {
    for (const partition of partitions) {
      // Reset all walls to closed by default
      partition.isTopOpen = false;
      partition.isRightOpen = false;
      partition.isBottomOpen = false;
      partition.isLeftOpen = false;

      // Check if partition touches map boundaries
      if (partition.x === 0) {
        partition.isLeftOpen = true;
      }
      if (partition.y === 0) {
        partition.isTopOpen = true;
      }
      if (partition.x + partition.w === mapWidth) {
        partition.isRightOpen = true;
      }
      if (partition.y + partition.h === mapHeight) {
        partition.isBottomOpen = true;
      }
    }
  };

  createLevel = (depth: number) => {
    let newLevel = new Level(this.game, depth, 100, 100);
    return newLevel;
  };

  getRooms = (
    partitions: Array<Partition>,
    depth: number,
    mapGroup: number,
  ): Array<Room> => {
    //this.setOpenWallsForPartitions(partitions, 35, 35); // Using standard map size

    let rooms: Array<Room> = [];

    for (let i = 0; i < partitions.length; i++) {
      let partition = partitions[i];

      // Pass open walls information to the Room constructor
      let room = new Room(
        this.game,
        partition.x - 1,
        partition.y - 1,
        partition.w + 2,
        partition.h + 2,
        partition.type,
        depth,
        mapGroup,
        this.game.levels[depth],
        Random.rand,
      );
      rooms.push(room);
    }

    let doors_added: Array<Door> = [];

    partitions.forEach((partition, index) => {
      partition.connections.forEach((connection) => {
        let door = rooms[index].addDoor(connection.x, connection.y);
        let existingDoor = doors_added.find(
          (existing) => existing.x === door.x && existing.y === door.y,
        );
        if (existingDoor) {
          existingDoor.link(door);
          door.link(existingDoor);
        }
        doors_added.push(door);
      });
    });

    for (let room of rooms) {
      room.populate(Random.rand);
    }

    return rooms;
  };

  setSeed = (seed: number) => {
    this.seed = seed;
  };

  generate = async (
    game: Game,
    depth: number,
    cave = false,
    callback: (linkedLevel: Room) => void,
  ) => {
    this.levelParams = LevelParameterGenerator.getParameters(depth);
    this.depthReached = depth;

    // Set the random state based on the seed and depth
    Random.setState(this.seed + depth);

    this.game = game;

    // Determine the map group
    let mapGroup =
      this.game.rooms.length > 0
        ? this.game.rooms[this.game.rooms.length - 1].mapGroup + 1
        : 0;

    this.partialLevel = new PartialLevel();

    // Generate partitions based on whether it's a cave or a dungeon
    if (cave)
      await generate_cave(this.partialLevel, 20, 20); // You might want to make these dynamic based on params
    else
      await generate_dungeon(
        game,
        this.partialLevel,
        this.levelParams.mapWidth,
        this.levelParams.mapHeight,
        depth,
        this.levelParams,
      );

    // Call this function before get_wall_rooms
    if (check_overlaps(this.partialLevel.partitions)) {
      console.warn("There are overlapping partitions.");
    }

    // Get the levels based on the partitions
    let newLevel = this.createLevel(depth);

    this.game.levels.push(newLevel);
    this.game.level = newLevel;
    let rooms = this.getRooms(this.partialLevel.partitions, depth, mapGroup);

    newLevel.setRooms(rooms);
    newLevel.exitRoom.linkExitToStart();

    // Update the current floor first level ID if it's not a cave
    if (!cave) this.currentFloorFirstLevelID = this.game.rooms.length;

    // Add the new levels to the game rooms
    this.game.rooms = rooms;

    // // Generate the rope hole if it exists
    for (let room of rooms) {
      if (room.type === RoomType.ROPEHOLE) {
        for (let x = room.roomX; x < room.roomX + room.width; x++) {
          for (let y = room.roomY; y < room.roomY + room.height; y++) {
            let tile = room.roomArray[x][y];
            if (tile instanceof DownLadder && tile.isRope) {
              tile.generate();

              callback(
                cave
                  ? rooms.find((r) => r.type === RoomType.ROPECAVE)
                  : rooms.find((r) => r.type === RoomType.START),
              );
              return;
            }
          }
        }
      }
    }

    // Return the start room or the rope cave room
    callback(
      cave
        ? rooms.find((r) => r.type === RoomType.ROPECAVE)
        : rooms.find((r) => r.type === RoomType.START),
    );
  };

  generateFirstNFloors = async (game, numFloors) => {
    await this.generate(game, 0, false, () => {});
    for (let i = 0; i < numFloors; i++) {
      let foundRoom = this.game.rooms
        .slice()
        .reverse()
        .find((room) => room.type === RoomType.DOWNLADDER);

      if (foundRoom) {
        for (
          let x = foundRoom.roomX;
          x < foundRoom.roomX + foundRoom.width;
          x++
        ) {
          for (
            let y = foundRoom.roomY;
            y < foundRoom.roomY + foundRoom.height;
            y++
          ) {
            let tile = foundRoom.roomArray[x][y];
            if (tile instanceof DownLadder) {
              tile.generate();
              break;
            }
          }
        }
      }
    }
  };

  draw = (delta: number) => {
    Game.ctx.fillStyle = "rgba(0, 0, 0, 1)";
    Game.ctx.fillRect(0, 0, GameConstants.WIDTH, GameConstants.HEIGHT);

    if (document.cookie.includes("showgeneration=true")) {
      if (this.partialLevel.partitions) {
        this.partialLevel.partitions.forEach((partition) => {
          partition.draw(
            delta,
            this.levelParams.mapWidth / 2,
            this.levelParams.mapHeight / 2,
          );
        });
      }
    } else {
      Game.ctx.fillStyle = "rgb(255, 255, 255)";
      let dimensions = Game.measureText("generating level...");
      Game.fillText(
        "generating level...",
        GameConstants.WIDTH / 2 - dimensions.width / 2,
        GameConstants.HEIGHT / 2 - dimensions.height / 2,
      );
    }
  };
}


--- src/levelParametersGenerator.ts ---
import { CrabEnemy } from "./entity/enemy/crabEnemy";
import { FrogEnemy } from "./entity/enemy/frogEnemy";
import { ZombieEnemy } from "./entity/enemy/zombieEnemy";
import { SkullEnemy } from "./entity/enemy/skullEnemy";
import { EnergyWizardEnemy } from "./entity/enemy/energyWizard";
import { ChargeEnemy } from "./entity/enemy/chargeEnemy";
import { Spawner } from "./entity/enemy/spawner";
import { BishopEnemy } from "./entity/enemy/bishopEnemy";
import { ArmoredzombieEnemy } from "./entity/enemy/armoredzombieEnemy";
import { BigSkullEnemy } from "./entity/enemy/bigSkullEnemy";
import { QueenEnemy } from "./entity/enemy/queenEnemy";
import { KnightEnemy } from "./entity/enemy/knightEnemy";
import { BigKnightEnemy } from "./entity/enemy/bigKnightEnemy";
import { FireWizardEnemy } from "./entity/enemy/fireWizard";
import { RookEnemy } from "./entity/enemy/rookEnemy";

export const enemyClasses = {
  1: CrabEnemy,
  2: FrogEnemy,
  3: ZombieEnemy,
  4: SkullEnemy,
  5: EnergyWizardEnemy,
  6: ChargeEnemy,
  7: RookEnemy,
  8: BishopEnemy,
  9: ArmoredzombieEnemy,
  10: BigSkullEnemy,
  11: QueenEnemy,
  12: KnightEnemy,
  13: BigKnightEnemy,
  14: FireWizardEnemy,
};

export interface LevelParameters {
  minRoomCount: number;
  maxRoomCount: number;
  maxRoomArea: number;
  mapWidth: number;
  mapHeight: number;
  splitProbabilities: number[];
  wallRemoveProbability: number;
  numLoopDoorsRange: [number, number];
  numberOfRooms: number;
  softMaxRoomArea: number;
}

export class LevelParameterGenerator {
  /**
   * Generates level parameters based on the current depth.
   * @param depth The current depth level.
   * @returns An object conforming to the LevelParameters interface.
   */
  static getParameters(depth: number): LevelParameters {
    return {
      minRoomCount: depth > 0 ? 0 : 0,
      maxRoomCount: depth > 0 ? 12 : 6,
      maxRoomArea: depth > 0 ? 120 + 10 * depth : 40,
      mapWidth: 25 + 5 * depth,
      mapHeight: 25 + 5 * depth,
      splitProbabilities: [0.75, 1.0, 0.25], // Example probabilities
      wallRemoveProbability: depth > 0 ? 0.1 : 1,
      numLoopDoorsRange: [4, 8], // Random between 4 and 8
      numberOfRooms: depth > 0 ? 5 : 3,
      softMaxRoomArea: depth > 0 ? 0.5 * (120 + 10 * depth) : 40,
    };
  }
}


--- src/lightSource.ts ---
import { Room } from "./room";

export class LightSource {
  x: number;
  y: number;
  r: number;
  c: [number, number, number];
  b: number = 1;

  oldX: number;
  oldY: number;
  oldR: number;
  oldC: [number, number, number];
  oldB: number;

  hasChanged: boolean;
  constructor(
    x: number,
    y: number,
    r: number,
    c: [number, number, number] = [180, 60, 5],
    b: number = 1,
  ) {
    this.x = x;
    this.y = y;
    this.r = r;
    this.c = c;
    this.b = b;
    this.oldX = x;
    this.oldY = y;
    this.oldR = r;
    this.oldC = c;
    this.oldB = b;
    this.hasChanged = true;
  }

  updatePosition = (x: number, y: number) => {
    this.x = x;
    this.y = y;
  };

  shouldUpdate = () => {
    return true;
    this.hasChanged =
      this.x !== this.oldX ||
      this.y !== this.oldY ||
      this.r !== this.oldR ||
      this.c !== this.oldC ||
      this.b !== this.oldB ||
      this.hasChanged;
    return this.hasChanged;
  };
}


--- src/lighting.ts ---
import { LightSource } from "./lightSource";
import { Room } from "./room";

export class Lighting {
  static momentaryLight = (
    room: Room,
    x: number,
    y: number,
    radius: number,
    color: [number, number, number],
    duration: number,
    brightness: number,
    delay: number,
  ) => {
    const lightSource = Lighting.newLightSource(
      x,
      y,
      color,
      radius,
      brightness,
    );
    setTimeout(() => {
      room.updateLightSources(lightSource);

      setTimeout(() => {
        room.updateLightSources(lightSource, true);
      }, duration);
    }, delay);
  };

  static newLightSource = (
    x: number,
    y: number,
    color: [number, number, number],
    radius: number,
    brightness: number,
  ) => {
    return new LightSource(x, y, radius, color, brightness);
  };

  static addLightSource = (room: Room, lightSource: LightSource) => {
    room.lightSources.push(lightSource);
  };

  static removeLightSource = (room: Room, lightSource: LightSource) => {
    room.lightSources = room.lightSources.filter((ls) => ls !== lightSource);
  };
}


--- src/map.ts ---
import { Game } from "./game";
import { GameConstants } from "./gameConstants";
import { Room, RoomType } from "./room";
import { Entity, EntityType } from "./entity/entity";
import { Wall } from "./tile/wall";
import { Player } from "./player";
import { LevelConstants } from "./levelConstants";

export class Map {
  game: Game;
  mapData: any[] = [];
  oldMapData: any[] = [];
  depth: number;
  scale: number;

  offsetX: number = 0;
  offsetY: number = 0;
  softOffsetX: number = 0;
  softOffsetY: number = 0;
  player: Player;
  constructor(game: Game, player: Player) {
    this.game = game;
    this.scale = 1;
    this.player = player;
    //this.depth = player.game.level.depth
  }

  saveMapData = () => {
    this.clearMap();
    for (const room of this.game.levels[this.player.depth].rooms) {
      if (
        this.game.room.mapGroup === room.mapGroup &&
        (room.entered === true || GameConstants.DEVELOPER_MODE)
      ) {
        this.mapData.push({
          room: room,
          walls: room.innerWalls,
          doors: room.doors,
          entities: room.entities,
          items: room.items,
          players: this.game.players,
        });
      }
    }

    const enteredRooms = this.mapData
      .map((data) => data.room)
      .filter((room) => room.entered);

    if (enteredRooms.length > 0) {
      const sortedByX = [...enteredRooms].sort((a, b) => a.roomX - b.roomX);
      const sortedByY = [...enteredRooms].sort((a, b) => a.roomY - b.roomY);

      const maxX = sortedByX[sortedByX.length - 1].roomX;
      const minY = sortedByY[0].roomY;

      this.offsetX = maxX;
      this.offsetY = minY;
    } else {
      this.offsetX = 0;
      this.offsetY = 0;
    }
  };

  clearMap = () => {
    this.mapData = [];
  };

  saveOldMap = () => {
    this.oldMapData = [...this.mapData];
  };

  renderMap = (delta: number) => {
    Game.ctx.save(); // Save the current canvas state

    this.setInitialCanvasSettings(1);
    this.translateCanvas(0);
    for (const data of this.mapData) {
      this.drawRoom(data, delta);
    }
    /*for (const data of this.oldMapData) {
      this.drawRoom(data);
    }*/
    this.resetCanvasTransform();

    Game.ctx.restore(); // Restore the canvas state
  };
  updateOffsetXY = () => {
    let diffX = this.offsetX - this.softOffsetX;
    let diffY = this.offsetY - this.softOffsetY;

    if (Math.abs(diffX) > 0.01) {
      this.softOffsetX += diffX * 0.1;
      this.softOffsetX = this.softOffsetX;
    } else this.softOffsetX = this.offsetX;
    if (Math.abs(diffY) > 0.01) {
      this.softOffsetY += diffY * 0.1;
      this.softOffsetY = this.softOffsetY;
    } else this.softOffsetY = this.offsetY;
  };

  draw = (delta: number) => {
    this.updateOffsetXY();
    this.renderMap(delta);
  };

  setInitialCanvasSettings = (alpha: number) => {
    Game.ctx.globalAlpha = alpha;
    Game.ctx.globalCompositeOperation = "source-over";
  };

  translateCanvas = (offset: number) => {
    Game.ctx.translate(
      Math.floor(0.95 * GameConstants.WIDTH) -
        //this.game.room.roomX -
        //Math.floor(0.5 * this.game.room.width) +
        15 * this.scale -
        Math.floor(this.softOffsetX),
      Math.floor(0.05 * GameConstants.HEIGHT) -
        //this.game.room.roomY -
        //Math.floor(0.5 * this.game.room.height) -
        1 * this.scale -
        offset -
        Math.floor(this.softOffsetY),
    );
  };

  drawRoom = (data, delta: number) => {
    //this.drawUnderRoomPlayers(data.players, delta);

    this.drawRoomOutline(data.room);

    this.drawRoomWalls(data.walls);
    this.drawRoomDoors(data.doors);
    this.drawRoomEntities(data.entities);
    this.drawRoomItems(data.items);
    this.drawRoomPlayers(data.players, delta);
  };

  drawRoomOutline = (level) => {
    const s = this.scale;
    Game.ctx.fillStyle = "#5A5A5A";
    Game.ctx.fillRect(
      level.roomX * s + 0,
      level.roomY * s + 0,
      level.width * s - 0,
      level.height * s - 0,
    );
    if (level.type === RoomType.UPLADDER) Game.ctx.fillStyle = "#101460";
    if (level.type === RoomType.DOWNLADDER) Game.ctx.fillStyle = "#601410";
    Game.ctx.fillStyle = "black";
    Game.ctx.fillRect(
      level.roomX * s + 1,
      level.roomY * s + 1,
      level.width * s - 2,
      level.height * s - 2,
    );
  };

  drawRoomWalls = (walls) => {
    const s = this.scale;
    Game.ctx.save(); // Save the current canvas state
    for (const wall of walls) {
      Game.ctx.fillStyle = "#404040";
      Game.ctx.fillRect(wall.x * s, wall.y * s, 1 * s, 1 * s);
    }
    Game.ctx.restore(); // Restore the canvas state
  };

  drawRoomDoors = (doors) => {
    const s = this.scale;
    Game.ctx.save(); // Save the current canvas state
    for (const door of doors) {
      if (door.opened === false) Game.ctx.fillStyle = "#5A5A5A";
      if (door.opened === true) {
        Game.ctx.fillStyle = "black";
        Game.ctx.fillRect(door.x * s, door.y * s, 1 * s, 1 * s);
      }
      Game.ctx.fillStyle = "#5A5A5A"; // Reset to default after each door
    }
    Game.ctx.restore(); // Restore the canvas state
  };

  drawRoomPlayers = (players, delta: number) => {
    const s = this.scale;
    Game.ctx.save(); // Save the current canvas state
    for (const i in players) {
      Game.ctx.fillStyle = "white";
      if (
        this.game.levels[players[i].depth].rooms[players[i].levelID]
          .mapGroup === this.game.room.mapGroup
      ) {
        Game.ctx.fillRect(players[i].x * s, players[i].y * s, 1 * s, 1 * s);
      }
    }
    Game.ctx.restore(); // Restore the canvas state
  };

  drawUnderRoomPlayers = (players, delta: number) => {
    const s = this.scale;
    Game.ctx.save(); // Save the current canvas state
    for (const i in players) {
      this.game.rooms[players[i].levelID].mapGroup === this.game.room.mapGroup;
      {
        if (Math.floor(Date.now() / 300) % 2) {
          Game.ctx.fillStyle = "#4D8C8C";
          // Draw 3x3 outline box around player
          Game.ctx.fillRect(
            (players[i].x - 1) * s,
            (players[i].y - 1) * s,
            1 * s,
            1 * s,
          ); // Top left
          Game.ctx.fillRect(
            players[i].x * s,
            (players[i].y - 1) * s,
            1 * s,
            1 * s,
          ); // Top middle
          Game.ctx.fillRect(
            (players[i].x + 1) * s,
            (players[i].y - 1) * s,
            1 * s,
            1 * s,
          ); // Top right
          Game.ctx.fillRect(
            (players[i].x - 1) * s,
            players[i].y * s,
            1 * s,
            1 * s,
          ); // Middle left
          Game.ctx.fillRect(
            (players[i].x + 1) * s,
            players[i].y * s,
            1 * s,
            1 * s,
          ); // Middle right
          Game.ctx.fillRect(
            (players[i].x - 1) * s,
            (players[i].y + 1) * s,
            1 * s,
            1 * s,
          ); // Bottom left
          Game.ctx.fillRect(
            players[i].x * s,
            (players[i].y + 1) * s,
            1 * s,
            1 * s,
          ); // Bottom middle
          Game.ctx.fillRect(
            (players[i].x + 1) * s,
            (players[i].y + 1) * s,
            1 * s,
            1 * s,
          ); // Bottom right
        }
      }
    }
    Game.ctx.restore(); // Restore the canvas state
  };

  drawRoomEntities = (entities) => {
    const s = this.scale;
    Game.ctx.save(); // Save the current canvas state
    for (const enemy of entities) {
      this.setEntityColor(enemy);
      Game.ctx.fillRect(enemy.x * s, enemy.y * s, 1 * s, 1 * s);
    }
    Game.ctx.restore(); // Restore the canvas state
  };

  setEntityColor = (enemy) => {
    // No need to save/restore here as only fillStyle is being set
    if (enemy.type === EntityType.ENEMY) {
      Game.ctx.fillStyle = "yellow";
    }
    if (enemy.type === EntityType.PROP) {
      Game.ctx.fillStyle = "#847e87";
    }
    if (enemy.type === EntityType.RESOURCE) {
      Game.ctx.fillStyle = "#5a595b";
    }
    if (enemy.type === EntityType.FRIENDLY) {
      Game.ctx.fillStyle = "cyan";
    }
  };

  drawRoomItems = (items) => {
    const s = this.scale;
    Game.ctx.save(); // Save the current canvas state
    for (const item of items) {
      let x = item.x;
      let y = item.y;
      Game.ctx.fillStyle = "#ac3232";
      if (!item.pickedUp) {
        Game.ctx.fillRect(item.x * s, item.y * s, 1 * s, 1 * s);
      }
    }
    Game.ctx.restore(); // Restore the canvas state
  };

  resetCanvasTransform = () => {
    Game.ctx.setTransform(1, 0, 0, 1, 0, 0);
  };
}


--- src/menu.ts ---
import { Game } from "./game";
import { guiButton } from "./guiButton";
import { InputEnum } from "./input";
import { GameConstants } from "./gameConstants";

export class Menu {
  buttons: guiButton[];
  open: boolean;
  selectedButton: number;
  subMenus: { [key: string]: Menu };
  currentSubMenu: string | null;

  constructor() {
    this.buttons = [];
    this.open = false;
    this.selectedButton = 0;
    this.subMenus = {};
    this.currentSubMenu = null;
    //this.initializeMainMenu();
  }

  initializeMainMenu() {
    this.addButton(new guiButton(0, 0, 200, 50, "Start Game", this.startGame));
    this.addButton(
      new guiButton(0, 60, 200, 50, "Settings", () =>
        this.openSubMenu("Settings"),
      ),
    );
    this.addButton(new guiButton(0, 120, 200, 50, "Exit", this.exitGame));
    this.initializeSettingsMenu();
    this.positionButtons();
  }

  initializeSettingsMenu() {
    const settingsMenu = new Menu();
    settingsMenu.addButton(
      new guiButton(0, 0, 200, 50, "Audio", this.openAudioSettings),
    );
    settingsMenu.addButton(
      new guiButton(0, 60, 200, 50, "Graphics", this.openGraphicsSettings),
    );
    settingsMenu.addButton(
      new guiButton(0, 120, 200, 50, "Controls", this.openControlsSettings),
    );
    settingsMenu.addButton(
      new guiButton(0, 180, 200, 50, "Back", () => this.closeSubMenu()),
    );
    settingsMenu.positionButtons();
    this.subMenus["Settings"] = settingsMenu;
  }

  addButton(button: guiButton) {
    this.buttons.push(button);
  }

  drawMenu() {
    if (!this.open && !this.currentSubMenu) return;

    Game.ctx.save();
    Game.ctx.fillStyle = "rgba(0, 0, 0, 0.5)";
    Game.ctx.fillRect(0, 0, innerWidth, innerHeight);

    const menuToDraw = this.currentSubMenu
      ? this.subMenus[this.currentSubMenu]
      : this;
    menuToDraw.buttons.forEach((button) => {
      this.drawButton(button, menuToDraw);
    });
    Game.ctx.restore();
  }

  drawButton(button: guiButton, menu: Menu) {
    Game.ctx.fillStyle =
      menu.selectedButton === menu.buttons.indexOf(button)
        ? "rgba(200, 200, 200, 1)"
        : "rgba(255, 255, 255, 1)";
    Game.ctx.fillRect(button.x, button.y, button.width, button.height);
    Game.ctx.fillStyle = "rgba(0, 0, 0, 1)";
    Game.ctx.font = "20px Arial";

    const textWidth = Game.measureText(button.text).width;
    const textX = button.x + (button.width - textWidth) / 2;
    const textY = button.y + button.height / 2 + Game.letter_height / 2;

    Game.fillText(button.text, textX, textY);
  }

  inputHandler(input: InputEnum) {
    if (!this.open) return;

    switch (input) {
      case InputEnum.ESCAPE:
        if (this.currentSubMenu) {
          this.closeSubMenu();
        } else {
          this.open = false;
        }
        break;
      case InputEnum.UP:
        this.up();
        break;
      case InputEnum.DOWN:
        this.down();
        break;
      case InputEnum.SPACE:
        this.select();
        break;
      default:
        break;
    }
  }

  openSubMenu(menuName: string) {
    if (this.subMenus[menuName]) {
      this.currentSubMenu = menuName;
      this.selectedButton = 0;
    }
  }

  closeSubMenu() {
    this.currentSubMenu = null;
    this.selectedButton = 0;
  }

  close() {
    this.open = false;
    this.currentSubMenu = null;
  }

  select() {
    const menuToSelect = this.currentSubMenu
      ? this.subMenus[this.currentSubMenu]
      : this;
    if (menuToSelect.open) {
      menuToSelect.buttons[menuToSelect.selectedButton].onClick();
    }
  }

  up() {
    const menuToNavigate = this.currentSubMenu
      ? this.subMenus[this.currentSubMenu]
      : this;
    if (menuToNavigate.open) {
      menuToNavigate.selectedButton =
        (menuToNavigate.selectedButton - 1 + menuToNavigate.buttons.length) %
        menuToNavigate.buttons.length;
    }
  }

  down() {
    const menuToNavigate = this.currentSubMenu
      ? this.subMenus[this.currentSubMenu]
      : this;
    if (menuToNavigate.open) {
      menuToNavigate.selectedButton =
        (menuToNavigate.selectedButton + 1) % menuToNavigate.buttons.length;
    }
  }

  // Example action methods
  startGame = () => {
    console.log("Game Started");
    this.close();
    // Implement game start logic
  };

  exitGame = () => {
    console.log("Exit Game");
    // Implement exit game logic
  };

  openAudioSettings = () => {
    console.log("Audio Settings Opened");
    // Implement audio settings logic
  };

  openGraphicsSettings = () => {
    console.log("Graphics Settings Opened");
    // Implement graphics settings logic
  };

  openControlsSettings = () => {
    console.log("Controls Settings Opened");
    // Implement controls settings logic
  };

  positionButtons() {
    const startX = (GameConstants.WIDTH - 200) / 2;
    const startY = (GameConstants.HEIGHT - this.buttons.length * 60) / 2;
    this.buttons.forEach((button, index) => {
      button.x = startX;
      button.y = startY + index * 60;
    });
  }
}


--- src/mouseCursor.ts ---
import { Game } from "./game";
import { Input } from "./input";
import { GameConstants } from "./gameConstants";

export class MouseCursor {
  private static instance: MouseCursor;
  private cursorSize: number = 5; // Size of the cursor rectangle
  private clickX: number = 0;
  private clickY: number = 0;
  private tileX: number = 6;

  private constructor() {}
  private frame: number = 0;

  public static getInstance(): MouseCursor {
    if (!MouseCursor.instance) {
      MouseCursor.instance = new MouseCursor();
    }
    return MouseCursor.instance;
  }

  public drawCursor(): void {
    Game.ctx.save();

    //Game.ctx.fillRect(Input.mouseX, Input.mouseY, 1, 1);
    Game.drawFX(
      this.tileX,
      0,
      1,
      1,
      Input.mouseX / GameConstants.TILESIZE - 8 / GameConstants.TILESIZE,
      Input.mouseY / GameConstants.TILESIZE - 8 / GameConstants.TILESIZE,
      1,
      1,
    );
    Game.ctx.restore();
  }

  public drawAnimation(delta: number): void {
    if (this.frame > 5) {
      //14 is max frame for animation
      return;
    }
    Game.drawFX(
      9 + Math.ceil(this.frame),
      1,
      1,
      1,
      this.clickX / GameConstants.TILESIZE - 8 / GameConstants.TILESIZE,
      this.clickY / GameConstants.TILESIZE - 8 / GameConstants.TILESIZE,
      1,
      1,
    );
    this.frame = this.frame + delta / 5;
  }

  public startClickAnim(): void {
    this.frame = 0;
    this.clickX = Input.mouseX;
    this.clickY = Input.mouseY;
  }

  public setIcon = (icon: string) => {
    switch (icon) {
      case "arrow":
        this.tileX = 8;
        break;
      case "sword":
        this.tileX = 7;
        break;
      case "hand":
        this.tileX = 6;
        break;
      case "wait":
        this.tileX = 9;
        break;
      case "grab":
        this.tileX = 10;
        break;
      case "up":
        this.tileX = 11;
        break;
      case "right":
        this.tileX = 12;
        break;
      case "down":
        this.tileX = 13;
        break;
      case "left":
        this.tileX = 14;
        break;
      case "mine":
        this.tileX = 15;
        break;
    }
  };

  public draw = (delta: number, mobile: boolean = false) => {
    if (!mobile) this.drawCursor();
    this.drawAnimation(delta);
  };

  public getPosition(): { x: number; y: number } {
    return { x: Input.mouseX, y: Input.mouseY };
  }

  public getTilePosition(): { x: number; y: number } {
    return {
      x: Math.floor(Input.mouseX / GameConstants.TILESIZE),
      y: Math.floor(Input.mouseY / GameConstants.TILESIZE),
    };
  }

  public getInventoryPosition(): { x: number; y: number } {
    return {
      x: Input.mouseX,
      y: Input.mouseY,
    };
  }
}


--- src/particle/attackAnimation.ts ---
import { Direction, Game } from "../game";
import { GameConstants } from "../gameConstants";
import { Particle } from "./particle";

export class AttackAnimation extends Particle {
  tileX: number;
  tileY: number;
  tileYOffset: number;
  x: number;
  y: number;
  frame: number;
  type: string;
  direction: Direction;
  frames: number;
  yOffset: number;
  xOffset: number;
  animationSpeed: number;

  constructor(x: number, y: number, type: string, direction: Direction) {
    super();
    this.x = x;
    this.y = y - 0.25;
    this.dead = false;
    this.frame = 0;
    this.type = type;
    this.xOffset = 0;
    this.yOffset = 0;
    this.tileX = 12;

    this.animationSpeed = 1;
    switch (type) {
      case "dagger":
        this.frames = 8;
        this.tileY = 24;
        this.yOffset = 0;
        this.xOffset = 0;

        switch (direction) {
          case Direction.DOWN:
            this.yOffset -= 0.75;
            break;
          case Direction.UP:
            this.yOffset += 0.5;
            break;
          case Direction.LEFT:
            this.xOffset += 0.8;
            this.yOffset += 0.25;
            break;
          case Direction.RIGHT:
            this.xOffset -= 0.8;
            this.yOffset -= 0.25;
            break;
        }

        break;
      case "warhammer":
        this.frames = 8;
        this.tileX = 12;
        this.tileY = 32;
        this.yOffset = -0.75;
        this.xOffset = -0;
        this.frame = -5;
        this.animationSpeed = 2;

        switch (direction) {
          case Direction.DOWN:
            this.yOffset -= 0.25;
            this.xOffset += 0.125;
            break;
          case Direction.UP:
            this.yOffset += 1;
            this.xOffset += 0.25;
            break;
          case Direction.LEFT:
            this.xOffset += 0.75;
            this.yOffset += 0.5;
            break;
          case Direction.RIGHT:
            this.xOffset -= 0.75;
            this.yOffset += 0.5;
            break;
        }
        break;

      case "dualdagger":
        this.frames = 8;
        this.tileY = 40;
        this.yOffset = 0;
        this.xOffset = 0;

        switch (direction) {
          case Direction.DOWN:
            this.yOffset -= 1;
            break;
          case Direction.UP:
            this.yOffset += 0.5;
            break;
          case Direction.LEFT:
            this.xOffset += 0.8;
            this.yOffset -= 0.25;
            break;
          case Direction.RIGHT:
            this.xOffset -= 0.8;
            this.yOffset -= 0.25;
            break;
        }
        break;

      case "dualdagger2":
        this.frames = 8;
        this.tileY = 48;
        this.yOffset = 0;
        this.xOffset = 0;
        //this.animationSpeed = 1;

        switch (direction) {
          case Direction.DOWN:
            this.yOffset -= 1;
            break;
          case Direction.UP:
            this.yOffset += 0.5;
            break;
          case Direction.LEFT:
            this.xOffset += 0.8;
            this.yOffset -= 0.25;
            break;
          case Direction.RIGHT:
            this.xOffset -= 0.8;
            this.yOffset -= 0.25;
            break;
        }
        break;
    }
    switch (direction) {
      case Direction.DOWN:
        this.tileYOffset = 0;
        break;
      case Direction.UP:
        this.tileYOffset = 2;
        break;
      case Direction.LEFT:
        this.tileYOffset = 4;
        break;
      case Direction.RIGHT:
        this.tileYOffset = 6;
        break;
    }
  }

  drawTopLayer = (delta: number) => {
    // if (this.frame <= this.frames / 2)
    this.drawAnimation(delta);
  };

  drawAnimation = (delta: number) => {
    if (this.dead) return;
    if (this.frame >= 0) {
      Game.drawFX(
        this.tileX + 2 * Math.round(Math.max(0, this.frame) / 2),
        this.tileY + this.tileYOffset,
        2,
        2,
        this.x - 0.5 + this.xOffset,
        this.y - 0.5 + this.yOffset,
        2,
        2,
      );
    }

    this.frame += this.animationSpeed * delta;
    if (this.frame > this.frames) this.dead = true;
  };
}


--- src/particle/damageNumber.ts ---
import { Game } from "../game";
import { GameConstants } from "../gameConstants";
import { Room } from "../room";
import { Particle } from "./particle";

export class DamageNumber extends Particle {
  room: Room;
  damage: number;
  x: number;
  y: number;
  alpha: number = 1;
  color: string;
  outlineColor: string;
  frame: number = 0;
  xoffset: number = 0;
  constructor(
    room: Room,
    x: number,
    y: number,
    damage: number,
    color?: string,
    outlineColor?: string,
  ) {
    super();
    this.room = room;
    this.damage = damage;
    this.x = x;
    this.y = y;
    if (color) this.color = color;
    else this.color = "red";
    if (outlineColor) this.outlineColor = outlineColor;
    else this.outlineColor = GameConstants.OUTLINE;
    this.xoffset = Random.rand() * 0.2;
  }
  getXoffset = () => {
    if (this.room.particles.length > 0) {
      let damageNumbers = this.room.particles.filter(
        (p) => p instanceof DamageNumber,
      );
      if (damageNumbers.length % 3 === 0) return 0.5;
      if (damageNumbers.length % 3 === 1) return 0;
      if (damageNumbers.length % 3 === 2) return 0.25;
    }
  };

  drawTopLayer = (delta: number) => {
    Game.ctx.save();

    if (this.dead) {
      Game.ctx.restore();
      return;
    }
    if (this.frame > 15) this.alpha -= 0.025 * delta;

    this.y -= 0.03 * delta;
    this.frame += delta;
    let width = Game.measureText(this.damage.toString()).width;
    if (this.alpha <= 0.002) {
      this.alpha = 0;
      this.dead = true;
    }
    Game.ctx.globalAlpha = this.alpha;

    Game.fillTextOutline(
      this.damage.toString(),
      (this.x + 0.4 + this.xoffset) * GameConstants.TILESIZE - width / 2,
      (this.y - 0.6) * GameConstants.TILESIZE,
      this.outlineColor,
      this.color,
    );

    Game.ctx.globalAlpha = 1;

    Game.ctx.restore();
  };
}


--- src/particle/deathParticle.ts ---
import { Game } from "../game";
import { GameConstants } from "../gameConstants";
import { Particle } from "./particle";

export class DeathParticle extends Particle {
  x: number;
  y: number;
  frame: number;

  constructor(x: number, y: number) {
    super();
    this.x = x;
    this.y = y - 1.5;
    this.dead = false;
    this.frame = 0;
  }

  drawTopLayer = (delta: number) => {
    if (this.dead) return;

    let yOffset = Math.max(0, ((this.frame - 3) * 3) / GameConstants.TILESIZE);
    let f = Math.round(this.frame);
    if (f == 2 || f == 4 || f == 6)
      Game.drawMob(2, 0, 1, 2, this.x, this.y - yOffset, 1, 2);
    else
      Game.drawFX(
        Math.round(this.frame),
        4,
        1,
        2,
        this.x,
        this.y - yOffset,
        1,
        2,
      );

    this.frame += 0.3 * delta;
    if (this.frame > 10) this.dead = true;
  };
}


--- src/particle/genericParticle.ts ---
import { Room } from "../room";
import { Particle } from "./particle";
import { Game } from "../game";
import { GameConstants } from "../gameConstants";

export class GenericParticle extends Particle {
  level: Room;
  x: number;
  y: number;
  z: number;
  s: number;
  dx: number;
  dy: number;
  targetX: number;
  targetY: number;
  targetZ: number;
  dz: number;
  color: string;
  alpha: number;
  delay: number;
  expirationTimer: number;

  static shotgun = (
    level: Room,
    cx: number,
    cy: number,
    tx: number,
    ty: number,
    color: string,
  ) => {
    for (let i = 0; i < 4; i++) {
      level.particles.push(
        new GenericParticle(
          level,
          cx,
          cy,
          0,
          Random.rand() * 0.5 + 0.3,
          0,
          0,
          0,
          color,
          0,
          10000000,
          tx + Random.rand() - 0.5,
          ty + Random.rand() - 0.5,
          0,
        ),
      );
    }
  };

  static spawnCluster = (
    level: Room,
    cx: number,
    cy: number,
    color: string,
  ) => {
    for (let i = 0; i < 4; i++) {
      level.particles.push(
        new GenericParticle(
          level,
          cx + Random.rand() * 0.05 - 0.025,
          cy + Random.rand() * 0.05 - 0.025,
          Random.rand() * 0.5,
          0.0625 * (i + 8),
          0.025 * (Random.rand() * 2 - 1),
          0.025 * (Random.rand() * 2 - 1),
          0.2 * (Random.rand() - 1),
          color,
          0,
        ),
      );
    }
  };

  constructor(
    level: Room,
    x: number,
    y: number,
    z: number,
    s: number,
    dx: number,
    dy: number,
    dz: number,
    color: string,
    delay?: number,
    expirationTimer?: number,
    targetX?: number,
    targetY?: number,
    targetZ?: number,
  ) {
    super();
    this.level = level;
    this.x = x;
    this.y = y;
    this.z = z;
    this.s = s;
    this.dx = dx;
    this.dy = dy;
    this.dz = dz;
    this.color = color;
    this.alpha = 1.0;
    if (delay !== undefined) this.delay = delay;
    this.targetX = targetX;
    this.targetY = targetY;
    this.targetZ = targetZ;
    this.expirationTimer = 1000000;
    if (expirationTimer !== undefined) this.expirationTimer = expirationTimer;
  }

  render = () => {
    let scale = GameConstants.TILESIZE;
    let scaledS = this.s * this.alpha; // using alpha for scaling, not alpha
    let halfS = 0.5 * scaledS;
    let oldFillStyle = Game.ctx.fillStyle;
    Game.ctx.fillStyle = this.color;
    Game.ctx.imageSmoothingEnabled = false;

    Game.ctx.beginPath();
    Game.ctx.arc(
      Math.round(this.x * scale),
      Math.round((this.y - this.z) * scale),
      Math.round(halfS * scale),
      0,
      2 * Math.PI,
      false,
    );
    Game.ctx.fill();

    Game.ctx.fillStyle = oldFillStyle;
  };

  draw = (delta: number) => {
    if (this.targetX) this.x += 0.1 * (this.targetX - this.x);
    else this.x += this.dx;
    if (this.targetY) this.y += 0.1 * (this.targetY - this.y);
    else this.y += this.dy;
    if (this.targetZ) this.z += 0.1 * (this.targetZ - this.z);
    else this.z += this.dz;

    this.dx *= 0.97;
    this.dy *= 0.97;
    if (this.z <= 0) {
      this.z = 0;
      this.dz *= -0.8;
    }

    // apply gravity
    this.dz -= 0.01;

    if (this.alpha < 0.2) this.alpha -= 0.007;
    else this.alpha -= 0.02;
    if (this.alpha <= 0.1) this.dead = true;

    this.expirationTimer--;
    if (this.expirationTimer <= 0) this.dead = true;

    if (this.dead) return;

    this.drawableY = this.y;

    this.render();
  };
}


--- src/particle/imageParticle.ts ---
import { Room } from "../room";
import { Particle } from "./particle";
import { Direction, Game } from "../game";
import { GameConstants } from "../gameConstants";
import { Random } from "../random";
import { Player, PlayerDirection } from "../player";
import { Entity } from "../entity/entity";

export class ImageParticle extends Particle {
  room: Room;
  x: number;
  y: number;
  z: number;
  s: number;
  dx: number;
  dy: number;
  targetX: number;
  targetY: number;
  targetZ: number;
  dz: number;
  color: string;
  alpha: number;
  delay: number;
  expirationTimer: number;
  tileX: number;
  tileY: number;
  size: number;
  static shotgun = (
    room: Room,
    cx: number,
    cy: number,
    tx: number,
    ty: number,
    tileX: number,
    tileY: number,
  ) => {
    for (let i = 0; i < 4; i++) {
      room.particles.push(
        new ImageParticle(
          room,
          cx,
          cy,
          0,
          Random.rand() * 0.5 + 0.3,
          0,
          0,
          0,
          tileX,
          tileY,
          0, //size
        ),
      );
    }
  };

  static spawnCluster = (
    level: Room,
    cx: number,
    cy: number,
    tileX: number,
    tileY: number,
  ) => {
    for (let i = Math.floor(Random.rand() * 3); i < 5; i++) {
      level.particles.push(
        new ImageParticle(
          level,
          cx + Random.rand() * 0.05 - 0.025, // x
          cy + Random.rand() * 0.05 - 0.025, // y
          Random.rand() * 0.5, // z
          0.0625 * (i + 8), // s
          0.025 * (Random.rand() * 2 - 1), //dx
          0.025 * (Random.rand() * 2 - 1), //dy
          0.2 * (Random.rand() - 1), //dz
          tileX,
          tileY,
          [2, 1, 0, 1, 2, 2, 2][i], //size
        ),
      );
    }
  };

  constructor(
    room: Room,
    x: number,
    y: number,
    z: number,
    s: number,
    dx: number,
    dy: number,
    dz: number,
    tileX: number,
    tileY: number,
    size: number,
    delay?: number,
    expirationTimer?: number,
    targetX?: number,
    targetY?: number,
    targetZ?: number,
  ) {
    super();
    this.room = room;
    this.x = x;
    this.y = y;
    this.z = z; // Use provided height
    this.s = s;
    this.dx = dx;
    this.dy = dy;
    this.dz = dz;
    this.tileX = tileX;
    this.tileY = tileY;
    this.size = size;
    this.alpha = 1.0;
    if (delay !== undefined) this.delay = delay;
    this.targetX = targetX;
    this.targetY = targetY;
    this.targetZ = targetZ;
    this.expirationTimer = 100; // Increased life duration
    if (expirationTimer !== undefined) this.expirationTimer = expirationTimer;
  }

  render = () => {
    let scale = GameConstants.TILESIZE;
    let yOffset = this.z * scale;
    let frame = this.s > 0.5 ? 1 : 0; // Placeholder frames for large and small particles
    Game.ctx.imageSmoothingEnabled = false;

    let adjustedTileX = this.tileX + this.size;
    Game.drawFX(
      adjustedTileX,
      this.tileY,
      1,
      1,
      this.x - this.alpha / 2,
      this.y - this.z - this.alpha / 2,
      1,
      1,
      this.shadeColor(),
      this.shadeAmount(),
    );
  };

  draw = (delta: number) => {
    Game.ctx.imageSmoothingEnabled = false;

    if (this.targetX) this.x += 0.2 * (this.targetX - this.x) * delta;
    else this.x += this.dx * delta;
    if (this.targetY) this.y += 0.2 * (this.targetY - this.y) * delta;
    else this.y += this.dy * delta;
    if (this.targetZ) this.z += 0.2 * (this.targetZ - this.z) * delta;
    else this.z += this.dz * delta;

    this.dx *= Math.pow(0.97, delta);
    this.dy *= Math.pow(0.97, delta);
    if (this.z <= 0) {
      this.z = 0;
      this.dz *= -0.8;
    }

    this.dz -= 0.01 * delta;

    this.expirationTimer -= delta;
    if (this.expirationTimer <= 0) this.dead = true;

    if (this.dead) return;

    this.drawableY = this.y;

    this.render();
  };
}


--- src/particle/particle.ts ---
import { Drawable } from "../drawable";
import { Entity } from "../entity/entity";
import { Player } from "../player";
import { Room } from "../room";

export class Particle extends Drawable {
  x: number;
  y: number;
  dead: boolean;
  room: Room;
  drawTopLayer = (delta) => {};
  shadeAmount = () => {
    const x = Math.floor(this.x);
    const y = Math.floor(this.y);

    if (!this.room.softVis[x]) return 0.9;

    const shade = this.room.softVis[x][y];
    return shade ?? 0.9;
  };
  shadeColor = () => {
    return this.room.shadeColor;
  };
}


--- src/particle/wizardTeleportParticle.ts ---
import { Particle } from "./particle";
import { Game } from "../game";

export class WizardTeleportParticle extends Particle {
  x: number;
  y: number;
  z: number;
  dz: number;
  frame: number;
  dead: boolean;

  constructor(x: number, y: number) {
    super();
    this.x = x;
    this.y = y;
    this.dead = false;
    this.frame = 0;
    this.z = 0;
    this.dz = 0.1;
  }

  draw = (delta: number) => {
    if (this.dead) return;
    Game.drawFX(Math.floor(this.frame), 3, 1, 1, this.x, this.y - this.z, 1, 1);
    this.z += this.dz * delta;
    this.dz *= 0.9;
    this.frame += 0.3 * delta;
    if (this.frame > 6) this.dead = true;
  };
}


--- src/player.ts ---
import { Input, InputEnum } from "./input";
import { GameConstants } from "./gameConstants";
import { ChatMessage, Direction, Game, LevelState } from "./game";
import { Door, DoorType } from "./tile/door";
import { Trapdoor } from "./tile/trapdoor";
import { Inventory } from "./inventory";
import { Sound } from "./sound";
import { LevelConstants } from "./levelConstants";
import { Map } from "./map";
import { SlashParticle } from "./particle/slashParticle";
import { HealthBar } from "./healthbar";
import { VendingMachine } from "./entity/object/vendingMachine";
import { Drawable } from "./drawable";
import { Random } from "./random";
import { GenericParticle } from "./particle/genericParticle";
import { ActionState, ActionTab } from "./actionTab";
import { HitWarning } from "./hitWarning";
import { Entity, EntityType } from "./entity/entity";
import { ZombieEnemy } from "./entity/enemy/zombieEnemy";
import { Item } from "./item/item";
import { PostProcessor } from "./postProcess";
import { Weapon } from "./weapon/weapon";
import { Room } from "./room";
import { ImageParticle } from "./particle/imageParticle";
import { Enemy } from "./entity/enemy/enemy";
import { MouseCursor } from "./mouseCursor";
import { Light } from "./item/light";
import { LightSource } from "./lightSource";
import { statsTracker } from "./stats";
import { BeamEffect } from "./beamEffect";
import { Spellbook } from "./weapon/spellbook";
import { globalEventBus } from "./eventBus";
import { Utils } from "./utils";
import { Menu } from "./menu";
import { Bestiary } from "./bestiary";
import { AttackAnimation } from "./particle/attackAnimation";

export enum PlayerDirection {
  DOWN,
  UP,
  RIGHT,
  LEFT,
}

enum DrawDirection {
  X,
  Y,
}

export class Player extends Drawable {
  id: string;
  x: number;
  y: number;
  w: number;
  h: number;
  drawX: number;
  drawY: number;
  hitX: number;
  hitY: number;
  frame: number;
  direction: Direction;
  game: Game;
  levelID: number; // which room we're in (level[levelID])
  flashing: boolean;
  flashingFrame: number;
  health: number;
  maxHealth: number;
  healthBar: HealthBar;
  dead: boolean;
  lastTickHealth: number;
  inventory: Inventory;
  sightRadius: number;
  defaultSightRadius: number;
  static minSightRadius: number = 2; //hard minimum sight radius that ignores depth
  guiHeartFrame: number;
  map: Map;
  openVendingMachine: VendingMachine;
  isLocalPlayer: boolean;
  mapToggled: boolean;
  //actionTab: ActionTab;
  lastHitBy: string;
  turnCount: number;
  triedMove: boolean;
  tutorialRoom: boolean;
  private lastMoveTime: number;
  private moveCooldown: number;
  moveRange: number;
  tileCursor: { x: number; y: number };
  private jumpY: number;
  lightEquipped: boolean;
  lightSource: LightSource;
  hurtAlpha: number;
  hurting: boolean; // handles drawing hurt animation
  hurtingShield: boolean; // handles drawing hurt shield animation
  hurtShield: boolean; // handles logic to take damage or not
  lightBrightness: number;
  sineAngle: number;
  drawMoveSpeed: number;
  jumpHeight: number;
  moveDistance: number;
  moveQueue: { x: number; y: number; direction: Direction }[];
  lastX: number;
  lastY: number;
  motionSpeed: number;
  slowMotionEnabled: boolean;
  justMoved: DrawDirection;
  slowMotionTickDuration: number;
  depth: number;
  menu: Menu;
  busyAnimating: boolean;
  private animationFrameId: number | null = null;
  private isProcessingQueue: boolean = false;
  private lowHealthFrame: number = 0;
  private drawMoveQueue: {
    drawX: number;
    drawY: number;
  }[] = [];

  seenEnemies: Set<typeof Enemy> = new Set();
  bestiary: Bestiary = null;
  constructor(game: Game, x: number, y: number, isLocalPlayer: boolean) {
    super();

    this.game = game;

    this.levelID = 0;

    this.x = x;
    this.y = y;
    this.w = 1;
    this.h = 1;
    this.drawX = 0;
    this.drawY = 0;
    this.jumpY = 0;
    this.jumpHeight = 0.3;
    this.frame = 0;
    this.moveDistance = 0;
    this.direction = Direction.UP;
    this.lastX = 0;
    this.lastY = 0;
    this.isLocalPlayer = isLocalPlayer;
    this.depth = 0;
    this.menu = new Menu();
    this.busyAnimating = false;
    if (isLocalPlayer) {
      Input.leftSwipeListener = () => {
        if (
          !this.inventory.isPointInQuickbarBounds(Input.mouseX, Input.mouseY)
            .inBounds &&
          !this.inventory.isOpen
        )
          this.inputHandler(InputEnum.LEFT);
      };

      Input.rightSwipeListener = () => {
        if (
          !this.inventory.isPointInQuickbarBounds(Input.mouseX, Input.mouseY)
            .inBounds &&
          !this.inventory.isOpen
        )
          this.inputHandler(InputEnum.RIGHT);
      };

      Input.upSwipeListener = () => {
        if (
          !this.inventory.isPointInQuickbarBounds(Input.mouseX, Input.mouseY)
            .inBounds &&
          !this.inventory.isOpen
        )
          this.inputHandler(InputEnum.UP);
      };

      Input.downSwipeListener = () => {
        if (
          !this.inventory.isPointInQuickbarBounds(Input.mouseX, Input.mouseY)
            .inBounds &&
          !this.inventory.isOpen
        )
          this.inputHandler(InputEnum.DOWN);
      };

      Input.commaListener = () => this.inputHandler(InputEnum.COMMA);
      Input.periodListener = () => this.inputHandler(InputEnum.PERIOD);
      Input.tapListener = () => {
        if (this.dead) {
          this.restart();
        } else if (!this.game.started) {
          this.game.startedFadeOut = true;
          return;
        }
        const mouseInBounds = this.inventory.isPointInInventoryBounds(
          Input.mouseX,
          Input.mouseY,
        ).inBounds;

        if (
          !this.inventory.isOpen &&
          this.inventory.isPointInInventoryButton(Input.mouseX, Input.mouseY)
        ) {
          this.inventory.open();
        } else if (this.inventory.isOpen) {
          if (mouseInBounds) {
            this.inputHandler(InputEnum.LEFT_CLICK);
          } else if (!mouseInBounds) {
            this.inventory.close();
          }
        }

        {
          if (
            this.inventory.isPointInQuickbarBounds(Input.mouseX, Input.mouseY)
              .inBounds
          ) {
            if (this.inventory.pointInside(Input.mouseX, Input.mouseY)) {
              this.inputHandler(InputEnum.LEFT_CLICK);
            }
          }
        }
      };
      Input.mouseMoveListener = () => this.inputHandler(InputEnum.MOUSE_MOVE);
      Input.mouseLeftClickListeners.push(() =>
        this.inputHandler(InputEnum.LEFT_CLICK),
      );
      Input.mouseRightClickListeners.push(() =>
        this.inputHandler(InputEnum.RIGHT_CLICK),
      );
      Input.numKeyListener = (num: number) =>
        this.inputHandler(InputEnum.NUMBER_1 + num - 1);
      Input.equalsListener = () => this.inputHandler(InputEnum.EQUALS);
      Input.minusListener = () => this.inputHandler(InputEnum.MINUS);
      Input.escapeListener = () => this.inputHandler(InputEnum.ESCAPE);
    }
    this.mapToggled = true;
    this.health = 2;
    this.maxHealth = 2;
    this.healthBar = new HealthBar();
    this.dead = false;
    this.flashing = false;
    this.flashingFrame = 0;
    this.lastTickHealth = this.health;
    this.guiHeartFrame = 0;

    this.inventory = new Inventory(game, this);
    this.defaultSightRadius = 3;
    this.sightRadius = LevelConstants.LIGHTING_MAX_DISTANCE; //this.defaultSightRadius;
    this.map = new Map(this.game, this);
    //this.actionTab = new ActionTab(this.inventory, this.game);
    this.turnCount = 0;
    this.triedMove = false;
    this.tutorialRoom = false;
    this.lastMoveTime = 0;
    this.moveCooldown = 100; // Cooldown in milliseconds (adjust as needed)
    this.tileCursor = { x: 0, y: 0 };
    this.moveRange = 1;
    this.lightEquipped = false;
    this.hurting = false;
    this.hurtingShield = false;
    this.hurtShield = false;
    this.hurtAlpha = 0.25;
    this.lightBrightness = 0.3;
    this.sineAngle = Math.PI / 2;
    this.drawMoveSpeed = 0.3; // greater than 1 less than 2
    this.moveQueue = [];
    this.isProcessingQueue = false;

    this.hitX = 0;
    this.hitY = 0;
    this.motionSpeed = 1;
    this.slowMotionEnabled = false;
    this.slowMotionTickDuration = 0;
    this.justMoved = DrawDirection.Y;

    this.bestiary = new Bestiary(this.game, this);
  }

  get angle(): number {
    if (this.direction !== undefined) {
      switch (this.direction) {
        case Direction.UP:
          return 270;
        case Direction.RIGHT:
          return 0;
        case Direction.DOWN:
          return 90;
        case Direction.LEFT:
          return 180;
      }
    } else {
      return 0;
    }
  }

  applyStatus = (
    enemy: Entity,
    status: { poison: boolean; blood: boolean },
  ) => {
    if (enemy instanceof Enemy) {
      if (status.poison) {
        enemy.poison();
        return true;
      }
      if (status.blood) {
        enemy.bleed();
        return true;
      }
    }
  };

  inputHandler = (input: InputEnum) => {
    if (this.busyAnimating) return;
    if (this.menu.open) {
      this.menu.inputHandler(input);
      return;
    }
    if (!this.game.started && input !== InputEnum.MOUSE_MOVE) {
      this.game.startedFadeOut = true;
      return;
    }
    switch (input) {
      case InputEnum.I:
        this.iListener();
        break;
      case InputEnum.Q:
        this.qListener();
        break;
      case InputEnum.LEFT:
        if (!this.ignoreDirectionInput()) this.leftListener(false);
        break;
      case InputEnum.RIGHT:
        if (!this.ignoreDirectionInput()) this.rightListener(false);
        break;
      case InputEnum.UP:
        if (!this.ignoreDirectionInput()) this.upListener(false);
        break;
      case InputEnum.DOWN:
        if (!this.ignoreDirectionInput()) this.downListener(false);
        break;
      case InputEnum.SPACE:
        this.spaceListener();
        break;
      case InputEnum.COMMA:
        this.commaListener();
        break;
      case InputEnum.PERIOD:
        this.periodListener();
        break;
      case InputEnum.LEFT_CLICK:
        this.mouseLeftClick();
        break;
      case InputEnum.RIGHT_CLICK:
        this.mouseRightClick();
        break;
      case InputEnum.MOUSE_MOVE:
        this.mouseMove();
        break;
      case InputEnum.NUMBER_1:
      case InputEnum.NUMBER_2:
      case InputEnum.NUMBER_3:
      case InputEnum.NUMBER_4:
      case InputEnum.NUMBER_5:
      case InputEnum.NUMBER_6:
      case InputEnum.NUMBER_7:
      case InputEnum.NUMBER_8:
      case InputEnum.NUMBER_9:
        this.numKeyListener(input);
        break;
      case InputEnum.EQUALS:
        this.plusListener();
        break;
      case InputEnum.MINUS:
        this.minusListener();
        break;
      case InputEnum.ESCAPE:
        this.escapeListener();
        break;
    }
  };
  escapeListener = () => {
    if (this.inventory.isOpen) {
      this.inventory.close();
    }
  };
  commaListener = () => {
    this.inventory.mostRecentInput = "keyboard";
    this.inventory.left();
  };
  periodListener = () => {
    this.inventory.mostRecentInput = "keyboard";
    this.inventory.right();
  };
  numKeyListener = (input: InputEnum) => {
    this.inventory.mostRecentInput = "keyboard";
    this.inventory.handleNumKey(input - 13);
  };

  tapListener = () => {
    this.inventory.mostRecentInput = "mouse";
    this.inventory.open();
  };
  iListener = () => {
    this.inventory.open();
  };
  qListener = () => {
    if (this.inventory.isOpen) {
      this.inventory.drop();
    }
  };
  ignoreDirectionInput = (): boolean => {
    return (
      !this.inventory.isOpen &&
      (this.dead || this.game.levelState !== LevelState.IN_LEVEL)
    );
  };
  leftListener = (isLocal: boolean): boolean => {
    this.inventory.mostRecentInput = "keyboard";
    if (this.inventory.isOpen) {
      this.inventory.left();
      return true;
    }
    if (
      !this.dead &&
      (!isLocal || this.game.levelState === LevelState.IN_LEVEL)
    ) {
      this.left();
      return true;
    }

    return false;
  };
  rightListener = (isLocal: boolean): boolean => {
    this.inventory.mostRecentInput = "keyboard";
    if (this.inventory.isOpen) {
      this.inventory.right();
      return true;
    }
    if (
      !this.dead &&
      (!isLocal || this.game.levelState === LevelState.IN_LEVEL)
    ) {
      this.right();
      return true;
    }

    return false;
  };
  upListener = (isLocal: boolean): boolean => {
    this.inventory.mostRecentInput = "keyboard";
    if (this.inventory.isOpen) {
      this.inventory.up();
      return true;
    }
    if (
      !this.dead &&
      (!isLocal || this.game.levelState === LevelState.IN_LEVEL)
    ) {
      this.up();
      return true;
    }

    return false;
  };
  downListener = (isLocal: boolean): boolean => {
    this.inventory.mostRecentInput = "keyboard";
    if (this.inventory.isOpen) {
      this.inventory.down();
      return true;
    }
    if (
      !this.dead &&
      (!isLocal || this.game.levelState === LevelState.IN_LEVEL)
    ) {
      this.down();
      return true;
    }

    return false;
  };
  spaceListener = () => {
    this.inventory.mostRecentInput = "keyboard";
    if (!this.game.chatOpen) {
      if (this.dead) {
        this.restart();
      } else if (this.openVendingMachine) {
        this.openVendingMachine.space();
      } else if (
        this.inventory.isOpen ||
        this.game.levelState === LevelState.IN_LEVEL
      ) {
        this.inventory.space();
        return;
      }
    }
  };

  plusListener = () => {
    0;
    GameConstants.INCREASE_SCALE();
    this.game.onResize();
  };
  minusListener = () => {
    GameConstants.DECREASE_SCALE();
    this.game.onResize();
  };

  mouseLeftClick = () => {
    this.inventory.mostRecentInput = "mouse";
    const mousePos = MouseCursor.getInstance().getPosition();
    const { x, y } = mousePos;

    if (this.dead) {
      this.restart();
      return;
    }

    if (
      (this.inventory.isOpen &&
        !this.inventory.isPointInInventoryBounds(x, y).inBounds) ||
      this.inventory.isPointInInventoryButton(x, y)
    ) {
      this.inventory.toggleOpen();
    }

    if (this.openVendingMachine) {
      if (
        VendingMachine.isPointInVendingMachineBounds(
          x,
          y,
          this.openVendingMachine,
        )
      ) {
        this.openVendingMachine.space();
      } else {
        this.inventory.mouseLeftClick();
      }
      return;
    }
    const notInInventoryUI =
      !this.inventory.isPointInInventoryButton(x, y) &&
      !this.inventory.isPointInQuickbarBounds(x, y).inBounds &&
      !this.inventory.isOpen;

    if (notInInventoryUI) {
      this.moveWithMouse();
    }
  };
  mouseRightClick = () => {
    this.inventory.mostRecentInput = "mouse";
    this.inventory.mouseRightClick();
  };

  mouseMove = () => {
    //when mouse moves
    this.inventory.mostRecentInput = "mouse";
    this.inventory.mouseMove();
    this.faceMouse();
    this.setTileCursorPosition();
  };
  isMouseOnPlayerTile = () => {
    return this.mouseToTile().x === this.x && this.mouseToTile().y === this.y;
  };

  isMouseAboveFloor = (offsetY: number = 0) => {
    return !(
      !this.game.room.tileInside(
        this.mouseToTile().x,
        this.mouseToTile(offsetY).y,
      ) ||
      (this.game.room.tileInside(
        this.mouseToTile().x,
        this.mouseToTile(offsetY).y,
      ) &&
        this.game.room.roomArray[this.mouseToTile().x][
          this.mouseToTile(offsetY).y
        ].isSolid() &&
        !(
          this.game.room.roomArray[this.mouseToTile().x][
            this.mouseToTile(offsetY).y
          ] instanceof Door
        ))
    );
  };

  mouseInLine = () => {
    const mouseTile = this.mouseToTile();
    return mouseTile.x === this.x || mouseTile.y === this.y;
  };

  canMoveWithMouse = () => {
    if (!this.isMouseAboveFloor() && !this.isMouseAboveFloor(8)) return;

    const mouseTile = this.mouseToTile();
    const offsetMouseTile = this.mouseToTile(8);
    let y = mouseTile.y;

    if (this.isMouseAboveFloor(8) && this.checkTileForEntity(offsetMouseTile)) {
      y = offsetMouseTile.y;
    }
    // Get mouse tile coordinates

    // Check if we're on same row or column
    const sameX = mouseTile.x === this.x;
    const sameY = y === this.y;

    // If both same, no movement needed
    if (sameX && sameY) return null;

    // Check for straight line movements first
    if (sameX) {
      if (y < this.y) {
        return { direction: Direction.UP, x: this.x, y: this.y - 1 };
      } else {
        return { direction: Direction.DOWN, x: this.x, y: this.y + 1 };
      }
    }
    if (sameY) {
      if (mouseTile.x < this.x) {
        return { direction: Direction.LEFT, x: this.x - 1, y: this.y };
      } else {
        return { direction: Direction.RIGHT, x: this.x + 1, y: this.y };
      }
    }
    /*
    // Fall back to angle-based approach for diagonal mouse positions
    const playerScreenX = GameConstants.WIDTH / 2;
    const playerScreenY = GameConstants.HEIGHT / 2;
    const dx = Input.mouseX - playerScreenX;
    const dy = Input.mouseY - playerScreenY;

    let angle = (Math.atan2(-dy, dx) * 180) / Math.PI;
    if (angle < 0) angle += 360;

    if (angle >= 310 || angle < 10) {
      return { direction: Direction.RIGHT, x: this.x + 1, y: this.y };
    } else if (angle >= 40 && angle < 140) {
      return { direction: Direction.UP, x: this.x, y: this.y - 1 };
    } else if (angle >= 130 && angle < 230) {
      return { direction: Direction.LEFT, x: this.x - 1, y: this.y };
    } else if (angle >= 220 && angle < 320) {
      return { direction: Direction.DOWN, x: this.x, y: this.y + 1 };
    }
      */
    return null;
  };

  moveWithMouse = () => {
    const moveData = this.canMoveWithMouse();
    if (moveData) {
      this.direction = moveData.direction;
      this.tryMove(moveData.x, moveData.y);
    }
  };

  mouseToTile = (offsetY: number = 0) => {
    // Get screen center coordinates
    const screenCenterX = GameConstants.WIDTH / 2;
    const screenCenterY = GameConstants.HEIGHT / 2;

    // Convert pixel offset to tile offset (this part was working correctly)
    const tileOffsetX = Math.floor(
      (Input.mouseX - screenCenterX + GameConstants.TILESIZE / 2) /
        GameConstants.TILESIZE,
    );
    const tileOffsetY = Math.floor(
      (Input.mouseY + offsetY - screenCenterY + GameConstants.TILESIZE / 2) /
        GameConstants.TILESIZE,
    );

    return {
      x: this.x + tileOffsetX,
      y: this.y + tileOffsetY,
    };
  };

  tileToMouse = (tileX, tileY) => {
    // Get screen center coordinates
    const screenCenterX = GameConstants.WIDTH / 2;
    const screenCenterY = GameConstants.HEIGHT / 2;

    // Calculate the offset from the center position
    const tileOffsetX = tileX - this.x;
    const tileOffsetY = tileY - this.y;

    // Convert tile offset to pixel coordinates
    const pixelX = screenCenterX + tileOffsetX * GameConstants.TILESIZE;
    const pixelY = screenCenterY + tileOffsetY * GameConstants.TILESIZE;

    return {
      x: pixelX,
      y: pixelY,
    };
  };

  tryVaultOver = (x: number, y: number, direction: PlayerDirection) => {
    switch (direction) {
      case PlayerDirection.UP:
        this.tryMove(x, y - 1);
        break;
      case PlayerDirection.DOWN:
        this.tryMove(x, y + 1);
        break;
      case PlayerDirection.LEFT:
        this.tryMove(x - 1, y);
        break;
      case PlayerDirection.RIGHT:
        this.tryMove(x + 1, y);
        break;
    }
  };

  moveRangeCheck = (x: number, y: number) => {
    const dx = Math.abs(this.x - x);
    const dy = Math.abs(this.y - y);
    return (
      dx <= this.moveRange &&
      dy <= this.moveRange &&
      (dx === 0 || dy === 0) &&
      dx + dy !== 0
    );
  };

  setTileCursorPosition = () => {
    const offsetX =
      Math.floor(GameConstants.WIDTH / 2) / GameConstants.TILESIZE;

    const offsetY =
      Math.floor(GameConstants.HEIGHT / 2) / GameConstants.TILESIZE;
    /*
    this.tileCursor = {
      x: this.mouseToTile().x - this.x + offsetX - 0.5,
      y: this.mouseToTile().y - this.y + offsetY - 0.5,
    };
    */

    const moveData = this.canMoveWithMouse();
    if (moveData) {
      this.tileCursor = {
        x: moveData.x - this.x + offsetX - 0.5,
        y: moveData.y - this.y + offsetY - 0.5,
      };
    }
  };

  enemyInRange = (eX: number, eY: number, range: number | null) => {
    // Use nullish coalescing operator for cleaner default value
    const r = range ?? 1;

    // Same tile - not in range
    if (eX === this.x && eY === this.y) return false;

    // Diagonal - not in range
    if (eX !== this.x && eY !== this.y) return false;

    // Check horizontal range
    if (eY === this.y) {
      return Math.abs(eX - this.x) <= r;
    }

    // Check vertical range
    if (eX === this.x) {
      return Math.abs(eY - this.y) <= r;
    }

    return false;
  };

  getDirectionFromCoords = (inputX: number, inputY: number): string => {
    // Same position - no direction
    if (inputX === this.x && inputY === this.y) return "";

    // Diagonal - no direction
    if (inputX !== this.x && inputY !== this.y) return "";

    // Check horizontal
    if (inputY === this.y) {
      return inputX > this.x ? "right" : "left";
    }

    // Check vertical
    if (inputX === this.x) {
      return inputY > this.y ? "down" : "up";
    }

    return "arrow";
  };

  setCursorIcon = () => {
    // Early return cases
    if (this.inventory.isDragging) {
      MouseCursor.getInstance().setIcon("grab");
      return;
    }

    const cursor = MouseCursor.getInstance();
    const mousePos = cursor.getPosition();
    const mouseTile = this.mouseToTile();

    // Check cursor states in order of priority
    const cursorState = this.getCursorState(mousePos, mouseTile);
    cursor.setIcon(cursorState);
  };

  private getCursorState = (
    mousePos: { x: number; y: number },
    mouseTile: { x: number; y: number },
  ): string => {
    // 1. Check UI interactions
    if (this.isMouseInUI(mousePos)) {
      return "hand";
    }
    if (this.isEntityAttackable(mouseTile)) {
      return "sword";
    }

    // 2. Check game world interactions
    if (this.isMouseAboveFloor() && this.mouseInLine()) {
      // 2a. Check for attackable entities

      // 2b. Check for movement target
      if (this.enemyInRange(mouseTile.x, mouseTile.y, 1)) {
        return this.getDirectionFromCoords(mouseTile.x, mouseTile.y);
      }

      // 2c. Default floor interaction
      return "hand";
    }

    // 3. Default cursor state
    return "arrow";
  };

  private isMouseInUI = (mousePos: { x: number; y: number }): boolean => {
    const { x, y } = mousePos;

    return (
      this.inventory.isPointInInventoryButton(x, y) ||
      this.isInventoryItemInteraction(x, y)
    );
  };

  private isInventoryItemInteraction = (x: number, y: number): boolean => {
    const hasSelectedItem = this.inventory.itemAtSelectedSlot() instanceof Item;

    return (
      (this.inventory.isPointInQuickbarBounds(x, y).inBounds &&
        hasSelectedItem) ||
      (this.inventory.isOpen &&
        this.inventory.isPointInInventoryBounds(x, y).inBounds &&
        hasSelectedItem)
    );
  };

  private isEntityAttackable = (mouseTile: {
    x: number;
    y: number;
  }): boolean => {
    // Check current tile
    const currentTileCheck = this.checkTileForEntity(mouseTile);
    if (currentTileCheck) return true;

    // Check tile above with 0.5 tile offset
    const belowTileCheck = this.checkTileForEntity({
      x: mouseTile.x,
      y: this.mouseToTile(GameConstants.TILESIZE / 2).y,
    });

    return belowTileCheck;
  };

  private checkTileForEntity = (tile: { x: number; y: number }): boolean => {
    return this.game.room.entities.some((entity) => {
      return (
        entity.x === tile.x &&
        entity.y === tile.y &&
        this.enemyInRange(entity.x, entity.y, this.inventory.weapon.range)
      );
    });
  };

  restart = () => {
    this.dead = false;
    this.game.newGame();
  };

  left = () => {
    const { x, y } = { x: this.x - 1, y: this.y };
    if (this.canMove()) {
      this.direction = Direction.LEFT;
      {
        this.tryMove(x, y);
      }
    } else this.queueMove(x, y, Direction.LEFT);
  };
  right = () => {
    const { x, y } = { x: this.x + 1, y: this.y };
    if (this.canMove()) {
      this.direction = Direction.RIGHT;
      {
        this.tryMove(x, y);
      }
    } else this.queueMove(x, y, Direction.RIGHT);
  };
  up = () => {
    const { x, y } = { x: this.x, y: this.y - 1 };

    if (this.canMove()) {
      this.direction = Direction.UP;
      {
        this.tryMove(x, y);
      }
    } else this.queueMove(x, y, Direction.UP);
  };
  down = () => {
    const { x, y } = { x: this.x, y: this.y + 1 };

    if (this.canMove()) {
      this.direction = Direction.DOWN;
      {
        this.tryMove(x, y);
      }
    } else this.queueMove(x, y, Direction.DOWN);
  };

  hit = (): number => {
    return 1;
  };

  tryCollide = (other: any, newX: number, newY: number) => {
    if (newX >= other.x + other.w || newX + this.w <= other.x) return false;
    if (newY >= other.y + other.h || newY + this.h <= other.y) return false;
    return true;
  };

  tryMove = (x: number, y: number) => {
    if (this.busyAnimating) return;
    let slowMotion = this.slowMotionEnabled;
    let newMove = { x: x, y: y };
    // TODO don't move if hit by enemy
    this.game.levels[this.depth].rooms[this.levelID].catchUp();
    if (this.dead) return;

    for (let i = 0; i < 2; i++)
      if (
        this.inventory.hasWeapon() &&
        !this.inventory.getWeapon().weaponMove(x, y)
      ) {
        //for (let h of this.game.levels[this.levelID].hitwarnings) {
        //if (newMove instanceof HitWarning)
        return;
        //}
      }

    for (let e of this.game.levels[this.depth].rooms[this.levelID].entities) {
      e.lastX = e.x;
      e.lastY = e.y;
      //console.log(`e.lastX, e.lastY: ${e.lastX}, ${e.lastY}`);
      if (this.tryCollide(e, x, y)) {
        if (e.pushable) {
          // pushing a crate or barrel

          let dx = x - this.x;
          let dy = y - this.y;
          let nextX = x + dx;
          let nextY = y + dy;
          let foundEnd = false; // end of the train of whatever we're pushing
          let enemyEnd = false; // end of the train is a solid enemy (i.e. potted plant)
          let pushedEnemies = [];
          while (true) {
            foundEnd = true;
            for (const f of this.game.levels[this.depth].rooms[this.levelID]
              .entities) {
              f.lastX = f.x;
              f.lastY = f.y;
              if (f.pointIn(nextX, nextY)) {
                if (!f.chainPushable) {
                  enemyEnd = true;
                  foundEnd = true;
                  break;
                }
                foundEnd = false;
                pushedEnemies.push(f);
                break;
              }
            }
            if (foundEnd) break;
            nextX += dx * pushedEnemies[pushedEnemies.length - 1].w;
            nextY += dy * pushedEnemies[pushedEnemies.length - 1].h;
          }
          /* if no enemies and there is a wall, no move
          otherwise, push everything, killing last enemy if there is a wall */
          // here, (nextX, nextY) is the position immediately after the end of the train

          if (
            pushedEnemies.length === 0 &&
            (this.game.levels[this.depth].rooms[this.levelID].roomArray[nextX][
              nextY
            ].canCrushEnemy() ||
              enemyEnd)
          ) {
            if (e.destroyable) {
              e.hurt(this, e.health, "none");
              if (
                this.game.levels[this.depth].rooms[this.levelID] ===
                this.game.room
              )
                Sound.hit();

              this.shakeScreen(this.x, this.y, e.x, e.y);
              this.hitShake(this.x, this.y, e.x, e.y);

              this.game.levels[this.depth].rooms[this.levelID].tick(this);
              return;
            }
          } else {
            if (
              this.game.levels[this.depth].rooms[this.levelID] ===
              this.game.room
            )
              Sound.push();
            // here pushedEnemies may still be []

            for (const f of pushedEnemies) {
              f.lastX = f.x;
              f.lastY = f.y;
              f.x += dx;
              f.y += dy;
              f.drawX = dx;
              f.drawY = dy;
              f.skipNextTurns = 1; // skip next turn, so they don't move while we're pushing them
            }
            if (
              this.game.levels[this.depth].rooms[this.levelID].roomArray[nextX][
                nextY
              ].canCrushEnemy() ||
              enemyEnd
            ) {
              pushedEnemies[pushedEnemies.length - 1].crush();
              if (
                this.game.levels[this.depth].rooms[this.levelID] ===
                this.game.room
              )
                Sound.hit();
            }

            e.x += dx;
            e.y += dy;
            e.drawX = dx;
            e.drawY = dy;
            this.move(x, y);
            this.moveDistance++;
            this.game.levels[this.depth].rooms[this.levelID].tick(this);
            return;
          }
        } else {
          // if we're trying to hit an enemy, check if it's destroyable
          if (!e.dead) {
            if (e.interactable) e.interact(this);
            //this.actionTab.actionState = ActionState.ATTACK;
            //sets the action tab state to Attack
            return;
          }
        }
      }
    }
    let other =
      this.game.levels[this.depth].rooms[this.levelID].roomArray[x][y];
    if (!other.isSolid()) {
      this.move(x, y);
      other.onCollide(this);
      if (!(other instanceof Door || other instanceof Trapdoor))
        this.game.levels[this.depth].rooms[this.levelID].tick(this);
    } else {
      if (other instanceof Door) {
        this.shakeScreen(this.x, this.y, x, y);

        if (other.canUnlock(this)) other.unlock(this);
      }
    }
  };
  private updateLastPosition = (x: number, y: number) => {
    this.lastX = x;
    this.lastY = y;
  };

  //get cancelHoldMove = () => {};

  wouldHurt = (x: number, y: number) => {
    for (let h of this.game.levels[this.depth].rooms[this.levelID]
      .hitwarnings) {
      if (h instanceof HitWarning && h.x == x && h.y == y) return true;
      else {
        return false;
      }
    }
  };

  hurt = (damage: number, enemy: string) => {
    if (this.game.levels[this.depth].rooms[this.levelID] === this.game.room)
      Sound.hurt();

    if (this.inventory.getArmor() && this.inventory.getArmor().health > 0) {
      this.inventory.getArmor().hurt(damage);
      this.hurtingShield = true;
      this.hurtShield = true;
    }
    {
      this.lastHitBy = enemy;
      //console.log("Last Hit by: ", enemy);
      this.healthBar.hurt();
      this.flashing = true;
      if (!this.hurtShield) this.health -= damage;
      this.hurtShield = false;
      this.hurting = true;
      this.hurtAlpha = 0.25;
      if (this.health <= 0 && !GameConstants.DEVELOPER_MODE) {
        this.dead = true;
      }

      /*
      if (this.health <= 0) {
        this.health = 0;
        
        if (!this.game.tutorialActive) {
          this.dead = true;
        } else {
          this.health = 2;
          this.game.pushMessage("You are dead, but you can try again!");
        }
        */
    }
  };

  dashMove = (x: number, y: number) => {
    this.x = x;
    this.y = y;

    for (let i of this.game.levels[this.depth].rooms[this.levelID].items) {
      if (i.x === x && i.y === y) {
        i.onPickup(this);
      }
    }

    //this.game.rooms[this.levelID].updateLighting();
  };

  doneMoving = (): boolean => {
    let EPSILON = 0.01;
    return Math.abs(this.drawX) < EPSILON && Math.abs(this.drawY) < EPSILON;
  };

  doneHitting = (): boolean => {
    let EPSILON = 0.01;
    return Math.abs(this.hitX) < EPSILON && Math.abs(this.hitY) < EPSILON;
  };

  enableSlowMotion = () => {
    if (this.motionSpeed < 1 && !this.slowMotionEnabled) {
      this.motionSpeed *= 1.08;
      if (this.motionSpeed >= 1) this.motionSpeed = 1;
    }
    if (this.slowMotionEnabled && this.motionSpeed > 0.25) {
      this.motionSpeed *= 0.95;
      if (this.motionSpeed < 0.25) this.motionSpeed = 0.25;
    }
  };

  move = (x: number, y: number) => {
    this.updateLastPosition(this.x, this.y);

    //this.actionTab.setState(ActionState.MOVE);
    if (this.game.levels[this.depth].rooms[this.levelID] === this.game.room)
      Sound.playerStoneFootstep();

    if (this.openVendingMachine) this.openVendingMachine.close();

    this.drawX += x - this.x;
    this.drawY += y - this.y;
    this.drawMoveQueue.push({
      drawX: x - this.x,
      drawY: y - this.y,
    });

    /*
    if (this.drawX > 1) this.drawX = 1;
    if (this.drawY > 1) this.drawY = 1;
    if (this.drawX < -1) this.drawX = -1;
    if (this.drawY < -1) this.drawY = -1;
    */

    this.x = x;
    this.y = y;

    for (let i of this.game.levels[this.depth].rooms[this.levelID].items) {
      if (i.x === x && i.y === y) {
        i.onPickup(this);
      }
    }
    let diffX = x - this.lastX;
    let diffY = y - this.lastY;
    if (diffX === 0 && diffY === 0) return;

    //this.game.rooms[this.levelID].updateLighting();
    let roomsOnScreen = 0;
    for (let room of this.game.level.rooms) {
      room.roomOnScreen(this);
      //console.log("On Screen? " + room.onScreen + " levelID: " + room.id);
      if (room.onScreen) roomsOnScreen++;
    }
    //console.log("Rooms On Screen Currently: " + roomsOnScreen);
  };

  moveNoSmooth = (x: number, y: number) => {
    // doesn't touch smoothing
    this.x = x;
    this.y = y;
  };

  moveSnap = (x: number, y: number) => {
    // no smoothing
    this.x = Math.round(x);
    this.y = Math.round(y);
    this.drawX = 0;
    this.drawY = 0;
    this.hitX = 0;
    this.hitY = 0;
    this.jumpY = 0;
  };

  update = () => {};

  updateSlowMotion = () => {
    if (this.slowMotionTickDuration > 0) this.slowMotionTickDuration -= 1;
    if (this.slowMotionTickDuration === 0) this.slowMotionEnabled = false;
  };

  finishTick = () => {
    this.turnCount += 1;
    this.inventory.tick();

    this.flashing = false;

    let totalHealthDiff = this.health - this.lastTickHealth;
    this.lastTickHealth = this.health; // update last tick health
    if (totalHealthDiff < 0) {
      this.flashing = true;
    }
    this.moveDistance = 0;

    //this.actionTab.actionState = ActionState.READY;
    //Sets the action tab state to Wait (during enemy turn)
  };

  /**
   * Draws the player sprite to the canvas.
   * Added `ctx.save()` at the beginning and `ctx.restore()` at the end
   * to ensure canvas state is preserved.
   */
  drawPlayerSprite = (delta: number) => {
    Game.ctx.save(); // Save the current canvas state

    this.frame += 0.1 * delta;
    if (this.frame >= 4) this.frame = 0;
    Game.drawMob(
      1 + Math.floor(this.frame),
      8 + this.direction * 2,
      1,
      2,
      this.x - this.drawX - this.hitX,
      this.y - 1.45 - this.drawY - this.jumpY - this.hitY,
      1,
      2,
      this.shadeColor(),
    );
    if (this.inventory.getArmor() && this.inventory.getArmor().health > 0) {
      // TODO draw armor
    }

    Game.ctx.restore(); // Restore the canvas state
  };

  shadeColor = () => {
    if (!GameConstants.CUSTOM_SHADER_COLOR_ENABLED) {
      return "black";
    } else {
      return Utils.rgbToHex(
        this.game.levels[this.depth].rooms[this.levelID].col[this.x][this.y][0],
        this.game.levels[this.depth].rooms[this.levelID].col[this.x][this.y][1],
        this.game.levels[this.depth].rooms[this.levelID].col[this.x][this.y][2],
      );
    }
  };

  heal = (amount: number) => {
    this.health += amount;
    if (this.health > this.maxHealth) this.health = this.maxHealth;
  };

  drawSpellBeam = (delta: number) => {
    Game.ctx.save();
    // Clear existing beam effects each frame
    this.game.levels[this.depth].rooms[this.levelID].beamEffects = [];

    if (this.inventory.getWeapon() instanceof Spellbook) {
      const spellbook = this.inventory.getWeapon() as Spellbook;
      if (spellbook.isTargeting) {
        let targets = spellbook.targets;
        for (let target of targets) {
          // Create a new beam effect from the player to the enemy
          this.game.levels[this.depth].rooms[this.levelID].addBeamEffect(
            this.x - this.drawX,
            this.y - this.drawY,
            target.x - target.drawX,
            target.y - target.drawY,
            target,
          );

          // Retrieve the newly added beam effect
          const beam =
            this.game.levels[this.depth].rooms[this.levelID].beamEffects[
              this.game.levels[this.depth].rooms[this.levelID].beamEffects
                .length - 1
            ];

          // Render the beam
          beam.render(
            this.x - this.drawX,
            this.y - this.drawY,
            target.x - target.drawX,
            target.y - target.drawY,
            "cyan",
            2,
            delta,
          );
        }
      }
    }
    Game.ctx.restore();
  };
  draw = (delta: number) => {
    Game.ctx.save();
    this.updateDrawXY(delta);
    this.drawableY = this.y;
    this.flashingFrame += (delta * 12) / GameConstants.FPS;
    if (!this.dead) {
      Game.drawMob(0, 0, 1, 1, this.x - this.drawX, this.y - this.drawY, 1, 1);
      if (!this.flashing || Math.floor(this.flashingFrame) % 2 === 0) {
        this.drawPlayerSprite(delta);
      }
    }
    this.drawSpellBeam(delta);
    Game.ctx.restore();
  };

  faceMouse = () => {
    const mousePosition = MouseCursor.getInstance().getPosition();
    const playerPixelPosition = {
      x: GameConstants.WIDTH / 2,
      y: GameConstants.HEIGHT / 2,
    };
    const dx = mousePosition.x - playerPixelPosition.x;
    const dy = mousePosition.y - playerPixelPosition.y;
    const angle = Math.atan2(dy, dx);

    // Convert angle to direction
    // atan2 returns angle in radians (- to )
    // Divide the circle into 4 sectors for the 4 directions
    if (angle >= -Math.PI / 4 && angle < Math.PI / 4) {
      this.direction = Direction.RIGHT;
    } else if (angle >= Math.PI / 4 && angle < (3 * Math.PI) / 4) {
      this.direction = Direction.DOWN;
    } else if (angle >= (-3 * Math.PI) / 4 && angle < -Math.PI / 4) {
      this.direction = Direction.UP;
    } else {
      this.direction = Direction.LEFT;
    }
  };

  heartbeat = () => {
    this.guiHeartFrame = 1;
  };

  tapHoldHandler = () => {
    this.mapToggled = !this.mapToggled;
  };

  /**
   * Draws the top layer elements, such as the health bar.
   * Added `ctx.save()` at the beginning and `ctx.restore()` at the end
   * to ensure canvas state is preserved.
   */
  drawTopLayer = (delta: number) => {
    Game.ctx.save(); // Save the current canvas state

    this.healthBar.draw(
      delta,
      this.health,
      this.maxHealth,
      this.x - this.drawX,
      this.y - this.drawY,
      !this.flashing || Math.floor(this.flashingFrame) % 2 === 0,
    );

    Game.ctx.restore(); // Restore the canvas state
  };

  drawGUI = (delta: number, transitioning: boolean = false) => {
    Game.ctx.save();
    if (!this.dead) {
      if (!transitioning) this.inventory.draw(delta);
      if (this.bestiary) this.bestiary.draw(delta);
      //this.actionTab.draw(delta);

      if (this.guiHeartFrame > 0) this.guiHeartFrame += delta;
      if (this.guiHeartFrame > 5) {
        this.guiHeartFrame = 0;
      }
      for (let i = 0; i < this.maxHealth; i++) {
        let shake = 0;
        let shakeY = 0;
        if (this.health <= 1) {
          shake =
            Math.round(Math.sin(Date.now() / 25 / (i + 1)) + i / 2) /
            2 /
            GameConstants.TILESIZE;
          shakeY =
            Math.round(Math.sin(Date.now() / 25 / (i + 2)) + i / 2) /
            2 /
            GameConstants.TILESIZE;
        }
        let frame = this.guiHeartFrame > 0 ? 1 : 0;
        let offsetY = GameConstants.WIDTH > 155 ? 0 : -1.25;

        if (i >= Math.floor(this.health)) {
          if (i == Math.floor(this.health) && (this.health * 2) % 2 == 1) {
            // draw half heart
            Game.drawFX(
              4,
              2,
              0.75,
              0.75,
              i / 1.5 + shake + 0.25,
              GameConstants.HEIGHT / GameConstants.TILESIZE -
                1 +
                shakeY +
                offsetY,
              0.75,
              0.75,
            );
          } else {
            Game.drawFX(
              3,
              2,
              0.75,
              0.75,
              i / 1.5 + shake + 0.25,
              GameConstants.HEIGHT / GameConstants.TILESIZE -
                1 +
                shakeY +
                offsetY,
              0.75,
              0.75,
            );
          }
        } else {
          Game.drawFX(
            frame,
            2,
            0.75,
            0.75,
            i / 1.5 + shake + 0.25,
            GameConstants.HEIGHT / GameConstants.TILESIZE -
              1 +
              shakeY +
              offsetY,
            0.75,
            0.75,
          );
        }
      }
      if (this.inventory.getArmor())
        this.inventory.getArmor().drawGUI(delta, this.maxHealth);
    } else {
      Game.ctx.fillStyle = LevelConstants.LEVEL_TEXT_COLOR;
      const enemies = statsTracker.getStats().enemies;
      // Count the occurrences of each enemy
      const enemyCounts = enemies.reduce(
        (acc, enemy) => {
          acc[enemy] = (acc[enemy] || 0) + 1;
          return acc;
        },
        {} as Record<string, number>,
      );

      // Create individual lines
      const lines: string[] = [];

      // Line 1: Game Over or slain by
      if (this.lastHitBy !== "enemy") {
        lines.push(`You were slain by ${this.lastHitBy}.`);
      } else {
        lines.push("Game Over");
      }

      lines.push(
        `Depth reached: ${this.game.levels[this.depth].rooms[this.levelID].depth}`,
      );

      // Line 2: Enemies killed
      lines.push(
        `${Object.values(enemyCounts).reduce(
          (a, b) => a + b,
          0,
        )} enemies killed in total:`,
      );

      // Subsequent lines: Each enemy count
      Object.entries(enemyCounts).forEach(([enemy, count]) => {
        lines.push(`${enemy} x${count}`);
      });

      // Line after enemy counts: Restart instruction
      let restartButton = "Press space or click to restart";
      if (GameConstants.isMobile) restartButton = "Tap to restart";

      // Calculate total height based on number of lines
      const lineHeight = Game.letter_height + 2; // Adjust spacing as needed
      const totalHeight = lines.length * lineHeight + lineHeight; // Additional space for restart button

      // Starting Y position to center the text block
      let startY = GameConstants.HEIGHT / 2 - totalHeight / 2;

      // Draw each line centered horizontally
      lines.forEach((line, index) => {
        const textWidth = Game.measureText(line).width;
        const spacing =
          index === 0 || index === 1 || index === lines.length - 1
            ? lineHeight * 1.5
            : lineHeight;
        Game.fillText(line, GameConstants.WIDTH / 2 - textWidth / 2, startY);
        startY += spacing;
      });

      // Draw the restart button
      const restartTextWidth = Game.measureText(restartButton).width;
      Game.fillText(
        restartButton,
        GameConstants.WIDTH / 2 - restartTextWidth / 2,
        startY,
      );
    }
    PostProcessor.draw(delta);
    if (this.hurting) this.drawHurt(delta);

    if (this.mapToggled === true) this.map.draw(delta);
    //this.drawTileCursor(delta);
    this.setCursorIcon();

    //this.drawInventoryButton(delta);
    if (this.menu.open) this.menu.drawMenu();
    Game.ctx.restore();
  };

  drawHurt = (delta: number) => {
    Game.ctx.save(); // Save the current canvas state
    Game.ctx.globalAlpha = this.hurtAlpha;
    this.hurtAlpha -= (this.hurtAlpha / 10) * delta;
    if (this.hurtAlpha <= 0.01) {
      this.hurtAlpha = 0;
      this.hurting = false;
      this.hurtingShield = false;
    }
    Game.ctx.globalCompositeOperation = "source-over";
    Game.ctx.fillStyle = "#cc3333"; // bright but not fully saturated red
    if (this.hurtingShield) {
      Game.ctx.fillStyle = "#639bff"; // bright but not fully saturated blue
    }

    Game.ctx.fillRect(0, 0, GameConstants.WIDTH, GameConstants.HEIGHT);

    Game.ctx.restore(); // Restore the canvas state
  };

  drawLowHealth = (delta: number) => {
    Game.ctx.save();
    //unused
    if (this.health <= 1 && !this.dead) {
      // Calculate pulsating alpha for the vignette effect
      const lowHealthAlpha = 0.5; //Math.sin(this.lowHealthFrame / 10) * 0.5 + 0.5;
      Game.ctx.globalAlpha = lowHealthAlpha;
      this.lowHealthFrame += delta;

      const gradientBottom = Game.ctx.createLinearGradient(
        0,
        GameConstants.HEIGHT,
        0,
        (GameConstants.HEIGHT * 2) / 3,
      );

      // Define gradient color stops
      [gradientBottom].forEach((gradient) => {
        gradient.addColorStop(0, "#cc3333"); // Solid red at edges
        gradient.addColorStop(1, "rgba(0, 0, 0, 0)"); // Transparent toward center
      });

      // Draw the gradients
      Game.ctx.globalCompositeOperation = "source-over";

      Game.ctx.fillStyle = gradientBottom;
      Game.ctx.fillRect(0, 0, GameConstants.WIDTH, GameConstants.HEIGHT);

      // Reset composite operation and alpha
      Game.ctx.globalCompositeOperation = "source-over";
      Game.ctx.globalAlpha = 1.0;
    } else {
      this.lowHealthFrame = 0;
    }
    Game.ctx.restore();
  };

  updateDrawXY = (delta: number) => {
    if (!this.doneMoving()) {
      this.drawX *= 0.85 ** delta;
      this.drawY *= 0.85 ** delta;
      this.drawX = Math.abs(this.drawX) < 0.01 ? 0 : this.drawX;
      this.drawY = Math.abs(this.drawY) < 0.01 ? 0 : this.drawY;
    }
    if (this.doneHitting()) {
      this.jump(delta);
    }

    if (!this.doneHitting()) {
      this.updateHitXY(delta);
    }

    this.enableSlowMotion();
    GameConstants.ANIMATION_SPEED = this.motionSpeed;
  };

  updateHitXY = (delta: number) => {
    const hitX = this.hitX - this.hitX * 0.3;
    const hitY = this.hitY - this.hitY * 0.3;
    this.hitX = Math.min(Math.max(hitX, -1), 1);
    this.hitY = Math.min(Math.max(hitY, -1), 1);
    if (Math.abs(hitX) < 0.01) this.hitX = 0;
    if (Math.abs(hitY) < 0.01) this.hitY = 0;
  };

  hitShake = (
    playerX: number,
    playerY: number,
    otherX: number,
    otherY: number,
  ) => {
    const range = GameConstants.TILESIZE;
    this.hitX = Math.min(Math.max(0.5 * (playerX - otherX), -range), range);
    this.hitY = Math.min(Math.max(0.5 * (playerY - otherY), -range), range);
  };

  shakeScreen = (
    playerX: number,
    playerY: number,
    otherX: number,
    otherY: number,
    shakeStrength: number = 10,
  ) => {
    const range = GameConstants.TILESIZE;
    this.hitX = Math.min(Math.max(0.5 * (playerX - otherX), -range), range);
    this.hitY = Math.min(Math.max(0.5 * (playerY - otherY), -range), range);

    this.game.shakeScreen(
      -this.hitX * 1 * shakeStrength,
      -this.hitY * 1 * shakeStrength,
    );
  };

  jump = (delta: number) => {
    let j = Math.max(Math.abs(this.drawX), Math.abs(this.drawY));
    this.jumpY = Math.abs(Math.sin(j * Math.PI) * this.jumpHeight);
    if (Math.abs(this.jumpY) < 0.01) this.jumpY = 0;
    if (this.jumpY > this.jumpHeight) this.jumpY = this.jumpHeight;
  };

  /**
   * Draws the tile cursor to the canvas.
   * Added `ctx.save()` at the beginning and `ctx.restore()` at the end
   * to ensure canvas state is preserved.
   */
  drawTileCursor = (delta: number) => {
    if (this.inventory.isOpen) return;
    Game.ctx.save(); // Save the current canvas state

    if (
      !this.mouseInLine() ||
      !this.isMouseAboveFloor() ||
      this.isMouseOnPlayerTile()
    )
      return;
    let tileX = 22; //inRange ? 22 : 24;
    let tileY = 3;

    const moveData = this.canMoveWithMouse();
    if (moveData && moveData.direction !== undefined) {
      switch (moveData.direction) {
        case Direction.UP:
          tileY = 3;
          break;
        case Direction.RIGHT:
          tileY = 4;
          break;
        case Direction.DOWN:
          tileY = 5;
          break;
        case Direction.LEFT:
          tileY = 6;
          break;
      }
    }

    Game.drawFX(
      tileX + Math.floor(HitWarning.frame),
      tileY,
      1,
      1,
      this.tileCursor.x,
      this.tileCursor.y,
      1,
      1,
    );

    Game.ctx.restore(); // Restore the canvas state
  };

  private queueHandler = () => {
    //      console.log("Queue handler running, queue length:", this.moveQueue.length);
    //console.log("Is processing queue:", this.isProcessingQueue);

    if (!this.isProcessingQueue) {
      return;
    }

    const currentTime = Date.now();
    const timeSinceLastMove = currentTime - this.lastMoveTime;
    //console.log("Time since last move:", timeSinceLastMove);

    if (currentTime - this.lastMoveTime >= GameConstants.MOVEMENT_COOLDOWN) {
      if (this.moveQueue.length > 0) {
        const { x, y, direction } = this.moveQueue.shift();
        //console.log("Processing move to:", x, y);
        this.handleMoveLoop({ x, y, direction });
        this.lastMoveTime = currentTime;
      } else {
        //console.log("Queue empty, stopping processing");
        this.stopQueueProcessing();
      }
    } else {
      //console.log(
      //  "Waiting for cooldown, remaining time:",
      //  GameConstants.MOVEMENT_COOLDOWN - timeSinceLastMove
      //);
    }

    this.animationFrameId = requestAnimationFrame(this.queueHandler);
    //console.log("Next animation frame requested:", this.animationFrameId);
  };

  private startQueueProcessing = () => {
    //console.log("Attempting to start queue processing");
    //console.log(
    //  "Current state - isProcessing:",
    //  this.isProcessingQueue,
    //  "animationFrameId:",
    //  this.animationFrameId
    //);

    if (!this.isProcessingQueue) {
      //console.log("Starting queue processing");
      this.isProcessingQueue = true;
      this.animationFrameId = requestAnimationFrame(this.queueHandler);
      //console.log("Animation frame requested:", this.animationFrameId);
    } else {
      //console.log("Queue processing already running");
    }
  };

  private stopQueueProcessing = () => {
    //console.log("Stopping queue processing");
    //console.log(
    //  "Current state - isProcessing:",
    //  this.isProcessingQueue,
    //  "animationFrameId:",
    //  this.animationFrameId
    //);

    this.isProcessingQueue = false;
    if (this.animationFrameId !== null) {
      //console.log("Canceling animation frame:", this.animationFrameId);
      cancelAnimationFrame(this.animationFrameId);
      this.animationFrameId = null;
    }
  };

  handleMoveLoop = ({
    x,
    y,
    direction,
  }: {
    x: number;
    y: number;
    direction: Direction;
  }) => {
    switch (direction) {
      case Direction.RIGHT:
        this.right();
        break;
      case Direction.LEFT:
        this.left();
        break;
      case Direction.DOWN:
        this.down();
        break;
      case Direction.UP:
        this.up();
        break;
    }
  };

  queueMove = (x: number, y: number, direction: Direction) => {
    if (!x || !y || this.moveQueue.length > 0) return;

    //console.log("Queueing move to:", x, y);
    //console.log("Current queue length:", this.moveQueue.length);
    const move = { x, y, direction };

    this.moveQueue.push(move);
    this.startQueueProcessing();
    //console.log("Queue length after push:", this.moveQueue.length);
  };

  private canMove(): boolean {
    const currentTime = Date.now();
    if (
      currentTime - this.lastMoveTime >=
      GameConstants.MOVEMENT_COOLDOWN - this.moveQueue.length * 25
    ) {
      this.lastMoveTime = currentTime;
      return true;
    }

    return false;
  }
}


--- src/postProcess.ts ---
import { Game } from "./game";
import { GameConstants } from "./gameConstants";

export class PostProcessor {
  static draw = (delta: number) => {
    Game.ctx.save();
    Game.ctx.globalAlpha = 0.15;
    Game.ctx.globalCompositeOperation = "screen";
    // GameConstants.SHADE_LAYER_COMPOSITE_OPERATION as GlobalCompositeOperation; //"soft-light";

    Game.ctx.fillStyle = "#006A6E"; //dark teal
    //Game.ctx.fillStyle = "#003B6F"; //deep underwater blue
    //Game.ctx.fillStyle = "#2F2F2F"; //smoky fog prison

    //Game.ctx.fillStyle = "#4a6c4b"; //darker muddy green
    //Game.ctx.fillStyle = "#800000"; // lighter red for dungeon hell theme

    Game.ctx.fillRect(0, 0, GameConstants.WIDTH, GameConstants.HEIGHT);
    Game.ctx.restore();
  };
}


--- src/projectile/enemyShield.ts ---
import { Projectile } from "./projectile";
import { Game } from "../game";
import { Player } from "../player";
import { HitWarning } from "../hitWarning";
import { Entity } from "../entity/entity";
import { Enemy } from "../entity/enemy/enemy";
import { LightSource } from "../lightSource";
import { Lighting } from "../lighting";
import { OccultistEnemy } from "../entity/enemy/occultistEnemy";
import { GameConstants } from "../gameConstants";
import { BeamEffect } from "../beamEffect";
import { GenericParticle } from "../particle/genericParticle";

export class EnemyShield extends Projectile {
  frame: number;
  parent: Entity;
  tileX: number;
  tileY: number;
  health: number;

  constructor(parent: Entity, x: number, y: number, health: number = 1) {
    super(parent, x, y);
    this.parent = parent;
    this.frame = 0;
    this.health = health;
    this.parent.shielded = true;
    this.lightSource = Lighting.newLightSource(
      this.x + 0.5,
      this.y + 0.5,
      [20, 0, 40],
      3.5,
      20,
    );
    this.parent.addLightSource(this.lightSource);
    this.parent.room.projectiles.push(this);
    this.parent.room.updateLighting();
  }

  remove = () => {
    this.parent.shielded = false;
    this.parent.removeLightSource(this.lightSource);
    this.parent.room.projectiles = this.parent.room.projectiles.filter(
      (projectile) => projectile !== this,
    );

    let beam = this.parent.room.projectiles.find(
      (projectile) =>
        projectile instanceof BeamEffect && projectile.parent === this.parent,
    );
    if (beam) {
      beam.dead = true;
    }
    this.parent.shadeColor = "black";
    this.lightSource = null;
    this.parent.shield = null;
  };

  updateLightSourcePos = () => {
    if (this.lightSource === null) return;
    let index = this.parent.room.lightSources.indexOf(this.lightSource);
    this.parent.room.lightSources[index].x = this.parent.x + 0.5;
    this.parent.room.lightSources[index].y = this.parent.y + 0.5;
    this.parent.room.updateLighting();
  };

  hurt = (damage: number) => {
    const damageOverShield = Math.max(0, damage - this.health);
    this.health -= damage;
    /*
    GenericParticle.spawnCluster(
      this.parent.room,
      this.parent.x + 0.5,
      this.parent.y + 0.5,
      "#fbf236",
    );
    */

    if (this.health <= 0) {
      this.remove();
    }
    return damageOverShield;
  };

  tick = () => {
    if (this.parent.dead) {
      this.remove();
    }
    if (this.dead) {
      this.parent.room.projectiles = this.parent.room.projectiles.filter(
        (projectile) => projectile !== this,
      );
    }
  };

  draw = (delta: number) => {
    if (this.dead) return;
    Game.ctx.save();
    Game.ctx.globalAlpha = 1;
    this.frame += 0.1 * delta;
    if (this.frame >= 4) this.frame = 0;

    this.drawableY = this.parent.drawableY - 0.05;
    Game.ctx.globalCompositeOperation = "difference";
    if (this.parent.shielded) {
      Game.drawFX(
        18 + Math.floor(this.frame),
        9,
        1,
        1,
        this.parent.x - this.parent.drawX,
        this.parent.y - this.parent.drawY,
        1,
        1,
      );
    }
    Game.ctx.restore();
  };
}


--- src/projectile/enemySpawnAnimation.ts ---
import { Projectile } from "./projectile";
import { Game } from "../game";
import { WizardEnemy } from "../entity/enemy/wizardEnemy";
import { Player } from "../player";
import { Entity } from "../entity/entity";
import { Room } from "../room";
import { GenericParticle } from "../particle/genericParticle";
import { Sound } from "../sound";
import { HitWarning } from "../hitWarning";

export class EnemySpawnAnimation extends Projectile {
  readonly ANIM_COUNT = 3;

  room: Room;
  enemy: Entity;
  frame: number;

  constructor(room: Room, enemy: Entity, x: number, y: number) {
    super(enemy, x, y);
    this.room = room;
    this.enemy = enemy;
    this.frame = 0;
  }

  tick = () => {
    if (this.room === this.room.game.room) Sound.enemySpawn();

    let hitPlayer = false;
    for (const i in this.room.game.players) {
      if (
        this.room.game.players[i].x === this.x &&
        this.room.game.players[i].y === this.y
      ) {
        this.room.game.players[i].hurt(0.5, "reaper");
        hitPlayer = true;
      }
    }
    if (!hitPlayer) {
      this.dead = true;
      this.enemy.skipNextTurns = 1;
      this.room.entities.push(this.enemy);
      GenericParticle.spawnCluster(
        this.room,
        this.x + 0.5,
        this.y + 0.5,
        "#ffffff",
      );
      GenericParticle.spawnCluster(
        this.room,
        this.x + 0.5,
        this.y + 0.5,
        "#ffffff",
      );
    } else {
      this.room.hitwarnings.push(
        new HitWarning(this.room.game, this.x, this.y, this.x, this.y),
      );
    }
  };

  drawTopLayer = (delta: number) => {
    if (this.dead) return;

    this.frame += 0.25 * delta;
    if (this.frame >= 8) this.frame = 0;
    for (let i = 0; i < this.ANIM_COUNT; i++) {
      let offsetX = 0;
      Game.drawFX(
        Math.floor(this.frame),
        27,
        1,
        1,
        this.x + Math.round(offsetX) / 16.0,
        this.y - 0.5,
        1,
        1,
      );
    }
    if (Math.floor(this.frame * 4) % 2 == 0)
      this.room.particles.push(
        new GenericParticle(
          this.room,
          this.x + 0.5 + Random.rand() * 0.05 - 0.025,
          this.y + Random.rand() * 0.05 - 0.025,
          0.25,
          Random.rand() * 0.5,
          0.025 * (Random.rand() * 1 - 0.5),
          0.025 * (Random.rand() * 1 - 0.5),
          0.2 * (Random.rand() - 1),
          "#ffffff",
          0,
        ),
      );
  };
}


--- src/projectile/explosion.ts ---
import { Projectile } from "./projectile";
import { Game } from "../game";
import { WizardEnemy } from "../entity/enemy/wizardEnemy";
import { Player } from "../player";
import { HitWarning } from "../hitWarning";
import { Lighting } from "../lighting";
import { Utils } from "../utils";
import { Entity } from "../entity/entity";
import { Bomb } from "../entity/object/bomb";
export class Explosion extends Projectile {
  state: number;
  frame: number;
  delay: number;
  parent: Entity;
  offsetFrame: number;

  constructor(entity: Entity, x: number, y: number, playerHitBy: Player) {
    super(entity, x, y);
    this.state = 0;
    this.frame = 6;
    this.parent = entity;
    this.offsetFrame =
      -Utils.distance(this.parent.x, this.parent.y, this.x, this.y) * 100;
    this.delay = 0;
    Lighting.momentaryLight(
      this.parent.room,
      this.x + 0.5,
      this.y + 0.5,
      0.5,
      [255, 100, 0],
      350,
      20,
      Math.abs(this.offsetFrame),
    );
    const distance = Utils.distance(
      this.parent.x,
      this.parent.y,
      this.x,
      this.y,
    );

    let damage =
      distance === 0 ? 1 : Math.max(0.5, Math.floor((1 / distance) * 4) / 2);
    console.log("damage:", damage);
    for (let entity of this.parent.room.entities) {
      if (
        entity.x === this.x &&
        entity.y === this.y &&
        entity !== this.parent
      ) {
        if (entity instanceof Bomb) {
          entity.fuseLength = 1;
        }
        entity.hurt(playerHitBy, damage);

        console.log(playerHitBy);
      }
      if (playerHitBy.x === this.x && playerHitBy.y === this.y) {
        playerHitBy.hurt(damage, "bomb");
      }
    }
  }
  drawTopLayer = (delta: number) => {
    if (this.dead) return;
    if (this.offsetFrame < 0) this.offsetFrame += 10 * delta;
    if (this.offsetFrame >= 0) {
      this.frame += 0.25 * delta;
    }

    if (this.frame > 17) this.dead = true;
    Game.drawFX(Math.floor(this.frame), 6, 1, 2, this.x, this.y - 1, 1, 2);
  };
}


--- src/projectile/playerFireball.ts ---
import { Projectile } from "./projectile";
import { Game } from "../game";
import { WizardEnemy } from "../entity/enemy/wizardEnemy";
import { Player } from "../player";
import { HitWarning } from "../hitWarning";
import { Lighting } from "../lighting";
import { Utils } from "../utils";
export class PlayerFireball extends Projectile {
  state: number;
  frame: number;
  delay: number;
  parent: Player;
  offsetFrame: number;

  constructor(parent: Player, x: number, y: number) {
    super(parent, x, y);
    this.state = 0;
    this.frame = 6;
    this.offsetFrame =
      -Utils.distance(this.parent.x, this.parent.y, this.x, this.y) * 50;
    this.delay = 0;
    Lighting.momentaryLight(
      this.parent.game.rooms[this.parent.levelID],
      this.x + 0.5,
      this.y + 0.5,
      0.5,
      [255, 100, 0],
      250,
      10,
      1,
    );
  }
  drawTopLayer = (delta: number) => {
    if (this.dead) return;
    if (this.offsetFrame < 0) this.offsetFrame += 10 * delta;
    if (this.offsetFrame >= 0) {
      this.frame += 0.25 * delta;
    }

    if (this.frame > 17) this.dead = true;
    Game.drawFX(Math.floor(this.frame), 6, 1, 2, this.x, this.y - 1, 1, 2);
  };
}


--- src/projectile/projectile.ts ---
import { Player } from "../player";
import { Entity } from "../entity/entity";
import { Drawable } from "../drawable";
import { HitWarning } from "../hitWarning";
import { Direction } from "../game";
import { LightSource } from "../lightSource";
import { WizardEnemy } from "../entity/enemy/wizardEnemy";

export class Projectile extends Drawable {
  x: number;
  y: number;
  dead: boolean;
  parent: Entity | Player;
  dir: Direction;
  lightSource: LightSource;

  constructor(parent: Entity | Player, x: number, y: number) {
    super();

    this.x = x;
    this.y = y;
    this.dead = false;
    this.parent = parent;
    this.drawableY = y;
    this.hasBloom = false;
    this.bloomColor = "#00BFFF";
  }

  get distanceToParent() {
    return Math.abs(this.x - this.parent.x) + Math.abs(this.y - this.parent.y);
  }

  setTarget(x: number, y: number, x2: number, y2: number) {}

  hitPlayer = (player: Player) => {};
  hitEnemy = (enemy: Entity) => {};

  tick = () => {};
  draw = (delta: number) => {};
  drawTopLayer = (delta: number) => {};
}


--- src/projectile/wizardFireball.ts ---
import { Projectile } from "./projectile";
import { Game } from "../game";
import { WizardEnemy } from "../entity/enemy/wizardEnemy";
import { Player } from "../player";
import { HitWarning } from "../hitWarning";
import { Entity } from "../entity/entity";
import { Enemy } from "../entity/enemy/enemy";
import { LightSource } from "../lightSource";
import { Lighting } from "../lighting";

export class WizardFireball extends Projectile {
  state: number;
  frame: number;
  parent: WizardEnemy;
  delay: number;
  frameOffset: number;
  offsetX: number;
  hitWarning: HitWarning;
  tileX: number;
  tileY: number;

  constructor(parent: WizardEnemy, x: number, y: number) {
    super(parent, x, y);
    this.tileY = parent.name === "wizard bomber" ? 7 : 8;
    this.parent = parent;
    this.frame = 0;
    this.state = 0; // this.distanceToParent;
    this.lightSource = new LightSource(
      this.x + 0.5,
      this.y + 0.5,
      4,
      (parent as WizardEnemy).projectileColor,
      0.1,
    );
    this.parent.addLightSource(this.lightSource);
    //this.parent.room.updateLighting();
    this.hasBloom = true;
    this.bloomColor = "#00BFFF";
    this.bloomAlpha = 0.5;
    this.softBloomAlpha = 0;
  }
  setMarkerFrame = () => {
    // Calculate offsetX based on direction
    this.offsetX = Math.floor(((this.dir + 1) % 8) / 2);
  };

  tick = () => {
    if (this.parent.dead || this.state === 3) {
      this.parent.removeLightSource(this.lightSource);
      this.dead = true;
    }

    if (!this.dead && this.state === 0) {
      this.bloomAlpha = 1;
    }

    this.state++;
    if (!this.dead && this.state === 1) {
      this.bloomAlpha = 0.5;

      const lightSource = this.parent.room.lightSources.find(
        (ls) => ls === this.lightSource,
      );
      lightSource.b = 0.4;
      this.parent.room.hitwarnings.push(
        new HitWarning(
          this.parent.game,
          this.x,
          this.y,
          this.parent.x,
          this.parent.y,
          true,
        ),
      );
    }
    if (!this.dead && this.state === 2) {
      this.bloomAlpha = 0;
      Lighting.momentaryLight(
        this.parent.room,
        this.x,
        this.y,
        3,
        (this.parent as WizardEnemy).projectileColor,
        500,
        5,
        350,
      );
      this.parent.removeLightSource(this.lightSource);
      this.frame = 0;
      this.delay = Game.rand(0, 10, Random.rand);
    }
  };

  hitPlayer = (player: Player) => {
    if (!this.dead && this.state === 2) {
      player.hurt(1, this.parent.name);
    }
  };

  draw = (delta: number) => {
    if (this.dead) return;
    /*Game.drawFX(
      18 + this.offsetX, //+ Math.floor(HitWarning.frame),
      4,
      1,
      1,
      this.x,
      this.y,
      1,
      1
    );*/

    if (this.state >= 0) {
      if (this.state === 0) {
        this.frame += 0.25 * delta;
        if (this.frame >= 4) this.frame = 0;
        Game.drawFX(
          22 + Math.floor(this.frame),
          this.tileY,
          1,
          1,
          this.x,
          this.y,
          1,
          1,
        );
      } else if (this.state === 1) {
        this.frame += 0.25 * delta;
        if (this.frame >= 4) this.frame = 0;
        Game.drawFX(
          18 + Math.floor(this.frame),
          this.tileY,
          1,
          1,
          this.x,
          this.y - 0.2,
          1,
          1,
        );
      } else {
        if (this.delay > 0) {
          this.delay--;
          return;
        }
        this.frame += 0.3 * delta;
        if (this.frame > 17) this.dead = true;
        Game.drawFX(Math.floor(this.frame), 6, 1, 2, this.x, this.y - 1, 1, 2);
      }
    }
  };
}


--- src/random.ts ---
export class Random {
  static state: number;

  static setState = (state: number) => {
    Random.state = state;
  };

  static rand = () => {
    Random.state ^= Random.state << 21;
    Random.state ^= Random.state >>> 35;
    Random.state ^= Random.state << 4;
    return (Random.state >>> 0) / 4294967296;
  };
}

// copy and paste into browser console
// let state;
// let rand = () => { state ^= (state << 21); state ^= (state >>> 35); state ^= (state << 4); return (state >>> 0) / 4294967296; }


--- src/reverb.ts ---
import { Game } from "./game";
import { Sound } from "./sound";

export class ReverbEngine {
  private static audioContext: AudioContext;
  private static convolver: ConvolverNode;
  private static reverbBuffer: AudioBuffer | null = null;
  private static mediaSources: WeakMap<
    HTMLAudioElement,
    MediaElementAudioSourceNode
  > = new WeakMap();
  static initialized: boolean = false;

  // Initialize the AudioContext and ConvolverNode
  public static async initialize() {
    if (ReverbEngine.initialized) return;
    let canInitialize = false;

    if (!Game.inputReceived) {
      console.time("initializeReverb");
      try {
        await new Promise<void>((resolve) => {
          const checkInput = () => {
            if (Game.inputReceived) {
              resolve();
              canInitialize = true;
              console.timeEnd("initializeReverb");
            } else {
              requestAnimationFrame(checkInput);
            }
          };
          checkInput();
        });
      } catch (error) {
        console.error("Failed to initialize ReverbEngine:", error);
        return;
      }
    }

    if (
      !ReverbEngine.audioContext &&
      !ReverbEngine.initialized &&
      canInitialize
    ) {
      ReverbEngine.audioContext = new (window.AudioContext ||
        (window as any).webkitAudioContext)();
      ReverbEngine.convolver = ReverbEngine.audioContext.createConvolver();
      ReverbEngine.convolver.connect(ReverbEngine.audioContext.destination);
      await ReverbEngine.loadReverbBuffer(`res/SFX/impulses/small.mp3`);
      ReverbEngine.setDefaultReverb();
      ReverbEngine.initialized = true;
      if (Sound.initialized) Sound.audioMuted = false;
    }
  }

  // Load a specified impulse response
  private static async loadReverbBuffer(filePath: string) {
    try {
      const response = await fetch(filePath);

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      const arrayBuffer = await response.arrayBuffer();
      ReverbEngine.reverbBuffer =
        await ReverbEngine.audioContext.decodeAudioData(arrayBuffer);
    } catch (error) {
      console.error("Error loading reverb buffer:", error);
    }
  }

  // Set the default reverb buffer
  private static setDefaultReverb() {
    if (ReverbEngine.reverbBuffer) {
      ReverbEngine.convolver.buffer = ReverbEngine.reverbBuffer;
    }
  }

  /**
   * Set the reverb characteristics by specifying an impulse response file.
   * @param filePath - The path to the impulse response file.
   */
  public static async setReverbImpulse(filePath: string): Promise<void> {
    if (!ReverbEngine.initialized) return;
    try {
      await ReverbEngine.loadReverbBuffer(filePath);
      if (ReverbEngine.reverbBuffer) {
        ReverbEngine.convolver.buffer = ReverbEngine.reverbBuffer;
      }
    } catch (error) {
      console.error("Error setting reverb impulse:", error);
    }
  }

  // Apply reverb to a given HTMLAudioElement
  public static async applyReverb(audioElement: HTMLAudioElement) {
    await ReverbEngine.initialize();
    if (!ReverbEngine.initialized) return;
    try {
      if (ReverbEngine.mediaSources.has(audioElement)) {
        return;
      }

      const track =
        ReverbEngine.audioContext.createMediaElementSource(audioElement);
      track.connect(ReverbEngine.convolver);
      ReverbEngine.mediaSources.set(audioElement, track);
    } catch (error) {
      console.error("Error applying reverb:", error);
    }
  }

  // Remove reverb from a given HTMLAudioElement
  public static async removeReverb(audioElement: HTMLAudioElement) {
    await ReverbEngine.initialize();
    if (!ReverbEngine.initialized) return;
    const track = ReverbEngine.mediaSources.get(audioElement);
    if (track) {
      track.disconnect();
      ReverbEngine.mediaSources.delete(audioElement);
    }
  }
}


--- src/room.ts ---
// #region imports
import { Wall } from "./tile/wall";
import { LevelConstants } from "./levelConstants";
import { Floor } from "./tile/floor";
import { Direction, Game, LevelState } from "./game";
import { Door, DoorType } from "./tile/door";
import { Tile, SkinType } from "./tile/tile";
import { KnightEnemy } from "./entity/enemy/knightEnemy";
import { Entity, EntityType } from "./entity/entity";
import { Chest } from "./entity/object/chest";
import { Item } from "./item/item";
import { GoldenKey } from "./item/goldenKey";
import { SpawnFloor } from "./tile/spawnfloor";
import { Spike } from "./tile/spike";
import { GameConstants } from "./gameConstants";
import { SkullEnemy } from "./entity/enemy/skullEnemy";
import { Barrel } from "./entity/object/barrel";
import { Crate } from "./entity/object/crate";
import { Armor } from "./item/armor";
import { Particle } from "./particle/particle";
import { Projectile } from "./projectile/projectile";
import { SpikeTrap } from "./tile/spiketrap";
import { FountainTile } from "./tile/fountainTile";
import { CoffinTile } from "./tile/coffinTile";
import { PottedPlant } from "./entity/object/pottedPlant";
import { InsideLevelDoor } from "./tile/insideLevelDoor";
import { Button } from "./tile/button";
import { HitWarning } from "./hitWarning";
import { UpLadder } from "./tile/upLadder";
import { DownLadder } from "./tile/downLadder";
import { CoalResource } from "./entity/resource/coalResource";
import { GoldResource } from "./entity/resource/goldResource";
import { EmeraldResource } from "./entity/resource/emeraldResource";
import { Chasm } from "./tile/chasm";
import { Spawner } from "./entity/enemy/spawner";
import { VendingMachine } from "./entity/object/vendingMachine";
import { WallTorch } from "./tile/wallTorch";
import { LightSource } from "./lightSource";
import { ChargeEnemy } from "./entity/enemy/chargeEnemy";
import { Shotgun } from "./weapon/shotgun";
import { Heart } from "./item/heart";
import { Spear } from "./weapon/spear";
import { Drawable } from "./drawable";
import { Player, PlayerDirection } from "./player";
import { CrabEnemy } from "./entity/enemy/crabEnemy";
import { ZombieEnemy } from "./entity/enemy/zombieEnemy";
import { BigSkullEnemy } from "./entity/enemy/bigSkullEnemy";
import { Random } from "./random";
import { Lantern } from "./item/lantern";
import { DualDagger } from "./weapon/dualdagger";
import { Pot } from "./entity/object/pot";
import { BishopEnemy } from "./entity/enemy/bishopEnemy";
import { Rock } from "./entity/resource/rockResource";
import { Mushrooms } from "./entity/object/mushrooms";
import { ArmoredzombieEnemy } from "./entity/enemy/armoredzombieEnemy";
import { TombStone } from "./entity/object/tombStone";
import { Pumpkin } from "./entity/object/pumpkin";
import { QueenEnemy } from "./entity/enemy/queenEnemy";
import { FrogEnemy } from "./entity/enemy/frogEnemy";
import { BigKnightEnemy } from "./entity/enemy/bigKnightEnemy";
import { Enemy } from "./entity/enemy/enemy";
import { FireWizardEnemy } from "./entity/enemy/fireWizard";
import { EnergyWizardEnemy } from "./entity/enemy/energyWizard";
import { ReverbEngine } from "./reverb";
import { astar } from "./astarclass";
import { Level } from "./level";
import { Warhammer } from "./weapon/warhammer";
import { Spellbook } from "./weapon/spellbook";
import { Torch } from "./item/torch";
import { RookEnemy } from "./entity/enemy/rookEnemy";
import { BeamEffect } from "./beamEffect";
import { EnvType } from "./environment";
import { Pickaxe } from "./weapon/pickaxe";
import { OccultistEnemy } from "./entity/enemy/occultistEnemy";
import { Puddle } from "./tile/decorations/puddle";
import { Decoration } from "./tile/decorations/decoration";
import { Bomb } from "./entity/object/bomb";
import { Sound } from "./sound";
import { Block } from "./entity/object/block";
import { Bestiary } from "./bestiary";
import { ArmoredSkullEnemy } from "./entity/enemy/armoredSkullEnemy";

// #endregion

// #region Enums & Interfaces
/**
 * Enumeration of available enemy types.
 */
export enum EnemyType {
  crab = "crab",
  frog = "frog",
  zombie = "zombie",
  skull = "skull",
  energyWizard = "energywizard",
  charge = "charge",
  rook = "rook",
  bishop = "bishop",
  armoredzombie = "armoredzombie",
  bigskull = "bigskull",
  queen = "queen",
  knight = "knight",
  bigknight = "bigknight",
  firewizard = "firewizard",
  spawner = "spawner",
  occultist = "occultist",
  bomb = "bomb",
  armoredskull = "armoredskull",
  // Add other enemy types here
}

/**
 * Mapping of enemy types to their corresponding classes.
 */
export const EnemyTypeMap: { [key in EnemyType]: EnemyStatic } = {
  [EnemyType.crab]: CrabEnemy,
  [EnemyType.frog]: FrogEnemy,
  [EnemyType.zombie]: ZombieEnemy,
  [EnemyType.skull]: SkullEnemy,
  [EnemyType.energyWizard]: EnergyWizardEnemy,
  [EnemyType.charge]: ChargeEnemy,
  [EnemyType.rook]: RookEnemy,
  [EnemyType.bishop]: BishopEnemy,
  [EnemyType.armoredzombie]: ArmoredzombieEnemy,
  [EnemyType.bigskull]: BigSkullEnemy,
  [EnemyType.queen]: QueenEnemy,
  [EnemyType.knight]: KnightEnemy,
  [EnemyType.bigknight]: BigKnightEnemy,
  [EnemyType.firewizard]: FireWizardEnemy,
  [EnemyType.spawner]: Spawner,
  [EnemyType.occultist]: OccultistEnemy,
  [EnemyType.bomb]: Bomb,
  [EnemyType.armoredskull]: ArmoredSkullEnemy,
  // Add other enemy mappings here
};

export enum RoomType {
  START,
  DUNGEON,
  BOSS,
  BIGDUNGEON,
  TREASURE,
  FOUNTAIN,
  COFFIN,
  GRASS,
  PUZZLE,
  KEYROOM,
  CHESSBOARD,
  MAZE,
  CORRIDOR,
  SPIKECORRIDOR,
  UPLADDER,
  DOWNLADDER,
  SHOP,
  BIGCAVE,
  CAVE,
  SPAWNER,
  ROPEHOLE,
  ROPECAVE,
  TUTORIAL,
}

export enum TurnState {
  playerTurn,
  computerTurn,
}

export interface WallInfo {
  isTopWall: boolean;
  isBottomWall: boolean;
  isLeftWall: boolean;
  isRightWall: boolean;
  isInnerWall: boolean;
  isBelowDoorWall: boolean;
  isDoorWall: boolean;
  innerWallType: string | null;
  shouldDrawBottom: boolean;
  isAboveDoorWall: boolean;
}

export enum WallDirection {
  NORTH = "North",
  EAST = "East",
  SOUTH = "South",
  WEST = "West",
  TOPLEFT = "TopLeft",
  TOPRIGHT = "TopRight",
  BOTTOMLEFT = "BottomLeft",
  BOTTOMRIGHT = "BottomRight",
}

interface RoomDimensions {
  width: number;
  height: number;
}

interface EntitySpawnConfig {
  name: Entity["name"];
  weight: number;
}

export interface EnemyStatic {
  add(room: Room, game: Game, x: number, y: number, ...rest: any[]): void;
}

// #endregion

export class Room {
  roomArray: Tile[][];

  softVis: number[][]; // this is the one we use for drawing (includes smoothing)
  vis: number[][]; // visibility ranges from 0 (fully visible) to 1 (fully black)
  softCol: [number, number, number][][];
  col: [number, number, number][][];
  renderBuffer: [number, number, number, number][][][]; // Array of color arrays (r,g,b,alpha) for each x,y position
  oldVis: number[][];
  oldCol: [number, number, number][][];

  entities: Array<Entity>;
  deadEntities: Array<Entity>;
  items: Array<Item>;
  doors: Array<Door>; // (Door | BottomDoor) just a reference for mapping, still access through levelArray
  projectiles: Array<Projectile>;
  particles: Array<Particle>;
  hitwarnings: Array<HitWarning>;
  private colorOffscreenCanvas: HTMLCanvasElement;
  private colorOffscreenCtx: CanvasRenderingContext2D;

  private shadeOffscreenCanvas: HTMLCanvasElement;
  private shadeOffscreenCtx: CanvasRenderingContext2D;
  private bloomOffscreenCanvas: HTMLCanvasElement;
  private bloomOffscreenCtx: CanvasRenderingContext2D;

  currentSpawnerCount: number;

  game: Game;
  roomX: number;
  roomY: number;
  width: number;
  height: number;
  type: RoomType;
  depth: number;
  mapGroup: number;
  name: string = "";
  message: string;
  turn: TurnState;
  playerTurnTime: number;
  playerTicked: Player;
  skin: SkinType;
  entered: boolean; // has the player entered this level
  lightSources: Array<LightSource>;
  shadeColor = "#000000";
  innerWalls: Array<Wall>;
  wallInfo: Map<string, WallInfo> = new Map();
  savePoint: Room;
  lastEnemyCount: number;
  outerWalls: Array<Wall>;
  level: Level;
  id: number;
  tunnelDoor: Door = null; // this is the door that connects the start room to the exit room
  active: boolean;
  onScreen: boolean;
  lastLightingUpdate: number;
  walls: Array<Wall>;
  decorations: Array<Decoration>;
  blurOffsetX: number = 5;
  blurOffsetY: number = 5;
  lastDraw: number = 0;
  drawTimestamp: number = 0;
  drawInterval: number = 4;

  // Add a list to keep track of BeamEffect instances
  beamEffects: BeamEffect[] = [];

  // Add this property to track created mask canvases
  private maskCanvases: HTMLCanvasElement[] = [];

  constructor(
    game: Game,
    x: number,
    y: number,
    w: number,
    h: number,
    type: RoomType,
    depth: number,
    mapGroup: number,
    level: Level,
    rand = Random.rand,
  ) {
    this.game = game;
    this.roomX = x; //Math.floor(- this.width / 2);
    this.roomY = y; //Math.floor(- this.height / 2);
    this.width = w;
    this.height = h;
    this.type = type;
    this.depth = depth;
    this.mapGroup = mapGroup;

    this.entered = false;
    this.turn = TurnState.playerTurn;
    this.playerTurnTime = Date.now();

    this.items = Array<Item>();
    this.projectiles = Array<Projectile>();
    this.hitwarnings = Array<HitWarning>();
    this.particles = Array<Particle>();
    this.doors = Array<Door>();
    this.entities = Array<Entity>();
    this.lightSources = Array<LightSource>();
    this.innerWalls = Array<Wall>();
    this.level = level;
    this.id = 0;
    this.currentSpawnerCount = 0;
    this.deadEntities = Array<Entity>();
    this.active = false;
    this.lastLightingUpdate = 0;
    this.walls = Array<Wall>();
    this.decorations = Array<Decoration>();
    // Initialize Color Offscreen Canvas
    this.colorOffscreenCanvas = document.createElement("canvas");
    this.colorOffscreenCanvas.width =
      (this.width + 10) * GameConstants.TILESIZE;
    this.colorOffscreenCanvas.height =
      (this.height + 10) * GameConstants.TILESIZE;
    const colorCtx = this.colorOffscreenCanvas.getContext("2d");
    if (!colorCtx) {
      throw new Error("Failed to initialize color offscreen canvas context.");
    }
    this.colorOffscreenCtx = colorCtx;

    // Initialize Shade Offscreen Canvas
    this.shadeOffscreenCanvas = document.createElement("canvas");
    this.shadeOffscreenCanvas.width =
      (this.width + 10) * GameConstants.TILESIZE;
    this.shadeOffscreenCanvas.height =
      (this.height + 10) * GameConstants.TILESIZE;
    const shadeCtx = this.shadeOffscreenCanvas.getContext("2d");
    if (!shadeCtx) {
      throw new Error("Failed to initialize shade offscreen canvas context.");
    }
    this.shadeOffscreenCtx = shadeCtx;

    // Initialize Bloom Offscreen Canvas
    this.bloomOffscreenCanvas = document.createElement("canvas");
    this.bloomOffscreenCanvas.width =
      (this.width + 10) * GameConstants.TILESIZE;
    this.bloomOffscreenCanvas.height =
      (this.height + 10) * GameConstants.TILESIZE;
    const bloomCtx = this.bloomOffscreenCanvas.getContext("2d");
    if (!bloomCtx) {
      throw new Error("Failed to initialize bloom offscreen canvas context.");
    }
    this.bloomOffscreenCtx = bloomCtx;

    // #region initialize arrays

    //initialize room array

    this.roomArray = [];
    for (let x = this.roomX - 1; x < this.roomX + this.width + 1; x++) {
      this.roomArray[x] = [];
      for (let y = this.roomY - 1; y < this.roomY + this.height + 1; y++) {
        this.roomArray[x][y] = null;
      }
    }

    //initialize visibility & color arrays, as well as their soft variants
    this.vis = [];
    this.softVis = [];
    this.col = [];
    this.softCol = [];
    for (let x = this.roomX; x < this.roomX + this.width; x++) {
      this.vis[x] = [];
      this.softVis[x] = [];
      this.col[x] = [];
      this.softCol[x] = [];
      for (let y = this.roomY; y < this.roomY + this.height; y++) {
        this.vis[x][y] = 1;
        this.softVis[x][y] = 1;
        this.col[x][y] = [0, 0, 0];
        this.softCol[x][y] = [0, 0, 0];
      }
    }

    //initialize the render buffer array
    this.renderBuffer = [];
    for (let x = this.roomX; x < this.roomX + this.width; x++) {
      this.renderBuffer[x] = [];
      for (let y = this.roomY; y < this.roomY + this.height; y++) {
        this.renderBuffer[x][y] = [];
      }
    }

    //initialize the skin for the given environment
    this.skin = this.level.environment.skin;
    if (this.type === RoomType.ROPECAVE || this.type === RoomType.CAVE)
      this.skin = SkinType.CAVE;
    this.buildEmptyRoom();

    // #endregion
  }

  // #region TILE ADDING METHODS

  private buildEmptyRoom() {
    // fill in wall and floor
    for (let x = this.roomX; x < this.roomX + this.width; x++) {
      for (let y = this.roomY; y < this.roomY + this.height; y++) {
        if (
          this.pointInside(
            x,
            y,
            this.roomX + 1,
            this.roomY + 1,
            this.width - 2,
            this.height - 2,
          )
        ) {
          this.roomArray[x][y] = new Floor(this, x, y);
        } else {
          this.roomArray[x][y] = new Wall(
            this,
            x,
            y,
            this.getWallType(
              x,
              y,
              this.roomX,
              this.roomY,
              this.width,
              this.height,
            ),
          );
        }
      }
    }
  }

  private removeWall = (x: number, y: number) => {
    if (this.roomArray[x][y] instanceof Wall) {
      this.roomArray[x][y] = null;
    }
    //this.innerWalls = this.innerWalls.filter((w) => w.x !== x && w.y !== y);
    //this.outerWalls = this.outerWalls.filter((w) => w.x !== x && w.y !== y);
  };

  private getWallType = (
    pointX: number,
    pointY: number,
    rectX: number,
    rectY: number,
    width: number,
    height: number,
  ): Array<WallDirection> => {
    let directions: Array<WallDirection> = [];
    if (pointY === rectY && pointX >= rectX && pointX <= rectX + width)
      directions.push(WallDirection.NORTH);
    if (pointY === rectY + height && pointX >= rectX && pointX <= rectX + width)
      directions.push(WallDirection.SOUTH);
    if (pointX === rectX && pointY >= rectY && pointY <= rectY + height)
      directions.push(WallDirection.WEST);
    if (pointX === rectX + width && pointY >= rectY && pointY <= rectY + height)
      directions.push(WallDirection.EAST);
    return directions;
  };

  private addWallBlocks(rand: () => number) {
    let numBlocks = Game.randTable([0, 0, 1, 1, 2, 2, 2, 2, 3], rand);
    if (this.width > 8 && rand() > 0.5) numBlocks *= 4;
    for (let i = 0; i < numBlocks; i++) {
      let blockW = Math.min(
        Game.randTable([2, 2, 2, 2, 2, 2, 3, 3, 3, 4, 5], rand),
        this.width - 4,
      );
      let blockH = Math.min(blockW + Game.rand(-2, 2, rand), this.height - 4);

      let x = Game.rand(
        this.roomX + 2,
        this.roomX + this.width - blockW - 2,
        rand,
      );
      let y = Game.rand(
        this.roomY + 2,
        this.roomY + this.height - blockH - 2,
        rand,
      );
      let neighborCount = (wall: Wall) => {
        let count = 0;
        for (let xx = wall.x - 1; xx <= wall.x + 1; xx++) {
          for (let yy = wall.y - 1; yy <= wall.y + 1; yy++) {
            if (
              this.roomArray[xx]?.[yy] instanceof Wall &&
              !(xx === wall.x && yy === wall.y)
            )
              count++;
          }
        }
        return count;
      };

      for (let xx = x; xx < x + blockW; xx++) {
        for (let yy = y; yy < y + blockH; yy++) {
          let w = new Wall(this, xx, yy);
          this.roomArray[xx][yy] = w;
          this.innerWalls.push(w);
        }
      }
      this.innerWalls.forEach((wall) => {
        if (neighborCount(wall) <= 1) {
          this.removeWall(wall.x, wall.y);
          this.roomArray[wall.x][wall.y] = new Floor(this, wall.x, wall.y);
          this.innerWalls = this.innerWalls.filter((w) => w !== wall);
        }
      });
    }
  }

  private addTorches(
    numTorches: number,
    rand: () => number,
    placeX?: number,
    placeY?: number,
  ) {
    if (
      this.level.environment.type === EnvType.FOREST &&
      this.type !== RoomType.DOWNLADDER
    )
      return;

    if (
      placeX !== undefined &&
      placeY !== undefined &&
      this.roomArray[placeX]?.[placeY] instanceof Wall
    ) {
      this.roomArray[placeX][placeY] = new WallTorch(this, placeX, placeY);

      return;
    }

    let walls = [];
    for (let xx = this.roomX + 1; xx < this.roomX + this.width - 2; xx++) {
      for (let yy = this.roomY; yy < this.roomY + this.height - 1; yy++) {
        if (
          this.roomArray[xx][yy] instanceof Wall &&
          !(this.roomArray[xx][yy + 1] instanceof Wall)
        ) {
          walls.push(this.roomArray[xx][yy]);
        }
      }
    }

    for (let i = 0; i < numTorches; i++) {
      if (walls.length == 0) return;
      const randomIndex = Game.rand(0, walls.length - 1, rand);
      const t = walls.splice(randomIndex, 1)[0];
      const x = t.x;
      const y = t.y;
      this.roomArray[x][y] = new WallTorch(this, x, y);
    }
  }

  private addChasms(rand: () => number) {
    // add chasms
    let w = Game.rand(2, 4, rand);
    let h = Game.rand(2, 4, rand);
    let xmin = this.roomX + 2;
    let xmax = this.roomX + this.width - w - 2;
    let ymin = this.roomY + 2;
    let ymax = this.roomY + this.height - h - 2;
    if (xmax < xmin || ymax < ymin) return;
    let x = Game.rand(xmin, xmax, rand);
    let y = Game.rand(ymin, ymax, rand);

    for (let xx = x - 1; xx < x + w + 1; xx++) {
      for (let yy = y - 1; yy < y + h + 1; yy++) {
        // add a floor border
        if (xx === x - 1 || xx === x + w || yy === y - 1 || yy === y + h) {
          if (!(this.roomArray[xx][yy] instanceof SpawnFloor))
            this.roomArray[xx][yy] = new Floor(this, xx, yy);
        } else
          this.roomArray[xx][yy] = new Chasm(
            this,
            xx,
            yy,
            xx === x,
            xx === x + w - 1,
            yy === y,
            yy === y + h - 1,
          );
      }
    }
  }

  addDoor = (
    x: number,
    y: number,
    room: Room = this,
    tunnelDoor: boolean = false,
  ) => {
    let d;
    let t = DoorType.DOOR;
    if (room.type === RoomType.BOSS) t = DoorType.GUARDEDDOOR;
    if (room.type === RoomType.KEYROOM) t = DoorType.LOCKEDDOOR;
    if (tunnelDoor) t = DoorType.TUNNELDOOR;
    if (x === room.roomX) {
      d = new Door(room, room.game, x, y, Direction.RIGHT, t);
      room.roomArray[x + 1][y] = new SpawnFloor(room, x + 1, y);
    } else if (x === room.roomX + room.width - 1) {
      d = new Door(room, room.game, x, y, Direction.LEFT, t);
      room.roomArray[x - 1][y] = new SpawnFloor(room, x - 1, y);
    } else if (y === room.roomY) {
      d = new Door(room, room.game, x, y, Direction.UP, t);
      room.roomArray[x][y + 1] = new SpawnFloor(room, x, y + 1);
    } else if (y === room.roomY + room.height - 1) {
      d = new Door(room, room.game, x, y, Direction.DOWN, t);
      room.roomArray[x][y - 1] = new SpawnFloor(room, x, y - 1);
    }

    if (tunnelDoor) {
      room.tunnelDoor = d;
    }

    room.doors.push(d);
    if (room.roomArray[d.x] == undefined) {
      console.log("door not added");
    }
    room.roomArray[d.x][d.y] = d;

    return d;
  };

  // ... start of file ...

  private addSpikeTraps(numSpikes: number, rand: () => number) {
    if (this.level.environment.type === EnvType.FOREST) return;
    // add spikes
    let tiles = this.getEmptyTiles();
    for (let i = 0; i < numSpikes; i++) {
      const { x, y } = this.getRandomEmptyPosition(tiles);
      this.roomArray[x][y] = new SpikeTrap(this, x, y);
    }
  }

  // #endregion

  // #region ADDING ENTITIES

  // Function to add enemies to the room
  private addEnemies(numEnemies: number, rand: () => number) {
    // Get all empty tiles in the room
    let tiles = this.getEmptyTiles();
    if (tiles === null) return;
    //don't put enemies near the entrances so you don't get screwed instantly

    // Create a Set to store coordinates that should be excluded
    const excludedCoords = new Set<string>();

    // For each door, add coordinates in a 5x5 area around it to excluded set
    for (const door of this.doors) {
      for (let dx = -2; dx <= 2; dx++) {
        for (let dy = -2; dy <= 2; dy++) {
          excludedCoords.add(`${door.x + dx},${door.y + dy}`);
        }
      }
    }

    // Filter tiles that aren't in the excluded set
    tiles = tiles.filter((tile) => !excludedCoords.has(`${tile.x},${tile.y}`));
    // Loop through the number of enemies to be added
    for (let i = 0; i < numEnemies; i++) {
      let rerolls = 1;

      if (tiles.length === 0) {
        console.log(`No tiles left to spawn enemies`);
        break;
      }
      let emptyTiles = this.getRandomEmptyPosition(tiles);
      if (emptyTiles.x === null || emptyTiles.y === null) {
        i = numEnemies;
        break;
      }
      const { x, y } = emptyTiles;

      // Define the enemy tables for each depth level
      let tables = this.level.enemyParameters.enemyTables;
      // Define the maximum depth level
      let max_depth_table = this.level.enemyParameters.maxDepthTable;
      // Get the current depth level, capped at the maximum
      let d = Math.min(this.depth, max_depth_table);
      // If there is a table for the current depth level
      if (tables[d] && tables[d].length > 0) {
        // Function to add an enemy to the room
        let addEnemy = (enemy: Entity): boolean => {
          // Check if the enemy overlaps with any other enemies
          for (let xx = 0; xx < enemy.w; xx++) {
            for (let yy = 0; yy < enemy.h; yy++) {
              if (!tiles.some((tt) => tt.x === x + xx && tt.y === y + yy)) {
                // If it does, increment the enemy count and return false
                numEnemies++;
                return false;
              }
            }
          }
          // If it doesn't, add the enemy to the room, remove the tiles used from the available pool, and return true
          this.entities.push(enemy);
          for (let xx = 0; xx < enemy.w; xx++) {
            for (let yy = 0; yy < enemy.h; yy++) {
              tiles = tiles.filter((t) => !(t.x === x + xx && t.y === y + yy));
            }
          }
          return true;
        };

        // Randomly select an enemy type from the table
        let type = Game.randTable(tables[d], Random.rand);

        switch (type) {
          case 1:
            CrabEnemy.add(this, this.game, x, y);
            break;
          case 2:
            FrogEnemy.add(this, this.game, x, y);
            break;
          case 3:
            ZombieEnemy.add(this, this.game, x, y);
            break;
          case 4:
            SkullEnemy.add(this, this.game, x, y);
            break;
          case 5:
            EnergyWizardEnemy.add(this, this.game, x, y);
            break;
          case 6:
            ChargeEnemy.add(this, this.game, x, y);
            break;
          case 7:
            RookEnemy.add(this, this.game, x, y);
            break;
          case 8:
            BishopEnemy.add(this, this.game, x, y);
            break;
          case 9:
            ArmoredzombieEnemy.add(this, this.game, x, y);
            break;
          case 10:
            if (addEnemy(new BigSkullEnemy(this, this.game, x, y))) {
              // clear out some space
              for (let xx = 0; xx < 2; xx++) {
                for (let yy = 0; yy < 2; yy++) {
                  this.roomArray[x + xx][y + yy] = new Floor(
                    this,
                    x + xx,
                    y + yy,
                  ); // remove any walls
                }
              }
            }
            break;
          case 11:
            QueenEnemy.add(this, this.game, x, y);
            break;
          case 12:
            KnightEnemy.add(this, this.game, x, y);
            break;
          case 13:
            if (addEnemy(new BigKnightEnemy(this, this.game, x, y))) {
              // clear out some space
              for (let xx = 0; xx < 2; xx++) {
                for (let yy = 0; yy < 2; yy++) {
                  this.roomArray[x + xx][y + yy] = new Floor(
                    this,
                    x + xx,
                    y + yy,
                  ); // remove any walls
                }
              }
            }
            break;
          case 14:
            ZombieEnemy.add(this, this.game, x, y);
            break;
          case 15:
            FireWizardEnemy.add(this, this.game, x, y);
            break;
        }
      }
    }
    let spawnerAmounts = [
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2,
      2, 2, 3, 3, 4, 5, 3,
    ];
    if (this.depth > 0) {
      let spawnerAmount = Game.randTable(spawnerAmounts, rand);
      //console.log(`Adding ${spawnerAmount} spawners`);
      this.addSpawners(spawnerAmount, rand);
    }
    let occultistAmounts = [
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1,
    ];
    if (this.depth > 1) {
      let occultistAmount = Game.randTable(occultistAmounts, rand);
      //console.log(`Adding ${occultistAmount} occultists`);
      this.addOccultists(occultistAmount, rand);
    }
  }

  private addRandomEnemies() {
    let numEmptyTiles = this.getEmptyTiles().length;

    let numEnemies = Math.ceil(
      numEmptyTiles * Math.min(this.depth * 0.1 + 0.5, 0.15), //this.depth * 0.01 is starting value
    );
    if (numEnemies > numEmptyTiles / 2) numEnemies = numEmptyTiles / 2;
    this.addEnemies(numEnemies, Random.rand);
  }

  private addSpawners(numSpawners: number, rand: () => number) {
    let tiles = this.getEmptyTiles();
    if (tiles === null) {
      //console.log(`No tiles left to spawn spawners`);
      return;
    }
    for (let i = 0; i < numSpawners; i++) {
      const { x, y } = this.getRandomEmptyPosition(tiles);
      let spawnTable = this.level
        .getEnemyParameters()
        .enemyTables[this.depth].filter((t) => t !== 7);
      Spawner.add(this, this.game, x, y, spawnTable);
    }
  }
  private addOccultists(numOccultists: number, rand: () => number) {
    let tiles = this.getEmptyTiles();
    if (tiles === null) {
      //console.log(`No tiles left to spawn spawners`);
      return;
    }
    for (let i = 0; i < numOccultists; i++) {
      const { x, y } = this.getRandomEmptyPosition(tiles);
      OccultistEnemy.add(this, this.game, x, y);
    }
  }
  //used for spawn commands, implement elsewhere later
  /**
   * Adds a new enemy to the room based on the provided enemy type string.
   *
   * @param enemyType - The string identifier for the enemy type.
   */
  addNewEnemy = (enemyType: EnemyType): void => {
    const EnemyClass = EnemyTypeMap[enemyType];
    if (!EnemyClass) {
      console.error(`Enemy type "${enemyType}" is not recognized.`);
      return;
    }

    const tiles = this.getEmptyTiles();
    if (!tiles || tiles.length === 0) {
      // console.log(`No tiles left to spawn enemies.`);
      return;
    }

    const { x, y } = this.getRandomEmptyPosition(tiles);
    EnemyClass.add(this, this.game, x, y);
  };

  addNewSpawner = (enemyType: EnemyType): void => {
    const EnemyClass = EnemyTypeMap[enemyType];
    if (!EnemyClass) {
      //console.error(`Enemy type "${enemyType}" is not recognized.`);
      return;
    }

    const tiles = this.getEmptyTiles();
    if (!tiles || tiles.length === 0) {
      // console.log(`No tiles left to spawn enemies.`);
      return;
    }

    const { x, y } = this.getRandomEmptyPosition(tiles);
    Spawner.add(this, this.game, x, y);
  };

  private addChests(numChests: number, rand: () => number) {
    // add chests
    let tiles = this.getEmptyTiles();
    for (let i = 0; i < numChests; i++) {
      const { x, y } = this.getRandomEmptyPosition(tiles);
      this.entities.push(new Chest(this, this.game, x, y));
    }
  }

  private addObstacles(numObstacles: number, rand: () => number) {
    // add crates/barrels
    let tiles = this.getEmptyTiles();
    for (let i = 0; i < numObstacles; i++) {
      const { x, y } = this.getRandomEmptyPosition(tiles);
      const env = this.level.environment.type; //bootleg variable to start to vary the environments
      switch (
        Game.randTable(
          [
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 5, 5, 5,
            6, 6, 6, 6, 6, 6, 6,
          ],
          rand,
        )
      ) {
        case 1:
          if (env === EnvType.FOREST) break;
          Crate.add(this, this.game, x, y);
          break;
        case 2:
          if (env === EnvType.FOREST) break;

          Barrel.add(this, this.game, x, y);
          break;
        case 3:
          if (env === EnvType.CAVE) break;
          TombStone.add(this, this.game, x, y, 1);
          break;
        case 4:
          if (env === EnvType.CAVE) break;

          TombStone.add(this, this.game, x, y, 0);
          break;
        case 5:
          if (env === EnvType.CAVE) break;

          Pumpkin.add(this, this.game, x, y);
          break;
        case 6:
          Block.add(this, this.game, x, y);
          break;
      }
    }
  }

  addBombs(numBombs: number, rand: () => number) {
    let tiles = this.getEmptyTiles();
    for (let i = 0; i < this.getEmptyTiles().length; i++) {
      const { x, y } = this.getRandomEmptyPosition(tiles);
      Bomb.add(this, this.game, x, y);
    }
  }

  private addPlants(numPlants: number, rand: () => number) {
    let tiles = this.getEmptyTiles();
    for (let i = 0; i < numPlants; i++) {
      const { x, y } = this.getRandomEmptyPosition(tiles);

      let r = rand();
      if (r <= 0.45) PottedPlant.add(this, this.game, x, y);
      else if (r <= 0.65) Pot.add(this, this.game, x, y);
      else if (r <= 0.75) Rock.add(this, this.game, x, y);
      else if (r <= 0.97) Mushrooms.add(this, this.game, x, y);
      else Chest.add(this, this.game, x, y);
    }
  }

  private addDecorations(numDecorations: number, rand: () => number) {
    let tiles = this.getEmptyTiles();
    for (let i = 0; i < numDecorations; i++) {
      const { x, y } = this.getRandomEmptyPosition(tiles);
      this.decorations.push(new Puddle(this, x, y));
    }
  }

  private addResources(numResources: number, rand: () => number) {
    let tiles = this.getEmptyTiles();
    for (let i = 0; i < numResources; i++) {
      const { x, y } = this.getRandomEmptyPosition(tiles);

      let r = rand();
      if (r <= (10 - this.depth ** 3) / 10)
        CoalResource.add(this, this.game, x, y);
      else if (r <= (10 - (this.depth - 2) ** 3) / 10)
        GoldResource.add(this, this.game, x, y);
      else EmeraldResource.add(this, this.game, x, y);
    }
  }

  private addVendingMachine(
    rand: () => number,
    placeX?: number,
    placeY?: number,
  ) {
    const pos = this.getRandomEmptyPosition(this.getEmptyTiles());

    let x = placeX ? placeX : pos.x;
    let y = placeY ? placeY : pos.y;

    let table =
      this.depth > 0
        ? [1, 1, 1, 1, 1, 1, 1, 2, 3, 4, 5, 6, 7, 8, 9]
        : [1, 1, 1];
    let type = Game.randTable(table, rand);
    switch (type) {
      case 1:
        VendingMachine.add(this, this.game, x, y, new Heart(this, x, y));
        break;
      case 2:
        VendingMachine.add(this, this.game, x, y, new Lantern(this, x, y));
        break;
      case 3:
        VendingMachine.add(this, this.game, x, y, new Armor(this, x, y));
        break;
      case 4:
        VendingMachine.add(this, this.game, x, y, new DualDagger(this, x, y));
        break;
      case 5:
        VendingMachine.add(this, this.game, x, y, new Spear(this, x, y));
        break;
      case 6:
        VendingMachine.add(this, this.game, x, y, new Shotgun(this, x, y));
        break;
      case 7:
        VendingMachine.add(this, this.game, x, y, new Warhammer(this, x, y));
        break;
      case 8:
        VendingMachine.add(this, this.game, x, y, new Spellbook(this, x, y));
        break;
      case 9:
        VendingMachine.add(this, this.game, x, y, new Torch(this, x, y));
        break;
    }
  }

  // #endregion

  // #region POPULATING METHODS

  linkExitToStart = () => {
    //if (this.type === RoomType.ROPEHOLE) return;
    if (
      this.addDoorWithOffset(
        this.level.startRoom.roomX +
          Math.floor(this.level.startRoom.width / 2) +
          1,
        this.level.startRoom.roomY,
        this.level.startRoom,
        true,
      ) &&
      this.addDoorWithOffset(
        this.roomX + Math.floor(this.width / 2) - 1,
        this.roomY,
        this,
        true,
      )
    ) {
      this.tunnelDoor.linkedDoor = this.level.startRoom.tunnelDoor;
      this.tunnelDoor.linkedDoor.linkedDoor = this.tunnelDoor;
    }
  };

  populateEmpty = (rand: () => number) => {
    this.addTorchesByArea();
  };

  populateDungeon = (rand: () => number) => {
    //this.addChests(10, rand);
    let factor = Game.rand(1, 36, rand);

    if (factor < 30) this.addWallBlocks(rand);
    if (factor % 4 === 0) this.addChasms(rand);
    this.addTorchesByArea();
    if (factor > 15)
      this.addSpikeTraps(Game.randTable([0, 0, 0, 1, 1, 2, 3], rand), rand);
    let numEmptyTiles = this.getEmptyTiles().length;
    let numTotalObstacles = Math.floor(numEmptyTiles * 0.35 * rand());
    let numPlants = Math.ceil(numTotalObstacles * rand());
    let numObstacles = numTotalObstacles - numPlants;
    this.addPlants(numPlants, rand);
    //this.addDecorations(Game.randTable([0, 0, 0, 1, 1, 2, 3], rand), rand);
    this.addObstacles(numObstacles, rand);

    if (factor <= 6) this.addVendingMachine(rand);
    this.addRandomEnemies();

    this.removeDoorObstructions();
  };

  populateBoss = (rand: () => number) => {
    this.addTorchesByArea();

    this.addSpikeTraps(Game.randTable([0, 0, 0, 1, 1, 2, 5], rand), rand);
    let numEmptyTiles = this.getEmptyTiles().length;
    let numTotalObstacles = Math.floor(numEmptyTiles * 0.2);
    let numPlants = Math.floor(numTotalObstacles * rand());
    let numObstacles = numTotalObstacles - numPlants;
    this.addPlants(numPlants, rand);
    this.addObstacles(numObstacles, rand);

    this.addRandomEnemies();
  };

  populateBigDungeon = (rand: () => number) => {
    if (Game.rand(1, 4, rand) === 1) this.addChasms(rand);
    this.addTorchesByArea();

    if (Game.rand(1, 4, rand) === 1)
      this.addPlants(
        Game.randTable([0, 0, 0, 0, 0, 1, 1, 2, 2, 3, 4], rand),
        rand,
      );
    if (Game.rand(1, 3, rand) === 1)
      this.addSpikeTraps(Game.randTable([3, 5, 7, 8], rand), rand);
    this.addRandomEnemies();

    this.addObstacles(Game.randTable([0, 0, 1, 1, 2, 3, 5], rand), rand);
    this.removeDoorObstructions();
  };

  populateSpawner = (rand: () => number) => {
    this.addTorchesByArea();

    Spawner.add(
      this,
      this.game,
      Math.floor(this.roomX + this.width / 2),
      Math.floor(this.roomY + this.height / 2),
    );
    this.removeDoorObstructions();
  };

  populateKeyRoom = (rand: () => number) => {
    this.addRandomTorches("medium");

    this.items.push(
      new GoldenKey(
        this,
        Math.floor(this.roomX + this.width / 2),
        Math.floor(this.roomY + this.height / 2),
      ),
    );
  };

  populateFountain = (rand: () => number) => {
    this.addRandomTorches("medium");

    let centerX = Math.floor(this.roomX + this.width / 2);
    let centerY = Math.floor(this.roomY + this.height / 2);
    for (let x = centerX - 1; x <= centerX + 1; x++) {
      for (let y = centerY - 1; y <= centerY + 1; y++) {
        this.roomArray[x][y] = new FountainTile(
          this,
          x,
          y,
          x - (centerX - 1),
          y - (centerY - 1),
        );
      }
    }

    this.addPlants(Game.randTable([0, 0, 1, 2], rand), rand);
  };

  placeCoffin = (x: number, y: number) => {
    this.roomArray[x][y] = new CoffinTile(this, x, y, 0);
    this.roomArray[x][y + 1] = new CoffinTile(this, x, y + 1, 1);
  };

  populateCoffin = (rand: () => number) => {
    this.addRandomTorches("medium");

    this.placeCoffin(
      Math.floor(this.roomX + this.width / 2 - 2),
      Math.floor(this.roomY + this.height / 2),
    );
    this.placeCoffin(
      Math.floor(this.roomX + this.width / 2),
      Math.floor(this.roomY + this.height / 2),
    );
    this.placeCoffin(
      Math.floor(this.roomX + this.width / 2) + 2,
      Math.floor(this.roomY + this.height / 2),
    );
  };

  populatePuzzle = (rand: () => number) => {
    let d;

    for (let x = this.roomX; x < this.roomX + this.width; x++) {
      let y = this.roomY + Math.floor(this.height / 2);
      if (x === this.roomX + Math.floor(this.width / 2)) {
        d = new InsideLevelDoor(this, this.game, x, y + 1);
        this.roomArray[x][y + 1] = d;
      } else {
        this.roomArray[x][y] = new Wall(this, x, y);
      }
    }

    let x = Game.rand(this.roomX, this.roomX + this.width - 1, rand);
    let y = Game.rand(
      this.roomY + Math.floor(this.height / 2) + 3,
      this.roomY + this.height - 2,
      rand,
    );

    this.roomArray[x][y] = new Button(this, x, y, d);

    let crateTiles = this.getEmptyTiles().filter(
      (t) =>
        t.x >= this.roomX + 1 &&
        t.x <= this.roomX + this.width - 2 &&
        t.y >= this.roomY + Math.floor(this.height / 2) + 3 &&
        t.y <= this.roomY + this.height - 2,
    );
    let numCrates = Game.randTable([1, 2, 2, 3, 4], rand);

    for (let i = 0; i < numCrates; i++) {
      let t = crateTiles.splice(
        Game.rand(0, crateTiles.length - 1, rand),
        1,
      )[0];
      if (t) this.entities.push(new Crate(this, this.game, t.x, t.y));
    }
    this.addPlants(
      Game.randTable([0, 0, 0, 0, 0, 1, 1, 2, 2, 3, 4], rand),
      rand,
    );
    this.removeDoorObstructions();
  };

  populateSpikeCorridor = (rand: () => number) => {
    for (let x = this.roomX; x < this.roomX + this.width; x++) {
      for (let y = this.roomY + 1; y < this.roomY + this.height - 1; y++) {
        this.roomArray[x][y] = new SpikeTrap(this, x, y, Game.rand(0, 3, rand));
      }
    }
    this.removeDoorObstructions();
    this.addRandomTorches("medium");
  };

  populateTreasure = (rand: () => number) => {
    this.addRandomTorches("medium");

    this.addChests(Game.randTable([4, 4, 5, 5, 5, 6, 8], rand), rand);
    this.addPlants(Game.randTable([0, 1, 2, 4, 5, 6], rand), rand);
  };

  populateCave = (rand: () => number) => {
    let factor = Game.rand(1, 36, rand);

    this.addWallBlocks(rand);

    if (factor > 15)
      this.addSpikeTraps(Game.randTable([0, 0, 0, 1, 1, 2, 5], rand), rand);
    let numEmptyTiles = this.getEmptyTiles().length;
    let numEnemies = Math.ceil(
      numEmptyTiles * Game.randTable([0.25, 0.3, 0.35], rand),
    );
    this.addEnemies(numEnemies, rand);
    if (this.level.environment.type === EnvType.CAVE)
      this.addResources(
        (numEmptyTiles - numEnemies) * Game.randTable([0.1, 0.2, 0.3], rand),
        rand,
      );
    this.removeDoorObstructions();
  };

  populateUpLadder = (rand: () => number) => {
    this.addRandomTorches("medium");

    const { x, y } = this.getRoomCenter();
    this.roomArray[x - 1][y - 1] = new UpLadder(this, this.game, x - 1, y - 1);
  };

  populateDownLadder = (rand: () => number) => {
    this.addTorches(1, rand, this.roomX + 3, this.roomY);

    const { x, y } = this.getRoomCenter();
    this.roomArray[x + 1][y - 1] = new DownLadder(
      this,
      this.game,
      x + 1,
      y - 1,
    );

    const numChests = Math.ceil(Random.rand() * 5);

    let tiles = this.getEmptyTiles();
    tiles = tiles.filter((tile) => tile.x !== x || tile.y !== y);
    let weaponDropped = false;
    let toolDropped = false;
    let lightDropped = false;
    for (let i = 0; i < numChests; i++) {
      if (tiles.length > 0) {
        const { x, y } = this.getRandomEmptyPosition(tiles);

        let chest = new Chest(this, this.game, x, y);

        if (!weaponDropped) {
          chest.getDrop(["weapon"], true);
          weaponDropped = true;
        } else {
          chest.getDrop(
            ["consumable", "gem", "light", "tool", "fuel", "backpack"],
            true,
          );
        }

        tiles.filter((tile) => tile.x !== x && tile.y !== y);
        this.entities.push(chest);
      }
    }
  };

  populateRopeHole = (rand: () => number) => {
    this.addRandomTorches("medium");

    const { x, y } = this.getRoomCenter();
    let d = new DownLadder(this, this.game, x, y);
    d.isRope = true;
    this.roomArray[x][y] = d;
  };

  populateRopeCave = (rand: () => number) => {
    const { x, y } = this.getRoomCenter();
    let upLadder = new UpLadder(this, this.game, x, y);
    upLadder.isRope = true;
    this.roomArray[x][y] = upLadder;

    this.removeDoorObstructions();
  };

  populateShop = (rand: () => number) => {
    this.addTorches(2, rand);

    const { x, y } = this.getRoomCenter();
    VendingMachine.add(this, this.game, x - 2, y - 1, new Shotgun(this, 0, 0));
    VendingMachine.add(this, this.game, x + 2, y - 1, new Heart(this, 0, 0));
    VendingMachine.add(this, this.game, x - 2, y + 2, new Armor(this, 0, 0));
    VendingMachine.add(this, this.game, x + 2, y + 2, new Spear(this, 0, 0));

    this.removeDoorObstructions();
  };

  // Many populate methods start with adding torches using the same pattern
  private addRandomTorches(
    intensity: "none" | "low" | "medium" | "high" = "medium",
  ): void {
    const torchPatterns = {
      none: [0, 0, 0],
      low: [0, 0, 0, 1, 1],
      medium: [0, 0, 0, 1, 1, 2, 2, 3],
      high: [1, 1, 2, 2, 3, 3, 4],
    };
    const randTorches = Game.randTable(torchPatterns[intensity], Random.rand);
    this.addTorches(randTorches, Random.rand);
  }

  private addTorchesByArea = () => {
    let numTorches = Math.max(
      1,
      Math.floor(Math.sqrt(this.roomArea) / 3) -
        Math.floor(Math.sqrt(this.depth)),
    );
    if (this.depth === 0) {
      if (Random.rand() < 0.25) {
        numTorches = 0;
      }
    } else {
      // Exponential falloff starting at depth 1, approaching 90% chance
      const falloffRate = 0.4; // Controls how quickly it approaches 90%
      const maxChance = 0.9;
      const chance =
        maxChance * (1 - Math.exp(-falloffRate * (this.depth - 1)));
      if (Random.rand() < chance) {
        numTorches = 0;
      }
    }
    console.log("numTorches:" + numTorches, "roomArea" + this.roomArea);
    this.addTorches(numTorches, Random.rand);
  };

  // Used in populateDungeon, populateCave, etc. NOT IN USE
  private populateWithEntities(config: {
    enemyDensity: number;
    obstacleDensity: number;
    plantDensity: number;
  }): void {
    const numEmptyTiles = this.getEmptyTiles().length;
    const numEnemies = Math.ceil(numEmptyTiles * config.enemyDensity);
    const numObstacles = Math.ceil(numEmptyTiles * config.obstacleDensity);
    const numPlants = Math.ceil(numEmptyTiles * config.plantDensity);

    this.addEnemies(numEnemies, Random.rand);
    this.addObstacles(numObstacles, Random.rand);
    this.addPlants(numPlants, Random.rand);
  }

  populate = (rand: () => number) => {
    this.name = "";
    switch (this.type) {
      case RoomType.START:
        //this.addNewEnemy(EnemyType.zombie);
        //this.addNewEnemy(EnemyType.occultist);
        //this.addNewEnemy(EnemyType.occultist);

        //   this.addNewEnemy(EnemyType.occultist);

        if (this.depth !== 0) {
          this.populateUpLadder(rand);
          //this.addVendingMachine(rand, this.roomX + 1, this.roomY + 1);
          this.placeVendingMachineInWall();
        }

        this.populateEmpty(rand);
        this.name = "FLOOR " + -this.depth;
        if (this.level.environment.type === EnvType.CAVE) {
          const { x, y } = this.getRoomCenter();
          let sign = Random.rand() < 0.5 ? -1 : 1;
          let offsetX = Math.floor(Random.rand()) * sign;
          let offsetY = offsetX !== 0 ? 0 : sign;
          this.items.push(new Pickaxe(this, x + offsetX, y + offsetY));
        }
        break;
      case RoomType.BOSS:
        this.populateBoss(rand);
        this.name = "BOSS";
        break;
      case RoomType.DUNGEON:
        if (
          this.level.environment.type === EnvType.CAVE &&
          Random.rand() <= 0.2
        ) {
          this.populateCave(rand);
        } else {
          this.populateDungeon(rand);
        }
        break;
      case RoomType.BIGDUNGEON:
        this.populateBigDungeon(rand);
        break;
      case RoomType.FOUNTAIN:
        this.populateFountain(rand);
        break;
      case RoomType.COFFIN:
        this.populateCoffin(rand);
        break;
      case RoomType.PUZZLE:
        this.populatePuzzle(rand);
        break;
      case RoomType.SPIKECORRIDOR:
        this.populateSpikeCorridor(rand);
        break;
      case RoomType.TREASURE:
        this.populateTreasure(rand);
        break;
      case RoomType.KEYROOM:
        this.populateKeyRoom(rand);
        break;
      case RoomType.GRASS:
        this.populateDungeon(rand);
        break;
      case RoomType.BIGCAVE:
        this.populateCave(rand);
      case RoomType.CAVE:
        this.populateCave(rand);
        break;
      case RoomType.UPLADDER:
        this.populateUpLadder(rand);
        this.name = "FLOOR " + -this.depth;

        break;
      case RoomType.DOWNLADDER:
        this.populateDownLadder(rand);
        this.name = "FLOOR " + -this.depth;
        break;
      case RoomType.ROPEHOLE:
        this.populateRopeHole(rand);
        break;
      case RoomType.ROPECAVE:
        this.populateRopeCave(rand);
        break;
      case RoomType.SHOP:
        /* shop rates:
         * 10 coal for an gold coin
         * 1 gold for 10 coins
         * 1 emerald for 100 coins
         *
         * shop items:
         * 1 empty heart   4 ^ (maxHealth + maxHealth ^ 1.05 ^ maxHealth - 2.05) coins
         * fill all hearts  1 coin
         * better torch    5 ^ (torchLevel + 1.05 ^ torchLevel - 2.05) coins
         * weapons
         */

        this.populateShop(rand);
        break;
      case RoomType.SPAWNER:
        this.populateSpawner(rand);
        break;
    }
    this.message = this.name;
  };

  // #endregion

  // #region ENTERING / EXITING ROOM METHODS

  exitLevel = () => {
    this.game.onResize(); // stupid hack to keep fps high
    for (let door of this.doors) {
      if (
        door.linkedDoor.lightSource !== null &&
        !door.linkedDoor.room.active &&
        door.linkedDoor.room.entered
      ) {
        door.linkedDoor.lightSource.b = 0;
        door.linkedDoor.lightSource.r = 0;

        door.room.updateLighting();
      }
    }
    this.active = false;
    this.updateLighting();

    this.particles.splice(0, this.particles.length);
    this.disableFuseSounds();
  };

  disableFuseSounds = () => {
    for (const b of this.entities.filter((e) => e instanceof Bomb)) {
      //if (!bomb.soundPaused) {
      //bomb.soundPaused = true;
      const bomb = b as Bomb;
      Sound.stopSound(bomb.fuseSound);
      //}
    }
  };

  enableFuseSounds = () => {
    for (const b of this.entities.filter((e) => e instanceof Bomb)) {
      //if (!bomb.soundPaused) {
      //bomb.soundPaused = true;

      const bomb = b as Bomb;
      if (bomb.lit) {
        Sound.playWithReverb(bomb.fuseSound);
      }
    }
  };

  onEnterRoom = (player: Player) => {
    this.enableFuseSounds();
    for (let room of this.level.rooms) {
      room.roomOnScreen(player);
    }

    this.entered = true;

    this.clearDeadStuff();
    this.calculateWallInfo();
    this.resetDoorLightSources();

    this.particles = [];

    this.alertEnemiesOnEntry();
    this.message = this.name;
    player.map.saveMapData();
    this.setReverb();
    this.active = true;

    this.updateLighting();
  };

  enterLevel = (player: Player) => {
    this.game.updateLevel();
    player.moveSnap(this.getRoomCenter().x, this.getRoomCenter().y);
    this.onEnterRoom(player);
  };

  enterLevelThroughDoor = (player: Player, door: Door, side?: number) => {
    // console.log(door.linkedDoor.x, door.linkedDoor.y, door.x, door.y);
    if (door.doorDir === door.linkedDoor.doorDir) {
      door.opened = true;
      player.moveSnap(door.x, door.y + 1);
      setTimeout(() => {
        player.direction = Direction.DOWN;
      }, 150);
    }
    if (door instanceof Door && door.doorDir === Direction.UP) {
      //if top door
      door.opened = true;
      player.moveNoSmooth(door.x, door.y + 1);
    } else if (door instanceof Door && door.doorDir === Direction.DOWN) {
      //if bottom door
      player.moveNoSmooth(door.x, door.y - 1);
    } else if (
      door instanceof Door &&
      [Direction.RIGHT, Direction.LEFT].includes(door.doorDir)
    ) {
      // if side door
      player.moveNoSmooth(door.x + side, door.y);
    }
    this.onEnterRoom(player);
  };

  alertEnemiesOnEntry = () => {
    for (const e of this.entities) {
      if (e instanceof Enemy) e.lookForPlayer(false);
    }
  };

  // #endregion

  // #region LOGIC METHODS

  tick = (player: Player) => {
    this.updateLighting();
    player.updateSlowMotion();
    this.lastEnemyCount = this.entities.filter(
      (e) => e instanceof Enemy,
    ).length;
    for (const h of this.hitwarnings) {
      h.tick();
    }
    for (const p of this.projectiles) {
      p.tick();
    }

    this.clearDeadStuff();

    this.calculateWallInfo();
    this.entities = this.entities.filter((e) => !e.dead);

    for (let x = this.roomX; x < this.roomX + this.width; x++) {
      for (let y = this.roomY; y < this.roomY + this.height; y++) {
        this.roomArray[x][y].tick();
      }
    }

    this.turn = TurnState.computerTurn;

    //player.actionTab.setState(ActionState.WAIT);
    //sets the action tab state to Ready
    this.playerTurnTime = Date.now();
    this.playerTicked = player;

    // Update Beam Effects lighting

    //console.log("updating lighting");

    this.updateLighting();

    player.map.saveMapData();
    this.clearDeadStuff();
  };

  computerTurn = () => {
    // take computer turn
    for (const e of this.entities) {
      e.tick();
    }
    this.entities = this.entities.filter((e) => !e.dead);
    for (const i of this.items) {
      i.tick();
    }

    for (const h of this.hitwarnings) {
      if (
        !this.roomArray[h.x] ||
        !this.roomArray[h.x][h.y] ||
        this.roomArray[h.x][h.y].isSolid()
      ) {
        h.dead = true;
      }
      h.removeOverlapping();
    }

    for (const p of this.projectiles) {
      if (
        this.roomArray[p.x] &&
        this.roomArray[p.x][p.y] &&
        this.roomArray[p.x][p.y].isSolid()
      )
        p.dead = true;
      for (const i in this.game.players) {
        if (
          this.level.rooms[this.game.players[i].levelID] === this &&
          p.x === this.game.players[i].x &&
          p.y === this.game.players[i].y
        ) {
          p.hitPlayer(this.game.players[i]);
        }
      }
      for (const e of this.entities) {
        if (p.x === e.x && p.y === e.y) {
          p.hitEnemy(e);
        }
      }
    }

    for (let x = this.roomX; x < this.roomX + this.width; x++) {
      for (let y = this.roomY; y < this.roomY + this.height; y++) {
        this.roomArray[x][y].tickEnd();
      }
    }
    this.entities = this.entities.filter((e) => !e.dead); // enemies may be killed by spiketrap

    this.clearDeadStuff();

    this.playerTicked.finishTick();

    this.checkForNoEnemies();
    //console.log(this.entities.filter((e) => e instanceof Enemy).length);

    this.turn = TurnState.playerTurn;
  };

  update = () => {
    if (this.turn == TurnState.computerTurn) {
      if (
        Date.now() - this.playerTurnTime >=
        LevelConstants.COMPUTER_TURN_DELAY
      ) {
        this.computerTurn();
      }
    }
  };

  clearDeadStuff = () => {
    this.deadEntities = this.deadEntities.filter((e) => !e.dead);
    this.entities = this.entities.filter((e) => !e.dead);
    this.projectiles = this.projectiles.filter((p) => !p.dead);
    this.hitwarnings = this.hitwarnings.filter((h) => !h.dead);
    this.particles = this.particles.filter((p) => !p.dead);
  };

  catchUp = () => {
    if (this.turn === TurnState.computerTurn) this.computerTurn(); // player skipped computer's turn, catch up
  };

  tickHitWarnings = () => {
    for (const h of this.hitwarnings) {
      if (h.parent && (h.parent.dead || h.parent.unconscious)) {
        h.tick();
      }
    }
  };

  // #endregion

  // #region LIGHTING METHODS

  fadeLighting = (delta: number) => {
    for (let x = this.roomX; x < this.roomX + this.width; x++) {
      for (let y = this.roomY; y < this.roomY + this.height; y++) {
        let visDiff = this.softVis[x][y] - this.vis[x][y];
        let softVis = this.softVis[x][y];
        let flag = false;
        if (Math.abs(visDiff) > 0.01) flag = true;

        if (!flag) continue;

        visDiff *= 0.05 * delta;

        softVis -= visDiff;

        if (softVis < 0) softVis = 0;
        if (softVis > 1) softVis = 1;

        this.softVis[x][y] = softVis;

        // if (this.softVis[x][y] < 0.01) this.softVis[x][y] = 0;
      }
    }
  };

  fadeRgb = (delta: number) => {
    for (let x = this.roomX; x < this.roomX + this.width; x++) {
      for (let y = this.roomY; y < this.roomY + this.height; y++) {
        const [softR, softG, softB] = this.softCol[x][y];
        const [targetR, targetG, targetB] = this.col[x][y];

        // Calculate differences
        let diffR = softR - targetR;
        let diffG = softG - targetG;
        let diffB = softB - targetB;

        let flagR = false;
        let flagG = false;
        let flagB = false;
        if (Math.abs(diffR) > 0.001) flagR = true;
        if (Math.abs(diffG) > 0.001) flagG = true;
        if (Math.abs(diffB) > 0.001) flagB = true;

        if (!flagR && !flagG && !flagB) {
          continue;
        }

        // Apply smoothing similar to fadeLighting
        if (flagR) {
          diffR *= 0.05 * delta;
          this.softCol[x][y][0] = this.clamp(Math.round(softR - diffR), 0, 255);
        }
        if (flagG) {
          diffG *= 0.05 * delta;
          this.softCol[x][y][1] = this.clamp(Math.round(softG - diffG), 0, 255);
        }
        if (flagB) {
          diffB *= 0.05 * delta;
          this.softCol[x][y][2] = this.clamp(Math.round(softB - diffB), 0, 255);
        }
      }
    }
  };

  resetDoorLightSources = () => {
    this.doors.forEach((d) => {
      d.lightSource.r = 0;
      d.linkedDoor.lightSource.r = 0;
    });
  };

  tileValuesToLightSource = (x: number, y: number, room: Room) => {
    if (!room.roomArray[x]) return null;
    if (!room.roomArray[x][y]) return null;
    const color = room.col[x][y];
    const brightness = (1 - room.vis[x][y]) / 4;
    const radius = 9;
    return { color, brightness, radius };
  };

  updateDoorLightSources = () => {
    //works from inactive rooms onto their connected rooms
    if (!this.active) return;

    const directionOffsets = {
      [Direction.UP]: { x: 0, y: -1 },
      [Direction.DOWN]: { x: 0, y: 1 },
      [Direction.LEFT]: { x: -1, y: 0 },
      [Direction.RIGHT]: { x: 1, y: 0 },
    };
    let linkedDoors: Door[] = [];
    this.doors.forEach((d) => {
      if (d.linkedDoor && d.room.entered) linkedDoors.push(d.linkedDoor);
    });

    this.doors.forEach((d) => {
      d.lightSource.b = 0.1;
    });

    for (const d of linkedDoors) {
      d.lightSource.c = this.tileValuesToLightSource(
        d.linkedDoor.x,
        d.linkedDoor.y,
        this,
      ).color;
      d.lightSource.b = this.tileValuesToLightSource(
        d.linkedDoor.x,
        d.linkedDoor.y,
        this,
      ).brightness;
      d.lightSource.r = LevelConstants.LIGHTING_MAX_DISTANCE;
    }

    let connectedRooms: Set<Room> = new Set(
      this.doors
        .filter((d) => d && d.linkedDoor) // Ensure door and linkedDoor exist
        .map((d) => d.linkedDoor.room)
        .filter((r) => r), // Ensure room exists
    );

    for (const r of Array.from(connectedRooms)) {
      if (r.entered) r.updateLighting();
    }
  };

  updateLighting = () => {
    if (!this.onScreen) return;
    // Start timing the initial setup
    //console.time("updateLighting: Initial Setup");
    this.updateDoorLightSources();

    let oldVis = [];
    let oldCol = [];
    for (let x = this.roomX; x < this.roomX + this.width; x++) {
      oldVis[x] = [];
      oldCol[x] = [];
      for (let y = this.roomY; y < this.roomY + this.height; y++) {
        oldVis[x][y] = this.vis[x][y];
        oldCol[x][y] = this.col[x][y];

        this.vis[x][y] = 1;
        this.col[x][y] = [1, 1, 1];
        this.renderBuffer[x][y] = [];
      }
    }
    // End timing the initial setup
    //console.timeEnd("updateLighting: Initial Setup");

    // Start timing the processing of light sources
    //console.time("updateLighting: Process LightSources");

    for (const l of this.lightSources) {
      if (l.shouldUpdate()) {
        for (let i = 0; i < 360; i += LevelConstants.LIGHTING_ANGLE_STEP) {
          this.castTintAtAngle(i, l.x, l.y, l.r, l.c, l.b); // RGB color in sRGB
        }
      }
    }

    let lightingAngleStep = LevelConstants.LIGHTING_ANGLE_STEP;

    for (const p in this.game.players) {
      let player = this.game.players[p];
      if (this === this.level.rooms[player.levelID]) {
        //console.log(`i: ${player.angle}`);
        for (let i = 0; i < 360; i += lightingAngleStep) {
          let lightColor = LevelConstants.AMBIENT_LIGHT_COLOR;
          let lightBrightness = 5;
          if (player.lightEquipped) {
            lightColor = LevelConstants.TORCH_LIGHT_COLOR;
            lightBrightness = player.lightBrightness;
          }
          this.castTintAtAngle(
            i,
            player.x + 0.5,
            player.y + 0.5,
            /*
            Math.min(
              Math.max(
                player.sightRadius - this.depth + 2,
                Player.minSightRadius,
              ),
              10,
            ),
            */
            LevelConstants.LIGHTING_MAX_DISTANCE,
            lightColor, // RGB color in sRGB
            lightBrightness, // intensity
          );
        }
      }
    }
    // End timing the processing of player lighting
    //console.timeEnd("updateLighting: Process Players");

    // Start timing the blending of colors
    //console.time("updateLighting: Blend Colors Array");
    const roomX = this.roomX;
    const roomY = this.roomY;
    const width = this.width;
    const height = this.height;
    const renderBuffer = this.renderBuffer;

    for (let x = roomX; x < roomX + width; x++) {
      for (let y = roomY; y < roomY + height; y++) {
        this.col[x][y] = this.blendColorsArray(renderBuffer[x][y]);
      }
    }
    // End timing the blending of colors
    //console.timeEnd("updateLighting: Blend Colors Array");

    // Start timing the conversion to luminance
    //console.time("updateLighting: Convert to Luminance");
    for (let x = roomX; x < roomX + width; x++) {
      for (let y = roomY; y < roomY + height; y++) {
        this.vis[x][y] = this.rgbToLuminance(this.col[x][y]);
      }
    }
    // End timing the conversion to luminance
    //console.timeEnd("updateLighting: Convert to Luminance");
    this.updateDoorLightSources();
  };

  updateLightSources = (lightSource?: LightSource, remove?: boolean) => {
    this.oldCol = [];
    this.oldVis = [];
    this.oldCol = this.col;
    this.oldVis = this.vis;
    if (lightSource) {
      for (let i = 0; i < 360; i += LevelConstants.LIGHTING_ANGLE_STEP) {
        if (!remove) {
          this.castTintAtAngle(
            i,
            lightSource.x,
            lightSource.y,
            lightSource.r,
            lightSource.c,
            lightSource.b,
          ); // RGB color in sRGB
        } else {
          this.unCastTintAtAngle(
            i,
            lightSource.x,
            lightSource.y,
            lightSource.r,
            lightSource.c,
            lightSource.b,
          );
        }
      }
    }
    for (let x = this.roomX; x < this.roomX + this.width; x++) {
      for (let y = this.roomY; y < this.roomY + this.height; y++) {
        this.col[x][y] = this.blendColorsArray(this.renderBuffer[x][y]);
      }
    }

    for (let x = this.roomX; x < this.roomX + this.width; x++) {
      for (let y = this.roomY; y < this.roomY + this.height; y++) {
        this.vis[x][y] = this.rgbToLuminance(this.col[x][y]);
      }
    }
  };

  revertLightSources = () => {
    //console.log("reverting lighting");
    this.oldCol = [];
    this.oldVis = [];
    this.col = this.oldCol;
    this.vis = this.oldVis;
  };

  /**
   * Casts or uncategorizes a tint from a light source at a specific angle.
   *
   * @param angle - The angle in degrees at which to cast or uncast the tint.
   * @param px - The x-coordinate of the light source.
   * @param py - The y-coordinate of the light source.
   * @param radius - The radius of the light's influence.
   * @param color - The RGB color tuple representing the tint.
   * @param brightness - The brightness of the light source.
   * @param action - 'cast' to add tint, 'unCast' to remove tint.
   */
  private processTintAtAngle = (
    angle: number,
    px: number,
    py: number,
    radius: number,
    color: [number, number, number],
    brightness: number,
    action: "cast" | "unCast" = "cast",
  ) => {
    const dx = Math.cos((angle * Math.PI) / 180);
    const dy = Math.sin((angle * Math.PI) / 180);

    // Convert input color from sRGB to linear RGB
    const linearColor: [number, number, number] = [
      this.sRGBToLinear(color[0]),
      this.sRGBToLinear(color[1]),
      this.sRGBToLinear(color[2]),
    ];

    for (
      let i = 0;
      i <= Math.min(LevelConstants.LIGHTING_MAX_DISTANCE, radius);
      i++
    ) {
      const currentX = Math.floor(px + dx * i);
      const currentY = Math.floor(py + dy * i);

      if (!this.isPositionInRoom(currentX, currentY)) return; // Outside the room

      const tile = this.roomArray[currentX][currentY];
      if (tile.isOpaque()) {
        return; // Stop processing through opaque tiles
      } else if (Random.rand() < 1 - tile.opacity) {
        return;
      }

      // Handle i=0 separately to ensure correct intensity
      let intensity: number;
      if (i === 0) {
        intensity = brightness * 0.1;
      } else {
        intensity = brightness / Math.E ** (i - 0.25);
      }
      if (intensity < 0.005) intensity = 0;

      if (intensity <= 0) continue;

      if (!this.renderBuffer[currentX]) {
        this.renderBuffer[currentX] = [];
      }
      if (!this.renderBuffer[currentX][currentY]) {
        this.renderBuffer[currentX][currentY] = [];
      }

      const weightedLinearColor: [number, number, number, number] = [
        linearColor[0],
        linearColor[1],
        linearColor[2],
        intensity,
      ];

      if (action === "cast") {
        this.renderBuffer[currentX][currentY].push(weightedLinearColor);
      } else if (action === "unCast") {
        this.renderBuffer[currentX][currentY] = this.renderBuffer[currentX][
          currentY
        ].filter(
          (colorEntry) =>
            !(
              Math.abs(colorEntry[0] - weightedLinearColor[0]) < 0.0001 &&
              Math.abs(colorEntry[1] - weightedLinearColor[1]) < 0.0001 &&
              Math.abs(colorEntry[2] - weightedLinearColor[2]) < 0.0001 &&
              Math.abs(colorEntry[3] - weightedLinearColor[3]) < 0.0001
            ),
        );
      }
    }
  };

  /**
   * Applies Gaussian blur to the specified offscreen canvas.
   *
   * @param {HTMLCanvasElement} canvas - The offscreen canvas to blur.
   * @param {number} radius - The radius of the blur.
   */
  applyGaussianBlur(canvas: HTMLCanvasElement, radius: number): void {
    const StackBlur = require("stackblur-canvas");
    const ctx = canvas.getContext("2d");
    if (!ctx) {
      throw new Error("Failed to get canvas context for Gaussian blur.");
    }

    // Get the image data from the canvas
    const width = canvas.width;
    const height = canvas.height;
    //const imageData = ctx.getImageData(0, 0, width, height);
    let r = radius;
    if (!GameConstants.BLUR_ENABLED) r = 0;
    // Apply StackBlur
    StackBlur.canvasRGBA(canvas, 0, 0, width, height, Math.floor(r / 2));
  }

  /**
   * Casts a tint from a light source at a specific angle.
   *
   * @param angle - The angle in degrees at which to cast the tint.
   * @param px - The x-coordinate of the light source.
   * @param py - The y-coordinate of the light source.
   * @param radius - The radius of the light's influence.
   * @param color - The RGB color tuple representing the tint.
   * @param brightness - The brightness of the light source.
   */
  castTintAtAngle = (
    angle: number,
    px: number,
    py: number,
    radius: number,
    color: [number, number, number],
    brightness: number,
  ) => {
    this.processTintAtAngle(
      angle,
      px,
      py,
      radius,
      color,
      brightness / 3,
      "cast",
    );
  };

  /**
   * Uncasts a tint from a light source at a specific angle.
   *
   * @param angle - The angle in degrees at which to uncast the tint.
   * @param px - The x-coordinate of the light source.
   * @param py - The y-coordinate of the light source.
   * @param radius - The radius of the light's influence.
   * @param color - The RGB color tuple representing the tint.
   * @param brightness - The brightness of the light source.
   */
  unCastTintAtAngle = (
    angle: number,
    px: number,
    py: number,
    radius: number,
    color: [number, number, number],
    brightness: number,
  ) => {
    this.processTintAtAngle(
      angle,
      px,
      py,
      radius,
      color,
      brightness / 3, // added this
      "unCast",
    );
  };

  private sRGBToLinear = (value: number): number => {
    const normalized = value / 255;
    if (normalized <= 0.04045) {
      return normalized / 12.92;
    } else {
      return Math.pow((normalized + 0.055) / 1.055, 2.2);
    }
  };

  private linearToSRGB = (value: number): number => {
    if (value <= 0.0031308) {
      return Math.round(12.92 * value * 255);
    } else {
      return Math.round(
        (1.055 * Math.pow(value, 1 / 2.2 /*gamma*/) - 0.055) * 255,
      );
    }
  };

  clamp = (value: number, min: number = 0, max: number = 1): number => {
    return Math.min(Math.max(value, min), max);
  };

  /**
   * Blends an array of RGB colors into a single color without excessive darkness or clipping to white.
   *
   * @param colors - An array of RGB tuples to blend.
   * @returns A single RGB tuple representing the blended color.
   */
  private blendColorsArray = (
    colors: [red: number, green: number, blue: number, alpha: number][],
  ): [red: number, green: number, blue: number] => {
    if (colors.length === 0) return [0, 0, 0];

    // Sum all color channels in linear RGB
    const sum = colors.reduce(
      (accumulator, color) => [
        accumulator[0] + color[0] * color[3],
        accumulator[1] + color[1] * color[3],
        accumulator[2] + color[2] * color[3],
      ],
      [0, 0, 0],
    );

    // Apply scaling factor to manage overall brightness
    const scalingFactor = 0.45 * 2.5; // Adjust as needed
    const scaledSum = [
      sum[0] * scalingFactor,
      sum[1] * scalingFactor,
      sum[2] * scalingFactor,
    ];

    // Clamp each channel to [0, 1] to prevent overflow
    const clampedSum: [number, number, number] = [
      this.clamp(scaledSum[0], 0, 1),
      this.clamp(scaledSum[1], 0, 1),
      this.clamp(scaledSum[2], 0, 1),
    ];
    // Convert back to sRGB
    return [
      this.linearToSRGB(clampedSum[0]),
      this.linearToSRGB(clampedSum[1]),
      this.linearToSRGB(clampedSum[2]),
    ];
  };

  rgbToLuminance = (color: [number, number, number]): number => {
    //map to 1-0 range
    return 1 - (0.299 * color[0] + 0.587 * color[1] + 0.114 * color[2]) / 255;
  };

  draw = (delta: number) => {
    if (this.active) {
      HitWarning.updateFrame(delta);
      this.drawInterval = 4;
    } else if (!this.active) {
      this.drawInterval = 12;
    }

    this.drawTimestamp += delta;

    if (this.drawTimestamp - this.lastDraw >= this.drawInterval) {
      this.fadeRgb(delta + this.drawInterval);
      this.fadeLighting(delta + this.drawInterval);
      this.lastDraw = this.drawTimestamp;
    }
  };
  // added a multiplier to the input rgb values to avoid clipping to white
  drawColorLayer = () => {
    Game.ctx.save();
    // Clear the offscreen color canvas
    this.colorOffscreenCtx.clearRect(
      0,
      0,
      this.colorOffscreenCanvas.width,
      this.colorOffscreenCanvas.height,
    );

    let lastFillStyle = "";
    const offsetX = this.blurOffsetX;
    const offsetY = this.blurOffsetY;

    // Draw all color rectangles without any filters
    for (let x = this.roomX; x < this.roomX + this.width; x++) {
      for (let y = this.roomY; y < this.roomY + this.height; y++) {
        const [r, g, b] = this.softCol[x][y];
        if (r === 0 && g === 0 && b === 0) continue; // Skip if no color

        const fillStyle = `rgba(${r}, ${g}, ${b}, 1)`;

        if (fillStyle !== lastFillStyle) {
          this.colorOffscreenCtx.fillStyle = fillStyle;
          lastFillStyle = fillStyle;
        }

        this.colorOffscreenCtx.fillRect(
          (x - this.roomX + offsetX) * GameConstants.TILESIZE,
          (y - this.roomY + offsetY) * GameConstants.TILESIZE,
          GameConstants.TILESIZE,
          GameConstants.TILESIZE,
        );
      }
    }

    // Draw the blurred color layer directly without masking
    Game.ctx.globalCompositeOperation =
      GameConstants.COLOR_LAYER_COMPOSITE_OPERATION as GlobalCompositeOperation;
    //Game.ctx.globalCompositeOperation = "source-over";
    Game.ctx.globalAlpha = 0.6; // 0.6;
    if (!GameConstants.ctxBlurEnabled) {
      this.applyGaussianBlur(this.colorOffscreenCanvas, 12);
    } else {
      Game.ctx.filter = "blur(6px)";
    }
    Game.ctx.drawImage(
      this.colorOffscreenCanvas,
      (this.roomX - offsetX) * GameConstants.TILESIZE,
      (this.roomY - offsetY) * GameConstants.TILESIZE,
    );

    //draw slight haze
    Game.ctx.globalCompositeOperation = "lighten";
    Game.ctx.globalAlpha = 0.05;
    if (!GameConstants.ctxBlurEnabled)
      this.applyGaussianBlur(this.colorOffscreenCanvas, 24);
    else Game.ctx.filter = "blur(12px)";
    Game.ctx.drawImage(
      this.colorOffscreenCanvas,
      (this.roomX - offsetX) * GameConstants.TILESIZE,
      (this.roomY - offsetY) * GameConstants.TILESIZE,
    );
    this.colorOffscreenCtx.clearRect(
      0,
      0,
      this.colorOffscreenCanvas.width,
      this.colorOffscreenCanvas.height,
    );

    Game.ctx.restore();
  };

  drawShadeLayer = () => {
    if (this.game.isMobile) return;
    if (!this.onScreen) return;
    Game.ctx.save();
    // Clear the offscreen shade canvas
    this.shadeOffscreenCtx.clearRect(
      0,
      0,
      this.shadeOffscreenCanvas.width,
      this.shadeOffscreenCanvas.height,
    );

    let lastFillStyle = "";
    const offsetX = this.blurOffsetX;
    const offsetY = this.blurOffsetY;

    // Draw all shade rectangles without any filters
    for (let x = this.roomX - 2; x < this.roomX + this.width + 4; x++) {
      for (let y = this.roomY - 2; y < this.roomY + this.height + 4; y++) {
        let alpha =
          this.softVis[x] && this.softVis[x][y] ? this.softVis[x][y] : 0;
        if (
          this.roomArray[x] &&
          this.roomArray[x][y] &&
          this.roomArray[x][y] instanceof WallTorch
        )
          continue;
        //if (alpha === 0) continue; // Skip if no visibility adjustment
        let factor = !GameConstants.SMOOTH_LIGHTING ? 2 : 0.5;
        let computedAlpha = alpha ** factor;
        // if (computedAlpha <= 0) continue; // Skip if alpha is effectively zero

        let fillX = x;
        let fillY = y;
        let fillWidth = 1;
        let fillHeight = 1;
        if (
          this.roomArray[x] &&
          this.roomArray[x][y] &&
          this.roomArray[x][y] instanceof Wall
        ) {
          const wall = this.roomArray[x][y] as Wall;
          if (!this.innerWalls.includes(wall)) {
            switch (wall.direction) {
              case Direction.UP:
                fillY = y - 0.5;
                fillHeight = 0.5;
                break;
              case Direction.DOWN:
                fillY = y - 0.5;
                fillHeight = 1.5;
                break;
              case Direction.LEFT:
                fillX = x + 0.5;
                fillWidth = 0.5;
                break;
              case Direction.RIGHT:
                fillX = x + 0;
                fillWidth = 0.5;
                break;
              case Direction.DOWN_LEFT:
                fillX = x + 0.5;
                fillY = y - 0.5;
                fillWidth = 0.5;
                fillHeight = 1.5;
                break;
              case Direction.DOWN_RIGHT:
                fillX = x;
                fillY = y - 0.5;
                fillWidth = 0.5;
                fillHeight = 1.5;
                break;
              case Direction.UP_LEFT:
                fillX = x + 0.5;
                fillY = y - 0.5;
                fillWidth = 0.5;
                fillHeight = 0.5;
                break;
              case Direction.UP_RIGHT:
                fillX = x - 0.5;
                fillY = y - 0.5;
                fillWidth = 0.5;
                fillHeight = 0.5;
                break;
            }
          }
        }
        /*
        if (
          this.roomArray[x] &&
          this.roomArray[x][y] &&
          this.roomArray[x][y] instanceof Door &&
          !(this.roomArray[x][y] as Door).opened &&
          !(this.roomArray[x][y] as Door).linkedDoor.room.entered
        ) {
          //computedAlpha = 1;
          switch ((this.roomArray[x][y] as Door).doorDir) {
            case Direction.UP:
              fillY = y - 0.75;
              fillX = x - 0.5;
              fillHeight = 2;
              fillWidth = 1.5;

              break;
            case Direction.DOWN:
              fillX = x;
              fillY = y + 0.5;
              fillHeight = 2;
              fillWidth = 1.5;
              break;
            case Direction.LEFT:
              fillX = x;
              fillY = y - 0.5;
              fillWidth = 2;
              fillHeight = 2;
              break;
            case Direction.RIGHT:
              fillX = x - 0.5;
              fillY = y - 0.5;
              fillWidth = 2;
              fillHeight = 2;
              break;
          }
        }
        */

        const fillStyle = `rgba(0, 0, 0, ${computedAlpha})`;

        if (fillStyle !== lastFillStyle) {
          this.shadeOffscreenCtx.fillStyle = fillStyle;
          lastFillStyle = fillStyle;
        }

        fillY += 1;
        fillX += 1;
        this.shadeOffscreenCtx.fillRect(
          (fillX - this.roomX + offsetX) * GameConstants.TILESIZE,
          (fillY - this.roomY + offsetY) * GameConstants.TILESIZE,
          fillWidth * GameConstants.TILESIZE,
          fillHeight * GameConstants.TILESIZE,
        );
      }
    }

    // Draw the blurred shade layer directly without masking
    Game.ctx.globalCompositeOperation = "source-over";
    Game.ctx.globalAlpha = 1;
    if (!GameConstants.ctxBlurEnabled)
      this.applyGaussianBlur(this.shadeOffscreenCanvas, 10);
    else Game.ctx.filter = "blur(5px)";
    Game.ctx.drawImage(
      this.shadeOffscreenCanvas,
      (this.roomX - offsetX - 1) * GameConstants.TILESIZE,
      (this.roomY - offsetY - 1) * GameConstants.TILESIZE,
    );

    Game.ctx.restore();
  };

  drawBloomLayer = (delta: number) => {
    if (this.game.isMobile) return;
    if (!this.onScreen) return;
    Game.ctx.save();
    // Clear the offscreen shade canvas
    this.bloomOffscreenCtx.clearRect(
      0,
      0,
      this.bloomOffscreenCanvas.width,
      this.bloomOffscreenCanvas.height,
    );
    const offsetX = this.blurOffsetX;
    const offsetY = this.blurOffsetY;

    let lastFillStyle = "";

    // Draw all shade rectangles without any filters
    const allEntities = this.entities.concat(this.deadEntities);
    if (allEntities.length > 0)
      for (let e of this.entities) {
        if (e.hasBloom) {
          e.updateBloom(delta);
          this.bloomOffscreenCtx.globalAlpha =
            1 * (1 - this.softVis[e.x][e.y]) * e.softBloomAlpha;
          this.bloomOffscreenCtx.fillStyle = e.bloomColor;

          this.bloomOffscreenCtx.fillRect(
            (e.x - e.drawX - this.roomX + offsetX + 0.5 - e.bloomSize / 2) *
              GameConstants.TILESIZE,
            (e.y -
              e.drawY -
              this.roomY -
              0.5 +
              offsetY +
              0.5 -
              e.bloomSize / 2) *
              GameConstants.TILESIZE +
              e.bloomOffsetY,
            GameConstants.TILESIZE * e.bloomSize,
            GameConstants.TILESIZE * e.bloomSize,
          );
        }
      }

    for (let x = this.roomX; x < this.roomX + this.width; x++) {
      for (let y = this.roomY; y < this.roomY + this.height; y++) {
        if (this.roomArray[x][y].hasBloom) {
          this.roomArray[x][y].updateBloom(delta);
          this.bloomOffscreenCtx.globalAlpha =
            1 * (1 - this.softVis[x][y]) * this.roomArray[x][y].softBloomAlpha;
          this.bloomOffscreenCtx.fillStyle = this.roomArray[x][y].bloomColor;

          this.bloomOffscreenCtx.fillRect(
            (x - this.roomX + offsetX) * GameConstants.TILESIZE,
            (y - this.roomY - 0.25 + offsetY) * GameConstants.TILESIZE,
            GameConstants.TILESIZE,
            GameConstants.TILESIZE * 0.75,
          );
        }
      }
    }

    if (this.projectiles.length > 0)
      for (let p of this.projectiles) {
        if (p.hasBloom) {
          p.updateBloom(delta);
          this.bloomOffscreenCtx.globalAlpha =
            1 * (1 - this.softVis[p.x][p.y]) * p.softBloomAlpha;
          this.bloomOffscreenCtx.fillStyle = p.bloomColor;

          this.bloomOffscreenCtx.fillRect(
            (p.x - this.roomX + offsetX) * GameConstants.TILESIZE,
            (p.y - this.roomY + offsetY) * GameConstants.TILESIZE,
            GameConstants.TILESIZE,
            GameConstants.TILESIZE,
          );
        }
      }

    // Draw the blurred shade layer directly without masking
    if (!GameConstants.ctxBlurEnabled)
      this.applyGaussianBlur(this.bloomOffscreenCanvas, 16);
    else Game.ctx.filter = "blur(8px)";
    Game.ctx.globalCompositeOperation = "screen";

    Game.ctx.globalAlpha = 1;
    Game.ctx.drawImage(
      this.bloomOffscreenCanvas,
      (this.roomX - offsetX) * GameConstants.TILESIZE,
      (this.roomY - offsetY) * GameConstants.TILESIZE,
    );
    this.bloomOffscreenCtx.fillStyle = "rgba(0, 0, 0, 1)";
    this.bloomOffscreenCtx.fillRect(
      0,
      0,
      this.bloomOffscreenCanvas.width,
      this.bloomOffscreenCanvas.height,
    );
    Game.ctx.restore();
  };

  drawEntities = (delta: number, skipLocalPlayer?: boolean) => {
    Game.ctx.save();
    let tiles = [];
    for (let x = this.roomX; x < this.roomX + this.width; x++) {
      for (let y = this.roomY; y < this.roomY + this.height; y++) {
        this.roomArray[x][y].drawUnderPlayer(delta);
        tiles.push(this.roomArray[x][y]);
      }
    }

    let drawables = new Array<Drawable>();
    let entities = new Array<Entity>();
    entities = entities.concat(this.entities, this.deadEntities);

    drawables = drawables.concat(
      tiles,
      this.decorations,
      entities,
      this.hitwarnings,
      this.projectiles,
      this.particles,
      this.items,
    );
    for (const i in this.game.players) {
      if (this.game.rooms[this.game.players[i].levelID] === this) {
        if (
          !(
            skipLocalPlayer &&
            this.game.players[i] === this.game.players[this.game.localPlayerID]
          )
        )
          drawables.push(this.game.players[i]);
      }
    }

    drawables.sort((a, b) => {
      if (a instanceof Floor || a instanceof SpawnFloor) {
        return -1;
      } else if (b instanceof Floor || b instanceof SpawnFloor) {
        return 1;
      } else if (a instanceof Decoration) {
        return -1;
      } else if (b instanceof Decoration) {
        return 1;
      }
      if (Math.abs(a.drawableY - b.drawableY) < 0.1) {
        if (a instanceof Player) {
          return 1;
        } else if (b instanceof Player) {
          return -1;
        } else if (a instanceof Entity) {
          return 1;
        } else if (b instanceof Entity) {
          return -1;
        } else return 0;
      } else {
        return a.drawableY - b.drawableY;
      }
    });

    for (const d of drawables) {
      d.draw(delta);
    }

    this.drawAbovePlayer(delta);
    for (const i of this.items) {
      i.drawTopLayer(delta);
    }
    Game.ctx.restore();
  };

  drawAbovePlayer = (delta: number) => {
    for (let x = this.roomX; x < this.roomX + this.width; x++) {
      for (let y = this.roomY; y < this.roomY + this.height; y++) {
        //if (this.softVis[x][y] < 1) this.roomArray[x][y].drawAbovePlayer(delta);
      }
    }
  };

  drawShade = (delta: number) => {
    Game.ctx.save();
    let bestSightRadius = 0;
    for (const p in this.game.players) {
      Game.ctx.globalCompositeOperation = "source-over"; // "soft-light";
      Game.ctx.globalAlpha = 1;
      if (
        this.level.rooms[this.game.players[p].levelID] === this &&
        this.game.players[p].defaultSightRadius > bestSightRadius
      ) {
        bestSightRadius = this.game.players[p].defaultSightRadius;
      }
    }
    let shadingAlpha = Math.max(0, Math.min(0.8, 2 / bestSightRadius));
    if (GameConstants.ALPHA_ENABLED) {
      Game.ctx.globalAlpha = 0.25; //this.shadeOpacity();
      //Game.ctx.resetTransform();
      //Game.ctx.fillStyle = "#4a5d23"; // hex dark misty green
      Game.ctx.fillStyle = this.shadeColor;
      Game.ctx.fillRect(
        this.roomX * GameConstants.TILESIZE,
        (this.roomY - 1) * GameConstants.TILESIZE,
        this.width * GameConstants.TILESIZE,
        (this.height + 1) * GameConstants.TILESIZE,
      );
      Game.ctx.globalAlpha = 1;
      Game.ctx.globalCompositeOperation = "source-over";
    }
    Game.ctx.restore();
  };

  shadeOpacity = () => {
    if (this.active) {
      return 0.25;
    } else {
      return 0.25;
    }
  };

  drawOverShade = (delta: number) => {
    Game.ctx.save();
    for (const e of this.entities) {
      e.drawTopLayer(delta); // health bars
    }

    for (const p of this.projectiles) {
      p.drawTopLayer(delta);
    }
    //Game.ctx.globalCompositeOperation = "overlay";
    for (const h of this.hitwarnings) {
      h.drawTopLayer(delta);
    }
    //Game.ctx.globalCompositeOperation = "source-over";

    for (const s of this.particles) {
      s.drawTopLayer(delta);
    }
    // draw over dithered shading
    for (let x = this.roomX; x < this.roomX + this.width; x++) {
      for (let y = this.roomY; y < this.roomY + this.height; y++) {
        this.roomArray[x][y].drawAboveShading(delta);
      }
    }
    Game.ctx.restore();
  };

  // for stuff rendered on top of the player
  drawTopLayer = (delta: number) => {
    Game.ctx.save();

    // gui stuff

    // room name
    let old = Game.ctx.font;
    Game.ctx.font = GameConstants.SCRIPT_FONT_SIZE + "px Script";
    Game.ctx.fillStyle = LevelConstants.LEVEL_TEXT_COLOR;
    Game.fillText(
      this.message,
      GameConstants.WIDTH / 2 - Game.measureText(this.name).width / 2,
      5,
    );
    Game.ctx.font = old;
    Game.ctx.restore();
  };

  // src/room.ts
  createWallMask = (): HTMLCanvasElement => {
    const maskCanvas = document.createElement("canvas");
    this.maskCanvases.push(maskCanvas); // <-- Track the canvas
    maskCanvas.width = this.width * GameConstants.TILESIZE;
    maskCanvas.height = this.height * GameConstants.TILESIZE;
    const ctx = maskCanvas.getContext("2d");
    if (!ctx) {
      throw new Error("Failed to create mask canvas context.");
    }

    // Fill the canvas with opaque color
    ctx.fillStyle = "rgba(255, 255, 255, 1)";
    ctx.fillRect(
      this.roomX * GameConstants.TILESIZE,
      this.roomY * GameConstants.TILESIZE,
      maskCanvas.width,
      maskCanvas.height,
    );

    // Make wall areas transparent
    /*
    for (let x = this.roomX - 1; x < this.roomX + 1 + this.width; x++) {
      for (let y = this.roomY - 1; y < this.roomY + 1 + this.height; y++) {
        const tile = this.getTile(x, y);
        if (tile instanceof Wall) {
          let offsetY = 0;
          if (tile.direction === Direction.DOWN) offsetY = 1;
          ctx.clearRect(
            (x - this.roomX) * GameConstants.TILESIZE,
            (y - 1 - this.roomY) * GameConstants.TILESIZE,
            GameConstants.TILESIZE,
            GameConstants.TILESIZE,
          );
        }
      }
    }
      */
    return maskCanvas;
  };

  //calculate wall info for proper wall rendering
  calculateWallInfo() {
    this.wallInfo.clear();
    for (let x = this.roomX; x < this.roomX + this.width; x++) {
      for (let y = this.roomY; y < this.roomY + this.height; y++) {
        const tile = this.getTile(x, y);
        if (tile instanceof Wall || tile instanceof WallTorch) {
          this.walls.push(tile);
          const isTopWall = y === this.roomY;
          const isBottomWall = y === this.roomY + this.height - 1;
          const isLeftWall = x === this.roomX;
          const isRightWall = x === this.roomX + this.width - 1;
          const isInnerWall =
            !isTopWall && !isBottomWall && !isLeftWall && !isRightWall;
          const isBelowDoorWall =
            y < this.roomY + this.height - 1 && this.getTile(x, y + 1)?.isDoor;
          const isAboveDoorWall =
            y < this.roomY + this.height - 1 && this.getTile(x, y - 1)?.isDoor;
          const isDoorWall =
            y < this.roomY + this.height && this.getTile(x, y + 1)?.isDoor;

          let innerWallType = null;
          if (isInnerWall) {
            const hasWallAbove = this.getTile(x, y - 1) instanceof Wall;
            const hasWallBelow = this.getTile(x, y + 1) instanceof Wall;

            if (!hasWallAbove && hasWallBelow) {
              innerWallType = "topInner";
            } else if (hasWallAbove && !hasWallBelow) {
              innerWallType = "bottomInner";
            } else if (hasWallAbove && hasWallBelow) {
              innerWallType = "surroundedInner";
            } else {
              innerWallType = "isolatedInner";
            }
          }

          this.wallInfo.set(`${x},${y}`, {
            isTopWall,
            isBottomWall,
            isLeftWall,
            isRightWall,
            isInnerWall,
            isBelowDoorWall,
            isDoorWall,
            innerWallType,
            isAboveDoorWall,
            shouldDrawBottom:
              isDoorWall ||
              isBelowDoorWall ||
              (isTopWall && !isLeftWall && !isRightWall) ||
              isInnerWall,
          });
        }
      }
    }
  }

  /**
   * Finds and returns the darkest and lightest tiles in the room based on their visibility.
   * Loops through the roomArray, sums all the vis values, sorts them, and identifies the extremes.
   *
   * @returns An object containing the darkest and lightest tiles with their coordinates and vis values.
   */
  getExtremeLuminance = (): {
    darkest: { x: number; y: number; vis: number } | null;
    lightest: { x: number; y: number; vis: number } | null;
  } => {
    const visValues: { x: number; y: number; vis: number }[] = [];

    // Loop through each tile in the room
    for (let x = this.roomX; x < this.roomX + this.width; x++) {
      for (let y = this.roomY; y < this.roomY + this.height; y++) {
        if (this.vis[x] && this.vis[x][y] !== undefined) {
          visValues.push({ x, y, vis: this.vis[x][y] });
        }
      }
    }

    if (visValues.length === 0) {
      return { darkest: null, lightest: null };
    }

    // Sort the vis values in ascending order
    visValues.sort((a, b) => a.vis - b.vis);

    return {
      darkest: visValues[visValues.length - 1],
      lightest: visValues[0],
    };
  };

  /**
   * Finds and returns the darkest and lightest tiles adjacent to a given point.
   * It checks the tiles above, below, to the left, and to the right of the specified point.
   *
   * @param px - The x-coordinate of the reference point.
   * @param py - The y-coordinate of the reference point.
   * @returns An object containing the darkest and lightest adjacent tiles with their coordinates and vis values,
   *          or null if no valid adjacent tiles are found.
   */
  getExtremeLuminanceFromPoint = (
    px: number,
    py: number,
  ): {
    darkest: { x: number; y: number; vis: number } | null;
    lightest: { x: number; y: number; vis: number } | null;
  } => {
    const adjacentPositions = [
      { x: px, y: py - 1 }, // Up
      { x: px, y: py + 1 }, // Down
      { x: px - 1, y: py }, // Left
      { x: px + 1, y: py }, // Right
    ];

    const visValues: { x: number; y: number; vis: number }[] = [];

    adjacentPositions.forEach((pos) => {
      const { x, y } = pos;
      if (this.vis[x] && this.vis[x][y] !== undefined) {
        if (this.roomArray[x] && this.roomArray[x][y]) {
          if (this.roomArray[x][y] instanceof Floor) {
            visValues.push({ x, y, vis: this.vis[x][y] });
          }
        }
      }
    });

    if (visValues.length === 0) {
      return { darkest: null, lightest: null };
    }

    // Sort the vis values in ascending order
    visValues.sort((a, b) => a.vis - b.vis);

    return {
      darkest: visValues[visValues.length - 1],
      lightest: visValues[0],
    };
  };

  getAverageLuminance = (): number => {
    let total = 0;
    let count = 0;
    for (let x = this.roomX - 2; x <= this.roomX + 2; x++) {
      if (this.roomArray[x] && this.roomArray[x][this.roomY]) {
        for (let y = this.roomY - 2; y <= this.roomY + 2; y++) {
          if (this.vis[x][y]) {
            total += this.vis[x][y];
            count++;
          }
        }
      }
    }
    return total / count;
  };

  // #endregion

  // #region UTILITIES

  private pointInside(
    x: number,
    y: number,
    rX: number,
    rY: number,
    rW: number,
    rH: number,
  ): boolean {
    if (x < rX || x >= rX + rW) return false;
    if (y < rY || y >= rY + rH) return false;
    return true;
  }

  tileInside = (tileX: number, tileY: number): boolean => {
    return this.pointInside(
      tileX,
      tileY,
      this.roomX,
      this.roomY,
      this.width,
      this.height,
    );
  };

  getEmptyTiles = (): Tile[] => {
    let returnVal: Tile[] = [];
    for (let x = this.roomX + 1; x < this.roomX + this.width - 1; x++) {
      for (let y = this.roomY + 1; y < this.roomY + this.height - 1; y++) {
        if (
          !this.roomArray[x][y].isSolid() &&
          !(this.roomArray[x][y] instanceof SpikeTrap) &&
          !(this.roomArray[x][y] instanceof SpawnFloor) &&
          !(this.roomArray[x][y] instanceof DownLadder)
        ) {
          returnVal.push(this.roomArray[x][y]);
        }
      }
    }
    for (const e of this.entities) {
      returnVal = returnVal.filter((t) => !e.pointIn(t.x, t.y));
    }
    return returnVal;
  };

  getTile = (x: number, y: number) => {
    if (this.roomArray[x]) return this.roomArray[x][y];
    else return undefined;
  };

  checkForNoEnemies = () => {
    let enemies = this.entities.filter((e) => e instanceof Enemy);
    if (enemies.length === 0 && this.lastEnemyCount > 0) {
      // if (this.doors[0].type === DoorType.GUARDEDDOOR) {
      this.doors.forEach((d) => {
        if (d.type === DoorType.GUARDEDDOOR) {
          d.unGuard();
          this.game.pushMessage(
            "The foes have been slain and the door allows you passage.",
          );
        }
      });
    }
  };

  // This pattern appears in multiple methods like addVendingMachine, addChests, addSpikes, etc.
  private getRandomEmptyPosition(tiles: Tile[]): { x: number; y: number } {
    if (tiles.length === 0) return null;
    const tile = tiles.splice(
      Game.rand(0, tiles.length - 1, Random.rand),
      1,
    )[0];
    return { x: tile.x, y: tile.y };
  }

  // Used in populateUpLadder, populateDownLadder, populateRopeHole, populateRopeCave
  private getRoomCenter(): { x: number; y: number } {
    return {
      x: Math.floor(this.roomX + this.width / 2),
      y: Math.floor(this.roomY + this.height / 2),
    };
  }

  // Used in multiple methods including castShadowsAtAngle
  isPositionInRoom(x: number, y: number): boolean {
    return !(
      Math.floor(x) < this.roomX ||
      Math.floor(x) >= this.roomX + this.width ||
      Math.floor(y) < this.roomY ||
      Math.floor(y) >= this.roomY + this.height
    );
  }

  pathIsBlockedBy(tile: Tile, otherTile: Tile): Entity[] {
    const entities = [];
    if (tile.isSolid()) entities.push(tile);
    if (otherTile.isSolid()) entities.push(otherTile);
    return entities;
  }

  // checks for obstructions between doors and finds paths avoiding obstacles.

  removeDoorObstructions = () => {
    let obstacles = [];
    for (const door of this.doors) {
      for (const otherDoor of this.doors) {
        if (door === otherDoor || door === null || otherDoor === null) break;
        const pathObstacles = this.findPath(door, otherDoor);
        if (pathObstacles.length > 0) {
        }
        obstacles.push(...pathObstacles);
      }
    }
    if (obstacles.length > 0) {
      for (let obstacle of obstacles) {
        // console.log(`Removing obstacle at (${obstacle.x},${obstacle.y})`);
        this.entities = this.entities.filter((e) => e !== obstacle);
        obstacle = null;
      }
    }
  };

  // avoid blocking doorways with unbreakable entities
  findPath = (startTile: Tile, targetTile: Tile): Array<Entity> => {
    let disablePositions = Array<astar.Position>();
    let obstacleCandidates = [];

    for (const e of this.entities) {
      if (e instanceof VendingMachine || e instanceof Rock) {
        disablePositions.push({ x: e.x, y: e.y } as astar.Position);
        obstacleCandidates.push(e);
      }
    }

    // Create a grid of the room
    let grid = [];
    for (let x = 0; x < this.roomX + this.width; x++) {
      grid[x] = [];
      for (let y = 0; y < this.roomY + this.height; y++) {
        if (this.roomArray[x] && this.roomArray[x][y])
          grid[x][y] = this.roomArray[x][y];
        else grid[x][y] = false;
      }
    }

    let moves = astar.AStar.search(
      grid,
      startTile,
      targetTile,
      disablePositions,
      false,
      false,
      false,
    );
    if (moves.length === 0) {
      return obstacleCandidates;
    } else {
      return [];
    }
  };

  // #endregion

  // #region MISC

  /**
   * Adds a new BeamEffect to the room.
   *
   * @param x1 - Starting tile X coordinate.
   * @param y1 - Starting tile Y coordinate.
   * @param x2 - Ending tile X coordinate.
   * @param y2 - Ending tile Y coordinate.
   */
  public addBeamEffect(
    x1: number,
    y1: number,
    x2: number,
    y2: number,
    parent: Entity,
  ): void {
    const beam = new BeamEffect(x1, y1, x2, y2, parent);
    this.beamEffects.push(beam);
  }

  public async changeReverb(newImpulsePath: string) {
    await ReverbEngine.setReverbImpulse(newImpulsePath);
  }
  get roomArea() {
    let area = (this.width - 2) * (this.height - 2);
    let openTiles = [];
    for (let x = this.roomX + 1; x < this.roomX + this.width - 1; x++) {
      for (let y = this.roomY + 1; y < this.roomY + this.height - 1; y++) {
        if (this.roomArray[x][y] instanceof Floor) openTiles.push({ x, y });
      }
    }
    //console.log(area, openTiles.length);
    return openTiles.length;
  }
  /**
   * Determines if the room is currently on screen.
   * Uses a buffer of 2 tiles beyond the room's dimensions to account for partial visibility.
   *
   * @returns {boolean} - True if the room is on screen, otherwise false.
   */
  public roomOnScreen(player: Player) {
    const tileSize = GameConstants.TILESIZE;

    // Calculate room boundaries with a buffer of 2 tiles
    const roomLeft = (this.roomX - 2) * tileSize;
    const roomRight = (this.roomX + this.width + 2) * tileSize;
    const roomTop = (this.roomY - 2) * tileSize;
    const roomBottom = (this.roomY + this.height + 2) * tileSize;

    // Convert player position from tiles to pixels
    const playerPosX = player.x * tileSize;
    const playerPosY = player.y * tileSize;

    // Calculate camera position in pixels
    const cameraX =
      playerPosX -
      player.drawX +
      0.5 * tileSize -
      0.5 * GameConstants.WIDTH -
      this.game.screenShakeX; // X-coordinate of the camera's top-left corner
    const cameraY =
      playerPosY -
      player.drawY +
      0.5 * tileSize -
      0.5 * GameConstants.HEIGHT - // Corrected from WIDTH to HEIGHT
      this.game.screenShakeY; // Y-coordinate of the camera's top-left corner
    const cameraWidth = GameConstants.WIDTH; // Corrected from innerWidth
    const cameraHeight = GameConstants.HEIGHT; // Corrected from innerHeight

    // Define the camera's boundaries
    const cameraLeft = cameraX;
    const cameraRight = cameraX + cameraWidth;
    const cameraTop = cameraY;
    const cameraBottom = cameraY + cameraHeight;

    // Check if the room's boundaries overlap with the camera's view
    const isOverlapping = !(
      roomRight < cameraLeft ||
      roomLeft > cameraRight ||
      roomBottom < cameraTop ||
      roomTop > cameraBottom
    );

    this.onScreen = isOverlapping;
  }

  private setReverb() {
    const roomArea = this.roomArea;
    if (roomArea < 10) {
      this.changeReverb(`res/SFX/impulses/small.mp3`);
    } else if (roomArea < 55) {
      this.changeReverb(`res/SFX/impulses/medium.mp3`);
    } else {
      this.changeReverb(`res/SFX/impulses/large.mp3`);
    }
  }

  // #endregion

  /**
   * Adds a door with offset to prevent overlapping doors.
   * If a door already exists at the desired (x, y) position, it offsets the door randomly to either side.
   * Ensures the new door is at least one tile away from the room's edge based on its direction.
   *
   * @param x - The x-coordinate for the door placement.
   * @param y - The y-coordinate for the door placement.
   * @param room - The Room object where the door is being placed. Defaults to the current room.
   * @param tunnelDoor - Whether the door is a tunnel door. Defaults to false.
   * @returns The created Door object or null if placement failed.
   */
  addDoorWithOffset = (
    x: number,
    y: number,
    room: Room = this,
    tunnelDoor: boolean = false,
  ) => {
    // Check if a door already exists at the desired position
    if (room.roomArray[x]?.[y] instanceof Door) {
      // Determine the direction based on the door's position
      let direction: Direction | null = null;
      if (x === room.roomX) {
        direction = Direction.RIGHT;
      } else if (x === room.roomX + room.width - 1) {
        direction = Direction.LEFT;
      } else if (y === room.roomY) {
        direction = Direction.DOWN;
      } else if (y === room.roomY + room.height - 1) {
        direction = Direction.UP;
      }

      if (!direction) {
        // console.log("Invalid door position.");
        return null;
      }

      // Define possible offset adjustments based on door direction
      const offsetOptions: Array<{ dx: number; dy: number }> = [];
      switch (direction) {
        case Direction.RIGHT | Direction.LEFT:
          // Offsets along the y-axis for vertical walls
          offsetOptions.push({ dx: 0, dy: 1 }, { dx: 0, dy: -1 });
          break;
        case Direction.UP | Direction.DOWN:
          // Offsets along the x-axis for horizontal walls
          offsetOptions.push({ dx: 1, dy: 0 }, { dx: -1, dy: 0 });
          break;
      }

      // Shuffle the offset options to randomize placement
      const shuffledOffsets = offsetOptions.sort(() => Random.rand() - 0.5);

      for (const offset of shuffledOffsets) {
        const newX = x + offset.dx;
        const newY = y + offset.dy;

        // Ensure the new position is within bounds and not on the edge
        const isWithinBounds =
          newX > room.roomX &&
          newX < room.roomX + room.width - 1 &&
          newY > room.roomY &&
          newY < room.roomY + room.height - 1;

        if (isWithinBounds && !(room.roomArray[newX]?.[newY] instanceof Door)) {
          // Offset the door placement
          return room.addDoor(newX, newY, room, tunnelDoor);
        }
      }

      return null;
    }

    // If no door exists at the desired position, place it normally
    return room.addDoor(x, y, room, tunnelDoor);
  };

  /**
   * Finds all wall tiles that do not have a door in them or adjacent to them.
   * @returns An array of wall tiles without doors or adjacent doors.
   */
  getEmptyWall(): Wall[] {
    const emptyWalls: Wall[] = [];

    for (let x = this.roomX + 1; x < this.roomX + this.width - 1; x++) {
      for (let y = this.roomY - 1; y < this.roomY + this.height - 1; y++) {
        const tile = this.roomArray[x][y];

        if (tile instanceof Wall || tile instanceof WallTorch) {
          // Check if the current wall tile is not a door
          if (!(tile instanceof Door)) {
            // Check adjacent tiles for doors
            const adjacentTiles = [
              this.roomArray[x + 1]?.[y],
              this.roomArray[x - 1]?.[y],
              this.roomArray[x]?.[y + 1],
              this.roomArray[x]?.[y - 1],
            ];

            const hasAdjacentDoor = adjacentTiles.some(
              (adjTile) => adjTile instanceof Door,
            );

            if (!hasAdjacentDoor) {
              emptyWalls.push(tile);
            }
          }
        }
      }
    }
    return emptyWalls;
  }

  pointExists = (x: number, y: number) => {
    return this.roomArray[x] && this.roomArray[x][y];
  };

  /**
   * Removes a specified empty wall from the room.
   * @param wall - The wall tile to remove.
   * @returns An object containing the x and y coordinates of the removed wall.
   */
  removeEmptyWall(wall: Wall): { x: number; y: number } | null {
    if (!(wall instanceof Wall)) return null;

    const { x, y } = wall;

    // Replace the wall with a Floor tile to maintain room integrity
    this.roomArray[x][y] = new Floor(this, x, y);

    // Remove from innerWalls or outerWalls if applicable
    const initialInnerWallsCount = this.innerWalls.length;
    this.innerWalls = this.innerWalls.filter((w) => w !== wall);
    const finalInnerWallsCount = this.innerWalls.length;

    return { x, y };
  }

  /**
   * Places a VendingMachine in an empty wall.
   */
  placeVendingMachineInWall(): void {
    const emptyWalls = this.getEmptyWall();
    if (emptyWalls.length === 0) return;

    // Select a random empty wall
    const selectedWall = Game.randTable(emptyWalls, Random.rand);
    if (!selectedWall) return;

    // Remove the selected wall
    const removedWallInfo = this.removeEmptyWall(selectedWall);
    if (!removedWallInfo) return;

    const { x, y } = removedWallInfo;

    // Create and add the VendingMachine
    this.addVendingMachine(Random.rand, x, y);
  }
}


--- src/sound.ts ---
import { Game } from "./game";
import { ReverbEngine } from "./reverb";

export class Sound {
  static playerStoneFootsteps: Array<HTMLAudioElement>;
  static enemyFootsteps: Array<HTMLAudioElement>;
  static hitSounds: Array<HTMLAudioElement>;
  static enemySpawnSound: HTMLAudioElement;
  static chestSounds: Array<HTMLAudioElement>;
  static coinPickupSounds: Array<HTMLAudioElement>;
  static miningSounds: Array<HTMLAudioElement>;
  static breakRockSound: HTMLAudioElement;
  static hurtSounds: Array<HTMLAudioElement>;
  static genericPickupSound: HTMLAudioElement;
  static pushSounds: Array<HTMLAudioElement>;
  static healSound: HTMLAudioElement;
  static music: HTMLAudioElement;
  static graveSound: HTMLAudioElement;
  static ambientSound: HTMLAudioElement;
  static goreSound: HTMLAudioElement;
  static swingSounds: Array<HTMLAudioElement>;
  static unlockSounds: Array<HTMLAudioElement>;
  static doorOpenSounds: Array<HTMLAudioElement>;
  static potSmashSounds: Array<HTMLAudioElement>;
  static keyPickupSound: HTMLAudioElement;
  static magicSound: HTMLAudioElement;
  static wooshSound: HTMLAudioElement;
  static initialized: boolean = false;
  static audioMuted: boolean = true;
  static bombSounds: Array<HTMLAudioElement>;
  static fuseBurnSound: HTMLAudioElement;
  static fuseLoopSound: HTMLAudioElement;
  static fuseStartSound: HTMLAudioElement;
  static warHammerSound: HTMLAudioElement;
  static loopHandlers: Map<HTMLAudioElement, EventListener> = new Map();
  static loadSounds = async () => {
    if (Sound.initialized) return;
    Sound.initialized = true;
    if (ReverbEngine.initialized) Sound.audioMuted = false;
    Sound.playerStoneFootsteps = new Array<HTMLAudioElement>();
    [1, 2, 3].forEach((i) =>
      Sound.playerStoneFootsteps.push(
        new Audio("res/SFX/footsteps/stone/footstep" + i + ".mp3"),
      ),
    );
    for (let f of Sound.playerStoneFootsteps) f.volume = 1.0;

    Sound.enemyFootsteps = new Array<HTMLAudioElement>();
    [1, 2, 3, 4, 5].forEach((i) =>
      Sound.enemyFootsteps.push(
        new Audio("res/SFX/footsteps/enemy/enemyfootstep" + i + ".mp3"),
      ),
    );
    for (let f of Sound.enemyFootsteps) f.volume = 1.0;

    Sound.swingSounds = new Array<HTMLAudioElement>();
    [1, 2, 3, 4].forEach((i) =>
      Sound.swingSounds.push(new Audio("res/SFX/attacks/swing" + i + ".mp3")),
    );
    for (let f of Sound.swingSounds) {
      (f.volume = 0.5), f.load;
      //f.play();
    }

    Sound.hitSounds = new Array<HTMLAudioElement>();
    [1, 2].forEach((i) =>
      Sound.hitSounds.push(new Audio("res/SFX/attacks/hurt" + i + ".mp3")),
    );
    for (let f of Sound.hitSounds) {
      (f.volume = 0.5), f.load;
      //f.play();
    }
    Sound.enemySpawnSound = new Audio("res/SFX/attacks/enemyspawn.mp3");
    Sound.enemySpawnSound.volume = 0.7;

    Sound.chestSounds = new Array<HTMLAudioElement>();
    [1, 2, 3].forEach((i) =>
      Sound.chestSounds.push(new Audio("res/SFX/chest/chest" + i + ".mp3")),
    );
    for (let f of Sound.chestSounds) f.volume = 0.5;

    Sound.coinPickupSounds = new Array<HTMLAudioElement>();
    [1, 2, 3, 4].forEach((i) =>
      Sound.coinPickupSounds.push(
        new Audio("res/SFX/items/coins" + i + ".mp3"),
      ),
    );
    for (let f of Sound.coinPickupSounds) f.volume = 1.0;

    Sound.miningSounds = new Array<HTMLAudioElement>();
    [1, 2, 3, 4].forEach((i) =>
      Sound.miningSounds.push(
        new Audio("res/SFX/resources/Pickaxe" + i + ".mp3"),
      ),
    );
    for (let f of Sound.miningSounds) f.volume = 0.3;

    Sound.hurtSounds = new Array<HTMLAudioElement>();
    [1].forEach((i) =>
      Sound.hurtSounds.push(new Audio("res/SFX/attacks/hit.mp3")),
    );
    for (let f of Sound.hurtSounds) f.volume = 0.3;

    Sound.genericPickupSound = new Audio("res/SFX/items/pickup.mp3");
    Sound.genericPickupSound.volume = 1.0;

    Sound.breakRockSound = new Audio("res/SFX/resources/rockbreak.mp3");
    Sound.breakRockSound.volume = 1.0;

    Sound.pushSounds = new Array<HTMLAudioElement>();
    [1, 2].forEach((i) =>
      Sound.pushSounds.push(new Audio("res/SFX/pushing/push" + i + ".mp3")),
    );
    for (let f of Sound.pushSounds) f.volume = 1.0;

    Sound.healSound = new Audio("res/SFX/items/powerup1.mp3");
    Sound.healSound.volume = 0.5;

    Sound.music = new Audio("res/bewitched.mp3");
    Sound.graveSound = new Audio("res/SFX/attacks/skelespawn.mp3");
    Sound.ambientSound = new Audio("res/SFX/ambient/ambientDark2.mp3");
    Sound.ambientSound.volume = 1;

    Sound.goreSound = new Audio(`res/SFX/misc Unused/gore2.mp3`);
    Sound.goreSound.volume = 0.5;

    Sound.unlockSounds = new Array<HTMLAudioElement>();
    [1].forEach((i) =>
      Sound.unlockSounds.push(new Audio("res/SFX/door/unlock" + i + ".mp3")),
    );
    for (let f of Sound.unlockSounds) f.volume = 0.5;

    Sound.doorOpenSounds = new Array<HTMLAudioElement>();
    [1, 2].forEach((i) =>
      Sound.doorOpenSounds.push(new Audio("res/SFX/door/open" + i + ".mp3")),
    );
    for (let f of Sound.doorOpenSounds) f.volume = 0.5;

    Sound.keyPickupSound = new Audio("res/SFX/items/keyPickup.mp3");
    Sound.keyPickupSound.volume = 1.0;

    Sound.potSmashSounds = new Array<HTMLAudioElement>();
    [1, 2, 3].forEach((i) =>
      Sound.potSmashSounds.push(
        new Audio("res/SFX/objects/potSmash" + i + ".mp3"),
      ),
    );
    for (let f of Sound.potSmashSounds) f.volume = 0.5;

    Sound.magicSound = new Audio("res/SFX/attacks/magic2.mp3");
    Sound.magicSound.volume = 0.25;

    Sound.wooshSound = new Audio("res/SFX/attacks/woosh1.mp3");
    Sound.wooshSound.volume = 0.2;

    Sound.bombSounds = new Array<HTMLAudioElement>();
    [1, 2].forEach((i) =>
      Sound.bombSounds.push(new Audio("res/SFX/attacks/explode" + i + ".mp3")),
    );
    for (let f of Sound.bombSounds) f.volume = 0.7;

    Sound.fuseBurnSound = new Audio("res/SFX/attacks/fuse.mp3");
    Sound.fuseBurnSound.volume = 0.2;

    Sound.fuseLoopSound = new Audio("res/SFX/attacks/fuseLoop.mp3");
    Sound.fuseLoopSound.volume = 0.2;

    Sound.fuseStartSound = new Audio("res/SFX/attacks/fuseStart.mp3");
    Sound.fuseStartSound.volume = 0.2;

    Sound.warHammerSound = new Audio("res/SFX/attacks/warhammer.mp3");
    Sound.warHammerSound.volume = 1;
  };

  private static playSoundSafely(audio: HTMLAudioElement) {
    audio.play().catch((err) => {
      if (err.name === "NotAllowedError") {
        console.warn("Audio playback requires user interaction first");
      } else {
        console.error("Error playing sound:", err);
      }
    });
  }

  static async playWithReverb(audio: HTMLAudioElement) {
    await ReverbEngine.initialize();
    ReverbEngine.applyReverb(audio);
    this.playSoundSafely(audio);
  }

  static playerStoneFootstep = async () => {
    if (Sound.audioMuted) return;
    let f = Game.randTable(Sound.playerStoneFootsteps, Random.rand);
    await this.playWithReverb(f);
    f.currentTime = 0;
    f.play();
  };

  static enemyFootstep = () => {
    if (Sound.audioMuted) return;
    let f = Game.randTable(Sound.enemyFootsteps, Random.rand);
    this.playWithReverb(f);
    f.currentTime = 0;
  };

  static hit = () => {
    if (Sound.audioMuted) return;
    let f = Game.randTable(Sound.swingSounds, Random.rand);
    this.playWithReverb(f);
    f.currentTime = 0;

    setTimeout(() => {
      let f = Game.randTable(Sound.hitSounds, Random.rand);
      this.playWithReverb(f);
      f.currentTime = 0;
    }, 100);
  };

  static hurt = () => {
    if (Sound.audioMuted) return;
    let f = Game.randTable(Sound.hurtSounds, Random.rand);
    this.playWithReverb(f);
    f.currentTime = 0;
  };

  static enemySpawn = () => {
    if (Sound.audioMuted) return;
    this.playWithReverb(Sound.enemySpawnSound);
    Sound.enemySpawnSound.currentTime = 0;
  };

  static chest = () => {
    if (Sound.audioMuted) return;
    let f = Game.randTable(Sound.chestSounds, Random.rand);
    this.playWithReverb(f);
    f.currentTime = 0;
  };

  static potSmash = () => {
    if (Sound.audioMuted) return;
    let f = Game.randTable(Sound.potSmashSounds, Random.rand);
    this.playWithReverb(f);
    f.currentTime = 0;
  };

  static pickupCoin = () => {
    if (Sound.audioMuted) return;
    let f = Game.randTable(Sound.coinPickupSounds, Random.rand);
    this.playWithReverb(f);
    f.currentTime = 0;
  };

  static mine = () => {
    if (Sound.audioMuted) return;
    let f = Game.randTable(Sound.miningSounds, Random.rand);
    this.playWithReverb(f);
    f.currentTime = 0;
  };

  static breakRock = () => {
    if (Sound.audioMuted) return;
    setTimeout(() => {
      this.playWithReverb(Sound.breakRockSound);
    }, 100);
    Sound.breakRockSound.currentTime = 0;
  };

  static heal = () => {
    if (Sound.audioMuted) return;
    this.playWithReverb(Sound.healSound);
    Sound.healSound.currentTime = 0;
  };

  static genericPickup = () => {
    if (Sound.audioMuted) return;
    this.playWithReverb(Sound.genericPickupSound);
    Sound.genericPickupSound.currentTime = 0;
  };

  static keyPickup = () => {
    if (Sound.audioMuted) return;
    this.playWithReverb(Sound.keyPickupSound);
    Sound.keyPickupSound.currentTime = 0;
  };

  static push = () => {
    if (Sound.audioMuted) return;
    let f = Game.randTable(Sound.pushSounds, Random.rand);
    this.playWithReverb(f);
    f.currentTime = 0;
  };

  static skeleSpawn = () => {
    if (Sound.audioMuted) return;
    this.playWithReverb(Sound.graveSound);
    Sound.graveSound.currentTime = 0;
    Sound.graveSound.volume = 0.3;
  };

  static unlock = () => {
    if (Sound.audioMuted) return;
    let f = Game.randTable(Sound.unlockSounds, Random.rand);
    this.playWithReverb(f);
    f.currentTime = 0;
  };

  static playMusic = () => {
    if (Sound.audioMuted) return;
    /*
    Sound.music.addEventListener(
      "ended",
      () => {
        Sound.music.currentTime = 0;
        Sound.playSoundSafely(Sound.music);
      },
      false
    );
    Sound.playSoundSafely(Sound.music);
    */
  };

  static doorOpen = () => {
    if (Sound.audioMuted) return;
    let f = Game.randTable(Sound.doorOpenSounds, Random.rand);
    this.playWithReverb(f);
    f.currentTime = 0;
  };

  static playAmbient = () => {
    if (Sound.audioMuted) return;
    Sound.ambientSound.addEventListener(
      "ended",
      () => {
        Sound.ambientSound.currentTime = 0;
        this.playWithReverb(Sound.ambientSound);
      },
      true,
    );
    this.playWithReverb(Sound.ambientSound);
  };

  static playFuse = () => {
    if (Sound.audioMuted) return;
    Sound.fuseStartSound.currentTime = 0;

    // Play the start sound first
    this.playWithReverb(Sound.fuseStartSound);

    // When start sound ends, begin the loop
    Sound.fuseStartSound.addEventListener(
      "ended",
      () => {
        Sound.fuseLoopSound.currentTime = 0;
        this.playWithReverb(Sound.fuseLoopSound);
      },
      { once: true },
    );

    // Set up loop sound to repeat
    Sound.fuseLoopSound.addEventListener("ended", () => {
      Sound.fuseLoopSound.currentTime = 0;
      this.playWithReverb(Sound.fuseLoopSound);
    });

    // Store the loop handler so we can remove it later
    const loopHandler = () => {
      Sound.fuseLoopSound.currentTime = 0;
      this.playWithReverb(Sound.fuseLoopSound);
    };
    Sound.loopHandlers.set(Sound.fuseLoopSound, loopHandler);
  };

  static stopFuse = () => {
    Sound.fuseLoopSound.pause();
    Sound.fuseLoopSound.currentTime = 0;
    Sound.fuseStartSound.pause();
    Sound.fuseStartSound.currentTime = 0;

    // Remove the loop handler
    const handler = Sound.loopHandlers.get(Sound.fuseLoopSound);
    if (handler) {
      Sound.fuseLoopSound.removeEventListener("ended", handler);
      Sound.loopHandlers.delete(Sound.fuseLoopSound);
    }
  };

  static playGore = () => {
    if (Sound.audioMuted) return;
    this.playWithReverb(Sound.goreSound);
    Sound.goreSound.currentTime = 0;
  };

  static playBomb = () => {
    if (Sound.audioMuted) return;
    let f = Game.randTable(Sound.bombSounds, Random.rand);
    this.playWithReverb(f);
    f.currentTime = 0;
  };

  static playWarHammer = () => {
    if (Sound.audioMuted) return;
    this.playWithReverb(Sound.warHammerSound);
    Sound.warHammerSound.currentTime = 0;
  };

  static playMagic = () => {
    if (Sound.audioMuted) return;
    let f = Sound.magicSound;
    let woosh = Sound.wooshSound;
    this.playWithReverb(f);
    this.playWithReverb(woosh);
    f.currentTime = 0;
    woosh.currentTime = 0;
  };

  static delayPlay = (method: () => void, delay: number) => {
    setTimeout(method, delay);
  };

  static stopSound(audio: HTMLAudioElement) {
    audio.pause();
    audio.currentTime = 0;
  }

  static stopSoundWithReverb(audio: HTMLAudioElement) {
    ReverbEngine.removeReverb(audio);
    this.stopSound(audio);
  }
}


--- src/stats.ts ---
import { globalEventBus } from "./eventBus";
import { AppEvents, EventPayloads, EVENTS } from "./events";

interface Stats {
  enemiesKilled: number;
  damageDone: number;
  damageTaken: number;
  turnsPassed: number;
  coinsCollected: number;
  itemsCollected: number;
  enemies: string[];
}

class StatsTracker {
  private stats: Stats = {
    enemiesKilled: 0,
    damageDone: 0,
    damageTaken: 0,
    turnsPassed: 0,
    coinsCollected: 0,
    itemsCollected: 0,
    enemies: [],
  };

  constructor() {
    this.initializeListeners();
  }

  private initializeListeners(): void {
    globalEventBus.on(EVENTS.ENEMY_KILLED, this.handleEnemyKilled);
    globalEventBus.on(EVENTS.DAMAGE_DONE, this.handleDamageDone);
    globalEventBus.on(EVENTS.DAMAGE_TAKEN, this.handleDamageTaken);
    globalEventBus.on(EVENTS.TURN_PASSED, this.handleTurnPassed);
    globalEventBus.on(EVENTS.COIN_COLLECTED, this.handleCoinCollected);
    globalEventBus.on(EVENTS.ITEM_COLLECTED, this.handleItemCollected);
  }

  private handleEnemyKilled = (
    payload: EventPayloads[typeof EVENTS.ENEMY_KILLED],
  ): void => {
    this.stats.enemiesKilled += 1;
    this.stats.enemies.push(payload.enemyId);
    //console.log(`Enemy killed: ${payload.enemyId}`);
  };

  private handleDamageDone = (
    payload: EventPayloads[typeof EVENTS.DAMAGE_DONE],
  ): void => {
    this.stats.damageDone += payload.amount;
    //console.log(`Damage done: ${payload.amount}`);
  };

  private handleDamageTaken = (
    payload: EventPayloads[typeof EVENTS.DAMAGE_TAKEN],
  ): void => {
    this.stats.damageTaken += payload.amount;
    //console.log(`Damage taken: ${payload.amount}`);
  };

  private handleTurnPassed = (): void => {
    this.stats.turnsPassed += 1;
    //console.log(`Turn passed: ${this.stats.turnsPassed}`);
  };

  private handleCoinCollected = (
    payload: EventPayloads[typeof EVENTS.COIN_COLLECTED],
  ): void => {
    this.stats.coinsCollected += payload.amount;
    //console.log(`Coins collected: ${payload.amount}`);
  };

  private handleItemCollected = (
    payload: EventPayloads[typeof EVENTS.ITEM_COLLECTED],
  ): void => {
    this.stats.itemsCollected += 1;
    //console.log(`Item collected: ${payload.itemId}`);
  };

  public getStats(): Stats {
    return this.stats;
  }

  public resetStats(): void {
    this.stats = {
      enemiesKilled: 0,
      damageDone: 0,
      damageTaken: 0,
      turnsPassed: 0,
      coinsCollected: 0,
      itemsCollected: 0,
      enemies: [],
    };
    //console.log("Stats have been reset.");
  }
}

export const statsTracker = new StatsTracker();


--- src/textbox.ts ---
import { globalEventBus } from "./eventBus";

export class TextBox {
  text: string;
  cursor: number;
  private enterCallback: () => void;
  private escapeCallback: () => void;
  private allowedCharacters: string = "all";
  private element: HTMLElement;
  private message: string = "";
  private sentMessages: Array<string>;
  private currentMessageIndex: number = -1;
  private readonly MAX_HISTORY: number = 50;

  constructor(element: HTMLElement) {
    this.text = "";
    this.cursor = 0;
    this.enterCallback = () => {};
    this.escapeCallback = () => {};
    this.element = element;
    this.sentMessages = [];

    this.element.addEventListener("touchstart", this.handleTouchStart);
  }

  public setEnterCallback(callback: () => void): void {
    this.enterCallback = callback;
  }

  public setEscapeCallback(callback: () => void): void {
    this.escapeCallback = callback;
  }

  public clear(): void {
    this.text = "";
    this.cursor = 0;
    this.message = "";
    this.updateElement();
  }

  public handleKeyPress = (key: string): void => {
    const fontHas = "abcdefghijklmnopqrstuvwxyz1234567890,.!?:'()[]%-/ ".split(
      "",
    );
    if (key.length === 1) {
      key = key.toLowerCase();
      if (fontHas.includes(key)) {
        if (
          this.allowedCharacters === "all" ||
          this.allowedCharacters.includes(key)
        ) {
          this.text =
            this.text.substring(0, this.cursor) +
            key +
            this.text.substring(this.cursor, this.text.length);
          this.cursor += 1;
          this.updateElement();

          this.message =
            this.message.substring(0, this.cursor - 1) +
            key +
            this.message.substring(this.cursor - 1, this.message.length);
        }
      }
      //console.log(`Current message: "${this.message}"`);
      return;
    } else {
      switch (key) {
        case "Backspace":
          if (this.cursor > 0) {
            this.text =
              this.text.substring(0, this.cursor - 1) +
              this.text.substring(this.cursor, this.text.length);
            this.cursor = Math.max(0, this.cursor - 1);
            this.updateElement();

            this.message =
              this.message.substring(0, this.cursor) +
              this.message.substring(this.cursor + 1, this.message.length);
          }
          break;
        case "Delete":
          if (this.cursor < this.text.length) {
            this.text =
              this.text.substring(0, this.cursor) +
              this.text.substring(this.cursor + 1, this.text.length);
            this.updateElement();

            this.message =
              this.message.substring(0, this.cursor) +
              this.message.substring(this.cursor + 1, this.message.length);
          }
          break;
        case "ArrowLeft":
          this.cursor = Math.max(0, this.cursor - 1);
          this.updateCursorPosition();
          break;
        case "ArrowRight":
          this.cursor = Math.min(this.text.length, this.cursor + 1);
          this.updateCursorPosition();
          break;
        case "ArrowUp":
          if (
            this.sentMessages.length > 0 &&
            this.currentMessageIndex < this.sentMessages.length - 1
          ) {
            this.currentMessageIndex++;
            this.text =
              this.sentMessages[
                this.sentMessages.length - 1 - this.currentMessageIndex
              ];
            this.updateElement();
            this.message = this.text;
          }
          break;
        case "ArrowDown":
          if (this.currentMessageIndex > 0) {
            this.currentMessageIndex--;
            this.text =
              this.sentMessages[
                this.sentMessages.length - 1 - this.currentMessageIndex
              ];
            this.updateElement();
            this.message = this.text;
          } else if (this.currentMessageIndex === 0) {
            this.currentMessageIndex = -1;
            this.clear();
          }
          break;
        case "Enter":
          this.sendMessage();
          this.escapeCallback();
          break;
        case "Escape":
          this.escapeCallback();
          break;
      }
    }
    //console.log(`Current message: "${this.message}"`);
  };

  private handleTouchStart = (e: TouchEvent): void => {
    this.focus();
    e.preventDefault();
  };

  private focus(): void {
    // Create a temporary input element to trigger the on-screen keyboard
    const tempInput = document.createElement("input");
    tempInput.type = "text";
    tempInput.style.position = "absolute";
    tempInput.style.opacity = "0";
    tempInput.style.zIndex = "-1"; // Ensure it doesn't interfere with the game UI
    document.body.appendChild(tempInput);
    tempInput.focus();
    tempInput.addEventListener("blur", () => {
      document.body.removeChild(tempInput);
    });
  }

  private sendMessage(): void {
    let message = this.message.trim();

    if (message) {
      // Add the new message to the history
      this.sentMessages.push(message);

      // Ensure the history size doesn't exceed the maximum limit
      if (this.sentMessages.length > this.MAX_HISTORY) {
        this.sentMessages.shift(); // Remove the oldest message
      }
      globalEventBus.emit("ChatMessageSent", message);

      console.log(this.sentMessages);

      this.enterCallback();

      if (message.startsWith("/")) {
        message = message.substring(1);
        globalEventBus.emit("ChatCommand", message);
      }

      this.clear();

      // Reset the navigation index
      this.currentMessageIndex = -1;
    }
  }

  private updateElement(): void {
    // Update the HTML element with the current text
    // Modify to handle multiple lines if necessary
    this.element.textContent = this.text;

    // Optionally, update cursor position in the UI
  }

  private updateCursorPosition(): void {
    // Implement cursor position update in the UI if necessary
  }

  // Optional: Modify other methods if needed to handle wrapped messages
}


--- src/tile/bones.ts ---
import { Game } from "../game";
import { Floor } from "./floor";

export class Bones extends Floor {
  draw = (delta: number) => {
    Game.drawTile(
      7,
      this.skin,
      1,
      1,
      this.x,
      this.y,
      1,
      1,
      this.room.shadeColor,
      this.shadeAmount(),
    );
  };
}


--- src/tile/button.ts ---
import { Game } from "../game";
import { Tile, SkinType } from "./tile";
import { Room } from "../room";
import { Player } from "../player";
import { InsideLevelDoor } from "./insideLevelDoor";
import { Entity } from "../entity/entity";
import { Enemy } from "../entity/enemy/enemy";

export class Button extends Tile {
  // all are in grid units
  w: number;
  h: number;
  pressed: boolean;
  turnsSincePressed: number;
  linkedDoor: InsideLevelDoor;

  constructor(room: Room, x: number, y: number, linkedDoor: InsideLevelDoor) {
    super(room, x, y);
    this.w = 1;
    this.h = 1;

    this.pressed = false;
    this.turnsSincePressed = 1;

    this.linkedDoor = linkedDoor;
  }

  press = () => {
    this.pressed = true;
    this.linkedDoor.opened = true;
  };

  unpress = () => {
    this.pressed = false;
    this.linkedDoor.opened = false;
  };

  onCollide = (player: Player) => {
    this.press();
  };

  onCollideEnemy = (enemy: Enemy) => {
    this.press();
  };

  tickEnd = () => {
    this.unpress();
    for (const i in this.room.game.players) {
      if (
        this.room.game.players[i].x === this.x &&
        this.room.game.players[i].y === this.y
      )
        this.press();
    }
    for (const e of this.room.entities) {
      if (e.x === this.x && e.y === this.y) this.press();
    }
  };

  draw = (delta: number) => {
    Game.drawTile(
      1,
      0,
      1,
      1,
      this.x,
      this.y,
      1,
      1,
      this.room.shadeColor,
      this.shadeAmount(),
    );
    if (this.pressed)
      Game.drawTile(
        18,
        0,
        1,
        1,
        this.x,
        this.y,
        this.w,
        this.h,
        this.room.shadeColor,
        this.shadeAmount(),
      );
    else
      Game.drawTile(
        17,
        0,
        1,
        1,
        this.x,
        this.y,
        this.w,
        this.h,
        this.room.shadeColor,
        this.shadeAmount(),
      );
  };
}


--- src/tile/chasm.ts ---
import { Room } from "../room";
import { Game } from "../game";
import { Tile } from "./tile";

export class Chasm extends Tile {
  tileX: number;
  tileY: number;
  topEdge: boolean;

  constructor(
    room: Room,
    x: number,
    y: number,
    leftEdge: boolean,
    rightEdge: boolean,
    topEdge: boolean,
    bottomEdge: boolean,
  ) {
    super(room, x, y);

    this.tileX = this.skin === 1 ? 24 : 20;
    this.tileY = 1;

    if (leftEdge) this.tileX--;
    else if (rightEdge) this.tileX++;
    if (topEdge) this.tileY--;
    else if (bottomEdge) this.tileY++;

    this.topEdge = topEdge;
  }

  isSolid = (): boolean => {
    return true;
  };
  canCrushEnemy = (): boolean => {
    return true;
  };

  draw = (delta: number) => {
    if (this.topEdge)
      Game.drawTile(
        22,
        0,
        1,
        2,
        this.x,
        this.y,
        1,
        2,
        this.room.shadeColor,
        this.shadeAmount(),
      );
    Game.drawTile(
      this.tileX,
      this.tileY,
      1,
      1,
      this.x,
      this.y,
      1,
      1,
      this.room.shadeColor,
      this.shadeAmount(),
    );
  };
}


--- src/tile/coffinTile.ts ---
import { Room } from "../room";
import { Game } from "../game";
import { Tile } from "./tile";

export class CoffinTile extends Tile {
  subTileY: number; // each coffin is 1x2, this is the sub-tile coordinate

  constructor(room: Room, x: number, y: number, subTileY: number) {
    super(room, x, y);
    this.subTileY = subTileY;
  }

  isSolid = (): boolean => {
    return true;
  };
  canCrushEnemy = (): boolean => {
    return true;
  };

  draw = (delta: number) => {
    if (this.subTileY === 0) {
      Game.drawTile(
        0,
        5,
        1,
        1,
        this.x - 1,
        this.y - 1,
        1,
        1,
        this.room.shadeColor,
        this.shadeAmount(),
      );
      Game.drawTile(
        1,
        5,
        1,
        1,
        this.x,
        this.y - 1,
        1,
        1,
        this.room.shadeColor,
        this.shadeAmount(),
      );
      Game.drawTile(
        2,
        5,
        1,
        1,
        this.x + 1,
        this.y - 1,
        1,
        1,
        this.room.shadeColor,
        this.shadeAmount(),
      );
      Game.drawTile(
        0,
        6,
        1,
        1,
        this.x - 1,
        this.y,
        1,
        1,
        this.room.shadeColor,
        this.shadeAmount(),
      );
      Game.drawTile(
        1,
        6,
        1,
        1,
        this.x,
        this.y,
        1,
        1,
        this.room.shadeColor,
        this.shadeAmount(),
      );
      Game.drawTile(
        2,
        6,
        1,
        1,
        this.x + 1,
        this.y,
        1,
        1,
        this.room.shadeColor,
        this.shadeAmount(),
      );
    } else {
      Game.drawTile(
        0,
        7,
        1,
        1,
        this.x - 1,
        this.y,
        1,
        1,
        this.room.shadeColor,
        this.shadeAmount(),
      );
      Game.drawTile(
        1,
        7,
        1,
        1,
        this.x,
        this.y,
        1,
        1,
        this.room.shadeColor,
        this.shadeAmount(),
      );
      Game.drawTile(
        2,
        7,
        1,
        1,
        this.x + 1,
        this.y,
        1,
        1,
        this.room.shadeColor,
        this.shadeAmount(),
      );
    }
  };
}


--- src/tile/decorations/decoration.ts ---
import { Room } from "../../room";
import { Player } from "../../player";
import { Entity } from "../../entity/entity";
import { Drawable } from "../../drawable";
import { GameConstants } from "../../gameConstants";
import { Game } from "../../game";

export enum SkinType {
  DUNGEON = 0,
  CAVE = 1,
  FOREST = 2,
  SWAMP = 3,
  GLACIER = 4,
  CASTLE = 5,
}

export abstract class Decoration extends Drawable {
  x: number;
  y: number;
  room: Room;
  skin: SkinType;
  isDoor: boolean;
  opacity: number;
  applySkin: boolean;

  constructor(room: Room, x: number, y: number) {
    super();
    this.skin = room.skin;
    this.room = room;
    this.x = x;
    this.y = y;
    this.drawableY = y;
    this.isDoor = false;
    this.opacity = 1;
    this.applySkin = false;
  }

  shadeAmount = (offsetX: number = 0, offsetY: number = 0) => {
    if (GameConstants.SMOOTH_LIGHTING) return 0;
    return this.room.softVis[this.x + offsetX][this.y + offsetY];
  };

  isSolid = (): boolean => {
    return false;
  };
  canCrushEnemy = (): boolean => {
    return false;
  };
  isOpaque = (): boolean => {
    return false;
  };
  onCollide = (player: Player) => {};
  onCollideEnemy = (enemy: Entity) => {};
  tick = () => {};
  tickEnd = () => {};

  draw = (delta: number) => {};
  drawUnderPlayer = (delta: number) => {
    let tileY = 1;
    if (this.applySkin) tileY = this.skin;

    Game.drawTile(
      1,
      tileY,
      1,
      1,
      this.x,
      this.y,
      1,
      1,
      this.room.shadeColor,
      this.shadeAmount(),
    );
  };
  drawAbovePlayer = (delta: number) => {};
  drawAboveShading = (delta: number) => {};
}


--- src/tile/decorations/puddle.ts ---
import { Room } from "../../room";
import { Player } from "../../player";
import { Entity } from "../../entity/entity";
import { Drawable } from "../../drawable";
import { GameConstants } from "../../gameConstants";
import { Game } from "../../game";
import { Decoration } from "./decoration";

export enum SkinType {
  DUNGEON = 0,
  CAVE = 1,
  FOREST = 2,
  SWAMP = 3,
  GLACIER = 4,
  CASTLE = 5,
}

export class Puddle extends Decoration {
  x: number;
  y: number;
  room: Room;
  skin: SkinType;
  isDoor: boolean;
  opacity: number;
  applySkin: boolean;

  constructor(room: Room, x: number, y: number) {
    super(room, x, y);
    this.skin = room.skin;
    this.room = room;
    this.x = x;
    this.y = y;
    this.drawableY = y;
    this.isDoor = false;
    this.opacity = 1;
    this.applySkin = false;
  }

  shadeAmount = (offsetX: number = 0, offsetY: number = 0) => {
    if (GameConstants.SMOOTH_LIGHTING) return 0;
    return this.room.softVis[this.x + offsetX][this.y + offsetY];
  };

  isSolid = (): boolean => {
    return false;
  };
  canCrushEnemy = (): boolean => {
    return false;
  };
  isOpaque = (): boolean => {
    return false;
  };
  onCollide = (player: Player) => {};
  onCollideEnemy = (enemy: Entity) => {};
  tick = () => {};
  tickEnd = () => {};

  draw = (delta: number) => {};
  drawUnderPlayer = (delta: number) => {
    let tileY = 1;
    if (this.applySkin) tileY = this.skin;

    Game.drawTile(
      1,
      tileY,
      1,
      1,
      this.x,
      this.y,
      1,
      1,
      this.room.shadeColor,
      this.shadeAmount(),
    );
  };
  drawAbovePlayer = (delta: number) => {};
  drawAboveShading = (delta: number) => {};
}


--- src/tile/door.ts ---
import { Player } from "../player";
import { Direction, Game } from "../game";
import { Room } from "../room";
import { GameConstants } from "../gameConstants";
import { SkinType, Tile } from "./tile";
import { EntityType } from "../entity/entity";
import { Key } from "../item/key";
import { Sound } from "../sound";
import { LightSource } from "../lightSource";

export enum DoorDir {
  North = "North",
  East = "East",
  South = "South",
  West = "West",
}

export enum DoorType {
  DOOR,
  LOCKEDDOOR,
  GUARDEDDOOR,
  TUNNELDOOR,
}

export class Door extends Tile {
  linkedDoor: Door;
  game: Game;
  opened: boolean;
  doorDir: Direction;
  guarded: boolean;
  type: DoorType;
  locked: boolean;
  iconTileX: number;
  iconXOffset: number;
  iconYOffset: number;
  unlocking: boolean;
  iconAlpha: number;
  frame: number;
  tileXOffset: number;
  tileX: number;
  drawTopOf: boolean;
  lightSource: LightSource;
  alpha: number;
  constructor(
    room: Room,
    game: Game,
    x: number,
    y: number,
    doorDir: Direction,
    doorType: DoorType,
  ) {
    super(room, x, y);
    this.game = game;
    this.opened = false;
    this.doorDir = doorDir;
    this.locked = false;
    this.isDoor = true;
    this.type = doorType;
    this.iconTileX = 2;
    this.iconXOffset = 0;
    this.iconYOffset = 0;
    this.unlocking = false;
    this.iconAlpha = 1;
    this.frame = 0;
    this.tileXOffset = 0;
    this.tileX = 2;
    this.drawTopOf = true;
    let lightOffsetX = 0;
    let lightOffsetY = 0;
    this.alpha = 1;

    switch (this.doorDir) {
      case Direction.UP:
        lightOffsetY = -0.5;
      case Direction.DOWN:
        lightOffsetY = 0.5;
      case Direction.LEFT:
        lightOffsetX = -0.5;
      case Direction.RIGHT:
        lightOffsetX = 0.5;
    }
    this.lightSource = new LightSource(x + 0.5, y + 0.5, 0, [0, 0, 0], 9);
    this.room.lightSources.push(this.lightSource);

    switch (this.type) {
      case DoorType.GUARDEDDOOR:
        this.guard();
        break;
      case DoorType.LOCKEDDOOR:
        this.lock();
        break;
      case DoorType.DOOR:
        this.removeLock();
        break;
      case DoorType.TUNNELDOOR:
        // this.tileX = ? find the right tile for this
        this.locked = true;
        this.iconTileX = 10;
        this.iconXOffset = 1 / 32;
        this.tileXOffset = 12;
        this.drawTopOf = false;
        break;
    }
  }

  shadeAmount = (offsetX: number = 0, offsetY: number = 0) => {
    if (GameConstants.SMOOTH_LIGHTING) return 0;
    const vis = this.room.softVis[this.x + offsetX][this.y + offsetY];
    if (this.opened) return vis / 2;
    else return vis;
  };

  openTunnelXOffset = () => {
    if (this.type === DoorType.TUNNELDOOR) {
      if (!this.opened) {
        return 0;
      } else {
        return -3;
      }
    }
    return 0;
  };

  guard = () => {
    this.type = DoorType.GUARDEDDOOR;
    this.locked = true;
    this.iconTileX = 9;
    this.iconXOffset = 1 / 32;
  };

  lock = () => {
    this.type = DoorType.LOCKEDDOOR;
    this.locked = true;
    this.iconTileX = 10;
    this.iconXOffset = 1 / 32;
  };

  removeLock = () => {
    if (this.type !== DoorType.TUNNELDOOR) this.type = DoorType.DOOR;
    this.locked = false;
  };

  removeLockIcon = () => {
    this.iconYOffset = 0;
    this.unlocking = false;
    this.iconTileX = 2;
    this.iconXOffset = 0;
    this.iconAlpha = 1;
  };

  canUnlock = (player: Player) => {
    if (this.type === DoorType.LOCKEDDOOR) {
      let k = player.inventory.hasItem(Key);
      if (k !== null) {
        this.game.pushMessage("You use the key to unlock the door.");
        return true;
      } else
        this.game.pushMessage("The door is locked tightly and won't budge.");
      return false;
    }

    if (this.type === DoorType.GUARDEDDOOR) {
      this.room.checkForNoEnemies();
      this.game.pushMessage(
        "There are still remaining foes guarding this door...",
      );
      return false;
    }

    if (
      this.type === DoorType.TUNNELDOOR &&
      (!this.opened || !this.linkedDoor.opened)
    ) {
      if (this.linkedDoor === this.room.level.exitRoom.tunnelDoor) {
        this.game.pushMessage("The door refuses to budge from this side.");
        return false;
      } else {
        this.game.pushMessage(
          "You clear the debris, revealing a narrow tunnel.",
        );
        return true;
      }
    }
    return true;
  };

  unlock = (player: Player) => {
    if (this.type === DoorType.LOCKEDDOOR) {
      let k = player.inventory.hasItem(Key);
      if (k !== null) {
        // remove key
        player.inventory.removeItem(k);
        Sound.unlock();
        this.removeLock();
        this.unlocking = true;
      }
    } else if (this.type === DoorType.TUNNELDOOR) {
      this.locked = false;
      this.unlocking = true;
    }
  };

  unGuard = () => {
    if (this.type === DoorType.GUARDEDDOOR) {
      this.removeLock();
      this.game.tutorialActive = false;
    }
  };

  link = (other: Door) => {
    this.linkedDoor = other;
  };

  isSolid = (): boolean => {
    if (this.locked) {
      return true;
    } else false;
  };
  canCrushEnemy = (): boolean => {
    return true;
  };

  onCollide = (player: Player) => {
    if (!this.opened) {
      Sound.doorOpen();
    }
    this.opened = true;

    this.linkedDoor.opened = true;

    if (this.doorDir === Direction.UP || this.doorDir === Direction.DOWN) {
      this.game.changeLevelThroughDoor(player, this.linkedDoor);
    } else
      this.game.changeLevelThroughDoor(
        player,
        this.linkedDoor,
        this.linkedDoor.room.roomX - this.room.roomX > 0 ? 1 : -1,
      );
    this.linkedDoor.removeLock();
    this.linkedDoor.removeLockIcon();
    this.removeLockIcon();
  };

  draw = (delta: number) => {
    Game.ctx.save();

    if (this.doorDir === Direction.DOWN) {
      Game.drawTile(
        1,
        this.skin,
        1,
        1,
        this.x,
        this.y,
        1,
        1,
        this.room.shadeColor,
        this.shadeAmount(),
      );
    }

    if (this.doorDir === Direction.UP) {
      //if top door
      if (this.opened)
        Game.drawTile(
          6 + this.tileXOffset + this.openTunnelXOffset(),
          this.skin,
          1,
          1,
          this.x,
          this.y,
          1,
          1,
          this.room.shadeColor,
          this.shadeAmount(0, 1),
        );
      else
        Game.drawTile(
          3 + this.tileXOffset + this.openTunnelXOffset(),
          this.skin,
          1,
          1,
          this.x,
          this.y,
          1,
          1,
          this.room.shadeColor,
          this.shadeAmount(),
        );
    }
    if (this.doorDir !== Direction.UP)
      //if not top door
      Game.drawTile(
        1,
        this.skin,
        1,
        1,
        this.x,
        this.y,
        1,
        1,
        this.room.shadeColor,
        this.shadeAmount(),
      );
    //the following used to be in the drawaboveplayer function
    if (this.doorDir === Direction.UP) {
      //if top door
      if (!this.drawTopOf) return;
      if (!this.opened)
        Game.drawTile(
          13,
          0,
          1,
          1,
          this.x,
          this.y - 1,
          1,
          1,
          this.room.shadeColor,
          this.shadeAmount(0, 1),
        );
      else
        Game.drawTile(
          14,
          0,
          1,
          1,
          this.x,
          this.y - 1,
          1,
          1,
          this.room.shadeColor,
          this.shadeAmount(0, 1),
        );
    }
    Game.ctx.restore();
  };

  drawAbovePlayer = (delta: number) => {};

  drawAboveShading = (delta: number) => {
    if (this.type === DoorType.TUNNELDOOR) return;
    if (this.frame > 100) this.frame = 0;
    this.frame += 1 * delta;
    Game.ctx.globalAlpha = this.iconAlpha;
    let multiplier = 0.125;
    if (this.unlocking === true) {
      this.iconAlpha *= 0.92 ** delta;
      this.iconYOffset -= 0.035 * delta;
      multiplier = 0;
      if (this.iconAlpha <= 0.01) {
        this.removeLockIcon();
      }
    }
    if (this.doorDir === Direction.UP) {
      //if top door
      Game.drawFX(
        this.iconTileX,
        2,
        1,
        1,
        this.x + this.iconXOffset,
        this.y -
          1.25 +
          multiplier * Math.sin((this.frame * Math.PI) / 50) +
          this.iconYOffset,
        1,
        1,
      );
    } else {
      Game.drawFX(
        this.iconTileX,
        2,
        1,
        1,
        this.x + this.iconXOffset,
        this.y -
          1.25 +
          multiplier * Math.sin((this.frame * Math.PI) / 50) +
          this.iconYOffset,
        1,
        1,
      ); //if not top door
    }
    Game.ctx.globalAlpha = 1;
  };
}


--- src/tile/downLadder.ts ---
import { Player } from "../player";
import { ChatMessage, Game } from "../game";
import { Room } from "../room";
import { GameConstants } from "../gameConstants";
import { SkinType, Tile } from "./tile";
import { UpLadder } from "./upLadder";
import { EVENTS } from "../events";
import { EventEmitter } from "../eventEmitter";
import { globalEventBus } from "../eventBus";

export class DownLadder extends Tile {
  linkedLevel: Room;
  game: Game;
  isRope = false;
  frame: number = 0;
  depth: number;

  constructor(room: Room, game: Game, x: number, y: number) {
    super(room, x, y);
    this.game = game;
    this.linkedLevel = null;
    this.depth = room.depth;
  }

  generate = async () => {
    if (!this.linkedLevel) {
      await this.game.levelgen.generate(
        this.game,
        this.room.depth + (this.isRope ? 0 : 1),
        this.isRope,
        (linkedLevel: Room) => {
          this.linkedLevel = linkedLevel;
          outerLoop: for (
            let x = this.linkedLevel.roomX;
            x < this.linkedLevel.roomX + this.linkedLevel.width;
            x++
          ) {
            for (
              let y = this.linkedLevel.roomY;
              y < this.linkedLevel.roomY + this.linkedLevel.height;
              y++
            ) {
              let tile = this.linkedLevel.roomArray[x][y];

              if (tile instanceof UpLadder) {
                tile.linkedLevel = this.game.levels[this.room.depth].exitRoom;
                //console.log("linked level", tile.linkedLevel);
                break outerLoop;
              }
            }
          }
        },
      );
    }
  };

  get linkedRoom() {
    return this.game.levels[this.depth - 1].exitRoom;
  }

  onCollide = (player: Player) => {
    let allPlayersHere = true;
    for (const i in this.game.players) {
      if (
        this.game.levels[this.game.players[i].depth].rooms[
          this.game.players[i].levelID
        ] !== this.room ||
        this.game.players[i].x !== this.x ||
        this.game.players[i].y !== this.y
      ) {
        allPlayersHere = false;
      }
    }
    if (allPlayersHere) {
      globalEventBus.emit(EVENTS.LEVEL_GENERATION_STARTED, {});
      this.generate().then(() => {
        globalEventBus.emit(EVENTS.LEVEL_GENERATION_COMPLETED, {});
        for (const i in this.game.players) {
          this.game.changeLevelThroughLadder(this.game.players[i], this);
        }
      });
    } else {
      if (player === this.game.players[this.game.localPlayerID])
        this.game.chat.push(new ChatMessage("all players must be present"));
    }
  };

  draw = (delta: number) => {
    let xx = 4;
    if (this.isRope) xx = 16;

    Game.drawTile(
      1,
      this.skin,
      1,
      1,
      this.x,
      this.y,
      1,
      1,
      this.room.shadeColor,
      this.shadeAmount(),
    );
    Game.drawTile(
      xx,
      this.skin,
      1,
      1,
      this.x,
      this.y,
      1,
      1,
      this.room.shadeColor,
      this.shadeAmount(),
    );
  };

  drawAboveShading = (delta: number) => {
    if (this.frame > 100) this.frame = 0;
    this.frame += 1 * delta;
    let multiplier = 0.125;

    Game.drawFX(
      2,
      2,
      1,
      1,
      this.x,
      this.y - 1.25 + multiplier * Math.sin((this.frame * Math.PI) / 50),
      1,
      1,
    );
  };

  drawAbovePlayer = (delta: number) => {};
}


--- src/tile/floor.ts ---
import { Game } from "../game";
import { Tile, SkinType } from "./tile";
import { Room } from "../room";

export class Floor extends Tile {
  // all are in grid units
  variation: number;

  constructor(room: Room, x: number, y: number) {
    super(room, x, y);
    this.variation = 1;
    if (this.skin == SkinType.DUNGEON)
      this.variation = Game.randTable(
        [1, 1, 1, 1, 1, 1, 8, 8, 8, 9, 10, 10, 10, 10, 10, 12],
        Random.rand,
      );
    if (this.skin == SkinType.CAVE)
      //this.variation = Game.randTable([1, 1, 1, 1, 8, 9, 10, 12], Random.rand);
      this.variation = Game.randTable(
        [1, 1, 1, 1, 1, 1, 8, 8, 8, 9, 10, 10, 10, 10, 10, 12],
        Random.rand,
      );
    if (this.skin == SkinType.FOREST)
      //this.variation = Game.randTable([1, 1, 1, 1, 8, 9, 10, 12], Random.rand);
      this.variation = Game.randTable(
        [1, 1, 1, 1, 1, 1, 8, 8, 8, 9, 10, 10, 10, 10, 10, 12],
        Random.rand,
      );
  }

  draw = (delta: number) => {
    Game.drawTile(
      this.variation,
      this.skin,
      1,
      1,
      this.x,
      this.y,
      1,
      1,
      this.room.shadeColor,
      this.shadeAmount(),
    );
  };
}


--- src/tile/fountainTile.ts ---
import { Room } from "../room";
import { Game } from "../game";
import { Tile } from "./tile";

export class FountainTile extends Tile {
  subTileX: number; // each fountain is 3x3, this is the sub-tile coordinate
  subTileY: number;

  constructor(
    room: Room,
    x: number,
    y: number,
    subTileX: number,
    subTileY: number,
  ) {
    super(room, x, y);
    this.subTileX = subTileX;
    this.subTileY = subTileY;
  }

  isSolid = (): boolean => {
    return true;
  };
  canCrushEnemy = (): boolean => {
    return true;
  };

  draw = (delta: number) => {
    Game.drawTile(
      1,
      this.skin,
      1,
      1,
      this.x,
      this.y,
      1,
      1,
      this.room.shadeColor,
      this.shadeAmount(),
    );
    Game.drawTile(
      this.subTileX,
      2 + this.subTileY,
      1,
      1,
      this.x,
      this.y,
      1,
      1,
      this.room.shadeColor,
      this.shadeAmount(),
    );
  };
}


--- src/tile/insideLevelDoor.ts ---
import { Player } from "../player";
import { Game } from "../game";
import { Room } from "../room";
import { GameConstants } from "../gameConstants";
import { SkinType, Tile } from "./tile";

export class InsideLevelDoor extends Tile {
  game: Game;
  opened: boolean;

  constructor(room: Room, game: Game, x: number, y: number) {
    super(room, x, y);
    this.game = game;
    this.opened = false;
  }

  isSolid = (): boolean => {
    return !this.opened;
  };
  canCrushEnemy = (): boolean => {
    return !this.opened;
  };
  isOpaque = (): boolean => {
    return !this.opened;
  };

  draw = (delta: number) => {
    Game.drawTile(
      1,
      0,
      1,
      1,
      this.x,
      this.y,
      1,
      1,
      this.room.shadeColor,
      this.shadeAmount(),
    );
    if (this.opened)
      Game.drawTile(
        15,
        1,
        1,
        1,
        this.x,
        this.y,
        1,
        1,
        this.room.shadeColor,
        this.shadeAmount(),
      );
    else
      Game.drawTile(
        3,
        this.skin,
        1,
        1,
        this.x,
        this.y,
        1,
        1,
        this.room.shadeColor,
        this.shadeAmount(),
      );
  };

  drawAbovePlayer = (delta: number) => {
    if (!this.opened)
      Game.drawTile(
        13,
        0,
        1,
        1,
        this.x,
        this.y - 1,
        1,
        1,
        this.room.shadeColor,
        this.shadeAmount(),
      );
    else
      Game.drawTile(
        14,
        0,
        1,
        1,
        this.x,
        this.y - 1,
        1,
        1,
        this.room.shadeColor,
        this.shadeAmount(),
      );
  };
}


--- src/tile/spawnfloor.ts ---
import { Game } from "../game";
import { Tile, SkinType } from "./tile";
import { Room } from "../room";

export class SpawnFloor extends Tile {
  // all are in grid units
  variation: number;

  constructor(room: Room, x: number, y: number) {
    super(room, x, y);
    this.variation = 1;
    if (this.skin == SkinType.DUNGEON)
      this.variation = Game.randTable(
        [1, 1, 1, 1, 1, 1, 8, 8, 8, 9, 10, 10, 10, 10, 10, 12],
        Random.rand,
      );
    if (this.skin == SkinType.CAVE)
      //this.variation = Game.randTable([1, 1, 1, 1, 8, 9, 10, 12], Random.rand);
      this.variation = Game.randTable(
        [1, 1, 1, 1, 1, 1, 8, 8, 8, 9, 10, 10, 10, 10, 10, 12],
        Random.rand,
      );
  }

  draw = (delta: number) => {
    Game.drawTile(
      this.variation,
      this.skin,
      1,
      1,
      this.x,
      this.y,
      1,
      1,
      this.room.shadeColor,
      this.shadeAmount(),
    );
  };
}


--- src/tile/spiketrap.ts ---
import { Player } from "../player";
import { Game } from "../game";
import { Room } from "../room";
import { LevelConstants } from "../levelConstants";
import { Tile } from "./tile";
import { Entity } from "../entity/entity";
import { Crate } from "../entity/object/crate";
import { Barrel } from "../entity/object/barrel";
import { HitWarning } from "../hitWarning";

export class SpikeTrap extends Tile {
  on: boolean;
  tickCount: number;
  frame: number;
  t: number;

  constructor(room: Room, x: number, y: number, tickCount?: number) {
    super(room, x, y);
    if (tickCount) this.tickCount = tickCount;
    else this.tickCount = 0;
    this.on = false;
    this.frame = 0;
    this.t = 0;
  }

  tick = () => {
    this.tickCount++;
    if (this.tickCount >= 4) this.tickCount = 0;
    this.on = this.tickCount === 0;

    if (this.on) {
      for (const i in this.room.game.players) {
        if (
          this.room ===
            this.room.game.rooms[this.room.game.players[i].levelID] &&
          this.room.game.players[i].x === this.x &&
          this.room.game.players[i].y === this.y
        )
          this.room.game.players[i].hurt(1, "spike trap");
      }
    }

    if (this.tickCount === 3)
      this.room.hitwarnings.push(
        new HitWarning(this.room.game, this.x, this.y, this.x, this.y, false),
      );
  };

  tickEnd = () => {
    if (this.on) {
      for (const e of this.room.entities) {
        if (e.x === this.x && e.y === this.y) {
          e.hurt(null, 1);
        }
      }
    }
  };

  onCollideEnemy = (enemy: Entity) => {
    if (this.on && !(enemy instanceof Crate || enemy instanceof Barrel))
      enemy.hurt(null, 1);
  };

  draw = (delta: number) => {
    this.drawableY = this.y - 0.01;
    Game.drawTile(
      1,
      this.skin,
      1,
      1,
      this.x,
      this.y,
      1,
      1,
      this.room.shadeColor,
      this.shadeAmount(),
    );

    let rumbleOffsetX = 0;
    this.t += delta;
    if (!this.on && this.tickCount === 3) {
      if (Math.floor(this.t) % 4 === 1) rumbleOffsetX = 0.0325;
      if (Math.floor(this.t) % 4 === 3) rumbleOffsetX = -0.0325;
    }
    let frames = [0, 1, 2, 3, 3, 4, 2, 0];
    let f = 6 + frames[Math.floor(this.frame)];
    if (
      this.tickCount === 1 ||
      (this.tickCount === 0 && frames[Math.floor(this.frame)] === 0)
    ) {
      f = 5;
    }
    Game.drawObj(
      f,
      0,
      1,
      2,
      this.x + rumbleOffsetX,
      this.y - 1,
      1,
      2,
      this.room.shadeColor,
      this.shadeAmount(),
    );
    if (this.on && this.frame < frames.length - 1) {
      if (frames[Math.floor(this.frame)] < 3) this.frame += 0.4 * delta;
      else this.frame += 0.2 * delta;
    }
    if (!this.on) this.frame = 0;
  };
}


--- src/tile/tile.ts ---
import { Room } from "../room";
import { Player } from "../player";
import { Entity } from "../entity/entity";
import { Drawable } from "../drawable";
import { GameConstants } from "../gameConstants";

export enum SkinType {
  DUNGEON = 0,
  CAVE = 1,
  FOREST = 2,
  SWAMP = 3,
  GLACIER = 4,
  CASTLE = 5,
}

export abstract class Tile extends Drawable {
  x: number;
  y: number;
  room: Room;
  skin: SkinType;
  isDoor: boolean;
  opacity: number;

  constructor(room: Room, x: number, y: number) {
    super();
    this.skin = room.skin;
    this.room = room;
    this.x = x;
    this.y = y;
    this.drawableY = y;
    this.isDoor = false;
    this.opacity = 1;
  }

  hasPlayer = (player: Player) => {
    if (player.x === this.x && player.y === this.y) return true;
    else return false;
  };

  shadeAmount = (offsetX: number = 0, offsetY: number = 0) => {
    if (GameConstants.SMOOTH_LIGHTING) return 0;
    return this.room.softVis[this.x + offsetX][this.y + offsetY];
  };

  isSolid = (): boolean => {
    return false;
  };
  canCrushEnemy = (): boolean => {
    return false;
  };
  isOpaque = (): boolean => {
    return false;
  };
  onCollide = (player: Player) => {};
  onCollideEnemy = (enemy: Entity) => {};
  tick = () => {};
  tickEnd = () => {};

  draw = (delta: number) => {};
  drawUnderPlayer = (delta: number) => {};
  drawAbovePlayer = (delta: number) => {};
  drawAboveShading = (delta: number) => {};
}


--- src/tile/trapdoor.ts ---
import { Game } from "../game";
import { Room } from "../room";
import { Player } from "../player";
import { LevelConstants } from "../levelConstants";
import { Tile } from "./tile";

export class Trapdoor extends Tile {
  game: Game;

  constructor(room: Room, game: Game, x: number, y: number) {
    super(room, x, y);
    this.game = game;
  }

  draw = (delta: number) => {
    Game.drawTile(
      13,
      this.skin,
      1,
      1,
      this.x,
      this.y,
      1,
      1,
      this.room.shadeColor,
      this.shadeAmount(),
    );
  };

  onCollide = (player: Player) => {
    // TODO
  };
}


--- src/tile/upLadder.ts ---
import { Player } from "../player";
import { Game } from "../game";
import { Room } from "../room";
import { GameConstants } from "../gameConstants";
import { SkinType, Tile } from "./tile";
import { DownLadder } from "./downLadder";

export class UpLadder extends Tile {
  linkedLevel: Room;
  game: Game;
  isRope = false;
  depth: number;
  constructor(room: Room, game: Game, x: number, y: number) {
    super(room, x, y);
    this.game = game;
    this.depth = room.depth;
  }

  onCollide = (player: Player) => {
    if (!this.game) {
      console.error("Game instance is undefined in UpLadder:", this);
      return;
    }
    try {
      this.linkLevel();
      this.game.changeLevelThroughLadder(player, this);
    } catch (error) {
      console.error("Error during changeLevelThroughLadder:", error);
    }
  };

  linkLevel = () => {
    this.linkedLevel = this.game.levels[this.depth - 1].exitRoom;
  };

  draw = (delta: number) => {
    let xx = 29;
    let yy = 0;
    if (this.isRope) {
      xx = 16;
      yy = 1;
    }

    Game.drawTile(
      1,
      this.skin,
      1,
      1,
      this.x,
      this.y,
      1,
      1,
      this.room.shadeColor,
      this.shadeAmount(),
    );
    if (!this.isRope)
      Game.drawTile(
        xx,
        yy,
        1,
        1,
        this.x,
        this.y - 1,
        1,
        1,
        this.room.shadeColor,
        this.shadeAmount(),
      );
    Game.drawTile(
      xx,
      yy + 1,
      1,
      1,
      this.x,
      this.y,
      1,
      1,
      this.room.shadeColor,
      this.shadeAmount(),
    );
  };

  drawAbovePlayer = (delta: number) => {
    if (this.isRope)
      Game.drawTile(
        16,
        1,
        1,
        1,
        this.x,
        this.y - 1,
        1,
        1,
        this.room.shadeColor,
        this.shadeAmount(),
      );
  };
}


--- src/tile/wall.ts ---
import { Direction, Game } from "../game";
import { Room, WallDirection } from "../room";
import { Door, DoorDir } from "./door";
import { Tile } from "./tile";
import { WallInfo } from "../room";
import { Player } from "../player";

export class Wall extends Tile {
  private tileXOffset: number;
  wallDirections: Array<WallDirection>;

  constructor(
    room: Room,
    x: number,
    y: number,
    wallDirections?: Array<WallDirection>,
  ) {
    super(room, x, y);
    this.isDoor = false;
    this.tileXOffset = 6;
    this.wallDirections = wallDirections || [];
    this.opacity = 1;
  }

  isSolid = (): boolean => {
    return true;
  };
  canCrushEnemy = (): boolean => {
    return true;
  };
  isOpaque = (): boolean => {
    const wallInfo = this.wallInfo();
    if (!wallInfo) return false;
    return (
      (!wallInfo.isTopWall && !wallInfo.isInnerWall) ||
      wallInfo.isLeftWall ||
      wallInfo.isRightWall
    );
  };

  get direction() {
    let directions = [];
    if (this.room.roomArray[this.x - 1][this.y] == null)
      directions.push(Direction.LEFT);
    if (this.room.roomArray[this.x + 1][this.y] == null)
      directions.push(Direction.RIGHT);
    if (this.room.roomArray[this.x][this.y - 1] == null)
      directions.push(Direction.DOWN);
    if (this.room.roomArray[this.x][this.y + 1] == null)
      directions.push(Direction.UP);
    if (directions.length == 1) return directions[0];
    if (
      directions.includes(Direction.UP) &&
      directions.includes(Direction.LEFT)
    ) {
      this.opacity = 0.5;
      return Direction.UP_LEFT;
    }
    if (
      directions.includes(Direction.UP) &&
      directions.includes(Direction.RIGHT)
    ) {
      this.opacity = 0.5;
      return Direction.UP_RIGHT;
    }
    if (
      directions.includes(Direction.DOWN) &&
      directions.includes(Direction.LEFT)
    ) {
      this.opacity = 0.5;
      return Direction.DOWN_LEFT;
    }
    return Direction.DOWN_RIGHT;
  }

  wallInfo = () => {
    return this.room.wallInfo.get(`${this.x},${this.y}`);
  };

  draw = (delta: number) => {
    this.drawWall(delta);
  };

  drawWall = (delta: number) => {
    const wallInfo = this.room.wallInfo.get(`${this.x},${this.y}`);
    if (!wallInfo) return;

    // Set tileYOffset based on inner wall type
    this.tileXOffset =
      wallInfo.innerWallType === "bottomInner" ||
      wallInfo.innerWallType === "surroundedInner"
        ? 0
        : 26;

    // Only draw the bottom part of the wall if it's not at the bottom edge of the room
    if (
      wallInfo.isDoorWall ||
      wallInfo.isBelowDoorWall ||
      (wallInfo.isTopWall && !wallInfo.isLeftWall && !wallInfo.isRightWall) ||
      wallInfo.isInnerWall
    )
      Game.drawTile(
        0,
        this.skin,
        1,
        1,
        this.x,
        this.y,
        1,
        1,
        this.room.shadeColor,
        this.shadeAmount(), //this.room.softVis[this.x][this.y + 1],
      );

    Game.drawTile(
      2 + this.tileXOffset,
      this.skin,
      1,
      1,
      this.x,
      this.y - 1,
      1,
      1,
      this.room.shadeColor,
      this.shadeAmount(),
    );
  };

  drawTopLayer = (delta: number) => {
    const wallInfo = this.room.wallInfo.get(`${this.x},${this.y}`);
    if (!wallInfo) return;
    if (
      wallInfo.isBottomWall ||
      wallInfo.isBelowDoorWall ||
      wallInfo.isAboveDoorWall
    ) {
      Game.drawTile(
        2 + this.tileXOffset,
        this.skin,
        1,
        1,
        this.x,
        this.y - 1,
        1,
        1,
        this.room.shadeColor,
        this.shadeAmount(), //this.room.softVis[this.x][this.y + 1],
      );
    }
  };
}


--- src/tile/wallTorch.ts ---
import { Game } from "../game";
import { Tile } from "./tile";
import { Room } from "../room";
import { LightSource } from "../lightSource";
import { LevelConstants } from "../levelConstants";
import { Wall } from "./wall";

export class WallTorch extends Wall {
  frame: number;
  private tileYOffset: number;

  constructor(room: Room, x: number, y: number) {
    super(room, x, y);
    this.room.lightSources.push(
      new LightSource(
        this.x + 0.5,
        this.y + 0.5,
        5,
        LevelConstants.TORCH_LIGHT_COLOR,
        1.5,
      ),
    );
    this.frame = Random.rand() * 12;
    this.tileYOffset = 6;
    this.hasBloom = true;
    this.bloomColor = "#FFA500";
    this.bloomAlpha = 1;
    this.softBloomAlpha = 0;
  }

  isSolid = (): boolean => {
    return true;
  };
  canCrushEnemy = (): boolean => {
    return true;
  };
  isOpaque = (): boolean => {
    const wallInfo = this.room.wallInfo.get(`${this.x},${this.y}`);
    if (!wallInfo) return true;
    return (
      (!wallInfo.isTopWall && !wallInfo.isInnerWall) ||
      wallInfo.isLeftWall ||
      wallInfo.isRightWall
    );
  };

  draw = (delta: number) => {
    this.drawWall(delta);
    const wallInfo = this.room.wallInfo.get(`${this.x},${this.y}`);
    if (!wallInfo) this.tileYOffset = 6;
    this.frame += 0.3 * delta;
    if (this.frame >= 12) this.frame = 0;

    this.tileYOffset =
      wallInfo.innerWallType === "bottomInner" ||
      wallInfo.innerWallType === "surroundedInner"
        ? 0
        : 6;

    Game.drawTile(
      0,
      this.skin,
      1,
      1,
      this.x,
      this.y,
      1,
      1,
      this.room.shadeColor,
      this.shadeAmount(),
    );

    Game.drawFX(Math.floor(this.frame), 32, 1, 2, this.x, this.y - 1, 1, 2);
  };
}


--- src/tutorialListener.ts ---
import { globalEventBus } from "./eventBus";
import { Enemy } from "./entity/enemy/enemy";
import { Room, RoomType } from "./room";
import { Game } from "./game";
import { DownLadder } from "./tile/downLadder";
import { Door, DoorType } from "./tile/door";
import { Player } from "./player";
import { Bestiary } from "./bestiary";

export class TutorialListener {
  private _seenEnemies: Set<typeof Enemy> = new Set();
  private _seenEnemyClasses: Set<Enemy> = new Set();
  private pendingNewEnemies: Set<typeof Enemy> = new Set();
  private tutorialCreationTimeout: NodeJS.Timeout | null = null;
  private game: Game;
  private player: Player;

  constructor(game: Game) {
    //console.log("Tutorial constructor called");
    this.setupEventListeners();
    this.game = game;
    this.player = this.game.player;
  }

  get seenEnemies(): Set<typeof Enemy> {
    if (this._seenEnemies === undefined) {
      this._seenEnemies = new Set();
    }
    return this._seenEnemies;
  }

  private setupEventListeners(): void {
    //console.log("Setting up event listeners");
    globalEventBus.on("EnemySeenPlayer", this.handleEnemySeen.bind(this));
  }

  private handleEnemySeen(data: {
    enemyType: typeof Enemy;
    enemyName: string;
  }): void {
    if (!this.hasSeenEnemy(data.enemyType)) {
      this.game.pushMessage(`New enemy encountered: ${data.enemyName}`);
      this.addSeenEnemy(data.enemyType);
      this.pendingNewEnemies.add(data.enemyType);
      this.scheduleTutorialCreation();

      this.player.bestiary.addEntry(data.enemyType);
      console.log(this.player.bestiary.entries);
    }
  }

  private scheduleTutorialCreation(): void {
    if (this.tutorialCreationTimeout === null) {
      this.tutorialCreationTimeout = setTimeout(() => {
        this.createTutorialRoom(Array.from(this.pendingNewEnemies));
        //this.game.pushMessage("Defeat the enemies guarding the exits.");
        this.pendingNewEnemies.clear();
        this.tutorialCreationTimeout = null;
      }, 100); // Wait 100ms to collect all new enemies
    }
  }

  private createTutorialRoom(enemyTypes: Array<typeof Enemy>) {
    /*
    this.game.tutorialActive = true;
    this.game.room.doors.forEach((door: Door) => {
      door.guard();
    });
    */
  }

  // Method to check if an enemy has been seen before
  hasSeenEnemy(enemyType: typeof Enemy): boolean {
    //console.log(`Checking if enemy has been seen: ${enemyType}`);
    return this._seenEnemies.has(enemyType);
  }

  // Method to manually add an enemy to the seen list (useful for testing or manual control)
  addSeenEnemy(enemyType: typeof Enemy): void {
    //console.log(`Adding enemy to seen list: ${enemyType}`);
    this._seenEnemies.add(enemyType);
    this._seenEnemyClasses.add(enemyType.prototype);
  }

  // Method to reset the seen enemies list (useful for testing or game resets)
  resetSeenEnemies(): void {
    //console.log("Resetting seen enemies list");
    this._seenEnemies.clear();
    this._seenEnemyClasses.clear();
  }

  // Method to clean up event listeners when needed
  cleanup(): void {
    //console.log("Cleaning up event listeners");
    globalEventBus.off("EnemySeenPlayer", this.handleEnemySeen.bind(this));
  }
}


--- src/utils.ts ---
export class Utils {
  static distance = (
    startX: number,
    startY: number,
    endX: number,
    endY: number,
  ) => {
    return Math.sqrt((endX - startX) ** 2 + (endY - startY) ** 2);
  };

  static calculateExponentialFalloff = (
    distance: number,
    falloffRate: number,
  ): number => {
    return Math.exp(-falloffRate * distance);
  };

  // Corrected HSV to HEX conversion
  static hsvToHex = (h: number, s: number, v: number): string => {
    let c = v * s;
    let x = c * (1 - Math.abs(((h / 60) % 2) - 1));
    let m = v - c;
    let r = 0,
      g = 0,
      b = 0;

    if (h >= 0 && h < 60) {
      r = c;
      g = x;
      b = 0;
    } else if (h >= 60 && h < 120) {
      r = x;
      g = c;
      b = 0;
    } else if (h >= 120 && h < 180) {
      r = 0;
      g = c;
      b = x;
    } else if (h >= 180 && h < 240) {
      r = 0;
      g = x;
      b = c;
    } else if (h >= 240 && h < 300) {
      r = x;
      g = 0;
      b = c;
    } else {
      r = c;
      g = 0;
      b = x;
    }

    // Convert to RGB values
    const rFinal = Math.round((r + m) * 255);
    const gFinal = Math.round((g + m) * 255);
    const bFinal = Math.round((b + m) * 255);

    return Utils.rgbToHex(rFinal, gFinal, bFinal);
  };

  // RGB to HEX conversion
  static rgbToHex = (r: number, g: number, b: number): string => {
    const toHex = (val: number) => {
      const hex = val.toString(16);
      return hex.length === 1 ? "0" + hex : hex;
    };

    return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
  };
}


--- src/weapon/dagger.ts ---
import { Weapon } from "./weapon";
import { Room } from "../room";

export class Dagger extends Weapon {
  static itemName = "dagger";
  constructor(level: Room, x: number, y: number) {
    super(level, x, y);

    this.tileX = 22;
    this.tileY = 0;
    this.name = "dagger";
    this.description = "A basic but dependable weapon.";
  }

  degrade = () => {};
}


--- src/weapon/dualdagger.ts ---
import { Weapon } from "./weapon";
import { Room } from "../room";
import { Sound } from "../sound";
import { SlashParticle } from "../particle/slashParticle";
import { Direction } from "../game";
import { AttackAnimation } from "../particle/attackAnimation";

export class DualDagger extends Weapon {
  firstAttack: boolean;
  static itemName = "dual daggers";

  constructor(level: Room, x: number, y: number) {
    super(level, x, y);

    this.tileX = 23;
    this.tileY = 0;
    this.firstAttack = true;
    this.name = "Dual Daggers";
    this.durability = 75;
    this.durabilityMax = 75;
    this.description =
      "After the first attack, enemies will not take their turn until you attack or move again.";
  }

  tickInInventory = () => {
    this.firstAttack = true;
  };

  weaponMove = (newX: number, newY: number): boolean => {
    let flag = false;
    for (let e of this.game.rooms[this.wielder.levelID].entities) {
      if (e.destroyable && !e.pushable && e.pointIn(newX, newY)) {
        e.hurt(this.wielder, 1);
        this.statusEffect(e);

        flag = true;
      }
    }
    if (flag) {
      this.hitSound();

      this.wielder.hitX = 0.5 * (this.wielder.x - newX);
      this.wielder.hitY = 0.5 * (this.wielder.y - newY);
      if (this.firstAttack) {
        this.game.rooms[this.wielder.levelID].particles.push(
          new AttackAnimation(newX, newY, "dualdagger", this.wielder.direction),
        );
      } else {
        this.game.rooms[this.wielder.levelID].particles.push(
          new AttackAnimation(
            newX,
            newY,
            "dualdagger2",
            this.wielder.direction,
          ),
        );
      }
      this.game.rooms[this.wielder.levelID].entities = this.game.rooms[
        this.wielder.levelID
      ].entities.filter((e) => !e.dead);

      if (!this.firstAttack) {
        this.game.rooms[this.wielder.levelID].tick(this.wielder);
      }
      if (this.wielder === this.game.players[this.game.localPlayerID])
        this.game.shakeScreen(10 * this.wielder.hitX, 10 * this.wielder.hitY);

      if (this.firstAttack) {
        this.game.rooms[this.wielder.levelID].tickHitWarnings();
        this.game.rooms[this.wielder.levelID].clearDeadStuff();
        this.firstAttack = false;
        this.wielder.slowMotionEnabled = true;
      }
      this.degrade();
    }
    return !flag;
  };
}


--- src/weapon/pickaxe.ts ---
import { Weapon } from "./weapon";
import { Room } from "../room";

export class Pickaxe extends Weapon {
  static itemName = "pickaxe";
  constructor(level: Room, x: number, y: number) {
    super(level, x, y);

    this.tileX = 30;
    this.tileY = 0;
    this.canMine = true;
  }
}


--- src/weapon/shotgun.ts ---
import { Game } from "../game";
import { Weapon } from "./weapon";
import { Room } from "../room";
import { Sound } from "../sound";
import { SlashParticle } from "../particle/slashParticle";
import { Crate } from "../entity/object/crate";
import { Barrel } from "../entity/object/barrel";
import { GenericParticle } from "../particle/genericParticle";

export class Shotgun extends Weapon {
  static itemName = "shotgun";
  constructor(level: Room, x: number, y: number) {
    super(level, x, y);

    this.tileX = 26;
    this.tileY = 0;
    this.name = "shotgun";
  }

  weaponMove = (newX: number, newY: number): boolean => {
    let newX2 = 2 * newX - this.wielder.x;
    let newY2 = 2 * newY - this.wielder.y;
    let newX3 = 3 * newX - 2 * this.wielder.x;
    let newY3 = 3 * newY - 2 * this.wielder.y;
    let range = 3;
    if (
      !this.game.rooms[this.wielder.levelID].tileInside(newX, newY) ||
      this.game.rooms[this.wielder.levelID].roomArray[newX][newY].isSolid()
    )
      //if current position is inside new position OR is solid
      return true;
    else if (
      !this.game.rooms[this.wielder.levelID].tileInside(newX2, newY2) ||
      this.game.rooms[this.wielder.levelID].roomArray[newX2][newY2].isSolid()
    )
      //if current position is inside new position 2 OR is solid
      //set range as one
      range = 1;
    else if (
      !this.game.rooms[this.wielder.levelID].tileInside(newX3, newY3) ||
      this.game.rooms[this.wielder.levelID].roomArray[newX3][newY3].isSolid()
    )
      //if current position is inside new position 3 OR is solid
      //set range as two
      range = 2;

    let enemyHitCandidates = [];
    let firstPushable = 4;
    let firstNonPushable = 5;
    let firstNonDestroyable = 5;
    for (let e of this.game.rooms[this.wielder.levelID].entities) {
      //loop through enemies in this weapons wielders level
      if (e.pushable) {
        //case for pushables
        if (e.pointIn(newX, newY)) return true;
        //if pushable is in new position return true
        if (e.pointIn(newX2, newY2) && range >= 2) {
          enemyHitCandidates.push({ enemy: e, dist: 2 });
          firstPushable = 2;
          //if pushable is in position 2 set firstPushable var
        }
        if (e.pointIn(newX3, newY3) && range >= 3) {
          enemyHitCandidates.push({ enemy: e, dist: 3 });
          firstPushable = Math.min(firstPushable, 3);
          //if pushable is in position 3 set firstPushable to min of firstPushable and 3
        }
      } else if (e.destroyable) {
        //case for destroyables
        if (e.pointIn(newX, newY) && range >= 1) {
          firstNonPushable = 1;
          enemyHitCandidates.push({ enemy: e, dist: 1 });
        }
        //if enemy is in new position and range is enough push enemy to hit candidate array
        if (e.pointIn(newX2, newY2) && range >= 2) {
          firstNonPushable = Math.min(firstNonPushable, 2);
          enemyHitCandidates.push({ enemy: e, dist: 2 });
        }
        //if enemy is in new position 2 and range is enough push enemy to hit candidate array
        if (e.pointIn(newX3, newY3) && range >= 3) {
          firstNonPushable = Math.min(firstNonPushable, 3);
          enemyHitCandidates.push({ enemy: e, dist: 3 });
        }
        //if enemy is in new position 3 and range is enough push enemy to hit candidate array
      } else {
        if (e.pointIn(newX, newY) && range >= 1) {
          firstNonDestroyable = 1;
        }
        //if enemy is in new position and range is enough set first non destroyable to 1
        if (e.pointIn(newX2, newY2) && range >= 2) {
          firstNonDestroyable = Math.min(firstNonDestroyable, 2);
        }
        //if enemy is in new position and range is enough set first non destroyable to 2

        if (e.pointIn(newX3, newY3) && range >= 3) {
          firstNonDestroyable = Math.min(firstNonDestroyable, 3);
        }
        //if enemy is in new position and range is enough set first non destroyable to 3
      }
    }
    let targetX = newX3;
    let targetY = newY3;
    if (
      firstNonDestroyable < firstNonPushable &&
      firstNonDestroyable < firstPushable
      //if a non destroyable comes before the first non pushable and before the first pushable
    ) {
      return true;
      //return true and exit the function
    }
    if (firstNonPushable <= firstPushable) {
      for (const c of enemyHitCandidates) {
        let e = c.enemy;
        let d = c.dist;
        if (d === 3) e.hurt(this.wielder, 0.5);
        else e.hurt(this.wielder, 1);
      }
      //finally bro
      //for the array c of enemyHitCandidates if the enemy distance is 3 only do .5 damage
      //if they're closer do the usual damage
      //hits all candidates in enemyHitCandidates

      this.hitSound();
      this.wielder.hitX = 0.5 * (this.wielder.x - newX);
      this.wielder.hitY = 0.5 * (this.wielder.y - newY);
      GenericParticle.shotgun(
        this.game.rooms[this.wielder.levelID],
        this.wielder.x + 0.5,
        this.wielder.y,
        targetX + 0.5,
        targetY,
        "black",
      );
      GenericParticle.shotgun(
        this.game.rooms[this.wielder.levelID],
        this.wielder.x + 0.5,
        this.wielder.y,
        targetX + 0.5,
        targetY,
        "#ffddff",
      );
      let gp = new GenericParticle(
        this.game.rooms[this.wielder.levelID],
        0.5 * (newX + this.wielder.x) + 0.5,
        0.5 * (newY + this.wielder.y),
        0,
        1,
        0,
        0,
        0,
        "white",
        0,
      );
      gp.expirationTimer = 10;
      this.game.rooms[this.wielder.levelID].particles.push(gp);
      //this.game.levels[this.wielder.levelID].particles.push(new SlashParticle(newX, newY));
      //this.game.levels[this.wielder.levelID].particles.push(new SlashParticle(newX2, newY2));
      //this.game.levels[this.wielder.levelID].particles.push(new SlashParticle(newX3, newY3));
      this.game.rooms[this.wielder.levelID].tick(this.wielder);
      if (this.wielder === this.game.players[this.game.localPlayerID])
        this.game.shakeScreen(10 * this.wielder.hitX, 10 * this.wielder.hitY);
      this.degrade();

      return false;
    }
    return true;
  };
}


--- src/weapon/spear.ts ---
import { Weapon } from "./weapon";
import { Room } from "../room";
import { Sound } from "../sound";
import { SlashParticle } from "../particle/slashParticle";
import type { Enemy } from "../entity/enemy/enemy";
import { AttackAnimation } from "../particle/attackAnimation";

export class Spear extends Weapon {
  static itemName = "spear";
  constructor(level: Room, x: number, y: number) {
    super(level, x, y);

    this.tileX = 24;
    this.tileY = 0;
    this.name = "spear";
    this.description =
      "Hits enemies in front of you within a range of 2 tiles.";
  }

  weaponMove = (newX: number, newY: number): boolean => {
    let newX2 = 2 * newX - this.wielder.x;
    let newY2 = 2 * newY - this.wielder.y;
    let flag = false;
    let enemyHitCandidates = [];
    for (let e of this.game.rooms[this.wielder.levelID].entities) {
      if (e.destroyable) {
        if (e.pointIn(newX, newY)) {
          if (e.pushable) return true;
          else {
            e.hurt(this.wielder, 1);
            this.statusEffect(e);
            flag = true;
          }
        }
        if (
          e.pointIn(newX2, newY2) &&
          !this.game.rooms[this.wielder.levelID].roomArray[newX][newY].isSolid()
        ) {
          //only hit targest 2 tiles away if they are enemies
          if (!e.pushable) enemyHitCandidates.push(e);
        }
      }
    }
    if (!flag && enemyHitCandidates.length > 0) {
      for (const e of enemyHitCandidates) e.hurt(this.wielder, 1);
      this.hitSound();
      this.wielder.hitX = 0.5 * (this.wielder.x - newX);
      this.wielder.hitY = 0.5 * (this.wielder.y - newY);
      this.game.rooms[this.wielder.levelID].particles.push(
        new AttackAnimation(newX, newY, "spear", this.wielder.direction),
      );
      this.game.rooms[this.wielder.levelID].particles.push(
        new AttackAnimation(newX2, newY2, "spear", this.wielder.direction),
      );
      this.game.rooms[this.wielder.levelID].tick(this.wielder);
      if (this.wielder === this.game.players[this.game.localPlayerID])
        this.game.shakeScreen(10 * this.wielder.hitX, 10 * this.wielder.hitY);
      this.degrade();
      return false;
    }
    if (flag) {
      if (
        this.wielder.game.room === this.wielder.game.rooms[this.wielder.levelID]
      )
        Sound.hit();
      this.wielder.hitX = 0.5 * (this.wielder.x - newX);
      this.wielder.hitY = 0.5 * (this.wielder.y - newY);
      this.game.rooms[this.wielder.levelID].particles.push(
        new AttackAnimation(newX, newY, "spear", this.wielder.direction),
      );
      this.game.rooms[this.wielder.levelID].tick(this.wielder);
      if (this.wielder === this.game.players[this.game.localPlayerID])
        this.game.shakeScreen(10 * this.wielder.hitX, 10 * this.wielder.hitY);
      this.degrade();
    }
    return !flag;
  };
}


--- src/weapon/spellbook.ts ---
import { Game } from "../game";
import { Weapon } from "./weapon";
import { Room } from "../room";
import { Sound } from "../sound";
import { PlayerFireball } from "../projectile/playerFireball";
import type { Entity } from "../entity/entity";
import { Utils } from "../utils";
import { Direction } from "../game";
import { SpellbookPage } from "../item/spellbookPage";
export class Spellbook extends Weapon {
  targets: Entity[];
  isTargeting: boolean;
  static itemName = "spellbook";
  constructor(level: Room, x: number, y: number) {
    super(level, x, y);
    this.range = 4;
    this.tileX = 25;
    this.tileY = 0;
    this.canMine = true;
    this.name = Spellbook.itemName;
    this.isTargeting = false;
    this.durability = 5;
    this.durabilityMax = 10;
    this.description = "Hits multiple enemies within a range of 4 tiles.";
  }

  getTargets = () => {
    this.targets = [];
    let entities = this.game.rooms[this.wielder.levelID].entities;
    this.targets = entities.filter(
      (e) =>
        !e.pushable &&
        Utils.distance(this.wielder.x, this.wielder.y, e.x, e.y) <= this.range,
    );
    let enemies = this.targets.filter((e) => e.isEnemy === true);
    //console.log(enemies);
    if (enemies.length > 0) return enemies;
    else {
      //console.log(this.targets);
      return this.targets;
    }
  };

  disassemble = () => {
    if (this.equipped) {
      this.game.pushMessage(
        "I should probably unequip this before I try to disassemble it...",
      );
      return;
    }
    this.game.pushMessage(
      `You tear the remaining pages out of your spellbook.`,
    );

    let inventory = this.wielder.inventory;
    let inventoryX = this.x;
    let inventoryY = this.y;
    let numFragments = Math.floor(this.durability);
    this.toggleEquip();
    //inventory.weapon = null;
    inventory.removeItem(this);
    inventory.addItem(
      new SpellbookPage(this.level, inventoryX, inventoryY, numFragments),
    );
  };

  weaponMove = (newX: number, newY: number): boolean => {
    this.getTargets();
    let direction = this.wielder.direction;
    let flag = false;
    let targets = this.targets;
    const isTargetInDirection = (e: Entity): boolean => {
      switch (direction) {
        case Direction.UP:
          return e.y <= newY;
        case Direction.RIGHT:
          return e.x >= newX;
        case Direction.DOWN:
          return e.y >= newY;
        case Direction.LEFT:
          return e.x <= newX;
        default:
          return false;
      }
    };
    if (targets.length > 0) {
      this.isTargeting = true;
    } else {
      this.isTargeting = false;
    }

    targets = targets.filter(isTargetInDirection);

    for (let e of targets) {
      if (
        !this.game.rooms[this.wielder.levelID].roomArray[e.x][e.y].isSolid()
      ) {
        e.hurt(this.wielder, 1);

        this.game.rooms[this.wielder.levelID].projectiles.push(
          new PlayerFireball(this.wielder, e.x, e.y),
        );

        flag = true;
      }
    }

    if (flag) {
      if (
        this.wielder.game.rooms[this.wielder.levelID] === this.wielder.game.room
      )
        Sound.hit();
      this.wielder.hitX = 0.5 * (this.wielder.x - newX);
      this.wielder.hitY = 0.5 * (this.wielder.y - newY);

      this.game.rooms[this.wielder.levelID].tick(this.wielder);
      if (this.wielder === this.game.players[this.game.localPlayerID])
        this.game.shakeScreen(10 * this.wielder.hitX, 10 * this.wielder.hitY);
      Sound.playMagic();
      this.degrade();
      setTimeout(() => {
        this.isTargeting = false;
      }, 100);
    }
    return !flag;
  };
}


--- src/weapon/warhammer.ts ---
import { Weapon } from "./weapon";
import { Room } from "../room";
import { Sound } from "../sound";
import { Direction } from "../game";

export class Warhammer extends Weapon {
  static itemName = "warhammer";
  hitDelay: number;
  constructor(level: Room, x: number, y: number) {
    super(level, x, y);

    this.tileX = 22;
    this.tileY = 2;
    this.damage = 3;
    this.name = "warhammer";
    this.durability = 25;
    this.durabilityMax = 25;
    this.hitDelay = 225;
  }

  hitSound = () => {
    Sound.hit();
    Sound.playWarHammer();
  };

  shakeScreen = () => {
    this.wielder.slowMotionEnabled = true;

    setTimeout(() => {
      this.wielder.slowMotionEnabled = false;
      //this.hitSound();
      switch (this.wielder.direction) {
        case Direction.DOWN:
          this.game.shakeScreen(0, -30, false);
          break;
        case Direction.UP:
          this.game.shakeScreen(0, -30, false);
          break;
        case Direction.LEFT:
          this.game.shakeScreen(-5, -30, false);
          break;
        case Direction.RIGHT:
          this.game.shakeScreen(5, -30, false);
          break;
      }
    }, this.hitDelay);
  };
}


--- src/weapon/weapon.ts ---
import { Room } from "../room";
import { Game } from "../game";
import { Equippable } from "../item/equippable";
import { Sound } from "../sound";
import { SlashParticle } from "../particle/slashParticle";
import type { Entity } from "../entity/entity";
import { GameConstants } from "../gameConstants";
import { WeaponFragments } from "../item/weaponFragments";
import { Enemy } from "../entity/enemy/enemy";
import { AttackAnimation } from "../particle/attackAnimation";

interface WeaponStatus {
  poison: boolean;
  blood: boolean;
}

export abstract class Weapon extends Equippable {
  game: Game;
  range: number;
  canMine: boolean;
  damage: number;
  status: WeaponStatus;
  static itemName = "weapon";
  name: string;
  statusApplicationCount: number;
  hitDelay: number;
  constructor(level: Room, x: number, y: number, status?: WeaponStatus) {
    super(level, x, y);

    if (level) this.game = level.game;

    this.canMine = false;
    this.range = 1;
    this.damage = 1;
    this.status = status || { poison: false, blood: false };
    this.durability = 50;
    this.durabilityMax = 50;
    this.statusApplicationCount = 0;
    this.equipTick = true;
    this.name = this.constructor.prototype.itemName;
  }

  break = () => {
    this.durability = 0;
    this.wielder.inventory.weapon = null;
    this.toggleEquip();
    //this.wielder.inventory.removeItem(this);
    //this.wielder = null;
    this.game.pushMessage("Your weapon breaks");
    if (this.status.poison || this.status.blood) {
      this.clearStatus();
    }
    this.broken = true;
  };

  coEquippable = (other: Equippable): boolean => {
    if (other instanceof Weapon) return false;
    return true;
  };

  applyStatus = (status: WeaponStatus) => {
    this.status = status;
    if (this.status.blood) {
      this.damage = Math.max(0.5, this.damage - 0.5);
    }
  };

  clearStatus = () => {
    const status = this.status.poison ? "poison" : "bleed";
    this.game.pushMessage(`Your ${this.name}'s ${status} effect dries up`);

    this.status = { poison: false, blood: false };
    this.statusApplicationCount = 0;
  };

  statusEffect = (entity: Entity) => {
    if (!entity.isEnemy) return;
    const enemy = entity as Enemy;
    if (!enemy.status.poison.active || !enemy.status.bleed.active) {
      if (this.wielder.applyStatus(enemy, this.status)) {
        this.statusApplicationCount++;
        const message = this.status.poison
          ? `Your weapon poisons the ${enemy.name}`
          : `Your cursed weapon draws blood from the ${enemy.name}`;

        this.game.pushMessage(message);

        //if (this.statusApplicationCount >= 10) this.clearStatus();
      }
    }
  };

  disassemble = () => {
    if (this.equipped) {
      this.game.pushMessage(
        "I should probably unequip this before I try to disassemble it...",
      );
      return;
    }
    this.game.pushMessage(`You dissassemble your ${this.name} into fragments.`);

    let inventory = this.wielder.inventory;
    let inventoryX = this.x;
    let inventoryY = this.y;
    let numFragments = Math.floor(this.durability / 1.5);
    this.toggleEquip();
    //inventory.weapon = null;
    inventory.removeItem(this);
    inventory.addItem(
      new WeaponFragments(this.level, inventoryX, inventoryY, numFragments),
    );
  };

  dropFromInventory = () => {
    if (this.wielder.inventory.weapon === this)
      this.wielder.inventory.weapon = null;
    this.wielder = null;
    this.equipped = false;
  };

  weaponMove = (newX: number, newY: number): boolean => {
    let flag = false;

    for (let e of this.game.rooms[this.wielder.levelID].entities) {
      if (e.destroyable && !e.pushable && e.pointIn(newX, newY)) {
        this.attack(e);
        flag = true;
      }
    }

    if (flag) {
      this.wielder.busyAnimating = true;

      this.attackAnimation(newX, newY);
      this.game.rooms[this.wielder.levelID].tick(this.wielder);
      this.shakeScreen();
      this.degrade();

      setTimeout(() => {
        this.wielder.busyAnimating = false;

        this.hitSound();
      }, this.hitDelay);
    }
    return !flag;
  };

  attack = (enemy: Entity) => {
    enemy.hurt(this.wielder, this.damage);
    this.statusEffect(enemy);
  };

  attackAnimation = (newX: number, newY: number) => {
    this.wielder.hitX = 0.5 * (this.wielder.x - newX);
    this.wielder.hitY = 0.5 * (this.wielder.y - newY);
    this.game.rooms[this.wielder.levelID].particles.push(
      new AttackAnimation(newX, newY, this.name, this.wielder.direction),
    );
  };

  shakeScreen = () => {
    if (
      this.wielder.game.rooms[this.wielder.levelID] === this.wielder.game.room
    )
      this.game.shakeScreen(10 * this.wielder.hitX, 10 * this.wielder.hitY);
  };

  hitSound = () => {
    if (
      this.wielder.game.rooms[this.wielder.levelID] === this.wielder.game.room
    )
      Sound.hit();
  };

  drawStatus = (x: number, y: number) => {
    if (this.status.poison || this.status.blood) {
      let tileX = 3;
      if (this.status.poison) {
        tileX = 4;
      }
      if (this.status.blood) {
        tileX = 3;
      }

      Game.drawFX(
        tileX,
        0,
        1,
        1,
        x - 1 / GameConstants.TILESIZE,
        y - 1 / GameConstants.TILESIZE,
        1,
        1,
      );
    }
  };

  getDescription = (): string => {
    let broken = this.broken ? " (broken)" : "";
    let status = [];
    let durability = "";
    if (this.status.poison) status.push("Poison");
    if (this.status.blood) status.push(" Bleed");
    if (this.durability < this.durabilityMax)
      durability = ` Durability: ${this.durability}/${this.durabilityMax}`;
    return `${this.name}${broken}\n${status.join(", ")}\n${durability}\n${this.description}\ndamage: ${this.damage}`;
  };

  tick = () => {};

  // returns true if nothing was hit, false if the player should move
}


--- webpack://witch-game/webpack/bootstrap ---
// The module cache
var __webpack_module_cache__ = {};

// The require function
function __webpack_require__(moduleId) {
	// Check if module is in cache
	var cachedModule = __webpack_module_cache__[moduleId];
	if (cachedModule !== undefined) {
		return cachedModule.exports;
	}
	// Create a new module (and put it into the cache)
	var module = __webpack_module_cache__[moduleId] = {
		// no module.id needed
		// no module.loaded needed
		exports: {}
	};

	// Execute the module function
	__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);

	// Return the exports of the module
	return module.exports;
}



--- webpack://witch-game/webpack/before-startup ---


--- webpack://witch-game/webpack/startup ---
// startup
// Load entry module and return exports
// This entry module is referenced by other modules so it can't be inlined
var __webpack_exports__ = __webpack_require__("./src/game.ts");


--- webpack://witch-game/webpack/after-startup ---


