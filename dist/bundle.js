/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/howler/dist/howler.js":
/*!********************************************!*\
  !*** ./node_modules/howler/dist/howler.js ***!
  \********************************************/
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
 *  howler.js v2.2.4
 *  howlerjs.com
 *
 *  (c) 2013-2020, James Simpson of GoldFire Studios
 *  goldfirestudios.com
 *
 *  MIT License
 */

(function() {

  'use strict';

  /** Global Methods **/
  /***************************************************************************/

  /**
   * Create the global controller. All contained methods and properties apply
   * to all sounds that are currently playing or will be in the future.
   */
  var HowlerGlobal = function() {
    this.init();
  };
  HowlerGlobal.prototype = {
    /**
     * Initialize the global Howler object.
     * @return {Howler}
     */
    init: function() {
      var self = this || Howler;

      // Create a global ID counter.
      self._counter = 1000;

      // Pool of unlocked HTML5 Audio objects.
      self._html5AudioPool = [];
      self.html5PoolSize = 10;

      // Internal properties.
      self._codecs = {};
      self._howls = [];
      self._muted = false;
      self._volume = 1;
      self._canPlayEvent = 'canplaythrough';
      self._navigator = (typeof window !== 'undefined' && window.navigator) ? window.navigator : null;

      // Public properties.
      self.masterGain = null;
      self.noAudio = false;
      self.usingWebAudio = true;
      self.autoSuspend = true;
      self.ctx = null;

      // Set to false to disable the auto audio unlocker.
      self.autoUnlock = true;

      // Setup the various state values for global tracking.
      self._setup();

      return self;
    },

    /**
     * Get/set the global volume for all sounds.
     * @param  {Float} vol Volume from 0.0 to 1.0.
     * @return {Howler/Float}     Returns self or current volume.
     */
    volume: function(vol) {
      var self = this || Howler;
      vol = parseFloat(vol);

      // If we don't have an AudioContext created yet, run the setup.
      if (!self.ctx) {
        setupAudioContext();
      }

      if (typeof vol !== 'undefined' && vol >= 0 && vol <= 1) {
        self._volume = vol;

        // Don't update any of the nodes if we are muted.
        if (self._muted) {
          return self;
        }

        // When using Web Audio, we just need to adjust the master gain.
        if (self.usingWebAudio) {
          self.masterGain.gain.setValueAtTime(vol, Howler.ctx.currentTime);
        }

        // Loop through and change volume for all HTML5 audio nodes.
        for (var i=0; i<self._howls.length; i++) {
          if (!self._howls[i]._webAudio) {
            // Get all of the sounds in this Howl group.
            var ids = self._howls[i]._getSoundIds();

            // Loop through all sounds and change the volumes.
            for (var j=0; j<ids.length; j++) {
              var sound = self._howls[i]._soundById(ids[j]);

              if (sound && sound._node) {
                sound._node.volume = sound._volume * vol;
              }
            }
          }
        }

        return self;
      }

      return self._volume;
    },

    /**
     * Handle muting and unmuting globally.
     * @param  {Boolean} muted Is muted or not.
     */
    mute: function(muted) {
      var self = this || Howler;

      // If we don't have an AudioContext created yet, run the setup.
      if (!self.ctx) {
        setupAudioContext();
      }

      self._muted = muted;

      // With Web Audio, we just need to mute the master gain.
      if (self.usingWebAudio) {
        self.masterGain.gain.setValueAtTime(muted ? 0 : self._volume, Howler.ctx.currentTime);
      }

      // Loop through and mute all HTML5 Audio nodes.
      for (var i=0; i<self._howls.length; i++) {
        if (!self._howls[i]._webAudio) {
          // Get all of the sounds in this Howl group.
          var ids = self._howls[i]._getSoundIds();

          // Loop through all sounds and mark the audio node as muted.
          for (var j=0; j<ids.length; j++) {
            var sound = self._howls[i]._soundById(ids[j]);

            if (sound && sound._node) {
              sound._node.muted = (muted) ? true : sound._muted;
            }
          }
        }
      }

      return self;
    },

    /**
     * Handle stopping all sounds globally.
     */
    stop: function() {
      var self = this || Howler;

      // Loop through all Howls and stop them.
      for (var i=0; i<self._howls.length; i++) {
        self._howls[i].stop();
      }

      return self;
    },

    /**
     * Unload and destroy all currently loaded Howl objects.
     * @return {Howler}
     */
    unload: function() {
      var self = this || Howler;

      for (var i=self._howls.length-1; i>=0; i--) {
        self._howls[i].unload();
      }

      // Create a new AudioContext to make sure it is fully reset.
      if (self.usingWebAudio && self.ctx && typeof self.ctx.close !== 'undefined') {
        self.ctx.close();
        self.ctx = null;
        setupAudioContext();
      }

      return self;
    },

    /**
     * Check for codec support of specific extension.
     * @param  {String} ext Audio file extention.
     * @return {Boolean}
     */
    codecs: function(ext) {
      return (this || Howler)._codecs[ext.replace(/^x-/, '')];
    },

    /**
     * Setup various state values for global tracking.
     * @return {Howler}
     */
    _setup: function() {
      var self = this || Howler;

      // Keeps track of the suspend/resume state of the AudioContext.
      self.state = self.ctx ? self.ctx.state || 'suspended' : 'suspended';

      // Automatically begin the 30-second suspend process
      self._autoSuspend();

      // Check if audio is available.
      if (!self.usingWebAudio) {
        // No audio is available on this system if noAudio is set to true.
        if (typeof Audio !== 'undefined') {
          try {
            var test = new Audio();

            // Check if the canplaythrough event is available.
            if (typeof test.oncanplaythrough === 'undefined') {
              self._canPlayEvent = 'canplay';
            }
          } catch(e) {
            self.noAudio = true;
          }
        } else {
          self.noAudio = true;
        }
      }

      // Test to make sure audio isn't disabled in Internet Explorer.
      try {
        var test = new Audio();
        if (test.muted) {
          self.noAudio = true;
        }
      } catch (e) {}

      // Check for supported codecs.
      if (!self.noAudio) {
        self._setupCodecs();
      }

      return self;
    },

    /**
     * Check for browser support for various codecs and cache the results.
     * @return {Howler}
     */
    _setupCodecs: function() {
      var self = this || Howler;
      var audioTest = null;

      // Must wrap in a try/catch because IE11 in server mode throws an error.
      try {
        audioTest = (typeof Audio !== 'undefined') ? new Audio() : null;
      } catch (err) {
        return self;
      }

      if (!audioTest || typeof audioTest.canPlayType !== 'function') {
        return self;
      }

      var mpegTest = audioTest.canPlayType('audio/mpeg;').replace(/^no$/, '');

      // Opera version <33 has mixed MP3 support, so we need to check for and block it.
      var ua = self._navigator ? self._navigator.userAgent : '';
      var checkOpera = ua.match(/OPR\/(\d+)/g);
      var isOldOpera = (checkOpera && parseInt(checkOpera[0].split('/')[1], 10) < 33);
      var checkSafari = ua.indexOf('Safari') !== -1 && ua.indexOf('Chrome') === -1;
      var safariVersion = ua.match(/Version\/(.*?) /);
      var isOldSafari = (checkSafari && safariVersion && parseInt(safariVersion[1], 10) < 15);

      self._codecs = {
        mp3: !!(!isOldOpera && (mpegTest || audioTest.canPlayType('audio/mp3;').replace(/^no$/, ''))),
        mpeg: !!mpegTest,
        opus: !!audioTest.canPlayType('audio/ogg; codecs="opus"').replace(/^no$/, ''),
        ogg: !!audioTest.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ''),
        oga: !!audioTest.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ''),
        wav: !!(audioTest.canPlayType('audio/wav; codecs="1"') || audioTest.canPlayType('audio/wav')).replace(/^no$/, ''),
        aac: !!audioTest.canPlayType('audio/aac;').replace(/^no$/, ''),
        caf: !!audioTest.canPlayType('audio/x-caf;').replace(/^no$/, ''),
        m4a: !!(audioTest.canPlayType('audio/x-m4a;') || audioTest.canPlayType('audio/m4a;') || audioTest.canPlayType('audio/aac;')).replace(/^no$/, ''),
        m4b: !!(audioTest.canPlayType('audio/x-m4b;') || audioTest.canPlayType('audio/m4b;') || audioTest.canPlayType('audio/aac;')).replace(/^no$/, ''),
        mp4: !!(audioTest.canPlayType('audio/x-mp4;') || audioTest.canPlayType('audio/mp4;') || audioTest.canPlayType('audio/aac;')).replace(/^no$/, ''),
        weba: !!(!isOldSafari && audioTest.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, '')),
        webm: !!(!isOldSafari && audioTest.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, '')),
        dolby: !!audioTest.canPlayType('audio/mp4; codecs="ec-3"').replace(/^no$/, ''),
        flac: !!(audioTest.canPlayType('audio/x-flac;') || audioTest.canPlayType('audio/flac;')).replace(/^no$/, '')
      };

      return self;
    },

    /**
     * Some browsers/devices will only allow audio to be played after a user interaction.
     * Attempt to automatically unlock audio on the first user interaction.
     * Concept from: http://paulbakaus.com/tutorials/html5/web-audio-on-ios/
     * @return {Howler}
     */
    _unlockAudio: function() {
      var self = this || Howler;

      // Only run this if Web Audio is supported and it hasn't already been unlocked.
      if (self._audioUnlocked || !self.ctx) {
        return;
      }

      self._audioUnlocked = false;
      self.autoUnlock = false;

      // Some mobile devices/platforms have distortion issues when opening/closing tabs and/or web views.
      // Bugs in the browser (especially Mobile Safari) can cause the sampleRate to change from 44100 to 48000.
      // By calling Howler.unload(), we create a new AudioContext with the correct sampleRate.
      if (!self._mobileUnloaded && self.ctx.sampleRate !== 44100) {
        self._mobileUnloaded = true;
        self.unload();
      }

      // Scratch buffer for enabling iOS to dispose of web audio buffers correctly, as per:
      // http://stackoverflow.com/questions/24119684
      self._scratchBuffer = self.ctx.createBuffer(1, 1, 22050);

      // Call this method on touch start to create and play a buffer,
      // then check if the audio actually played to determine if
      // audio has now been unlocked on iOS, Android, etc.
      var unlock = function(e) {
        // Create a pool of unlocked HTML5 Audio objects that can
        // be used for playing sounds without user interaction. HTML5
        // Audio objects must be individually unlocked, as opposed
        // to the WebAudio API which only needs a single activation.
        // This must occur before WebAudio setup or the source.onended
        // event will not fire.
        while (self._html5AudioPool.length < self.html5PoolSize) {
          try {
            var audioNode = new Audio();

            // Mark this Audio object as unlocked to ensure it can get returned
            // to the unlocked pool when released.
            audioNode._unlocked = true;

            // Add the audio node to the pool.
            self._releaseHtml5Audio(audioNode);
          } catch (e) {
            self.noAudio = true;
            break;
          }
        }

        // Loop through any assigned audio nodes and unlock them.
        for (var i=0; i<self._howls.length; i++) {
          if (!self._howls[i]._webAudio) {
            // Get all of the sounds in this Howl group.
            var ids = self._howls[i]._getSoundIds();

            // Loop through all sounds and unlock the audio nodes.
            for (var j=0; j<ids.length; j++) {
              var sound = self._howls[i]._soundById(ids[j]);

              if (sound && sound._node && !sound._node._unlocked) {
                sound._node._unlocked = true;
                sound._node.load();
              }
            }
          }
        }

        // Fix Android can not play in suspend state.
        self._autoResume();

        // Create an empty buffer.
        var source = self.ctx.createBufferSource();
        source.buffer = self._scratchBuffer;
        source.connect(self.ctx.destination);

        // Play the empty buffer.
        if (typeof source.start === 'undefined') {
          source.noteOn(0);
        } else {
          source.start(0);
        }

        // Calling resume() on a stack initiated by user gesture is what actually unlocks the audio on Android Chrome >= 55.
        if (typeof self.ctx.resume === 'function') {
          self.ctx.resume();
        }

        // Setup a timeout to check that we are unlocked on the next event loop.
        source.onended = function() {
          source.disconnect(0);

          // Update the unlocked state and prevent this check from happening again.
          self._audioUnlocked = true;

          // Remove the touch start listener.
          document.removeEventListener('touchstart', unlock, true);
          document.removeEventListener('touchend', unlock, true);
          document.removeEventListener('click', unlock, true);
          document.removeEventListener('keydown', unlock, true);

          // Let all sounds know that audio has been unlocked.
          for (var i=0; i<self._howls.length; i++) {
            self._howls[i]._emit('unlock');
          }
        };
      };

      // Setup a touch start listener to attempt an unlock in.
      document.addEventListener('touchstart', unlock, true);
      document.addEventListener('touchend', unlock, true);
      document.addEventListener('click', unlock, true);
      document.addEventListener('keydown', unlock, true);

      return self;
    },

    /**
     * Get an unlocked HTML5 Audio object from the pool. If none are left,
     * return a new Audio object and throw a warning.
     * @return {Audio} HTML5 Audio object.
     */
    _obtainHtml5Audio: function() {
      var self = this || Howler;

      // Return the next object from the pool if one exists.
      if (self._html5AudioPool.length) {
        return self._html5AudioPool.pop();
      }

      //.Check if the audio is locked and throw a warning.
      var testPlay = new Audio().play();
      if (testPlay && typeof Promise !== 'undefined' && (testPlay instanceof Promise || typeof testPlay.then === 'function')) {
        testPlay.catch(function() {
          console.warn('HTML5 Audio pool exhausted, returning potentially locked audio object.');
        });
      }

      return new Audio();
    },

    /**
     * Return an activated HTML5 Audio object to the pool.
     * @return {Howler}
     */
    _releaseHtml5Audio: function(audio) {
      var self = this || Howler;

      // Don't add audio to the pool if we don't know if it has been unlocked.
      if (audio._unlocked) {
        self._html5AudioPool.push(audio);
      }

      return self;
    },

    /**
     * Automatically suspend the Web Audio AudioContext after no sound has played for 30 seconds.
     * This saves processing/energy and fixes various browser-specific bugs with audio getting stuck.
     * @return {Howler}
     */
    _autoSuspend: function() {
      var self = this;

      if (!self.autoSuspend || !self.ctx || typeof self.ctx.suspend === 'undefined' || !Howler.usingWebAudio) {
        return;
      }

      // Check if any sounds are playing.
      for (var i=0; i<self._howls.length; i++) {
        if (self._howls[i]._webAudio) {
          for (var j=0; j<self._howls[i]._sounds.length; j++) {
            if (!self._howls[i]._sounds[j]._paused) {
              return self;
            }
          }
        }
      }

      if (self._suspendTimer) {
        clearTimeout(self._suspendTimer);
      }

      // If no sound has played after 30 seconds, suspend the context.
      self._suspendTimer = setTimeout(function() {
        if (!self.autoSuspend) {
          return;
        }

        self._suspendTimer = null;
        self.state = 'suspending';

        // Handle updating the state of the audio context after suspending.
        var handleSuspension = function() {
          self.state = 'suspended';

          if (self._resumeAfterSuspend) {
            delete self._resumeAfterSuspend;
            self._autoResume();
          }
        };

        // Either the state gets suspended or it is interrupted.
        // Either way, we need to update the state to suspended.
        self.ctx.suspend().then(handleSuspension, handleSuspension);
      }, 30000);

      return self;
    },

    /**
     * Automatically resume the Web Audio AudioContext when a new sound is played.
     * @return {Howler}
     */
    _autoResume: function() {
      var self = this;

      if (!self.ctx || typeof self.ctx.resume === 'undefined' || !Howler.usingWebAudio) {
        return;
      }

      if (self.state === 'running' && self.ctx.state !== 'interrupted' && self._suspendTimer) {
        clearTimeout(self._suspendTimer);
        self._suspendTimer = null;
      } else if (self.state === 'suspended' || self.state === 'running' && self.ctx.state === 'interrupted') {
        self.ctx.resume().then(function() {
          self.state = 'running';

          // Emit to all Howls that the audio has resumed.
          for (var i=0; i<self._howls.length; i++) {
            self._howls[i]._emit('resume');
          }
        });

        if (self._suspendTimer) {
          clearTimeout(self._suspendTimer);
          self._suspendTimer = null;
        }
      } else if (self.state === 'suspending') {
        self._resumeAfterSuspend = true;
      }

      return self;
    }
  };

  // Setup the global audio controller.
  var Howler = new HowlerGlobal();

  /** Group Methods **/
  /***************************************************************************/

  /**
   * Create an audio group controller.
   * @param {Object} o Passed in properties for this group.
   */
  var Howl = function(o) {
    var self = this;

    // Throw an error if no source is provided.
    if (!o.src || o.src.length === 0) {
      console.error('An array of source files must be passed with any new Howl.');
      return;
    }

    self.init(o);
  };
  Howl.prototype = {
    /**
     * Initialize a new Howl group object.
     * @param  {Object} o Passed in properties for this group.
     * @return {Howl}
     */
    init: function(o) {
      var self = this;

      // If we don't have an AudioContext created yet, run the setup.
      if (!Howler.ctx) {
        setupAudioContext();
      }

      // Setup user-defined default properties.
      self._autoplay = o.autoplay || false;
      self._format = (typeof o.format !== 'string') ? o.format : [o.format];
      self._html5 = o.html5 || false;
      self._muted = o.mute || false;
      self._loop = o.loop || false;
      self._pool = o.pool || 5;
      self._preload = (typeof o.preload === 'boolean' || o.preload === 'metadata') ? o.preload : true;
      self._rate = o.rate || 1;
      self._sprite = o.sprite || {};
      self._src = (typeof o.src !== 'string') ? o.src : [o.src];
      self._volume = o.volume !== undefined ? o.volume : 1;
      self._xhr = {
        method: o.xhr && o.xhr.method ? o.xhr.method : 'GET',
        headers: o.xhr && o.xhr.headers ? o.xhr.headers : null,
        withCredentials: o.xhr && o.xhr.withCredentials ? o.xhr.withCredentials : false,
      };

      // Setup all other default properties.
      self._duration = 0;
      self._state = 'unloaded';
      self._sounds = [];
      self._endTimers = {};
      self._queue = [];
      self._playLock = false;

      // Setup event listeners.
      self._onend = o.onend ? [{fn: o.onend}] : [];
      self._onfade = o.onfade ? [{fn: o.onfade}] : [];
      self._onload = o.onload ? [{fn: o.onload}] : [];
      self._onloaderror = o.onloaderror ? [{fn: o.onloaderror}] : [];
      self._onplayerror = o.onplayerror ? [{fn: o.onplayerror}] : [];
      self._onpause = o.onpause ? [{fn: o.onpause}] : [];
      self._onplay = o.onplay ? [{fn: o.onplay}] : [];
      self._onstop = o.onstop ? [{fn: o.onstop}] : [];
      self._onmute = o.onmute ? [{fn: o.onmute}] : [];
      self._onvolume = o.onvolume ? [{fn: o.onvolume}] : [];
      self._onrate = o.onrate ? [{fn: o.onrate}] : [];
      self._onseek = o.onseek ? [{fn: o.onseek}] : [];
      self._onunlock = o.onunlock ? [{fn: o.onunlock}] : [];
      self._onresume = [];

      // Web Audio or HTML5 Audio?
      self._webAudio = Howler.usingWebAudio && !self._html5;

      // Automatically try to enable audio.
      if (typeof Howler.ctx !== 'undefined' && Howler.ctx && Howler.autoUnlock) {
        Howler._unlockAudio();
      }

      // Keep track of this Howl group in the global controller.
      Howler._howls.push(self);

      // If they selected autoplay, add a play event to the load queue.
      if (self._autoplay) {
        self._queue.push({
          event: 'play',
          action: function() {
            self.play();
          }
        });
      }

      // Load the source file unless otherwise specified.
      if (self._preload && self._preload !== 'none') {
        self.load();
      }

      return self;
    },

    /**
     * Load the audio file.
     * @return {Howler}
     */
    load: function() {
      var self = this;
      var url = null;

      // If no audio is available, quit immediately.
      if (Howler.noAudio) {
        self._emit('loaderror', null, 'No audio support.');
        return;
      }

      // Make sure our source is in an array.
      if (typeof self._src === 'string') {
        self._src = [self._src];
      }

      // Loop through the sources and pick the first one that is compatible.
      for (var i=0; i<self._src.length; i++) {
        var ext, str;

        if (self._format && self._format[i]) {
          // If an extension was specified, use that instead.
          ext = self._format[i];
        } else {
          // Make sure the source is a string.
          str = self._src[i];
          if (typeof str !== 'string') {
            self._emit('loaderror', null, 'Non-string found in selected audio sources - ignoring.');
            continue;
          }

          // Extract the file extension from the URL or base64 data URI.
          ext = /^data:audio\/([^;,]+);/i.exec(str);
          if (!ext) {
            ext = /\.([^.]+)$/.exec(str.split('?', 1)[0]);
          }

          if (ext) {
            ext = ext[1].toLowerCase();
          }
        }

        // Log a warning if no extension was found.
        if (!ext) {
          console.warn('No file extension was found. Consider using the "format" property or specify an extension.');
        }

        // Check if this extension is available.
        if (ext && Howler.codecs(ext)) {
          url = self._src[i];
          break;
        }
      }

      if (!url) {
        self._emit('loaderror', null, 'No codec support for selected audio sources.');
        return;
      }

      self._src = url;
      self._state = 'loading';

      // If the hosting page is HTTPS and the source isn't,
      // drop down to HTML5 Audio to avoid Mixed Content errors.
      if (window.location.protocol === 'https:' && url.slice(0, 5) === 'http:') {
        self._html5 = true;
        self._webAudio = false;
      }

      // Create a new sound object and add it to the pool.
      new Sound(self);

      // Load and decode the audio data for playback.
      if (self._webAudio) {
        loadBuffer(self);
      }

      return self;
    },

    /**
     * Play a sound or resume previous playback.
     * @param  {String/Number} sprite   Sprite name for sprite playback or sound id to continue previous.
     * @param  {Boolean} internal Internal Use: true prevents event firing.
     * @return {Number}          Sound ID.
     */
    play: function(sprite, internal) {
      var self = this;
      var id = null;

      // Determine if a sprite, sound id or nothing was passed
      if (typeof sprite === 'number') {
        id = sprite;
        sprite = null;
      } else if (typeof sprite === 'string' && self._state === 'loaded' && !self._sprite[sprite]) {
        // If the passed sprite doesn't exist, do nothing.
        return null;
      } else if (typeof sprite === 'undefined') {
        // Use the default sound sprite (plays the full audio length).
        sprite = '__default';

        // Check if there is a single paused sound that isn't ended.
        // If there is, play that sound. If not, continue as usual.
        if (!self._playLock) {
          var num = 0;
          for (var i=0; i<self._sounds.length; i++) {
            if (self._sounds[i]._paused && !self._sounds[i]._ended) {
              num++;
              id = self._sounds[i]._id;
            }
          }

          if (num === 1) {
            sprite = null;
          } else {
            id = null;
          }
        }
      }

      // Get the selected node, or get one from the pool.
      var sound = id ? self._soundById(id) : self._inactiveSound();

      // If the sound doesn't exist, do nothing.
      if (!sound) {
        return null;
      }

      // Select the sprite definition.
      if (id && !sprite) {
        sprite = sound._sprite || '__default';
      }

      // If the sound hasn't loaded, we must wait to get the audio's duration.
      // We also need to wait to make sure we don't run into race conditions with
      // the order of function calls.
      if (self._state !== 'loaded') {
        // Set the sprite value on this sound.
        sound._sprite = sprite;

        // Mark this sound as not ended in case another sound is played before this one loads.
        sound._ended = false;

        // Add the sound to the queue to be played on load.
        var soundId = sound._id;
        self._queue.push({
          event: 'play',
          action: function() {
            self.play(soundId);
          }
        });

        return soundId;
      }

      // Don't play the sound if an id was passed and it is already playing.
      if (id && !sound._paused) {
        // Trigger the play event, in order to keep iterating through queue.
        if (!internal) {
          self._loadQueue('play');
        }

        return sound._id;
      }

      // Make sure the AudioContext isn't suspended, and resume it if it is.
      if (self._webAudio) {
        Howler._autoResume();
      }

      // Determine how long to play for and where to start playing.
      var seek = Math.max(0, sound._seek > 0 ? sound._seek : self._sprite[sprite][0] / 1000);
      var duration = Math.max(0, ((self._sprite[sprite][0] + self._sprite[sprite][1]) / 1000) - seek);
      var timeout = (duration * 1000) / Math.abs(sound._rate);
      var start = self._sprite[sprite][0] / 1000;
      var stop = (self._sprite[sprite][0] + self._sprite[sprite][1]) / 1000;
      sound._sprite = sprite;

      // Mark the sound as ended instantly so that this async playback
      // doesn't get grabbed by another call to play while this one waits to start.
      sound._ended = false;

      // Update the parameters of the sound.
      var setParams = function() {
        sound._paused = false;
        sound._seek = seek;
        sound._start = start;
        sound._stop = stop;
        sound._loop = !!(sound._loop || self._sprite[sprite][2]);
      };

      // End the sound instantly if seek is at the end.
      if (seek >= stop) {
        self._ended(sound);
        return;
      }

      // Begin the actual playback.
      var node = sound._node;
      if (self._webAudio) {
        // Fire this when the sound is ready to play to begin Web Audio playback.
        var playWebAudio = function() {
          self._playLock = false;
          setParams();
          self._refreshBuffer(sound);

          // Setup the playback params.
          var vol = (sound._muted || self._muted) ? 0 : sound._volume;
          node.gain.setValueAtTime(vol, Howler.ctx.currentTime);
          sound._playStart = Howler.ctx.currentTime;

          // Play the sound using the supported method.
          if (typeof node.bufferSource.start === 'undefined') {
            sound._loop ? node.bufferSource.noteGrainOn(0, seek, 86400) : node.bufferSource.noteGrainOn(0, seek, duration);
          } else {
            sound._loop ? node.bufferSource.start(0, seek, 86400) : node.bufferSource.start(0, seek, duration);
          }

          // Start a new timer if none is present.
          if (timeout !== Infinity) {
            self._endTimers[sound._id] = setTimeout(self._ended.bind(self, sound), timeout);
          }

          if (!internal) {
            setTimeout(function() {
              self._emit('play', sound._id);
              self._loadQueue();
            }, 0);
          }
        };

        if (Howler.state === 'running' && Howler.ctx.state !== 'interrupted') {
          playWebAudio();
        } else {
          self._playLock = true;

          // Wait for the audio context to resume before playing.
          self.once('resume', playWebAudio);

          // Cancel the end timer.
          self._clearTimer(sound._id);
        }
      } else {
        // Fire this when the sound is ready to play to begin HTML5 Audio playback.
        var playHtml5 = function() {
          node.currentTime = seek;
          node.muted = sound._muted || self._muted || Howler._muted || node.muted;
          node.volume = sound._volume * Howler.volume();
          node.playbackRate = sound._rate;

          // Some browsers will throw an error if this is called without user interaction.
          try {
            var play = node.play();

            // Support older browsers that don't support promises, and thus don't have this issue.
            if (play && typeof Promise !== 'undefined' && (play instanceof Promise || typeof play.then === 'function')) {
              // Implements a lock to prevent DOMException: The play() request was interrupted by a call to pause().
              self._playLock = true;

              // Set param values immediately.
              setParams();

              // Releases the lock and executes queued actions.
              play
                .then(function() {
                  self._playLock = false;
                  node._unlocked = true;
                  if (!internal) {
                    self._emit('play', sound._id);
                  } else {
                    self._loadQueue();
                  }
                })
                .catch(function() {
                  self._playLock = false;
                  self._emit('playerror', sound._id, 'Playback was unable to start. This is most commonly an issue ' +
                    'on mobile devices and Chrome where playback was not within a user interaction.');

                  // Reset the ended and paused values.
                  sound._ended = true;
                  sound._paused = true;
                });
            } else if (!internal) {
              self._playLock = false;
              setParams();
              self._emit('play', sound._id);
            }

            // Setting rate before playing won't work in IE, so we set it again here.
            node.playbackRate = sound._rate;

            // If the node is still paused, then we can assume there was a playback issue.
            if (node.paused) {
              self._emit('playerror', sound._id, 'Playback was unable to start. This is most commonly an issue ' +
                'on mobile devices and Chrome where playback was not within a user interaction.');
              return;
            }

            // Setup the end timer on sprites or listen for the ended event.
            if (sprite !== '__default' || sound._loop) {
              self._endTimers[sound._id] = setTimeout(self._ended.bind(self, sound), timeout);
            } else {
              self._endTimers[sound._id] = function() {
                // Fire ended on this audio node.
                self._ended(sound);

                // Clear this listener.
                node.removeEventListener('ended', self._endTimers[sound._id], false);
              };
              node.addEventListener('ended', self._endTimers[sound._id], false);
            }
          } catch (err) {
            self._emit('playerror', sound._id, err);
          }
        };

        // If this is streaming audio, make sure the src is set and load again.
        if (node.src === 'data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA') {
          node.src = self._src;
          node.load();
        }

        // Play immediately if ready, or wait for the 'canplaythrough'e vent.
        var loadedNoReadyState = (window && window.ejecta) || (!node.readyState && Howler._navigator.isCocoonJS);
        if (node.readyState >= 3 || loadedNoReadyState) {
          playHtml5();
        } else {
          self._playLock = true;
          self._state = 'loading';

          var listener = function() {
            self._state = 'loaded';
            
            // Begin playback.
            playHtml5();

            // Clear this listener.
            node.removeEventListener(Howler._canPlayEvent, listener, false);
          };
          node.addEventListener(Howler._canPlayEvent, listener, false);

          // Cancel the end timer.
          self._clearTimer(sound._id);
        }
      }

      return sound._id;
    },

    /**
     * Pause playback and save current position.
     * @param  {Number} id The sound ID (empty to pause all in group).
     * @return {Howl}
     */
    pause: function(id) {
      var self = this;

      // If the sound hasn't loaded or a play() promise is pending, add it to the load queue to pause when capable.
      if (self._state !== 'loaded' || self._playLock) {
        self._queue.push({
          event: 'pause',
          action: function() {
            self.pause(id);
          }
        });

        return self;
      }

      // If no id is passed, get all ID's to be paused.
      var ids = self._getSoundIds(id);

      for (var i=0; i<ids.length; i++) {
        // Clear the end timer.
        self._clearTimer(ids[i]);

        // Get the sound.
        var sound = self._soundById(ids[i]);

        if (sound && !sound._paused) {
          // Reset the seek position.
          sound._seek = self.seek(ids[i]);
          sound._rateSeek = 0;
          sound._paused = true;

          // Stop currently running fades.
          self._stopFade(ids[i]);

          if (sound._node) {
            if (self._webAudio) {
              // Make sure the sound has been created.
              if (!sound._node.bufferSource) {
                continue;
              }

              if (typeof sound._node.bufferSource.stop === 'undefined') {
                sound._node.bufferSource.noteOff(0);
              } else {
                sound._node.bufferSource.stop(0);
              }

              // Clean up the buffer source.
              self._cleanBuffer(sound._node);
            } else if (!isNaN(sound._node.duration) || sound._node.duration === Infinity) {
              sound._node.pause();
            }
          }
        }

        // Fire the pause event, unless `true` is passed as the 2nd argument.
        if (!arguments[1]) {
          self._emit('pause', sound ? sound._id : null);
        }
      }

      return self;
    },

    /**
     * Stop playback and reset to start.
     * @param  {Number} id The sound ID (empty to stop all in group).
     * @param  {Boolean} internal Internal Use: true prevents event firing.
     * @return {Howl}
     */
    stop: function(id, internal) {
      var self = this;

      // If the sound hasn't loaded, add it to the load queue to stop when capable.
      if (self._state !== 'loaded' || self._playLock) {
        self._queue.push({
          event: 'stop',
          action: function() {
            self.stop(id);
          }
        });

        return self;
      }

      // If no id is passed, get all ID's to be stopped.
      var ids = self._getSoundIds(id);

      for (var i=0; i<ids.length; i++) {
        // Clear the end timer.
        self._clearTimer(ids[i]);

        // Get the sound.
        var sound = self._soundById(ids[i]);

        if (sound) {
          // Reset the seek position.
          sound._seek = sound._start || 0;
          sound._rateSeek = 0;
          sound._paused = true;
          sound._ended = true;

          // Stop currently running fades.
          self._stopFade(ids[i]);

          if (sound._node) {
            if (self._webAudio) {
              // Make sure the sound's AudioBufferSourceNode has been created.
              if (sound._node.bufferSource) {
                if (typeof sound._node.bufferSource.stop === 'undefined') {
                  sound._node.bufferSource.noteOff(0);
                } else {
                  sound._node.bufferSource.stop(0);
                }

                // Clean up the buffer source.
                self._cleanBuffer(sound._node);
              }
            } else if (!isNaN(sound._node.duration) || sound._node.duration === Infinity) {
              sound._node.currentTime = sound._start || 0;
              sound._node.pause();

              // If this is a live stream, stop download once the audio is stopped.
              if (sound._node.duration === Infinity) {
                self._clearSound(sound._node);
              }
            }
          }

          if (!internal) {
            self._emit('stop', sound._id);
          }
        }
      }

      return self;
    },

    /**
     * Mute/unmute a single sound or all sounds in this Howl group.
     * @param  {Boolean} muted Set to true to mute and false to unmute.
     * @param  {Number} id    The sound ID to update (omit to mute/unmute all).
     * @return {Howl}
     */
    mute: function(muted, id) {
      var self = this;

      // If the sound hasn't loaded, add it to the load queue to mute when capable.
      if (self._state !== 'loaded'|| self._playLock) {
        self._queue.push({
          event: 'mute',
          action: function() {
            self.mute(muted, id);
          }
        });

        return self;
      }

      // If applying mute/unmute to all sounds, update the group's value.
      if (typeof id === 'undefined') {
        if (typeof muted === 'boolean') {
          self._muted = muted;
        } else {
          return self._muted;
        }
      }

      // If no id is passed, get all ID's to be muted.
      var ids = self._getSoundIds(id);

      for (var i=0; i<ids.length; i++) {
        // Get the sound.
        var sound = self._soundById(ids[i]);

        if (sound) {
          sound._muted = muted;

          // Cancel active fade and set the volume to the end value.
          if (sound._interval) {
            self._stopFade(sound._id);
          }

          if (self._webAudio && sound._node) {
            sound._node.gain.setValueAtTime(muted ? 0 : sound._volume, Howler.ctx.currentTime);
          } else if (sound._node) {
            sound._node.muted = Howler._muted ? true : muted;
          }

          self._emit('mute', sound._id);
        }
      }

      return self;
    },

    /**
     * Get/set the volume of this sound or of the Howl group. This method can optionally take 0, 1 or 2 arguments.
     *   volume() -> Returns the group's volume value.
     *   volume(id) -> Returns the sound id's current volume.
     *   volume(vol) -> Sets the volume of all sounds in this Howl group.
     *   volume(vol, id) -> Sets the volume of passed sound id.
     * @return {Howl/Number} Returns self or current volume.
     */
    volume: function() {
      var self = this;
      var args = arguments;
      var vol, id;

      // Determine the values based on arguments.
      if (args.length === 0) {
        // Return the value of the groups' volume.
        return self._volume;
      } else if (args.length === 1 || args.length === 2 && typeof args[1] === 'undefined') {
        // First check if this is an ID, and if not, assume it is a new volume.
        var ids = self._getSoundIds();
        var index = ids.indexOf(args[0]);
        if (index >= 0) {
          id = parseInt(args[0], 10);
        } else {
          vol = parseFloat(args[0]);
        }
      } else if (args.length >= 2) {
        vol = parseFloat(args[0]);
        id = parseInt(args[1], 10);
      }

      // Update the volume or return the current volume.
      var sound;
      if (typeof vol !== 'undefined' && vol >= 0 && vol <= 1) {
        // If the sound hasn't loaded, add it to the load queue to change volume when capable.
        if (self._state !== 'loaded'|| self._playLock) {
          self._queue.push({
            event: 'volume',
            action: function() {
              self.volume.apply(self, args);
            }
          });

          return self;
        }

        // Set the group volume.
        if (typeof id === 'undefined') {
          self._volume = vol;
        }

        // Update one or all volumes.
        id = self._getSoundIds(id);
        for (var i=0; i<id.length; i++) {
          // Get the sound.
          sound = self._soundById(id[i]);

          if (sound) {
            sound._volume = vol;

            // Stop currently running fades.
            if (!args[2]) {
              self._stopFade(id[i]);
            }

            if (self._webAudio && sound._node && !sound._muted) {
              sound._node.gain.setValueAtTime(vol, Howler.ctx.currentTime);
            } else if (sound._node && !sound._muted) {
              sound._node.volume = vol * Howler.volume();
            }

            self._emit('volume', sound._id);
          }
        }
      } else {
        sound = id ? self._soundById(id) : self._sounds[0];
        return sound ? sound._volume : 0;
      }

      return self;
    },

    /**
     * Fade a currently playing sound between two volumes (if no id is passed, all sounds will fade).
     * @param  {Number} from The value to fade from (0.0 to 1.0).
     * @param  {Number} to   The volume to fade to (0.0 to 1.0).
     * @param  {Number} len  Time in milliseconds to fade.
     * @param  {Number} id   The sound id (omit to fade all sounds).
     * @return {Howl}
     */
    fade: function(from, to, len, id) {
      var self = this;

      // If the sound hasn't loaded, add it to the load queue to fade when capable.
      if (self._state !== 'loaded' || self._playLock) {
        self._queue.push({
          event: 'fade',
          action: function() {
            self.fade(from, to, len, id);
          }
        });

        return self;
      }

      // Make sure the to/from/len values are numbers.
      from = Math.min(Math.max(0, parseFloat(from)), 1);
      to = Math.min(Math.max(0, parseFloat(to)), 1);
      len = parseFloat(len);

      // Set the volume to the start position.
      self.volume(from, id);

      // Fade the volume of one or all sounds.
      var ids = self._getSoundIds(id);
      for (var i=0; i<ids.length; i++) {
        // Get the sound.
        var sound = self._soundById(ids[i]);

        // Create a linear fade or fall back to timeouts with HTML5 Audio.
        if (sound) {
          // Stop the previous fade if no sprite is being used (otherwise, volume handles this).
          if (!id) {
            self._stopFade(ids[i]);
          }

          // If we are using Web Audio, let the native methods do the actual fade.
          if (self._webAudio && !sound._muted) {
            var currentTime = Howler.ctx.currentTime;
            var end = currentTime + (len / 1000);
            sound._volume = from;
            sound._node.gain.setValueAtTime(from, currentTime);
            sound._node.gain.linearRampToValueAtTime(to, end);
          }

          self._startFadeInterval(sound, from, to, len, ids[i], typeof id === 'undefined');
        }
      }

      return self;
    },

    /**
     * Starts the internal interval to fade a sound.
     * @param  {Object} sound Reference to sound to fade.
     * @param  {Number} from The value to fade from (0.0 to 1.0).
     * @param  {Number} to   The volume to fade to (0.0 to 1.0).
     * @param  {Number} len  Time in milliseconds to fade.
     * @param  {Number} id   The sound id to fade.
     * @param  {Boolean} isGroup   If true, set the volume on the group.
     */
    _startFadeInterval: function(sound, from, to, len, id, isGroup) {
      var self = this;
      var vol = from;
      var diff = to - from;
      var steps = Math.abs(diff / 0.01);
      var stepLen = Math.max(4, (steps > 0) ? len / steps : len);
      var lastTick = Date.now();

      // Store the value being faded to.
      sound._fadeTo = to;

      // Update the volume value on each interval tick.
      sound._interval = setInterval(function() {
        // Update the volume based on the time since the last tick.
        var tick = (Date.now() - lastTick) / len;
        lastTick = Date.now();
        vol += diff * tick;

        // Round to within 2 decimal points.
        vol = Math.round(vol * 100) / 100;

        // Make sure the volume is in the right bounds.
        if (diff < 0) {
          vol = Math.max(to, vol);
        } else {
          vol = Math.min(to, vol);
        }

        // Change the volume.
        if (self._webAudio) {
          sound._volume = vol;
        } else {
          self.volume(vol, sound._id, true);
        }

        // Set the group's volume.
        if (isGroup) {
          self._volume = vol;
        }

        // When the fade is complete, stop it and fire event.
        if ((to < from && vol <= to) || (to > from && vol >= to)) {
          clearInterval(sound._interval);
          sound._interval = null;
          sound._fadeTo = null;
          self.volume(to, sound._id);
          self._emit('fade', sound._id);
        }
      }, stepLen);
    },

    /**
     * Internal method that stops the currently playing fade when
     * a new fade starts, volume is changed or the sound is stopped.
     * @param  {Number} id The sound id.
     * @return {Howl}
     */
    _stopFade: function(id) {
      var self = this;
      var sound = self._soundById(id);

      if (sound && sound._interval) {
        if (self._webAudio) {
          sound._node.gain.cancelScheduledValues(Howler.ctx.currentTime);
        }

        clearInterval(sound._interval);
        sound._interval = null;
        self.volume(sound._fadeTo, id);
        sound._fadeTo = null;
        self._emit('fade', id);
      }

      return self;
    },

    /**
     * Get/set the loop parameter on a sound. This method can optionally take 0, 1 or 2 arguments.
     *   loop() -> Returns the group's loop value.
     *   loop(id) -> Returns the sound id's loop value.
     *   loop(loop) -> Sets the loop value for all sounds in this Howl group.
     *   loop(loop, id) -> Sets the loop value of passed sound id.
     * @return {Howl/Boolean} Returns self or current loop value.
     */
    loop: function() {
      var self = this;
      var args = arguments;
      var loop, id, sound;

      // Determine the values for loop and id.
      if (args.length === 0) {
        // Return the grou's loop value.
        return self._loop;
      } else if (args.length === 1) {
        if (typeof args[0] === 'boolean') {
          loop = args[0];
          self._loop = loop;
        } else {
          // Return this sound's loop value.
          sound = self._soundById(parseInt(args[0], 10));
          return sound ? sound._loop : false;
        }
      } else if (args.length === 2) {
        loop = args[0];
        id = parseInt(args[1], 10);
      }

      // If no id is passed, get all ID's to be looped.
      var ids = self._getSoundIds(id);
      for (var i=0; i<ids.length; i++) {
        sound = self._soundById(ids[i]);

        if (sound) {
          sound._loop = loop;
          if (self._webAudio && sound._node && sound._node.bufferSource) {
            sound._node.bufferSource.loop = loop;
            if (loop) {
              sound._node.bufferSource.loopStart = sound._start || 0;
              sound._node.bufferSource.loopEnd = sound._stop;

              // If playing, restart playback to ensure looping updates.
              if (self.playing(ids[i])) {
                self.pause(ids[i], true);
                self.play(ids[i], true);
              }
            }
          }
        }
      }

      return self;
    },

    /**
     * Get/set the playback rate of a sound. This method can optionally take 0, 1 or 2 arguments.
     *   rate() -> Returns the first sound node's current playback rate.
     *   rate(id) -> Returns the sound id's current playback rate.
     *   rate(rate) -> Sets the playback rate of all sounds in this Howl group.
     *   rate(rate, id) -> Sets the playback rate of passed sound id.
     * @return {Howl/Number} Returns self or the current playback rate.
     */
    rate: function() {
      var self = this;
      var args = arguments;
      var rate, id;

      // Determine the values based on arguments.
      if (args.length === 0) {
        // We will simply return the current rate of the first node.
        id = self._sounds[0]._id;
      } else if (args.length === 1) {
        // First check if this is an ID, and if not, assume it is a new rate value.
        var ids = self._getSoundIds();
        var index = ids.indexOf(args[0]);
        if (index >= 0) {
          id = parseInt(args[0], 10);
        } else {
          rate = parseFloat(args[0]);
        }
      } else if (args.length === 2) {
        rate = parseFloat(args[0]);
        id = parseInt(args[1], 10);
      }

      // Update the playback rate or return the current value.
      var sound;
      if (typeof rate === 'number') {
        // If the sound hasn't loaded, add it to the load queue to change playback rate when capable.
        if (self._state !== 'loaded' || self._playLock) {
          self._queue.push({
            event: 'rate',
            action: function() {
              self.rate.apply(self, args);
            }
          });

          return self;
        }

        // Set the group rate.
        if (typeof id === 'undefined') {
          self._rate = rate;
        }

        // Update one or all volumes.
        id = self._getSoundIds(id);
        for (var i=0; i<id.length; i++) {
          // Get the sound.
          sound = self._soundById(id[i]);

          if (sound) {
            // Keep track of our position when the rate changed and update the playback
            // start position so we can properly adjust the seek position for time elapsed.
            if (self.playing(id[i])) {
              sound._rateSeek = self.seek(id[i]);
              sound._playStart = self._webAudio ? Howler.ctx.currentTime : sound._playStart;
            }
            sound._rate = rate;

            // Change the playback rate.
            if (self._webAudio && sound._node && sound._node.bufferSource) {
              sound._node.bufferSource.playbackRate.setValueAtTime(rate, Howler.ctx.currentTime);
            } else if (sound._node) {
              sound._node.playbackRate = rate;
            }

            // Reset the timers.
            var seek = self.seek(id[i]);
            var duration = ((self._sprite[sound._sprite][0] + self._sprite[sound._sprite][1]) / 1000) - seek;
            var timeout = (duration * 1000) / Math.abs(sound._rate);

            // Start a new end timer if sound is already playing.
            if (self._endTimers[id[i]] || !sound._paused) {
              self._clearTimer(id[i]);
              self._endTimers[id[i]] = setTimeout(self._ended.bind(self, sound), timeout);
            }

            self._emit('rate', sound._id);
          }
        }
      } else {
        sound = self._soundById(id);
        return sound ? sound._rate : self._rate;
      }

      return self;
    },

    /**
     * Get/set the seek position of a sound. This method can optionally take 0, 1 or 2 arguments.
     *   seek() -> Returns the first sound node's current seek position.
     *   seek(id) -> Returns the sound id's current seek position.
     *   seek(seek) -> Sets the seek position of the first sound node.
     *   seek(seek, id) -> Sets the seek position of passed sound id.
     * @return {Howl/Number} Returns self or the current seek position.
     */
    seek: function() {
      var self = this;
      var args = arguments;
      var seek, id;

      // Determine the values based on arguments.
      if (args.length === 0) {
        // We will simply return the current position of the first node.
        if (self._sounds.length) {
          id = self._sounds[0]._id;
        }
      } else if (args.length === 1) {
        // First check if this is an ID, and if not, assume it is a new seek position.
        var ids = self._getSoundIds();
        var index = ids.indexOf(args[0]);
        if (index >= 0) {
          id = parseInt(args[0], 10);
        } else if (self._sounds.length) {
          id = self._sounds[0]._id;
          seek = parseFloat(args[0]);
        }
      } else if (args.length === 2) {
        seek = parseFloat(args[0]);
        id = parseInt(args[1], 10);
      }

      // If there is no ID, bail out.
      if (typeof id === 'undefined') {
        return 0;
      }

      // If the sound hasn't loaded, add it to the load queue to seek when capable.
      if (typeof seek === 'number' && (self._state !== 'loaded' || self._playLock)) {
        self._queue.push({
          event: 'seek',
          action: function() {
            self.seek.apply(self, args);
          }
        });

        return self;
      }

      // Get the sound.
      var sound = self._soundById(id);

      if (sound) {
        if (typeof seek === 'number' && seek >= 0) {
          // Pause the sound and update position for restarting playback.
          var playing = self.playing(id);
          if (playing) {
            self.pause(id, true);
          }

          // Move the position of the track and cancel timer.
          sound._seek = seek;
          sound._ended = false;
          self._clearTimer(id);

          // Update the seek position for HTML5 Audio.
          if (!self._webAudio && sound._node && !isNaN(sound._node.duration)) {
            sound._node.currentTime = seek;
          }

          // Seek and emit when ready.
          var seekAndEmit = function() {
            // Restart the playback if the sound was playing.
            if (playing) {
              self.play(id, true);
            }

            self._emit('seek', id);
          };

          // Wait for the play lock to be unset before emitting (HTML5 Audio).
          if (playing && !self._webAudio) {
            var emitSeek = function() {
              if (!self._playLock) {
                seekAndEmit();
              } else {
                setTimeout(emitSeek, 0);
              }
            };
            setTimeout(emitSeek, 0);
          } else {
            seekAndEmit();
          }
        } else {
          if (self._webAudio) {
            var realTime = self.playing(id) ? Howler.ctx.currentTime - sound._playStart : 0;
            var rateSeek = sound._rateSeek ? sound._rateSeek - sound._seek : 0;
            return sound._seek + (rateSeek + realTime * Math.abs(sound._rate));
          } else {
            return sound._node.currentTime;
          }
        }
      }

      return self;
    },

    /**
     * Check if a specific sound is currently playing or not (if id is provided), or check if at least one of the sounds in the group is playing or not.
     * @param  {Number}  id The sound id to check. If none is passed, the whole sound group is checked.
     * @return {Boolean} True if playing and false if not.
     */
    playing: function(id) {
      var self = this;

      // Check the passed sound ID (if any).
      if (typeof id === 'number') {
        var sound = self._soundById(id);
        return sound ? !sound._paused : false;
      }

      // Otherwise, loop through all sounds and check if any are playing.
      for (var i=0; i<self._sounds.length; i++) {
        if (!self._sounds[i]._paused) {
          return true;
        }
      }

      return false;
    },

    /**
     * Get the duration of this sound. Passing a sound id will return the sprite duration.
     * @param  {Number} id The sound id to check. If none is passed, return full source duration.
     * @return {Number} Audio duration in seconds.
     */
    duration: function(id) {
      var self = this;
      var duration = self._duration;

      // If we pass an ID, get the sound and return the sprite length.
      var sound = self._soundById(id);
      if (sound) {
        duration = self._sprite[sound._sprite][1] / 1000;
      }

      return duration;
    },

    /**
     * Returns the current loaded state of this Howl.
     * @return {String} 'unloaded', 'loading', 'loaded'
     */
    state: function() {
      return this._state;
    },

    /**
     * Unload and destroy the current Howl object.
     * This will immediately stop all sound instances attached to this group.
     */
    unload: function() {
      var self = this;

      // Stop playing any active sounds.
      var sounds = self._sounds;
      for (var i=0; i<sounds.length; i++) {
        // Stop the sound if it is currently playing.
        if (!sounds[i]._paused) {
          self.stop(sounds[i]._id);
        }

        // Remove the source or disconnect.
        if (!self._webAudio) {
          // Set the source to 0-second silence to stop any downloading (except in IE).
          self._clearSound(sounds[i]._node);

          // Remove any event listeners.
          sounds[i]._node.removeEventListener('error', sounds[i]._errorFn, false);
          sounds[i]._node.removeEventListener(Howler._canPlayEvent, sounds[i]._loadFn, false);
          sounds[i]._node.removeEventListener('ended', sounds[i]._endFn, false);

          // Release the Audio object back to the pool.
          Howler._releaseHtml5Audio(sounds[i]._node);
        }

        // Empty out all of the nodes.
        delete sounds[i]._node;

        // Make sure all timers are cleared out.
        self._clearTimer(sounds[i]._id);
      }

      // Remove the references in the global Howler object.
      var index = Howler._howls.indexOf(self);
      if (index >= 0) {
        Howler._howls.splice(index, 1);
      }

      // Delete this sound from the cache (if no other Howl is using it).
      var remCache = true;
      for (i=0; i<Howler._howls.length; i++) {
        if (Howler._howls[i]._src === self._src || self._src.indexOf(Howler._howls[i]._src) >= 0) {
          remCache = false;
          break;
        }
      }

      if (cache && remCache) {
        delete cache[self._src];
      }

      // Clear global errors.
      Howler.noAudio = false;

      // Clear out `self`.
      self._state = 'unloaded';
      self._sounds = [];
      self = null;

      return null;
    },

    /**
     * Listen to a custom event.
     * @param  {String}   event Event name.
     * @param  {Function} fn    Listener to call.
     * @param  {Number}   id    (optional) Only listen to events for this sound.
     * @param  {Number}   once  (INTERNAL) Marks event to fire only once.
     * @return {Howl}
     */
    on: function(event, fn, id, once) {
      var self = this;
      var events = self['_on' + event];

      if (typeof fn === 'function') {
        events.push(once ? {id: id, fn: fn, once: once} : {id: id, fn: fn});
      }

      return self;
    },

    /**
     * Remove a custom event. Call without parameters to remove all events.
     * @param  {String}   event Event name.
     * @param  {Function} fn    Listener to remove. Leave empty to remove all.
     * @param  {Number}   id    (optional) Only remove events for this sound.
     * @return {Howl}
     */
    off: function(event, fn, id) {
      var self = this;
      var events = self['_on' + event];
      var i = 0;

      // Allow passing just an event and ID.
      if (typeof fn === 'number') {
        id = fn;
        fn = null;
      }

      if (fn || id) {
        // Loop through event store and remove the passed function.
        for (i=0; i<events.length; i++) {
          var isId = (id === events[i].id);
          if (fn === events[i].fn && isId || !fn && isId) {
            events.splice(i, 1);
            break;
          }
        }
      } else if (event) {
        // Clear out all events of this type.
        self['_on' + event] = [];
      } else {
        // Clear out all events of every type.
        var keys = Object.keys(self);
        for (i=0; i<keys.length; i++) {
          if ((keys[i].indexOf('_on') === 0) && Array.isArray(self[keys[i]])) {
            self[keys[i]] = [];
          }
        }
      }

      return self;
    },

    /**
     * Listen to a custom event and remove it once fired.
     * @param  {String}   event Event name.
     * @param  {Function} fn    Listener to call.
     * @param  {Number}   id    (optional) Only listen to events for this sound.
     * @return {Howl}
     */
    once: function(event, fn, id) {
      var self = this;

      // Setup the event listener.
      self.on(event, fn, id, 1);

      return self;
    },

    /**
     * Emit all events of a specific type and pass the sound id.
     * @param  {String} event Event name.
     * @param  {Number} id    Sound ID.
     * @param  {Number} msg   Message to go with event.
     * @return {Howl}
     */
    _emit: function(event, id, msg) {
      var self = this;
      var events = self['_on' + event];

      // Loop through event store and fire all functions.
      for (var i=events.length-1; i>=0; i--) {
        // Only fire the listener if the correct ID is used.
        if (!events[i].id || events[i].id === id || event === 'load') {
          setTimeout(function(fn) {
            fn.call(this, id, msg);
          }.bind(self, events[i].fn), 0);

          // If this event was setup with `once`, remove it.
          if (events[i].once) {
            self.off(event, events[i].fn, events[i].id);
          }
        }
      }

      // Pass the event type into load queue so that it can continue stepping.
      self._loadQueue(event);

      return self;
    },

    /**
     * Queue of actions initiated before the sound has loaded.
     * These will be called in sequence, with the next only firing
     * after the previous has finished executing (even if async like play).
     * @return {Howl}
     */
    _loadQueue: function(event) {
      var self = this;

      if (self._queue.length > 0) {
        var task = self._queue[0];

        // Remove this task if a matching event was passed.
        if (task.event === event) {
          self._queue.shift();
          self._loadQueue();
        }

        // Run the task if no event type is passed.
        if (!event) {
          task.action();
        }
      }

      return self;
    },

    /**
     * Fired when playback ends at the end of the duration.
     * @param  {Sound} sound The sound object to work with.
     * @return {Howl}
     */
    _ended: function(sound) {
      var self = this;
      var sprite = sound._sprite;

      // If we are using IE and there was network latency we may be clipping
      // audio before it completes playing. Lets check the node to make sure it
      // believes it has completed, before ending the playback.
      if (!self._webAudio && sound._node && !sound._node.paused && !sound._node.ended && sound._node.currentTime < sound._stop) {
        setTimeout(self._ended.bind(self, sound), 100);
        return self;
      }

      // Should this sound loop?
      var loop = !!(sound._loop || self._sprite[sprite][2]);

      // Fire the ended event.
      self._emit('end', sound._id);

      // Restart the playback for HTML5 Audio loop.
      if (!self._webAudio && loop) {
        self.stop(sound._id, true).play(sound._id);
      }

      // Restart this timer if on a Web Audio loop.
      if (self._webAudio && loop) {
        self._emit('play', sound._id);
        sound._seek = sound._start || 0;
        sound._rateSeek = 0;
        sound._playStart = Howler.ctx.currentTime;

        var timeout = ((sound._stop - sound._start) * 1000) / Math.abs(sound._rate);
        self._endTimers[sound._id] = setTimeout(self._ended.bind(self, sound), timeout);
      }

      // Mark the node as paused.
      if (self._webAudio && !loop) {
        sound._paused = true;
        sound._ended = true;
        sound._seek = sound._start || 0;
        sound._rateSeek = 0;
        self._clearTimer(sound._id);

        // Clean up the buffer source.
        self._cleanBuffer(sound._node);

        // Attempt to auto-suspend AudioContext if no sounds are still playing.
        Howler._autoSuspend();
      }

      // When using a sprite, end the track.
      if (!self._webAudio && !loop) {
        self.stop(sound._id, true);
      }

      return self;
    },

    /**
     * Clear the end timer for a sound playback.
     * @param  {Number} id The sound ID.
     * @return {Howl}
     */
    _clearTimer: function(id) {
      var self = this;

      if (self._endTimers[id]) {
        // Clear the timeout or remove the ended listener.
        if (typeof self._endTimers[id] !== 'function') {
          clearTimeout(self._endTimers[id]);
        } else {
          var sound = self._soundById(id);
          if (sound && sound._node) {
            sound._node.removeEventListener('ended', self._endTimers[id], false);
          }
        }

        delete self._endTimers[id];
      }

      return self;
    },

    /**
     * Return the sound identified by this ID, or return null.
     * @param  {Number} id Sound ID
     * @return {Object}    Sound object or null.
     */
    _soundById: function(id) {
      var self = this;

      // Loop through all sounds and find the one with this ID.
      for (var i=0; i<self._sounds.length; i++) {
        if (id === self._sounds[i]._id) {
          return self._sounds[i];
        }
      }

      return null;
    },

    /**
     * Return an inactive sound from the pool or create a new one.
     * @return {Sound} Sound playback object.
     */
    _inactiveSound: function() {
      var self = this;

      self._drain();

      // Find the first inactive node to recycle.
      for (var i=0; i<self._sounds.length; i++) {
        if (self._sounds[i]._ended) {
          return self._sounds[i].reset();
        }
      }

      // If no inactive node was found, create a new one.
      return new Sound(self);
    },

    /**
     * Drain excess inactive sounds from the pool.
     */
    _drain: function() {
      var self = this;
      var limit = self._pool;
      var cnt = 0;
      var i = 0;

      // If there are less sounds than the max pool size, we are done.
      if (self._sounds.length < limit) {
        return;
      }

      // Count the number of inactive sounds.
      for (i=0; i<self._sounds.length; i++) {
        if (self._sounds[i]._ended) {
          cnt++;
        }
      }

      // Remove excess inactive sounds, going in reverse order.
      for (i=self._sounds.length - 1; i>=0; i--) {
        if (cnt <= limit) {
          return;
        }

        if (self._sounds[i]._ended) {
          // Disconnect the audio source when using Web Audio.
          if (self._webAudio && self._sounds[i]._node) {
            self._sounds[i]._node.disconnect(0);
          }

          // Remove sounds until we have the pool size.
          self._sounds.splice(i, 1);
          cnt--;
        }
      }
    },

    /**
     * Get all ID's from the sounds pool.
     * @param  {Number} id Only return one ID if one is passed.
     * @return {Array}    Array of IDs.
     */
    _getSoundIds: function(id) {
      var self = this;

      if (typeof id === 'undefined') {
        var ids = [];
        for (var i=0; i<self._sounds.length; i++) {
          ids.push(self._sounds[i]._id);
        }

        return ids;
      } else {
        return [id];
      }
    },

    /**
     * Load the sound back into the buffer source.
     * @param  {Sound} sound The sound object to work with.
     * @return {Howl}
     */
    _refreshBuffer: function(sound) {
      var self = this;

      // Setup the buffer source for playback.
      sound._node.bufferSource = Howler.ctx.createBufferSource();
      sound._node.bufferSource.buffer = cache[self._src];

      // Connect to the correct node.
      if (sound._panner) {
        sound._node.bufferSource.connect(sound._panner);
      } else {
        sound._node.bufferSource.connect(sound._node);
      }

      // Setup looping and playback rate.
      sound._node.bufferSource.loop = sound._loop;
      if (sound._loop) {
        sound._node.bufferSource.loopStart = sound._start || 0;
        sound._node.bufferSource.loopEnd = sound._stop || 0;
      }
      sound._node.bufferSource.playbackRate.setValueAtTime(sound._rate, Howler.ctx.currentTime);

      return self;
    },

    /**
     * Prevent memory leaks by cleaning up the buffer source after playback.
     * @param  {Object} node Sound's audio node containing the buffer source.
     * @return {Howl}
     */
    _cleanBuffer: function(node) {
      var self = this;
      var isIOS = Howler._navigator && Howler._navigator.vendor.indexOf('Apple') >= 0;

      if (!node.bufferSource) {
        return self;
      }

      if (Howler._scratchBuffer && node.bufferSource) {
        node.bufferSource.onended = null;
        node.bufferSource.disconnect(0);
        if (isIOS) {
          try { node.bufferSource.buffer = Howler._scratchBuffer; } catch(e) {}
        }
      }
      node.bufferSource = null;

      return self;
    },

    /**
     * Set the source to a 0-second silence to stop any downloading (except in IE).
     * @param  {Object} node Audio node to clear.
     */
    _clearSound: function(node) {
      var checkIE = /MSIE |Trident\//.test(Howler._navigator && Howler._navigator.userAgent);
      if (!checkIE) {
        node.src = 'data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA';
      }
    }
  };

  /** Single Sound Methods **/
  /***************************************************************************/

  /**
   * Setup the sound object, which each node attached to a Howl group is contained in.
   * @param {Object} howl The Howl parent group.
   */
  var Sound = function(howl) {
    this._parent = howl;
    this.init();
  };
  Sound.prototype = {
    /**
     * Initialize a new Sound object.
     * @return {Sound}
     */
    init: function() {
      var self = this;
      var parent = self._parent;

      // Setup the default parameters.
      self._muted = parent._muted;
      self._loop = parent._loop;
      self._volume = parent._volume;
      self._rate = parent._rate;
      self._seek = 0;
      self._paused = true;
      self._ended = true;
      self._sprite = '__default';

      // Generate a unique ID for this sound.
      self._id = ++Howler._counter;

      // Add itself to the parent's pool.
      parent._sounds.push(self);

      // Create the new node.
      self.create();

      return self;
    },

    /**
     * Create and setup a new sound object, whether HTML5 Audio or Web Audio.
     * @return {Sound}
     */
    create: function() {
      var self = this;
      var parent = self._parent;
      var volume = (Howler._muted || self._muted || self._parent._muted) ? 0 : self._volume;

      if (parent._webAudio) {
        // Create the gain node for controlling volume (the source will connect to this).
        self._node = (typeof Howler.ctx.createGain === 'undefined') ? Howler.ctx.createGainNode() : Howler.ctx.createGain();
        self._node.gain.setValueAtTime(volume, Howler.ctx.currentTime);
        self._node.paused = true;
        self._node.connect(Howler.masterGain);
      } else if (!Howler.noAudio) {
        // Get an unlocked Audio object from the pool.
        self._node = Howler._obtainHtml5Audio();

        // Listen for errors (http://dev.w3.org/html5/spec-author-view/spec.html#mediaerror).
        self._errorFn = self._errorListener.bind(self);
        self._node.addEventListener('error', self._errorFn, false);

        // Listen for 'canplaythrough' event to let us know the sound is ready.
        self._loadFn = self._loadListener.bind(self);
        self._node.addEventListener(Howler._canPlayEvent, self._loadFn, false);

        // Listen for the 'ended' event on the sound to account for edge-case where
        // a finite sound has a duration of Infinity.
        self._endFn = self._endListener.bind(self);
        self._node.addEventListener('ended', self._endFn, false);

        // Setup the new audio node.
        self._node.src = parent._src;
        self._node.preload = parent._preload === true ? 'auto' : parent._preload;
        self._node.volume = volume * Howler.volume();

        // Begin loading the source.
        self._node.load();
      }

      return self;
    },

    /**
     * Reset the parameters of this sound to the original state (for recycle).
     * @return {Sound}
     */
    reset: function() {
      var self = this;
      var parent = self._parent;

      // Reset all of the parameters of this sound.
      self._muted = parent._muted;
      self._loop = parent._loop;
      self._volume = parent._volume;
      self._rate = parent._rate;
      self._seek = 0;
      self._rateSeek = 0;
      self._paused = true;
      self._ended = true;
      self._sprite = '__default';

      // Generate a new ID so that it isn't confused with the previous sound.
      self._id = ++Howler._counter;

      return self;
    },

    /**
     * HTML5 Audio error listener callback.
     */
    _errorListener: function() {
      var self = this;

      // Fire an error event and pass back the code.
      self._parent._emit('loaderror', self._id, self._node.error ? self._node.error.code : 0);

      // Clear the event listener.
      self._node.removeEventListener('error', self._errorFn, false);
    },

    /**
     * HTML5 Audio canplaythrough listener callback.
     */
    _loadListener: function() {
      var self = this;
      var parent = self._parent;

      // Round up the duration to account for the lower precision in HTML5 Audio.
      parent._duration = Math.ceil(self._node.duration * 10) / 10;

      // Setup a sprite if none is defined.
      if (Object.keys(parent._sprite).length === 0) {
        parent._sprite = {__default: [0, parent._duration * 1000]};
      }

      if (parent._state !== 'loaded') {
        parent._state = 'loaded';
        parent._emit('load');
        parent._loadQueue();
      }

      // Clear the event listener.
      self._node.removeEventListener(Howler._canPlayEvent, self._loadFn, false);
    },

    /**
     * HTML5 Audio ended listener callback.
     */
    _endListener: function() {
      var self = this;
      var parent = self._parent;

      // Only handle the `ended`` event if the duration is Infinity.
      if (parent._duration === Infinity) {
        // Update the parent duration to match the real audio duration.
        // Round up the duration to account for the lower precision in HTML5 Audio.
        parent._duration = Math.ceil(self._node.duration * 10) / 10;

        // Update the sprite that corresponds to the real duration.
        if (parent._sprite.__default[1] === Infinity) {
          parent._sprite.__default[1] = parent._duration * 1000;
        }

        // Run the regular ended method.
        parent._ended(self);
      }

      // Clear the event listener since the duration is now correct.
      self._node.removeEventListener('ended', self._endFn, false);
    }
  };

  /** Helper Methods **/
  /***************************************************************************/

  var cache = {};

  /**
   * Buffer a sound from URL, Data URI or cache and decode to audio source (Web Audio API).
   * @param  {Howl} self
   */
  var loadBuffer = function(self) {
    var url = self._src;

    // Check if the buffer has already been cached and use it instead.
    if (cache[url]) {
      // Set the duration from the cache.
      self._duration = cache[url].duration;

      // Load the sound into this Howl.
      loadSound(self);

      return;
    }

    if (/^data:[^;]+;base64,/.test(url)) {
      // Decode the base64 data URI without XHR, since some browsers don't support it.
      var data = atob(url.split(',')[1]);
      var dataView = new Uint8Array(data.length);
      for (var i=0; i<data.length; ++i) {
        dataView[i] = data.charCodeAt(i);
      }

      decodeAudioData(dataView.buffer, self);
    } else {
      // Load the buffer from the URL.
      var xhr = new XMLHttpRequest();
      xhr.open(self._xhr.method, url, true);
      xhr.withCredentials = self._xhr.withCredentials;
      xhr.responseType = 'arraybuffer';

      // Apply any custom headers to the request.
      if (self._xhr.headers) {
        Object.keys(self._xhr.headers).forEach(function(key) {
          xhr.setRequestHeader(key, self._xhr.headers[key]);
        });
      }

      xhr.onload = function() {
        // Make sure we get a successful response back.
        var code = (xhr.status + '')[0];
        if (code !== '0' && code !== '2' && code !== '3') {
          self._emit('loaderror', null, 'Failed loading audio file with status: ' + xhr.status + '.');
          return;
        }

        decodeAudioData(xhr.response, self);
      };
      xhr.onerror = function() {
        // If there is an error, switch to HTML5 Audio.
        if (self._webAudio) {
          self._html5 = true;
          self._webAudio = false;
          self._sounds = [];
          delete cache[url];
          self.load();
        }
      };
      safeXhrSend(xhr);
    }
  };

  /**
   * Send the XHR request wrapped in a try/catch.
   * @param  {Object} xhr XHR to send.
   */
  var safeXhrSend = function(xhr) {
    try {
      xhr.send();
    } catch (e) {
      xhr.onerror();
    }
  };

  /**
   * Decode audio data from an array buffer.
   * @param  {ArrayBuffer} arraybuffer The audio data.
   * @param  {Howl}        self
   */
  var decodeAudioData = function(arraybuffer, self) {
    // Fire a load error if something broke.
    var error = function() {
      self._emit('loaderror', null, 'Decoding audio data failed.');
    };

    // Load the sound on success.
    var success = function(buffer) {
      if (buffer && self._sounds.length > 0) {
        cache[self._src] = buffer;
        loadSound(self, buffer);
      } else {
        error();
      }
    };

    // Decode the buffer into an audio source.
    if (typeof Promise !== 'undefined' && Howler.ctx.decodeAudioData.length === 1) {
      Howler.ctx.decodeAudioData(arraybuffer).then(success).catch(error);
    } else {
      Howler.ctx.decodeAudioData(arraybuffer, success, error);
    }
  }

  /**
   * Sound is now loaded, so finish setting everything up and fire the loaded event.
   * @param  {Howl} self
   * @param  {Object} buffer The decoded buffer sound source.
   */
  var loadSound = function(self, buffer) {
    // Set the duration.
    if (buffer && !self._duration) {
      self._duration = buffer.duration;
    }

    // Setup a sprite if none is defined.
    if (Object.keys(self._sprite).length === 0) {
      self._sprite = {__default: [0, self._duration * 1000]};
    }

    // Fire the loaded event.
    if (self._state !== 'loaded') {
      self._state = 'loaded';
      self._emit('load');
      self._loadQueue();
    }
  };

  /**
   * Setup the audio context when available, or switch to HTML5 Audio mode.
   */
  var setupAudioContext = function() {
    // If we have already detected that Web Audio isn't supported, don't run this step again.
    if (!Howler.usingWebAudio) {
      return;
    }

    // Check if we are using Web Audio and setup the AudioContext if we are.
    try {
      if (typeof AudioContext !== 'undefined') {
        Howler.ctx = new AudioContext();
      } else if (typeof webkitAudioContext !== 'undefined') {
        Howler.ctx = new webkitAudioContext();
      } else {
        Howler.usingWebAudio = false;
      }
    } catch(e) {
      Howler.usingWebAudio = false;
    }

    // If the audio context creation still failed, set using web audio to false.
    if (!Howler.ctx) {
      Howler.usingWebAudio = false;
    }

    // Check if a webview is being used on iOS8 or earlier (rather than the browser).
    // If it is, disable Web Audio as it causes crashing.
    var iOS = (/iP(hone|od|ad)/.test(Howler._navigator && Howler._navigator.platform));
    var appVersion = Howler._navigator && Howler._navigator.appVersion.match(/OS (\d+)_(\d+)_?(\d+)?/);
    var version = appVersion ? parseInt(appVersion[1], 10) : null;
    if (iOS && version && version < 9) {
      var safari = /safari/.test(Howler._navigator && Howler._navigator.userAgent.toLowerCase());
      if (Howler._navigator && !safari) {
        Howler.usingWebAudio = false;
      }
    }

    // Create and expose the master GainNode when using Web Audio (useful for plugins or advanced usage).
    if (Howler.usingWebAudio) {
      Howler.masterGain = (typeof Howler.ctx.createGain === 'undefined') ? Howler.ctx.createGainNode() : Howler.ctx.createGain();
      Howler.masterGain.gain.setValueAtTime(Howler._muted ? 0 : Howler._volume, Howler.ctx.currentTime);
      Howler.masterGain.connect(Howler.ctx.destination);
    }

    // Re-run the setup on Howler.
    Howler._setup();
  };

  // Add support for AMD (Asynchronous Module Definition) libraries such as require.js.
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {
      return {
        Howler: Howler,
        Howl: Howl
      };
    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  }

  // Add support for CommonJS libraries such as browserify.
  if (true) {
    exports.Howler = Howler;
    exports.Howl = Howl;
  }

  // Add to global in Node.js (for testing, etc).
  if (typeof __webpack_require__.g !== 'undefined') {
    __webpack_require__.g.HowlerGlobal = HowlerGlobal;
    __webpack_require__.g.Howler = Howler;
    __webpack_require__.g.Howl = Howl;
    __webpack_require__.g.Sound = Sound;
  } else if (typeof window !== 'undefined') {  // Define globally in case AMD is not available or unused.
    window.HowlerGlobal = HowlerGlobal;
    window.Howler = Howler;
    window.Howl = Howl;
    window.Sound = Sound;
  }
})();


/*!
 *  Spatial Plugin - Adds support for stereo and 3D audio where Web Audio is supported.
 *  
 *  howler.js v2.2.4
 *  howlerjs.com
 *
 *  (c) 2013-2020, James Simpson of GoldFire Studios
 *  goldfirestudios.com
 *
 *  MIT License
 */

(function() {

  'use strict';

  // Setup default properties.
  HowlerGlobal.prototype._pos = [0, 0, 0];
  HowlerGlobal.prototype._orientation = [0, 0, -1, 0, 1, 0];

  /** Global Methods **/
  /***************************************************************************/

  /**
   * Helper method to update the stereo panning position of all current Howls.
   * Future Howls will not use this value unless explicitly set.
   * @param  {Number} pan A value of -1.0 is all the way left and 1.0 is all the way right.
   * @return {Howler/Number}     Self or current stereo panning value.
   */
  HowlerGlobal.prototype.stereo = function(pan) {
    var self = this;

    // Stop right here if not using Web Audio.
    if (!self.ctx || !self.ctx.listener) {
      return self;
    }

    // Loop through all Howls and update their stereo panning.
    for (var i=self._howls.length-1; i>=0; i--) {
      self._howls[i].stereo(pan);
    }

    return self;
  };

  /**
   * Get/set the position of the listener in 3D cartesian space. Sounds using
   * 3D position will be relative to the listener's position.
   * @param  {Number} x The x-position of the listener.
   * @param  {Number} y The y-position of the listener.
   * @param  {Number} z The z-position of the listener.
   * @return {Howler/Array}   Self or current listener position.
   */
  HowlerGlobal.prototype.pos = function(x, y, z) {
    var self = this;

    // Stop right here if not using Web Audio.
    if (!self.ctx || !self.ctx.listener) {
      return self;
    }

    // Set the defaults for optional 'y' & 'z'.
    y = (typeof y !== 'number') ? self._pos[1] : y;
    z = (typeof z !== 'number') ? self._pos[2] : z;

    if (typeof x === 'number') {
      self._pos = [x, y, z];

      if (typeof self.ctx.listener.positionX !== 'undefined') {
        self.ctx.listener.positionX.setTargetAtTime(self._pos[0], Howler.ctx.currentTime, 0.1);
        self.ctx.listener.positionY.setTargetAtTime(self._pos[1], Howler.ctx.currentTime, 0.1);
        self.ctx.listener.positionZ.setTargetAtTime(self._pos[2], Howler.ctx.currentTime, 0.1);
      } else {
        self.ctx.listener.setPosition(self._pos[0], self._pos[1], self._pos[2]);
      }
    } else {
      return self._pos;
    }

    return self;
  };

  /**
   * Get/set the direction the listener is pointing in the 3D cartesian space.
   * A front and up vector must be provided. The front is the direction the
   * face of the listener is pointing, and up is the direction the top of the
   * listener is pointing. Thus, these values are expected to be at right angles
   * from each other.
   * @param  {Number} x   The x-orientation of the listener.
   * @param  {Number} y   The y-orientation of the listener.
   * @param  {Number} z   The z-orientation of the listener.
   * @param  {Number} xUp The x-orientation of the top of the listener.
   * @param  {Number} yUp The y-orientation of the top of the listener.
   * @param  {Number} zUp The z-orientation of the top of the listener.
   * @return {Howler/Array}     Returns self or the current orientation vectors.
   */
  HowlerGlobal.prototype.orientation = function(x, y, z, xUp, yUp, zUp) {
    var self = this;

    // Stop right here if not using Web Audio.
    if (!self.ctx || !self.ctx.listener) {
      return self;
    }

    // Set the defaults for optional 'y' & 'z'.
    var or = self._orientation;
    y = (typeof y !== 'number') ? or[1] : y;
    z = (typeof z !== 'number') ? or[2] : z;
    xUp = (typeof xUp !== 'number') ? or[3] : xUp;
    yUp = (typeof yUp !== 'number') ? or[4] : yUp;
    zUp = (typeof zUp !== 'number') ? or[5] : zUp;

    if (typeof x === 'number') {
      self._orientation = [x, y, z, xUp, yUp, zUp];

      if (typeof self.ctx.listener.forwardX !== 'undefined') {
        self.ctx.listener.forwardX.setTargetAtTime(x, Howler.ctx.currentTime, 0.1);
        self.ctx.listener.forwardY.setTargetAtTime(y, Howler.ctx.currentTime, 0.1);
        self.ctx.listener.forwardZ.setTargetAtTime(z, Howler.ctx.currentTime, 0.1);
        self.ctx.listener.upX.setTargetAtTime(xUp, Howler.ctx.currentTime, 0.1);
        self.ctx.listener.upY.setTargetAtTime(yUp, Howler.ctx.currentTime, 0.1);
        self.ctx.listener.upZ.setTargetAtTime(zUp, Howler.ctx.currentTime, 0.1);
      } else {
        self.ctx.listener.setOrientation(x, y, z, xUp, yUp, zUp);
      }
    } else {
      return or;
    }

    return self;
  };

  /** Group Methods **/
  /***************************************************************************/

  /**
   * Add new properties to the core init.
   * @param  {Function} _super Core init method.
   * @return {Howl}
   */
  Howl.prototype.init = (function(_super) {
    return function(o) {
      var self = this;

      // Setup user-defined default properties.
      self._orientation = o.orientation || [1, 0, 0];
      self._stereo = o.stereo || null;
      self._pos = o.pos || null;
      self._pannerAttr = {
        coneInnerAngle: typeof o.coneInnerAngle !== 'undefined' ? o.coneInnerAngle : 360,
        coneOuterAngle: typeof o.coneOuterAngle !== 'undefined' ? o.coneOuterAngle : 360,
        coneOuterGain: typeof o.coneOuterGain !== 'undefined' ? o.coneOuterGain : 0,
        distanceModel: typeof o.distanceModel !== 'undefined' ? o.distanceModel : 'inverse',
        maxDistance: typeof o.maxDistance !== 'undefined' ? o.maxDistance : 10000,
        panningModel: typeof o.panningModel !== 'undefined' ? o.panningModel : 'HRTF',
        refDistance: typeof o.refDistance !== 'undefined' ? o.refDistance : 1,
        rolloffFactor: typeof o.rolloffFactor !== 'undefined' ? o.rolloffFactor : 1
      };

      // Setup event listeners.
      self._onstereo = o.onstereo ? [{fn: o.onstereo}] : [];
      self._onpos = o.onpos ? [{fn: o.onpos}] : [];
      self._onorientation = o.onorientation ? [{fn: o.onorientation}] : [];

      // Complete initilization with howler.js core's init function.
      return _super.call(this, o);
    };
  })(Howl.prototype.init);

  /**
   * Get/set the stereo panning of the audio source for this sound or all in the group.
   * @param  {Number} pan  A value of -1.0 is all the way left and 1.0 is all the way right.
   * @param  {Number} id (optional) The sound ID. If none is passed, all in group will be updated.
   * @return {Howl/Number}    Returns self or the current stereo panning value.
   */
  Howl.prototype.stereo = function(pan, id) {
    var self = this;

    // Stop right here if not using Web Audio.
    if (!self._webAudio) {
      return self;
    }

    // If the sound hasn't loaded, add it to the load queue to change stereo pan when capable.
    if (self._state !== 'loaded') {
      self._queue.push({
        event: 'stereo',
        action: function() {
          self.stereo(pan, id);
        }
      });

      return self;
    }

    // Check for PannerStereoNode support and fallback to PannerNode if it doesn't exist.
    var pannerType = (typeof Howler.ctx.createStereoPanner === 'undefined') ? 'spatial' : 'stereo';

    // Setup the group's stereo panning if no ID is passed.
    if (typeof id === 'undefined') {
      // Return the group's stereo panning if no parameters are passed.
      if (typeof pan === 'number') {
        self._stereo = pan;
        self._pos = [pan, 0, 0];
      } else {
        return self._stereo;
      }
    }

    // Change the streo panning of one or all sounds in group.
    var ids = self._getSoundIds(id);
    for (var i=0; i<ids.length; i++) {
      // Get the sound.
      var sound = self._soundById(ids[i]);

      if (sound) {
        if (typeof pan === 'number') {
          sound._stereo = pan;
          sound._pos = [pan, 0, 0];

          if (sound._node) {
            // If we are falling back, make sure the panningModel is equalpower.
            sound._pannerAttr.panningModel = 'equalpower';

            // Check if there is a panner setup and create a new one if not.
            if (!sound._panner || !sound._panner.pan) {
              setupPanner(sound, pannerType);
            }

            if (pannerType === 'spatial') {
              if (typeof sound._panner.positionX !== 'undefined') {
                sound._panner.positionX.setValueAtTime(pan, Howler.ctx.currentTime);
                sound._panner.positionY.setValueAtTime(0, Howler.ctx.currentTime);
                sound._panner.positionZ.setValueAtTime(0, Howler.ctx.currentTime);
              } else {
                sound._panner.setPosition(pan, 0, 0);
              }
            } else {
              sound._panner.pan.setValueAtTime(pan, Howler.ctx.currentTime);
            }
          }

          self._emit('stereo', sound._id);
        } else {
          return sound._stereo;
        }
      }
    }

    return self;
  };

  /**
   * Get/set the 3D spatial position of the audio source for this sound or group relative to the global listener.
   * @param  {Number} x  The x-position of the audio source.
   * @param  {Number} y  The y-position of the audio source.
   * @param  {Number} z  The z-position of the audio source.
   * @param  {Number} id (optional) The sound ID. If none is passed, all in group will be updated.
   * @return {Howl/Array}    Returns self or the current 3D spatial position: [x, y, z].
   */
  Howl.prototype.pos = function(x, y, z, id) {
    var self = this;

    // Stop right here if not using Web Audio.
    if (!self._webAudio) {
      return self;
    }

    // If the sound hasn't loaded, add it to the load queue to change position when capable.
    if (self._state !== 'loaded') {
      self._queue.push({
        event: 'pos',
        action: function() {
          self.pos(x, y, z, id);
        }
      });

      return self;
    }

    // Set the defaults for optional 'y' & 'z'.
    y = (typeof y !== 'number') ? 0 : y;
    z = (typeof z !== 'number') ? -0.5 : z;

    // Setup the group's spatial position if no ID is passed.
    if (typeof id === 'undefined') {
      // Return the group's spatial position if no parameters are passed.
      if (typeof x === 'number') {
        self._pos = [x, y, z];
      } else {
        return self._pos;
      }
    }

    // Change the spatial position of one or all sounds in group.
    var ids = self._getSoundIds(id);
    for (var i=0; i<ids.length; i++) {
      // Get the sound.
      var sound = self._soundById(ids[i]);

      if (sound) {
        if (typeof x === 'number') {
          sound._pos = [x, y, z];

          if (sound._node) {
            // Check if there is a panner setup and create a new one if not.
            if (!sound._panner || sound._panner.pan) {
              setupPanner(sound, 'spatial');
            }

            if (typeof sound._panner.positionX !== 'undefined') {
              sound._panner.positionX.setValueAtTime(x, Howler.ctx.currentTime);
              sound._panner.positionY.setValueAtTime(y, Howler.ctx.currentTime);
              sound._panner.positionZ.setValueAtTime(z, Howler.ctx.currentTime);
            } else {
              sound._panner.setPosition(x, y, z);
            }
          }

          self._emit('pos', sound._id);
        } else {
          return sound._pos;
        }
      }
    }

    return self;
  };

  /**
   * Get/set the direction the audio source is pointing in the 3D cartesian coordinate
   * space. Depending on how direction the sound is, based on the `cone` attributes,
   * a sound pointing away from the listener can be quiet or silent.
   * @param  {Number} x  The x-orientation of the source.
   * @param  {Number} y  The y-orientation of the source.
   * @param  {Number} z  The z-orientation of the source.
   * @param  {Number} id (optional) The sound ID. If none is passed, all in group will be updated.
   * @return {Howl/Array}    Returns self or the current 3D spatial orientation: [x, y, z].
   */
  Howl.prototype.orientation = function(x, y, z, id) {
    var self = this;

    // Stop right here if not using Web Audio.
    if (!self._webAudio) {
      return self;
    }

    // If the sound hasn't loaded, add it to the load queue to change orientation when capable.
    if (self._state !== 'loaded') {
      self._queue.push({
        event: 'orientation',
        action: function() {
          self.orientation(x, y, z, id);
        }
      });

      return self;
    }

    // Set the defaults for optional 'y' & 'z'.
    y = (typeof y !== 'number') ? self._orientation[1] : y;
    z = (typeof z !== 'number') ? self._orientation[2] : z;

    // Setup the group's spatial orientation if no ID is passed.
    if (typeof id === 'undefined') {
      // Return the group's spatial orientation if no parameters are passed.
      if (typeof x === 'number') {
        self._orientation = [x, y, z];
      } else {
        return self._orientation;
      }
    }

    // Change the spatial orientation of one or all sounds in group.
    var ids = self._getSoundIds(id);
    for (var i=0; i<ids.length; i++) {
      // Get the sound.
      var sound = self._soundById(ids[i]);

      if (sound) {
        if (typeof x === 'number') {
          sound._orientation = [x, y, z];

          if (sound._node) {
            // Check if there is a panner setup and create a new one if not.
            if (!sound._panner) {
              // Make sure we have a position to setup the node with.
              if (!sound._pos) {
                sound._pos = self._pos || [0, 0, -0.5];
              }

              setupPanner(sound, 'spatial');
            }

            if (typeof sound._panner.orientationX !== 'undefined') {
              sound._panner.orientationX.setValueAtTime(x, Howler.ctx.currentTime);
              sound._panner.orientationY.setValueAtTime(y, Howler.ctx.currentTime);
              sound._panner.orientationZ.setValueAtTime(z, Howler.ctx.currentTime);
            } else {
              sound._panner.setOrientation(x, y, z);
            }
          }

          self._emit('orientation', sound._id);
        } else {
          return sound._orientation;
        }
      }
    }

    return self;
  };

  /**
   * Get/set the panner node's attributes for a sound or group of sounds.
   * This method can optionall take 0, 1 or 2 arguments.
   *   pannerAttr() -> Returns the group's values.
   *   pannerAttr(id) -> Returns the sound id's values.
   *   pannerAttr(o) -> Set's the values of all sounds in this Howl group.
   *   pannerAttr(o, id) -> Set's the values of passed sound id.
   *
   *   Attributes:
   *     coneInnerAngle - (360 by default) A parameter for directional audio sources, this is an angle, in degrees,
   *                      inside of which there will be no volume reduction.
   *     coneOuterAngle - (360 by default) A parameter for directional audio sources, this is an angle, in degrees,
   *                      outside of which the volume will be reduced to a constant value of `coneOuterGain`.
   *     coneOuterGain - (0 by default) A parameter for directional audio sources, this is the gain outside of the
   *                     `coneOuterAngle`. It is a linear value in the range `[0, 1]`.
   *     distanceModel - ('inverse' by default) Determines algorithm used to reduce volume as audio moves away from
   *                     listener. Can be `linear`, `inverse` or `exponential.
   *     maxDistance - (10000 by default) The maximum distance between source and listener, after which the volume
   *                   will not be reduced any further.
   *     refDistance - (1 by default) A reference distance for reducing volume as source moves further from the listener.
   *                   This is simply a variable of the distance model and has a different effect depending on which model
   *                   is used and the scale of your coordinates. Generally, volume will be equal to 1 at this distance.
   *     rolloffFactor - (1 by default) How quickly the volume reduces as source moves from listener. This is simply a
   *                     variable of the distance model and can be in the range of `[0, 1]` with `linear` and `[0, ∞]`
   *                     with `inverse` and `exponential`.
   *     panningModel - ('HRTF' by default) Determines which spatialization algorithm is used to position audio.
   *                     Can be `HRTF` or `equalpower`.
   *
   * @return {Howl/Object} Returns self or current panner attributes.
   */
  Howl.prototype.pannerAttr = function() {
    var self = this;
    var args = arguments;
    var o, id, sound;

    // Stop right here if not using Web Audio.
    if (!self._webAudio) {
      return self;
    }

    // Determine the values based on arguments.
    if (args.length === 0) {
      // Return the group's panner attribute values.
      return self._pannerAttr;
    } else if (args.length === 1) {
      if (typeof args[0] === 'object') {
        o = args[0];

        // Set the grou's panner attribute values.
        if (typeof id === 'undefined') {
          if (!o.pannerAttr) {
            o.pannerAttr = {
              coneInnerAngle: o.coneInnerAngle,
              coneOuterAngle: o.coneOuterAngle,
              coneOuterGain: o.coneOuterGain,
              distanceModel: o.distanceModel,
              maxDistance: o.maxDistance,
              refDistance: o.refDistance,
              rolloffFactor: o.rolloffFactor,
              panningModel: o.panningModel
            };
          }

          self._pannerAttr = {
            coneInnerAngle: typeof o.pannerAttr.coneInnerAngle !== 'undefined' ? o.pannerAttr.coneInnerAngle : self._coneInnerAngle,
            coneOuterAngle: typeof o.pannerAttr.coneOuterAngle !== 'undefined' ? o.pannerAttr.coneOuterAngle : self._coneOuterAngle,
            coneOuterGain: typeof o.pannerAttr.coneOuterGain !== 'undefined' ? o.pannerAttr.coneOuterGain : self._coneOuterGain,
            distanceModel: typeof o.pannerAttr.distanceModel !== 'undefined' ? o.pannerAttr.distanceModel : self._distanceModel,
            maxDistance: typeof o.pannerAttr.maxDistance !== 'undefined' ? o.pannerAttr.maxDistance : self._maxDistance,
            refDistance: typeof o.pannerAttr.refDistance !== 'undefined' ? o.pannerAttr.refDistance : self._refDistance,
            rolloffFactor: typeof o.pannerAttr.rolloffFactor !== 'undefined' ? o.pannerAttr.rolloffFactor : self._rolloffFactor,
            panningModel: typeof o.pannerAttr.panningModel !== 'undefined' ? o.pannerAttr.panningModel : self._panningModel
          };
        }
      } else {
        // Return this sound's panner attribute values.
        sound = self._soundById(parseInt(args[0], 10));
        return sound ? sound._pannerAttr : self._pannerAttr;
      }
    } else if (args.length === 2) {
      o = args[0];
      id = parseInt(args[1], 10);
    }

    // Update the values of the specified sounds.
    var ids = self._getSoundIds(id);
    for (var i=0; i<ids.length; i++) {
      sound = self._soundById(ids[i]);

      if (sound) {
        // Merge the new values into the sound.
        var pa = sound._pannerAttr;
        pa = {
          coneInnerAngle: typeof o.coneInnerAngle !== 'undefined' ? o.coneInnerAngle : pa.coneInnerAngle,
          coneOuterAngle: typeof o.coneOuterAngle !== 'undefined' ? o.coneOuterAngle : pa.coneOuterAngle,
          coneOuterGain: typeof o.coneOuterGain !== 'undefined' ? o.coneOuterGain : pa.coneOuterGain,
          distanceModel: typeof o.distanceModel !== 'undefined' ? o.distanceModel : pa.distanceModel,
          maxDistance: typeof o.maxDistance !== 'undefined' ? o.maxDistance : pa.maxDistance,
          refDistance: typeof o.refDistance !== 'undefined' ? o.refDistance : pa.refDistance,
          rolloffFactor: typeof o.rolloffFactor !== 'undefined' ? o.rolloffFactor : pa.rolloffFactor,
          panningModel: typeof o.panningModel !== 'undefined' ? o.panningModel : pa.panningModel
        };

        // Create a new panner node if one doesn't already exist.
        var panner = sound._panner;
        if (!panner) {
          // Make sure we have a position to setup the node with.
          if (!sound._pos) {
            sound._pos = self._pos || [0, 0, -0.5];
          }

          // Create a new panner node.
          setupPanner(sound, 'spatial');
          panner = sound._panner
        }

        // Update the panner values or create a new panner if none exists.
        panner.coneInnerAngle = pa.coneInnerAngle;
        panner.coneOuterAngle = pa.coneOuterAngle;
        panner.coneOuterGain = pa.coneOuterGain;
        panner.distanceModel = pa.distanceModel;
        panner.maxDistance = pa.maxDistance;
        panner.refDistance = pa.refDistance;
        panner.rolloffFactor = pa.rolloffFactor;
        panner.panningModel = pa.panningModel;
      }
    }

    return self;
  };

  /** Single Sound Methods **/
  /***************************************************************************/

  /**
   * Add new properties to the core Sound init.
   * @param  {Function} _super Core Sound init method.
   * @return {Sound}
   */
  Sound.prototype.init = (function(_super) {
    return function() {
      var self = this;
      var parent = self._parent;

      // Setup user-defined default properties.
      self._orientation = parent._orientation;
      self._stereo = parent._stereo;
      self._pos = parent._pos;
      self._pannerAttr = parent._pannerAttr;

      // Complete initilization with howler.js core Sound's init function.
      _super.call(this);

      // If a stereo or position was specified, set it up.
      if (self._stereo) {
        parent.stereo(self._stereo);
      } else if (self._pos) {
        parent.pos(self._pos[0], self._pos[1], self._pos[2], self._id);
      }
    };
  })(Sound.prototype.init);

  /**
   * Override the Sound.reset method to clean up properties from the spatial plugin.
   * @param  {Function} _super Sound reset method.
   * @return {Sound}
   */
  Sound.prototype.reset = (function(_super) {
    return function() {
      var self = this;
      var parent = self._parent;

      // Reset all spatial plugin properties on this sound.
      self._orientation = parent._orientation;
      self._stereo = parent._stereo;
      self._pos = parent._pos;
      self._pannerAttr = parent._pannerAttr;

      // If a stereo or position was specified, set it up.
      if (self._stereo) {
        parent.stereo(self._stereo);
      } else if (self._pos) {
        parent.pos(self._pos[0], self._pos[1], self._pos[2], self._id);
      } else if (self._panner) {
        // Disconnect the panner.
        self._panner.disconnect(0);
        self._panner = undefined;
        parent._refreshBuffer(self);
      }

      // Complete resetting of the sound.
      return _super.call(this);
    };
  })(Sound.prototype.reset);

  /** Helper Methods **/
  /***************************************************************************/

  /**
   * Create a new panner node and save it on the sound.
   * @param  {Sound} sound Specific sound to setup panning on.
   * @param {String} type Type of panner to create: 'stereo' or 'spatial'.
   */
  var setupPanner = function(sound, type) {
    type = type || 'spatial';

    // Create the new panner node.
    if (type === 'spatial') {
      sound._panner = Howler.ctx.createPanner();
      sound._panner.coneInnerAngle = sound._pannerAttr.coneInnerAngle;
      sound._panner.coneOuterAngle = sound._pannerAttr.coneOuterAngle;
      sound._panner.coneOuterGain = sound._pannerAttr.coneOuterGain;
      sound._panner.distanceModel = sound._pannerAttr.distanceModel;
      sound._panner.maxDistance = sound._pannerAttr.maxDistance;
      sound._panner.refDistance = sound._pannerAttr.refDistance;
      sound._panner.rolloffFactor = sound._pannerAttr.rolloffFactor;
      sound._panner.panningModel = sound._pannerAttr.panningModel;

      if (typeof sound._panner.positionX !== 'undefined') {
        sound._panner.positionX.setValueAtTime(sound._pos[0], Howler.ctx.currentTime);
        sound._panner.positionY.setValueAtTime(sound._pos[1], Howler.ctx.currentTime);
        sound._panner.positionZ.setValueAtTime(sound._pos[2], Howler.ctx.currentTime);
      } else {
        sound._panner.setPosition(sound._pos[0], sound._pos[1], sound._pos[2]);
      }

      if (typeof sound._panner.orientationX !== 'undefined') {
        sound._panner.orientationX.setValueAtTime(sound._orientation[0], Howler.ctx.currentTime);
        sound._panner.orientationY.setValueAtTime(sound._orientation[1], Howler.ctx.currentTime);
        sound._panner.orientationZ.setValueAtTime(sound._orientation[2], Howler.ctx.currentTime);
      } else {
        sound._panner.setOrientation(sound._orientation[0], sound._orientation[1], sound._orientation[2]);
      }
    } else {
      sound._panner = Howler.ctx.createStereoPanner();
      sound._panner.pan.setValueAtTime(sound._stereo, Howler.ctx.currentTime);
    }

    sound._panner.connect(sound._node);

    // Update the connections.
    if (!sound._paused) {
      sound._parent.pause(sound._id, true).play(sound._id, true);
    }
  };
})();


/***/ }),

/***/ "./src/constants/environmentTypes.ts":
/*!*******************************************!*\
  !*** ./src/constants/environmentTypes.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EnvType = void 0;
var EnvType;
(function (EnvType) {
    EnvType[EnvType["DUNGEON"] = 0] = "DUNGEON";
    EnvType[EnvType["CAVE"] = 1] = "CAVE";
    EnvType[EnvType["FOREST"] = 2] = "FOREST";
    EnvType[EnvType["SWAMP"] = 3] = "SWAMP";
    EnvType[EnvType["GLACIER"] = 4] = "GLACIER";
    EnvType[EnvType["CASTLE"] = 5] = "CASTLE";
})(EnvType = exports.EnvType || (exports.EnvType = {}));


/***/ }),

/***/ "./src/drawable/drawable.ts":
/*!**********************************!*\
  !*** ./src/drawable/drawable.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Drawable = void 0;
class Drawable {
    constructor() {
        this.drawableY = 0;
        this.draw = (delta) => { };
        this.hasBloom = false;
        this.bloomColor = "#FFFFFF";
        this.bloomAlpha = 1;
        this.softBloomAlpha = 0;
        this.updateBloom = (delta) => {
            if (this.hasBloom) {
                let diff = this.softBloomAlpha - this.bloomAlpha;
                if (Math.abs(diff) > 0.001) {
                    this.softBloomAlpha = this.softBloomAlpha - diff * 0.1 * delta;
                }
                else {
                    this.softBloomAlpha = this.bloomAlpha;
                }
            }
            else {
                this.softBloomAlpha = 0;
            }
        };
    }
}
exports.Drawable = Drawable;


/***/ }),

/***/ "./src/drawable/healthbar.ts":
/*!***********************************!*\
  !*** ./src/drawable/healthbar.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HealthBar = void 0;
const game_1 = __webpack_require__(/*! ../game */ "./src/game.ts");
const levelConstants_1 = __webpack_require__(/*! ../level/levelConstants */ "./src/level/levelConstants.ts");
class HealthBar {
    constructor() {
        this.hurt = () => {
            this.hurtTimer = Date.now();
        };
        this.draw = (delta, hearts, maxHearts, x, y, flashing) => {
            let t = Date.now() - this.hurtTimer;
            if (t <= levelConstants_1.LevelConstants.HEALTH_BAR_TOTALTIME) {
                let fullHearts = Math.floor(hearts);
                let halfHearts = Math.ceil(hearts - fullHearts);
                let emptyHearts = maxHearts - fullHearts - halfHearts;
                // I wouldn't normally use magic numbers here, but these are hardcoded based on the tileset
                //   (which isn't really parameterizable)
                let drawWidth = Math.round(Math.min(9, Math.min(0.05 * (levelConstants_1.LevelConstants.HEALTH_BAR_TOTALTIME - t), 0.05 * t)));
                let drawHeight = Math.round(Math.min(0.5, Math.min(0.003 * (levelConstants_1.LevelConstants.HEALTH_BAR_TOTALTIME - t), 0.003 * t)) * 16) / 16.0;
                let width = (drawWidth * (maxHearts - 1) + 8) / 16.0;
                let xxStart = 0.5 + -width / 2;
                for (let i = 0; i < Math.ceil(0.5 * maxHearts); i++) {
                    let tileX = 0;
                    if (!flashing)
                        tileX = 1.5;
                    else if (i < fullHearts)
                        tileX = 0;
                    else if (i < fullHearts + halfHearts)
                        tileX = 0.5;
                    else
                        tileX = 1;
                    let xx = (drawWidth * i) / 16.0 + xxStart;
                    game_1.Game.drawFX(tileX, 8, 0.5, 0.5, x + xx, y - 1 - drawHeight / 2, 0.5, drawHeight);
                    xx += 9.0 / 16.0;
                    let j = maxHearts - i - 1;
                    if (j !== i) {
                        let tileX = 0;
                        if (!flashing)
                            tileX = 1.5;
                        else if (j < fullHearts)
                            tileX = 0;
                        else if (j < fullHearts + halfHearts)
                            tileX = 0.5;
                        else
                            tileX = 1;
                        let xx = (drawWidth * j) / 16.0 + xxStart;
                        game_1.Game.drawFX(tileX, 8, 0.5, 0.5, x + xx, y - 1 - drawHeight / 2, 0.5, drawHeight);
                        xx += 9.0 / 16.0;
                    }
                }
            }
        };
        this.hurtTimer = 0;
    }
}
exports.HealthBar = HealthBar;


/***/ }),

/***/ "./src/drawable/hitWarning.ts":
/*!************************************!*\
  !*** ./src/drawable/hitWarning.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HitWarning = void 0;
const game_1 = __webpack_require__(/*! ../game */ "./src/game.ts");
const drawable_1 = __webpack_require__(/*! ./drawable */ "./src/drawable/drawable.ts");
const utils_1 = __webpack_require__(/*! ../utility/utils */ "./src/utility/utils.ts");
var Direction;
(function (Direction) {
    Direction[Direction["North"] = 0] = "North";
    Direction[Direction["NorthEast"] = 1] = "NorthEast";
    Direction[Direction["East"] = 2] = "East";
    Direction[Direction["SouthEast"] = 3] = "SouthEast";
    Direction[Direction["South"] = 4] = "South";
    Direction[Direction["SouthWest"] = 5] = "SouthWest";
    Direction[Direction["West"] = 6] = "West";
    Direction[Direction["NorthWest"] = 7] = "NorthWest";
    Direction[Direction["Center"] = 8] = "Center";
})(Direction || (Direction = {}));
class HitWarning extends drawable_1.Drawable {
    constructor(game, x, y, eX, eY, isEnemy, dirOnly = false, parent = null) {
        super();
        this.parent = null;
        this._pointerDir = null;
        this._pointerOffset = null;
        this.alpha = 0;
        this.tickedForDeath = false;
        this.tick = () => {
            if (this.tickedForDeath)
                this.dead = true;
            this.tickedForDeath = true;
        };
        this.removeOverlapping = () => {
            for (const entity of this.game.room.entities) {
                if (entity.x === this.x &&
                    entity.y === this.y &&
                    entity.pushable === false) {
                    this.dead = true;
                    break;
                }
            }
            for (const door of this.game.room.doors) {
                if (door.x === this.x && door.y === this.y) {
                    this.dead = true;
                    break;
                }
            }
        };
        this.fadeHitwarnings = (delta) => {
            if (!this.tickedForDeath) {
                if (this.alpha < 1)
                    this.alpha += 0.03 * delta;
                if (this.alpha > 1)
                    this.alpha = 1;
            }
            else {
                if (this.alpha > 0)
                    this.alpha -= 0.03 * delta;
                if (this.alpha < 0)
                    this.alpha = 0;
            }
        };
        this.draw = (delta) => {
            this.fadeHitwarnings(delta);
            if (Math.abs(this.x - this.game.players[this.game.localPlayerID].x) <= 1 &&
                Math.abs(this.y - this.game.players[this.game.localPlayerID].y) <= 1) {
                game_1.Game.ctx.globalAlpha = this.alpha;
                if (this.isEnemy &&
                    utils_1.Utils.distance(this.x, this.y, this.game.players[this.game.localPlayerID].x, this.game.players[this.game.localPlayerID].y) <= 1) {
                    // Red Arrow that only renders one square away
                    game_1.Game.drawFX(this.tileX + Math.floor(HitWarning.frame), this.tileY, 1, 1, this.x + this.pointerOffset.x, this.y + this.pointerOffset.y - this.offsetY, 1, 1);
                }
                if (false) {}
                game_1.Game.ctx.globalAlpha = 1;
            }
        };
        this.drawTopLayer = (delta) => {
            this.fadeHitwarnings(delta);
            game_1.Game.ctx.globalAlpha = this.alpha;
            if (this.isEnemy && this.getPointerDir() !== Direction.North) {
                //white arrow top layer
                game_1.Game.drawFX(this.tileX + Math.floor(HitWarning.frame), this.tileY + 1, 1, 1, this.x + this.pointerOffset.x, this.y + this.pointerOffset.y - this.offsetY, 1, 1);
            }
            if (utils_1.Utils.distance(this.x, this.y, this.game.players[this.game.localPlayerID].x, this.game.players[this.game.localPlayerID].y) <= 1) {
                if (!this.dirOnly) {
                    // Red X that renders 1 square away for top layer
                    game_1.Game.drawFX(18 + Math.floor(HitWarning.frame), 6, 1, 1, this.x, this.y - this.offsetY + 0, 1, 1);
                }
            }
            game_1.Game.ctx.globalAlpha = 1;
        };
        this.x = x;
        this.y = y;
        this.dead = false;
        this.game = game;
        this.parent = parent;
        this.tileX = 0;
        this.tileY = 22;
        this.eX = eX;
        this.eY = eY;
        this.offsetY = 0.2;
        this.dirOnly = dirOnly;
        this.isEnemy = isEnemy !== undefined ? isEnemy : true;
        this.pointerOffset = this.getPointerOffset();
        this.removeOverlapping();
    }
    getPointerDir() {
        if (this._pointerDir === null) {
            const dx = this.eX - this.x;
            const dy = this.eY - this.y;
            if (dx === 0 && dy === 0) {
                this._pointerDir = Direction.Center;
            }
            else if (dx === 0) {
                this._pointerDir = dy < 0 ? Direction.South : Direction.North;
            }
            else if (dy === 0) {
                this._pointerDir = dx < 0 ? Direction.East : Direction.West;
            }
            else if (dx < 0) {
                this._pointerDir = dy < 0 ? Direction.SouthEast : Direction.NorthEast;
            }
            else {
                this._pointerDir = dy < 0 ? Direction.SouthWest : Direction.NorthWest;
            }
            this.tileX = 0 + 2 * this._pointerDir;
        }
        return this._pointerDir;
    }
    getPointerOffset() {
        if (this._pointerOffset === null) {
            const offsets = {
                [Direction.North]: { x: 0, y: 0.5 },
                [Direction.South]: { x: 0, y: -0.6 },
                [Direction.West]: { x: 0.6, y: 0 },
                [Direction.East]: { x: -0.6, y: 0 },
                [Direction.NorthEast]: { x: -0.5, y: 0.5 },
                [Direction.NorthWest]: { x: 0.5, y: 0.5 },
                [Direction.SouthEast]: { x: -0.5, y: -0.5 },
                [Direction.SouthWest]: { x: 0.5, y: -0.5 },
                [Direction.Center]: { x: 0, y: -0.25 },
            };
            this._pointerOffset = offsets[this.getPointerDir()];
        }
        return this._pointerOffset;
    }
}
exports.HitWarning = HitWarning;
HitWarning.frame = 0;
HitWarning.updateFrame = (delta) => {
    HitWarning.frame += 0.125 * delta;
    if (HitWarning.frame >= 2)
        HitWarning.frame = 0;
};


/***/ }),

/***/ "./src/entity/downladderMaker.ts":
/*!***************************************!*\
  !*** ./src/entity/downladderMaker.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DownladderMaker = void 0;
const entity_1 = __webpack_require__(/*! ./entity */ "./src/entity/entity.ts");
const downLadder_1 = __webpack_require__(/*! ../tile/downLadder */ "./src/tile/downLadder.ts");
const lockable_1 = __webpack_require__(/*! ../tile/lockable */ "./src/tile/lockable.ts");
const environmentTypes_1 = __webpack_require__(/*! ../constants/environmentTypes */ "./src/constants/environmentTypes.ts");
const random_1 = __webpack_require__(/*! ../utility/random */ "./src/utility/random.ts");
class DownladderMaker extends entity_1.Entity {
    constructor(room, game, x, y) {
        super(room, game, x, y);
        this.createDownladder = () => {
            let environment = this.room.depth < 1 ? environmentTypes_1.EnvType.FOREST : environmentTypes_1.EnvType.CAVE;
            if (this.room.depth > 1) {
                environment = random_1.Random.rand() < 0.5 ? environmentTypes_1.EnvType.FOREST : environmentTypes_1.EnvType.CAVE;
            }
            const newTile = new downLadder_1.DownLadder(this.room, this.game, this.x, this.y, true, environment, lockable_1.LockType.NONE);
            this.room.roomArray[this.x][this.y] = newTile;
        };
        this.draw = (delta) => { };
        this.drawTopLayer = (delta) => { };
        this.room = room;
        if (this.room.level.environment.type === environmentTypes_1.EnvType.DUNGEON)
            this.createDownladder();
        this.name = "DownladderMaker";
        this.dead = true;
    }
}
exports.DownladderMaker = DownladderMaker;


/***/ }),

/***/ "./src/entity/enemy/armoredSkullEnemy.ts":
/*!***********************************************!*\
  !*** ./src/entity/enemy/armoredSkullEnemy.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ArmoredSkullEnemy = void 0;
const game_1 = __webpack_require__(/*! ../../game */ "./src/game.ts");
const astarclass_1 = __webpack_require__(/*! ../../utility/astarclass */ "./src/utility/astarclass.ts");
const spiketrap_1 = __webpack_require__(/*! ../../tile/spiketrap */ "./src/tile/spiketrap.ts");
const imageParticle_1 = __webpack_require__(/*! ../../particle/imageParticle */ "./src/particle/imageParticle.ts");
const enemy_1 = __webpack_require__(/*! ./enemy */ "./src/entity/enemy/enemy.ts");
const sound_1 = __webpack_require__(/*! ../../sound/sound */ "./src/sound/sound.ts");
class ArmoredSkullEnemy extends enemy_1.Enemy {
    constructor(room, game, x, y, drop) {
        super(room, game, x, y);
        this.REGEN_TICKS = 5;
        this.hit = () => {
            return 1;
        };
        this.hurt = (playerHitBy, damage, type = "none") => {
            this.handleEnemyCase(playerHitBy);
            let hitShield = false;
            let shieldHealth = 0;
            if (this.shielded) {
                shieldHealth = this.shield.health;
                if (shieldHealth > 0) {
                    this.shield.hurt(damage);
                    hitShield = true;
                }
            }
            this.ticksSinceFirstHit = 0;
            if (this.health == 2)
                this.unconscious = false;
            this.health -= damage;
            this.maxHealth -= shieldHealth;
            this.startHurting();
            this.healthBar.hurt();
            this.createDamageNumber(damage, type);
            this.playHitSound();
            if (this.health === 2)
                sound_1.Sound.playParry();
            if (this.health === 1) {
                this.unconscious = true;
                imageParticle_1.ImageParticle.spawnCluster(this.room, this.x + 0.5, this.y + 0.5, 3, 28);
            }
            else if (this.health === 2) {
                imageParticle_1.ImageParticle.spawnCluster(this.room, this.x + 0.5, this.y + 0.5, 6, 26);
            }
            else
                this.healthBar.hurt();
            if (this.health <= 0) {
                imageParticle_1.ImageParticle.spawnCluster(this.room, this.x + 0.5, this.y + 0.5, 0, 24);
                this.kill();
            }
            else
                this.hurtCallback();
        };
        this.behavior = () => {
            this.lastX = this.x;
            this.lastY = this.y;
            if (!this.dead) {
                if (this.skipNextTurns > 0) {
                    this.skipNextTurns--;
                    this.ticks++;
                    return;
                }
                if (this.health <= 1) {
                    this.unconscious = true;
                    this.ticksSinceFirstHit++;
                    if (this.ticksSinceFirstHit >= this.REGEN_TICKS) {
                        this.healthBar.hurt();
                        this.health = 2;
                        this.unconscious = false;
                    }
                    this.ticks++;
                    return;
                }
                this.ticks++;
                if (!this.seenPlayer) {
                    this.lookForPlayer();
                }
                else if (this.seenPlayer) {
                    if (this.room.playerTicked === this.targetPlayer) {
                        this.alertTicks = Math.max(0, this.alertTicks - 1);
                        let oldX = this.x;
                        let oldY = this.y;
                        let disablePositions = Array();
                        for (const e of this.room.entities) {
                            if (e !== this) {
                                disablePositions.push({ x: e.x, y: e.y });
                            }
                        }
                        for (let xx = this.x - 1; xx <= this.x + 1; xx++) {
                            for (let yy = this.y - 1; yy <= this.y + 1; yy++) {
                                if (this.room.roomArray[xx][yy] instanceof spiketrap_1.SpikeTrap &&
                                    this.room.roomArray[xx][yy].on) {
                                    disablePositions.push({ x: xx, y: yy });
                                }
                            }
                        }
                        let grid = [];
                        for (let x = 0; x < this.room.roomX + this.room.width; x++) {
                            grid[x] = [];
                            for (let y = 0; y < this.room.roomY + this.room.height; y++) {
                                if (this.room.roomArray[x] && this.room.roomArray[x][y])
                                    grid[x][y] = this.room.roomArray[x][y];
                                else
                                    grid[x][y] = false;
                            }
                        }
                        let moves = astarclass_1.astar.AStar.search(grid, this, this.targetPlayer, disablePositions, false, false, true, this.direction, undefined, undefined);
                        if (moves.length > 0) {
                            let moveX = moves[0].pos.x;
                            let moveY = moves[0].pos.y;
                            let oldDir = this.direction;
                            let player = this.targetPlayer;
                            this.facePlayer(player);
                            if (moveX > oldX)
                                this.direction = game_1.Direction.RIGHT;
                            else if (moveX < oldX)
                                this.direction = game_1.Direction.LEFT;
                            else if (moveY > oldY)
                                this.direction = game_1.Direction.DOWN;
                            else if (moveY < oldY)
                                this.direction = game_1.Direction.UP;
                            if (oldDir == this.direction) {
                                let hitPlayer = false;
                                for (const i in this.game.players) {
                                    if (this.game.rooms[this.game.players[i].levelID] === this.room &&
                                        this.game.players[i].x === moveX &&
                                        this.game.players[i].y === moveY) {
                                        this.game.players[i].hurt(this.hit(), this.name);
                                        this.drawX = 0.5 * (this.x - this.game.players[i].x);
                                        this.drawY = 0.5 * (this.y - this.game.players[i].y);
                                        if (this.game.players[i] ===
                                            this.game.players[this.game.localPlayerID])
                                            this.game.shakeScreen(10 * this.drawX, 10 * this.drawY);
                                    }
                                }
                                if (!hitPlayer) {
                                    this.tryMove(moveX, moveY);
                                    this.setDrawXY(oldX, oldY);
                                    if (this.x > oldX)
                                        this.direction = game_1.Direction.RIGHT;
                                    else if (this.x < oldX)
                                        this.direction = game_1.Direction.LEFT;
                                    else if (this.y > oldY)
                                        this.direction = game_1.Direction.DOWN;
                                    else if (this.y < oldY)
                                        this.direction = game_1.Direction.UP;
                                }
                            }
                        }
                        if (this.direction == game_1.Direction.LEFT) {
                            disablePositions.push({
                                x: this.x,
                                y: this.y + 1,
                            });
                            disablePositions.push({
                                x: this.x,
                                y: this.y - 1,
                            });
                        }
                        if (this.direction == game_1.Direction.RIGHT) {
                            disablePositions.push({
                                x: this.x,
                                y: this.y + 1,
                            });
                            disablePositions.push({
                                x: this.x,
                                y: this.y - 1,
                            });
                        }
                        if (this.direction == game_1.Direction.DOWN) {
                            disablePositions.push({
                                x: this.x + 1,
                                y: this.y,
                            });
                            disablePositions.push({
                                x: this.x - 1,
                                y: this.y,
                            });
                        }
                        if (this.direction == game_1.Direction.UP) {
                            disablePositions.push({
                                x: this.x + 1,
                                y: this.y,
                            });
                            disablePositions.push({
                                x: this.x - 1,
                                y: this.y,
                            });
                        }
                        this.makeHitWarnings();
                    }
                    let targetPlayerOffline = Object.values(this.game.offlinePlayers).indexOf(this.targetPlayer) !==
                        -1;
                    if (!this.aggro || targetPlayerOffline) {
                        let p = this.nearestPlayer();
                        if (p !== false) {
                            let [distance, player] = p;
                            if (distance <= 4 &&
                                (targetPlayerOffline ||
                                    distance < this.playerDistance(this.targetPlayer))) {
                                if (player !== this.targetPlayer) {
                                    this.targetPlayer = player;
                                    this.facePlayer(player);
                                    if (player === this.game.players[this.game.localPlayerID])
                                        this.alertTicks = 1;
                                    this.makeHitWarnings();
                                }
                            }
                        }
                    }
                }
            }
        };
        this.draw = (delta) => {
            if (this.dead)
                return;
            game_1.Game.ctx.save();
            game_1.Game.ctx.globalAlpha = this.alpha;
            if (!this.dead) {
                this.updateDrawXY(delta);
                this.tileX = 27;
                this.tileY = 16;
                if (this.health <= 2) {
                    this.tileX = 5;
                    this.tileY = 8;
                }
                if (this.health <= 1 || this.dying) {
                    this.tileX = 3;
                    this.tileY = 0;
                    if (this.ticksSinceFirstHit >= 3) {
                        this.flashingFrame += 0.1 * delta;
                        if (Math.floor(this.flashingFrame) % 2 === 0) {
                            this.tileX = 2;
                        }
                    }
                }
                this.frame += 0.1 * delta;
                if (this.frame >= 4)
                    this.frame = 0;
                if (this.hasShadow)
                    game_1.Game.drawMob(0, 0, 1, 1, this.x - this.drawX, this.y - this.drawY, 1, 1, this.room.shadeColor, this.shadeAmount());
                game_1.Game.drawMob(this.tileX +
                    (this.tileX % 5 && !this.unconscious && !this.dying
                        ? Math.floor(this.frame)
                        : 0), this.tileY + this.direction * 2, 1, 2, this.x - this.drawX, this.y - this.drawYOffset - this.drawY - this.jumpY, 1, 2, this.softShadeColor, this.shadeAmount());
            }
            if (!this.cloned) {
                if (!this.seenPlayer) {
                    this.drawSleepingZs(delta);
                }
                if (this.alertTicks > 0) {
                    this.drawExclamation(delta);
                }
            }
            game_1.Game.ctx.restore();
        };
        if (this.cloned)
            return;
        this.ticks = 0;
        this.frame = 0;
        this.health = 3;
        this.maxHealth = 3;
        this.tileX = 17;
        this.tileY = 16;
        this.seenPlayer = false;
        this.aggro = false;
        this.ticksSinceFirstHit = 0;
        this.flashingFrame = 0;
        this.deathParticleColor = "#ffffff";
        this.name = "armored skeleton";
        this.forwardOnlyAttack = true;
        this.armored = true;
        if (drop)
            this.drop = drop;
        this.getDrop(["weapon", "consumable", "tool", "coin"]);
    }
}
exports.ArmoredSkullEnemy = ArmoredSkullEnemy;
ArmoredSkullEnemy.difficulty = 2;
ArmoredSkullEnemy.tileX = 5;
ArmoredSkullEnemy.tileY = 8;


/***/ }),

/***/ "./src/entity/enemy/armoredzombieEnemy.ts":
/*!************************************************!*\
  !*** ./src/entity/enemy/armoredzombieEnemy.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ArmoredzombieEnemy = void 0;
// src/entity/enemy/armoredzombieEnemy.ts
const game_1 = __webpack_require__(/*! ../../game */ "./src/game.ts");
const enemy_1 = __webpack_require__(/*! ./enemy */ "./src/entity/enemy/enemy.ts");
const astarclass_1 = __webpack_require__(/*! ../../utility/astarclass */ "./src/utility/astarclass.ts");
const spiketrap_1 = __webpack_require__(/*! ../../tile/spiketrap */ "./src/tile/spiketrap.ts");
class ArmoredzombieEnemy extends enemy_1.Enemy {
    constructor(room, game, x, y, drop) {
        super(room, game, x, y);
        this.hit = () => {
            return 1;
        };
        this.behavior = () => {
            this.lastX = this.x;
            this.lastY = this.y;
            if (!this.dead) {
                if (this.skipNextTurns > 0) {
                    this.skipNextTurns--;
                    return;
                }
                this.ticks++;
                if (!this.seenPlayer)
                    this.lookForPlayer();
                else if (this.seenPlayer) {
                    if (this.room.playerTicked === this.targetPlayer) {
                        this.alertTicks = Math.max(0, this.alertTicks - 1);
                        let oldX = this.x;
                        let oldY = this.y;
                        let disablePositions = Array();
                        for (const e of this.room.entities) {
                            if (e !== this) {
                                disablePositions.push({ x: e.x, y: e.y });
                            }
                        }
                        for (let xx = this.x - 1; xx <= this.x + 1; xx++) {
                            for (let yy = this.y - 1; yy <= this.y + 1; yy++) {
                                if (this.room.roomArray[xx][yy] instanceof spiketrap_1.SpikeTrap &&
                                    this.room.roomArray[xx][yy].on) {
                                    // don't walk on active spiketraps
                                    disablePositions.push({ x: xx, y: yy });
                                }
                            }
                        }
                        let grid = [];
                        for (let x = 0; x < this.room.roomX + this.room.width; x++) {
                            grid[x] = [];
                            for (let y = 0; y < this.room.roomY + this.room.height; y++) {
                                if (this.room.roomArray[x] && this.room.roomArray[x][y])
                                    grid[x][y] = this.room.roomArray[x][y];
                                else
                                    grid[x][y] = false;
                            }
                        }
                        let moves = astarclass_1.astar.AStar.search(grid, this, this.targetPlayer, disablePositions, false, false, true, this.direction);
                        if (moves.length > 0) {
                            let moveX = moves[0].pos.x;
                            let moveY = moves[0].pos.y;
                            let oldDir = this.direction;
                            let player = this.targetPlayer;
                            this.facePlayer(player);
                            if (moveX > oldX)
                                this.direction = game_1.Direction.RIGHT;
                            else if (moveX < oldX)
                                this.direction = game_1.Direction.LEFT;
                            else if (moveY > oldY)
                                this.direction = game_1.Direction.DOWN;
                            else if (moveY < oldY)
                                this.direction = game_1.Direction.UP;
                            if (oldDir == this.direction) {
                                let hitPlayer = false;
                                for (const i in this.game.players) {
                                    if (this.game.rooms[this.game.players[i].levelID] === this.room &&
                                        this.game.players[i].x === moveX &&
                                        this.game.players[i].y === moveY &&
                                        oldDir == this.direction) {
                                        this.game.players[i].hurt(this.hit(), this.name);
                                        this.drawX = 0.5 * (this.x - this.game.players[i].x);
                                        this.drawY = 0.5 * (this.y - this.game.players[i].y);
                                        if (this.game.players[i] ===
                                            this.game.players[this.game.localPlayerID])
                                            this.game.shakeScreen(10 * this.drawX, 10 * this.drawY);
                                    }
                                }
                                if (!hitPlayer) {
                                    this.tryMove(moveX, moveY);
                                    this.setDrawXY(oldX, oldY);
                                    if (this.x > oldX)
                                        this.direction = game_1.Direction.RIGHT;
                                    else if (this.x < oldX)
                                        this.direction = game_1.Direction.LEFT;
                                    else if (this.y > oldY)
                                        this.direction = game_1.Direction.DOWN;
                                    else if (this.y < oldY)
                                        this.direction = game_1.Direction.UP;
                                }
                            }
                        }
                        if (this.direction == game_1.Direction.LEFT) {
                            disablePositions.push({
                                x: this.x,
                                y: this.y + 1,
                            });
                            disablePositions.push({
                                x: this.x,
                                y: this.y - 1,
                            });
                        }
                        if (this.direction == game_1.Direction.RIGHT) {
                            disablePositions.push({
                                x: this.x,
                                y: this.y + 1,
                            });
                            disablePositions.push({
                                x: this.x,
                                y: this.y - 1,
                            });
                        }
                        if (this.direction == game_1.Direction.DOWN) {
                            disablePositions.push({
                                x: this.x + 1,
                                y: this.y,
                            });
                            disablePositions.push({
                                x: this.x - 1,
                                y: this.y,
                            });
                        }
                        if (this.direction == game_1.Direction.UP) {
                            disablePositions.push({
                                x: this.x + 1,
                                y: this.y,
                            });
                            disablePositions.push({
                                x: this.x - 1,
                                y: this.y,
                            });
                        }
                        this.makeHitWarnings();
                    }
                    let targetPlayerOffline = Object.values(this.game.offlinePlayers).indexOf(this.targetPlayer) !==
                        -1;
                    if (!this.aggro || targetPlayerOffline) {
                        let p = this.nearestPlayer();
                        if (p !== false) {
                            let [distance, player] = p;
                            if (distance <= 4 &&
                                (targetPlayerOffline ||
                                    distance < this.playerDistance(this.targetPlayer))) {
                                if (player !== this.targetPlayer) {
                                    this.targetPlayer = player;
                                    this.facePlayer(player);
                                    if (player === this.game.players[this.game.localPlayerID])
                                        this.alertTicks = 1;
                                    this.makeHitWarnings();
                                }
                            }
                        }
                    }
                }
            }
        };
        this.draw = (delta) => {
            if (this.dead)
                return;
            game_1.Game.ctx.save();
            game_1.Game.ctx.globalAlpha = this.alpha;
            if (!this.dead) {
                this.updateDrawXY(delta);
                this.tileX = 27;
                this.tileY = 8;
                if (this.health <= 1 || this.dying) {
                    this.tileX = 17;
                    this.tileY = 8;
                }
                this.frame += 0.1 * delta;
                if (this.frame >= 4)
                    this.frame = 0;
                if (this.hasShadow)
                    game_1.Game.drawMob(0, 0, 1, 1, this.x - this.drawX, this.y - this.drawY, 1, 1, this.room.shadeColor, this.shadeAmount());
                game_1.Game.drawMob(this.tileX + (this.tileX === 5 ? Math.floor(this.frame) : 0), this.tileY + this.direction * 2, 1, 2, this.x - this.drawX, this.y - this.drawYOffset - this.drawY, 1, 2, this.softShadeColor, this.shadeAmount());
            }
            if (!this.cloned) {
                if (!this.seenPlayer) {
                    this.drawSleepingZs(delta);
                }
                if (this.alertTicks > 0) {
                    this.drawExclamation(delta);
                }
            }
            game_1.Game.ctx.restore();
        };
        this.ticks = 0;
        this.frame = 0;
        this.health = 2;
        this.maxHealth = 2;
        this.tileX = 17;
        this.tileY = 8;
        this.seenPlayer = false;
        this.aggro = false;
        this.deathParticleColor = "#ffffff";
        this.name = "armored zombie";
        this.forwardOnlyAttack = true;
        this.armored = true;
        if (drop)
            this.drop = drop;
        this.getDrop(["weapon", "equipment", "consumable", "tool", "coin"]);
    }
}
exports.ArmoredzombieEnemy = ArmoredzombieEnemy;
ArmoredzombieEnemy.difficulty = 2;
ArmoredzombieEnemy.tileX = 17;
ArmoredzombieEnemy.tileY = 8;


/***/ }),

/***/ "./src/entity/enemy/bigKnightEnemy.ts":
/*!********************************************!*\
  !*** ./src/entity/enemy/bigKnightEnemy.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BigKnightEnemy = void 0;
const game_1 = __webpack_require__(/*! ../../game */ "./src/game.ts");
const hitWarning_1 = __webpack_require__(/*! ../../drawable/hitWarning */ "./src/drawable/hitWarning.ts");
const coin_1 = __webpack_require__(/*! ../../item/coin */ "./src/item/coin.ts");
const redgem_1 = __webpack_require__(/*! ../../item/resource/redgem */ "./src/item/resource/redgem.ts");
const spear_1 = __webpack_require__(/*! ../../item/weapon/spear */ "./src/item/weapon/spear.ts");
const gameConstants_1 = __webpack_require__(/*! ../../game/gameConstants */ "./src/game/gameConstants.ts");
const enemy_1 = __webpack_require__(/*! ./enemy */ "./src/entity/enemy/enemy.ts");
const random_1 = __webpack_require__(/*! ../../utility/random */ "./src/utility/random.ts");
class BigKnightEnemy extends enemy_1.Enemy {
    constructor(room, game, x, y, drop) {
        super(room, game, x, y);
        this.REGEN_TICKS = 5;
        this.addHitWarnings = () => {
            this.room.hitwarnings.push(new hitWarning_1.HitWarning(this.game, this.x - 1, this.y, this.x, this.y));
            this.room.hitwarnings.push(new hitWarning_1.HitWarning(this.game, this.x - 1, this.y + 1, this.x, this.y));
            this.room.hitwarnings.push(new hitWarning_1.HitWarning(this.game, this.x + 2, this.y, this.x, this.y));
            this.room.hitwarnings.push(new hitWarning_1.HitWarning(this.game, this.x + 2, this.y + 1, this.x, this.y));
            this.room.hitwarnings.push(new hitWarning_1.HitWarning(this.game, this.x, this.y - 1, this.x, this.y));
            this.room.hitwarnings.push(new hitWarning_1.HitWarning(this.game, this.x + 1, this.y - 1, this.x, this.y));
            this.room.hitwarnings.push(new hitWarning_1.HitWarning(this.game, this.x, this.y + 2, this.x, this.y));
            this.room.hitwarnings.push(new hitWarning_1.HitWarning(this.game, this.x + 1, this.y + 2, this.x, this.y));
        };
        this.hit = () => {
            return 1;
        };
        this.behavior = () => {
            this.lastX = this.x;
            this.lastY = this.y;
            if (!this.dead) {
                if (this.skipNextTurns > 0) {
                    this.skipNextTurns--;
                    return;
                }
                if (this.health == 1) {
                    this.ticksSinceFirstHit++;
                    if (this.ticksSinceFirstHit >= this.REGEN_TICKS) {
                        this.health++;
                        this.ticksSinceFirstHit = 0;
                    }
                }
                else {
                    this.ticks++;
                    if (!this.seenPlayer) {
                        let p = this.nearestPlayer();
                        if (p !== false) {
                            let [distance, player] = p;
                            if (distance <= 4) {
                                this.targetPlayer = player;
                                this.facePlayer(player);
                                this.seenPlayer = true;
                                if (player === this.game.players[this.game.localPlayerID])
                                    this.alertTicks = 1;
                                if (this.health >= 3)
                                    this.addHitWarnings();
                            }
                        }
                    }
                    else if (this.seenPlayer) {
                        if (this.room.playerTicked === this.targetPlayer) {
                            this.alertTicks = Math.max(0, this.alertTicks - 1);
                            let oldX = this.x;
                            let oldY = this.y;
                            let moveX = this.x;
                            let moveY = this.y;
                            if (this.ticks % 2 === 0) {
                                // horizontal preference
                                if (this.targetPlayer.x >= this.x + this.w)
                                    moveX++;
                                else if (this.targetPlayer.x < this.x)
                                    moveX--;
                                else if (this.targetPlayer.y >= this.y + this.h)
                                    moveY++;
                                else if (this.targetPlayer.y < this.y)
                                    moveY--;
                            }
                            else {
                                // vertical preference
                                if (this.targetPlayer.y >= this.y + this.h)
                                    moveY++;
                                else if (this.targetPlayer.y < this.y)
                                    moveY--;
                                else if (this.targetPlayer.x >= this.x + this.w)
                                    moveX++;
                                else if (this.targetPlayer.x < this.x)
                                    moveX--;
                            }
                            let hitPlayer = false;
                            if (this.health >= 3) {
                                let wouldHit = (player, moveX, moveY) => {
                                    return (player.x >= moveX &&
                                        player.x < moveX + this.w &&
                                        player.y >= moveY &&
                                        player.y < moveY + this.h);
                                };
                                for (const i in this.game.players) {
                                    if (this.game.rooms[this.game.players[i].levelID] === this.room &&
                                        wouldHit(this.game.players[i], moveX, moveY)) {
                                        this.game.players[i].hurt(this.hit(), this.name);
                                        this.drawX = 0.5 * (this.x - this.game.players[i].x);
                                        this.drawY = 0.5 * (this.y - this.game.players[i].y);
                                        if (this.game.players[i] ===
                                            this.game.players[this.game.localPlayerID])
                                            this.game.shakeScreen(10 * this.drawX, 10 * this.drawY);
                                    }
                                }
                            }
                            if (!hitPlayer) {
                                this.tryMove(moveX, moveY);
                                this.drawX = this.x - oldX;
                                this.drawY = this.y - oldY;
                                if (this.x > oldX)
                                    this.direction = game_1.Direction.RIGHT;
                                else if (this.x < oldX)
                                    this.direction = game_1.Direction.LEFT;
                                else if (this.y > oldY)
                                    this.direction = game_1.Direction.DOWN;
                                else if (this.y < oldY)
                                    this.direction = game_1.Direction.UP;
                            }
                            if (this.health < this.maxHealth) {
                                this.ticksSinceFirstHit++;
                                if (this.ticksSinceFirstHit >= this.REGEN_TICKS) {
                                    this.health++;
                                    this.ticksSinceFirstHit = 0;
                                }
                            }
                            if (this.health >= 3)
                                this.addHitWarnings();
                        }
                        let targetPlayerOffline = Object.values(this.game.offlinePlayers).indexOf(this.targetPlayer) !== -1;
                        if (!this.aggro || targetPlayerOffline) {
                            let p = this.nearestPlayer();
                            if (p !== false) {
                                let [distance, player] = p;
                                if (distance <= 4 &&
                                    (targetPlayerOffline ||
                                        distance < this.playerDistance(this.targetPlayer))) {
                                    if (player !== this.targetPlayer) {
                                        this.targetPlayer = player;
                                        this.facePlayer(player);
                                        if (player === this.game.players[this.game.localPlayerID])
                                            this.alertTicks = 1;
                                        if (this.health >= 3)
                                            this.addHitWarnings();
                                    }
                                }
                            }
                        }
                    }
                }
            }
        };
        this.draw = (delta) => {
            if (this.dead)
                return;
            game_1.Game.ctx.save();
            game_1.Game.ctx.globalAlpha = this.alpha;
            if (!this.dead) {
                this.updateDrawXY(delta);
                this.frame += 0.1 * delta;
                if (this.frame >= 4)
                    this.frame = 0;
                if (this.hasShadow)
                    game_1.Game.drawMob(18, 0, 2, 2, this.x - this.drawX, this.y - this.drawY, 2, 2, this.room.shadeColor, this.shadeAmount());
                game_1.Game.drawMob(2 * Math.floor((this.tileX + this.frame) / 2) + 1, this.tileY, 2, 4, this.x - this.drawX, this.y - 2.5 - this.drawY, 2, 4, this.softShadeColor, this.shadeAmount());
                if (!this.cloned) {
                    if (!this.seenPlayer) {
                        this.drawSleepingZs(delta, gameConstants_1.GameConstants.TILESIZE * 0.5, gameConstants_1.GameConstants.TILESIZE * -1);
                    }
                    if (this.alertTicks > 0) {
                        this.drawExclamation(delta, gameConstants_1.GameConstants.TILESIZE * 0.5, gameConstants_1.GameConstants.TILESIZE * -1);
                    }
                }
            }
            game_1.Game.ctx.restore();
        };
        this.drawTopLayer = (delta) => {
            this.drawableY = this.y;
            this.healthBar.draw(delta, this.health, this.maxHealth, this.x + 0.5, this.y, true);
        };
        this.dropLoot = () => {
            let dropOffsets = [
                { x: 0, y: 0 },
                { x: 1, y: 0 },
                { x: 0, y: 1 },
                { x: 1, y: 1 },
            ];
            for (let i = 0; i < this.drops.length; i++) {
                this.drops[i].level = this.room;
                this.drops[i].x = this.x + dropOffsets[i].x;
                this.drops[i].y = this.y + dropOffsets[i].y;
                this.room.items.push(this.drops[i]);
            }
        };
        this.w = 2;
        this.h = 2;
        this.ticks = 0;
        this.frame = 0;
        this.health = 4;
        this.maxHealth = 4;
        this.tileX = 29;
        this.tileY = 0;
        this.seenPlayer = false;
        this.aggro = false;
        this.ticksSinceFirstHit = 0;
        this.flashingFrame = 0;
        this.deathParticleColor = "#ffffff";
        this.chainPushable = false;
        this.name = "giant knight";
        this.drops = [];
        if (drop)
            this.drops.push(drop);
        while (this.drops.length < 4) {
            let dropProb = random_1.Random.rand();
            if (dropProb < 0.005)
                this.drops.push(new spear_1.Spear(this.room, this.x, this.y));
            else if (dropProb < 0.04)
                this.drops.push(new redgem_1.RedGem(this.room, this.x, this.y));
            else if (dropProb < 0.075)
                this.drops.push(new redgem_1.RedGem(this.room, this.x, this.y));
            else if (dropProb < 0.1)
                this.drops.push(new redgem_1.RedGem(this.room, this.x, this.y));
            else
                this.drops.push(new coin_1.Coin(this.room, this.x, this.y));
        }
    }
}
exports.BigKnightEnemy = BigKnightEnemy;
BigKnightEnemy.difficulty = 4;
BigKnightEnemy.tileX = 29;
BigKnightEnemy.tileY = 0;


/***/ }),

/***/ "./src/entity/enemy/bigSkullEnemy.ts":
/*!*******************************************!*\
  !*** ./src/entity/enemy/bigSkullEnemy.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BigSkullEnemy = void 0;
const game_1 = __webpack_require__(/*! ../../game */ "./src/game.ts");
const gameConstants_1 = __webpack_require__(/*! ../../game/gameConstants */ "./src/game/gameConstants.ts");
const enemy_1 = __webpack_require__(/*! ./enemy */ "./src/entity/enemy/enemy.ts");
const random_1 = __webpack_require__(/*! ../../utility/random */ "./src/utility/random.ts");
const astarclass_1 = __webpack_require__(/*! ../../utility/astarclass */ "./src/utility/astarclass.ts");
const spiketrap_1 = __webpack_require__(/*! ../../tile/spiketrap */ "./src/tile/spiketrap.ts");
const imageParticle_1 = __webpack_require__(/*! ../../particle/imageParticle */ "./src/particle/imageParticle.ts");
class BigSkullEnemy extends enemy_1.Enemy {
    constructor(room, game, x, y, drop) {
        super(room, game, x, y);
        this.REGEN_TICKS = 5;
        this.hit = () => {
            return 1;
        };
        this.hurt = (playerHitBy, damage, type = "none") => {
            this.handleEnemyCase(playerHitBy);
            let hitShield = false;
            let shieldHealth = 0;
            if (this.shielded) {
                shieldHealth = this.shield.health;
                if (shieldHealth > 0) {
                    this.shield.hurt(damage);
                    hitShield = true;
                }
            }
            this.ticksSinceFirstHit = 0;
            if (this.health == 4)
                this.unconscious = false;
            this.health -= damage;
            this.maxHealth -= shieldHealth;
            this.startHurting();
            this.healthBar.hurt();
            this.createDamageNumber(damage, type);
            this.playHitSound();
            if (this.health == 2) {
                this.unconscious = true;
                imageParticle_1.ImageParticle.spawnCluster(this.room, this.x + 1, this.y + 1, 3, 28);
            }
            else {
                this.healthBar.hurt();
            }
            if (this.health <= 0) {
                imageParticle_1.ImageParticle.spawnCluster(this.room, this.x + 1, this.y + 1, 0, 24);
                this.kill();
            }
            else
                this.hurtCallback();
        };
        this.behavior = () => {
            this.lastX = this.x;
            this.lastY = this.y;
            if (!this.dead) {
                if (this.skipNextTurns > 0) {
                    this.skipNextTurns--;
                    this.ticks++;
                    return;
                }
                if (this.health <= 2) {
                    this.unconscious = true;
                    this.ticksSinceFirstHit++;
                    if (this.ticksSinceFirstHit >= this.REGEN_TICKS) {
                        this.healthBar.hurt();
                        this.health = 4;
                        this.unconscious = false;
                    }
                    this.ticks++;
                    return;
                }
                this.ticks++;
                if (!this.seenPlayer) {
                    this.lookForPlayer();
                }
                else if (this.seenPlayer) {
                    if (this.room.playerTicked === this.targetPlayer) {
                        this.alertTicks = Math.max(0, this.alertTicks - 1);
                        let oldX = this.x;
                        let oldY = this.y;
                        let disablePositions = Array();
                        for (const e of this.room.entities) {
                            if (e !== this) {
                                // For 2x2 enemy, block all tiles the entity occupies
                                for (let ex = 0; ex < (e.w || 1); ex++) {
                                    for (let ey = 0; ey < (e.h || 1); ey++) {
                                        disablePositions.push({
                                            x: e.x + ex,
                                            y: e.y + ey,
                                        });
                                    }
                                }
                            }
                        }
                        // Check for spike traps around the 2x2 area
                        for (let xx = this.x - 1; xx <= this.x + this.w; xx++) {
                            for (let yy = this.y - 1; yy <= this.y + this.h; yy++) {
                                if (this.room.roomArray[xx] &&
                                    this.room.roomArray[xx][yy] &&
                                    this.room.roomArray[xx][yy] instanceof spiketrap_1.SpikeTrap &&
                                    this.room.roomArray[xx][yy].on) {
                                    disablePositions.push({ x: xx, y: yy });
                                }
                            }
                        }
                        let grid = [];
                        for (let x = 0; x < this.room.roomX + this.room.width; x++) {
                            grid[x] = [];
                            for (let y = 0; y < this.room.roomY + this.room.height; y++) {
                                if (this.room.roomArray[x] && this.room.roomArray[x][y])
                                    grid[x][y] = this.room.roomArray[x][y];
                                else
                                    grid[x][y] = false;
                            }
                        }
                        let moves = astarclass_1.astar.AStar.search(grid, this, this.targetPlayer, disablePositions, false, false, true, this.direction, undefined, undefined);
                        if (moves.length > 0) {
                            let moveX = moves[0].pos.x;
                            let moveY = moves[0].pos.y;
                            let oldDir = this.direction;
                            let player = this.targetPlayer;
                            this.facePlayer(player);
                            if (moveX > oldX)
                                this.direction = game_1.Direction.RIGHT;
                            else if (moveX < oldX)
                                this.direction = game_1.Direction.LEFT;
                            else if (moveY > oldY)
                                this.direction = game_1.Direction.DOWN;
                            else if (moveY < oldY)
                                this.direction = game_1.Direction.UP;
                            if (oldDir == this.direction) {
                                let hitPlayer = false;
                                let wouldHit = (player, moveX, moveY) => {
                                    return (player.x >= moveX &&
                                        player.x < moveX + this.w &&
                                        player.y >= moveY &&
                                        player.y < moveY + this.h);
                                };
                                for (const i in this.game.players) {
                                    if (this.game.rooms[this.game.players[i].levelID] === this.room &&
                                        wouldHit(this.game.players[i], moveX, moveY)) {
                                        this.game.players[i].hurt(this.hit(), this.name);
                                        this.drawX = 0.5 * (this.x - this.game.players[i].x);
                                        this.drawY = 0.5 * (this.y - this.game.players[i].y);
                                        if (this.game.players[i] ===
                                            this.game.players[this.game.localPlayerID])
                                            this.game.shakeScreen(10 * this.drawX, 10 * this.drawY);
                                        hitPlayer = true;
                                    }
                                }
                                if (!hitPlayer) {
                                    this.tryMove(moveX, moveY);
                                    this.setDrawXY(oldX, oldY);
                                    if (this.x > oldX)
                                        this.direction = game_1.Direction.RIGHT;
                                    else if (this.x < oldX)
                                        this.direction = game_1.Direction.LEFT;
                                    else if (this.y > oldY)
                                        this.direction = game_1.Direction.DOWN;
                                    else if (this.y < oldY)
                                        this.direction = game_1.Direction.UP;
                                }
                            }
                        }
                        else {
                            this.facePlayer(this.targetPlayer);
                        }
                        // Add directional disable positions for forward-only attack
                        if (this.direction == game_1.Direction.LEFT) {
                            for (let i = 0; i < this.h; i++) {
                                disablePositions.push({
                                    x: this.x,
                                    y: this.y + i + 1,
                                });
                                disablePositions.push({
                                    x: this.x,
                                    y: this.y + i - 1,
                                });
                            }
                        }
                        if (this.direction == game_1.Direction.RIGHT) {
                            for (let i = 0; i < this.h; i++) {
                                disablePositions.push({
                                    x: this.x + this.w - 1,
                                    y: this.y + i + 1,
                                });
                                disablePositions.push({
                                    x: this.x + this.w - 1,
                                    y: this.y + i - 1,
                                });
                            }
                        }
                        if (this.direction == game_1.Direction.DOWN) {
                            for (let i = 0; i < this.w; i++) {
                                disablePositions.push({
                                    x: this.x + i + 1,
                                    y: this.y + this.h - 1,
                                });
                                disablePositions.push({
                                    x: this.x + i - 1,
                                    y: this.y + this.h - 1,
                                });
                            }
                        }
                        if (this.direction == game_1.Direction.UP) {
                            for (let i = 0; i < this.w; i++) {
                                disablePositions.push({
                                    x: this.x + i + 1,
                                    y: this.y,
                                });
                                disablePositions.push({
                                    x: this.x + i - 1,
                                    y: this.y,
                                });
                            }
                        }
                        this.makeBigHitWarnings();
                    }
                    let targetPlayerOffline = Object.values(this.game.offlinePlayers).indexOf(this.targetPlayer) !==
                        -1;
                    if (!this.aggro || targetPlayerOffline) {
                        let p = this.nearestPlayer();
                        if (p !== false) {
                            let [distance, player] = p;
                            if (distance <= 4 &&
                                (targetPlayerOffline ||
                                    distance < this.playerDistance(this.targetPlayer))) {
                                if (player !== this.targetPlayer) {
                                    this.targetPlayer = player;
                                    this.facePlayer(player);
                                    if (player === this.game.players[this.game.localPlayerID])
                                        this.alertTicks = 1;
                                    this.makeBigHitWarnings();
                                }
                            }
                        }
                    }
                }
            }
        };
        this.draw = (delta) => {
            if (this.dead)
                return;
            game_1.Game.ctx.save();
            game_1.Game.ctx.globalAlpha = this.alpha;
            if (!this.dead) {
                this.updateDrawXY(delta);
                this.tileX = 21;
                this.tileY = 0;
                if (this.health <= 3) {
                    this.tileX = 21;
                    this.tileY = 4;
                    if (this.ticksSinceFirstHit >= 3) {
                        this.flashingFrame += 0.1 * delta;
                        if (Math.floor(this.flashingFrame) % 2 === 0) {
                            this.tileY = 0;
                        }
                    }
                }
                if (this.health <= 2) {
                    this.tileX = 21;
                    this.tileY = 8;
                    if (this.ticksSinceFirstHit >= 3) {
                        this.flashingFrame += 0.1 * delta;
                        if (Math.floor(this.flashingFrame) % 2 === 0) {
                            this.tileY = 4;
                        }
                    }
                }
                if (this.health <= 1 || this.cloned) {
                    this.tileX = 21;
                    this.tileY = 12;
                    if (this.ticksSinceFirstHit >= 3) {
                        this.flashingFrame += 0.1 * delta;
                        if (Math.floor(this.flashingFrame) % 2 === 0) {
                            this.tileY = 8;
                        }
                    }
                }
                this.frame += 0.1 * delta;
                if (this.frame >= 4)
                    this.frame = 0;
                if (this.hasShadow)
                    game_1.Game.drawMob(18, 0, 2, 2, this.x - this.drawX, this.y - this.drawY, 2, 2, this.room.shadeColor, this.shadeAmount());
                game_1.Game.drawMob(this.tileX + (this.tileX === 20 ? Math.floor(this.frame) * 2 : 0), this.tileY, 2, 4, this.x - this.drawX, this.y - 2.5 - this.drawY, 2, 4, this.softShadeColor, this.shadeAmount());
                if (!this.cloned) {
                    if (!this.seenPlayer) {
                        this.drawSleepingZs(delta, gameConstants_1.GameConstants.TILESIZE * 0.5, gameConstants_1.GameConstants.TILESIZE * -1);
                    }
                    if (this.alertTicks > 0) {
                        this.drawExclamation(delta, gameConstants_1.GameConstants.TILESIZE * 0.5, gameConstants_1.GameConstants.TILESIZE * -1);
                    }
                }
            }
            game_1.Game.ctx.restore();
        };
        this.drawTopLayer = (delta) => {
            this.drawableY = this.y;
            this.healthBar.draw(delta, this.health, this.maxHealth, this.x + 0.5, this.y, true);
        };
        this.dropLoot = () => {
            let dropOffsets = [
                { x: 0, y: 0 },
                { x: 1, y: 0 },
                { x: 0, y: 1 },
                { x: 1, y: 1 },
            ];
            for (let i = 0; i < this.drops.length; i++) {
                this.drops[i].level = this.room;
                this.drops[i].x = this.x + dropOffsets[i].x;
                this.drops[i].y = this.y + dropOffsets[i].y;
                this.room.items.push(this.drops[i]);
            }
        };
        this.w = 2;
        this.h = 2;
        this.ticks = 0;
        this.frame = 0;
        this.health = 4;
        this.maxHealth = 4;
        this.tileX = 21;
        this.tileY = 0;
        this.seenPlayer = false;
        this.aggro = false;
        this.unconscious = false;
        this.ticksSinceFirstHit = 0;
        this.flashingFrame = 0;
        this.deathParticleColor = "#ffffff";
        this.chainPushable = false;
        this.name = "giant skeleton";
        this.dropChance = 1;
        this.drops = [];
        this.direction = game_1.Direction.DOWN;
        this.forwardOnlyAttack = true;
        this.alertRange = 10;
        this.drawMoveSpeed = 0.9;
        if (drop)
            this.drops.push(drop);
        const dropAmount = Math.floor(random_1.Random.rand() * 3) + 2;
        while (this.drops.length < dropAmount && !this.cloned) {
            this.getDrop();
        }
    }
}
exports.BigSkullEnemy = BigSkullEnemy;
BigSkullEnemy.difficulty = 4;
BigSkullEnemy.tileX = 21;
BigSkullEnemy.tileY = 0;


/***/ }),

/***/ "./src/entity/enemy/bigZombieEnemy.ts":
/*!********************************************!*\
  !*** ./src/entity/enemy/bigZombieEnemy.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BigZombieEnemy = void 0;
const game_1 = __webpack_require__(/*! ../../game */ "./src/game.ts");
const random_1 = __webpack_require__(/*! ../../utility/random */ "./src/utility/random.ts");
const astarclass_1 = __webpack_require__(/*! ../../utility/astarclass */ "./src/utility/astarclass.ts");
const spiketrap_1 = __webpack_require__(/*! ../../tile/spiketrap */ "./src/tile/spiketrap.ts");
const enemy_1 = __webpack_require__(/*! ./enemy */ "./src/entity/enemy/enemy.ts");
class BigZombieEnemy extends enemy_1.Enemy {
    constructor(room, game, x, y, drop) {
        super(room, game, x, y);
        this.hit = () => {
            return 1;
        };
        this.behavior = () => {
            // Store the current position
            this.lastX = this.x;
            this.lastY = this.y;
            // If the enemy is not dead
            if (!this.dead) {
                // Skip turns if necessary
                if (this.skipNextTurns > 0) {
                    this.skipNextTurns--;
                    return;
                }
                // Increment the tick counter
                this.ticks++;
                // If the enemy has not seen the player yet
                if (!this.seenPlayer)
                    this.lookForPlayer();
                else if (this.seenPlayer) {
                    // If the target player has taken their turn
                    if (this.room.playerTicked === this.targetPlayer) {
                        // Decrement alert ticks
                        this.alertTicks = Math.max(0, this.alertTicks - 1);
                        // Store the old position
                        let oldX = this.x;
                        let oldY = this.y;
                        // Create a list of positions to avoid
                        let disablePositions = Array();
                        for (const e of this.room.entities) {
                            if (e !== this) {
                                // For 2x2 entity, block all positions the entity occupies
                                for (let dx = 0; dx < e.w; dx++) {
                                    for (let dy = 0; dy < e.h; dy++) {
                                        disablePositions.push({
                                            x: e.x + dx,
                                            y: e.y + dy,
                                        });
                                    }
                                }
                            }
                        }
                        // Check spike traps in a larger area for 2x2 entity
                        for (let xx = this.x - 1; xx <= this.x + this.w; xx++) {
                            for (let yy = this.y - 1; yy <= this.y + this.h; yy++) {
                                if (this.room.roomArray[xx] &&
                                    this.room.roomArray[xx][yy] &&
                                    this.room.roomArray[xx][yy] instanceof spiketrap_1.SpikeTrap &&
                                    this.room.roomArray[xx][yy].on) {
                                    disablePositions.push({ x: xx, y: yy });
                                }
                            }
                        }
                        // Create a grid of the room
                        let grid = [];
                        for (let x = 0; x < this.room.roomX + this.room.width; x++) {
                            grid[x] = [];
                            for (let y = 0; y < this.room.roomY + this.room.height; y++) {
                                if (this.room.roomArray[x] && this.room.roomArray[x][y])
                                    grid[x][y] = this.room.roomArray[x][y];
                                else
                                    grid[x][y] = false;
                            }
                        }
                        // Find a path to the target player
                        let moves = astarclass_1.astar.AStar.search(grid, this, this.targetPlayer, disablePositions, false, false, true, this.direction);
                        // If there are moves available
                        if (moves.length > 0) {
                            let moveX = moves[0].pos.x;
                            let moveY = moves[0].pos.y;
                            let oldDir = this.direction;
                            let player = this.targetPlayer;
                            // Face the target player
                            this.facePlayer(player);
                            // Determine the new direction based on the move
                            if (moveX > oldX)
                                this.direction = game_1.Direction.RIGHT;
                            else if (moveX < oldX)
                                this.direction = game_1.Direction.LEFT;
                            else if (moveY > oldY)
                                this.direction = game_1.Direction.DOWN;
                            else if (moveY < oldY)
                                this.direction = game_1.Direction.UP;
                            // If the direction hasn't changed, attempt to move or attack
                            if (oldDir == this.direction) {
                                let hitPlayer = false;
                                for (const i in this.game.players) {
                                    if (this.game.rooms[this.game.players[i].levelID] === this.room) {
                                        // Check if player is within any of the 2x2 positions we're moving to
                                        let playerHit = false;
                                        for (let dx = 0; dx < this.w; dx++) {
                                            for (let dy = 0; dy < this.h; dy++) {
                                                if (this.game.players[i].x === moveX + dx &&
                                                    this.game.players[i].y === moveY + dy) {
                                                    playerHit = true;
                                                    break;
                                                }
                                            }
                                            if (playerHit)
                                                break;
                                        }
                                        if (playerHit) {
                                            this.game.players[i].hurt(this.hit(), this.name);
                                            this.drawX = 0.5 * (this.x - this.game.players[i].x);
                                            this.drawY = 0.5 * (this.y - this.game.players[i].y);
                                            if (this.game.players[i] ===
                                                this.game.players[this.game.localPlayerID])
                                                this.game.shakeScreen(10 * this.drawX, 10 * this.drawY);
                                            hitPlayer = true;
                                        }
                                    }
                                }
                                if (!hitPlayer) {
                                    // Move to the new position
                                    this.tryMove(moveX, moveY);
                                    this.setDrawXY(oldX, oldY);
                                    if (this.x > oldX)
                                        this.direction = game_1.Direction.RIGHT;
                                    else if (this.x < oldX)
                                        this.direction = game_1.Direction.LEFT;
                                    else if (this.y > oldY)
                                        this.direction = game_1.Direction.DOWN;
                                    else if (this.y < oldY)
                                        this.direction = game_1.Direction.UP;
                                }
                            }
                        }
                        else {
                            this.facePlayer(this.targetPlayer);
                        }
                        // Add positions to avoid based on the current direction
                        if (this.direction == game_1.Direction.LEFT) {
                            disablePositions.push({
                                x: this.x,
                                y: this.y + 1,
                            });
                            disablePositions.push({
                                x: this.x,
                                y: this.y - 1,
                            });
                        }
                        if (this.direction == game_1.Direction.RIGHT) {
                            disablePositions.push({
                                x: this.x,
                                y: this.y + 1,
                            });
                            disablePositions.push({
                                x: this.x,
                                y: this.y - 1,
                            });
                        }
                        if (this.direction == game_1.Direction.DOWN) {
                            disablePositions.push({
                                x: this.x + 1,
                                y: this.y,
                            });
                            disablePositions.push({
                                x: this.x - 1,
                                y: this.y,
                            });
                        }
                        if (this.direction == game_1.Direction.UP) {
                            disablePositions.push({
                                x: this.x + 1,
                                y: this.y,
                            });
                            disablePositions.push({
                                x: this.x - 1,
                                y: this.y,
                            });
                        }
                        // Make hit warnings
                        this.makeBigHitWarnings();
                    }
                    // Check if the target player is offline
                    let targetPlayerOffline = Object.values(this.game.offlinePlayers).indexOf(this.targetPlayer) !==
                        -1;
                    // If the enemy is not aggro or the target player is offline, find a new target player
                    if (!this.aggro || targetPlayerOffline) {
                        let p = this.nearestPlayer();
                        if (p !== false) {
                            let [distance, player] = p;
                            if (distance <= 4 &&
                                (targetPlayerOffline ||
                                    distance < this.playerDistance(this.targetPlayer))) {
                                if (player !== this.targetPlayer) {
                                    this.targetPlayer = player;
                                    this.facePlayer(player);
                                    if (player === this.game.players[this.game.localPlayerID])
                                        this.alertTicks = 1;
                                    this.makeBigHitWarnings();
                                }
                            }
                        }
                    }
                }
            }
        };
        this.drawTopLayer = (delta) => {
            this.drawableY = this.y;
            this.healthBar.draw(delta, this.health, this.maxHealth, this.x + 0.5, this.y, true);
        };
        this.dropLoot = () => {
            let dropOffsets = [
                { x: 0, y: 0 },
                { x: 1, y: 0 },
                { x: 0, y: 1 },
                { x: 1, y: 1 },
            ];
            for (let i = 0; i < this.drops.length; i++) {
                this.drops[i].level = this.room;
                this.drops[i].x = this.x + dropOffsets[i].x;
                this.drops[i].y = this.y + dropOffsets[i].y;
                this.room.items.push(this.drops[i]);
            }
        };
        this.draw = (delta) => {
            if (this.dead)
                return;
            //this.updateShadeColor(delta);
            game_1.Game.ctx.globalAlpha = this.alpha;
            this.updateDrawXY(delta);
            this.frame += 0.1 * delta;
            if (this.frame >= 4)
                this.frame = 0;
            if (this.hasShadow)
                game_1.Game.drawMob(0, 0, 2, 2, this.x - this.drawX, this.y - this.drawY, 2, 2, this.shadeColor, this.shadeAmount());
            game_1.Game.drawMob(this.tileX, // + Math.floor(this.frame),
            this.tileY + this.direction * 3, 2, 3, this.x - this.drawX, this.y - this.drawYOffset - this.drawY - this.jumpY, 2, 3, this.softShadeColor, this.shadeAmount());
            if (!this.cloned) {
                if (!this.seenPlayer) {
                    this.drawSleepingZs(delta);
                }
                if (this.alertTicks > 0) {
                    this.drawExclamation(delta);
                }
            }
            game_1.Game.ctx.globalAlpha = 1;
        };
        this.w = 2;
        this.h = 2;
        this.ticks = 0;
        this.frame = 0;
        this.health = 4;
        this.maxHealth = 4;
        this.tileX = 31;
        this.tileY = 12;
        this.seenPlayer = false;
        this.aggro = false;
        this.dir = game_1.Direction.DOWN;
        this.name = "bigzombie";
        this.chainPushable = false;
        this.forwardOnlyAttack = true;
        this.drawMoveSpeed = 0.9;
        this.jumpHeight = 0.35;
        this.drawYOffset = 1.5;
        this.alertRange = 10;
        if (drop)
            this.drop = drop;
        const dropAmount = Math.floor(random_1.Random.rand() * 3) + 2;
        while (this.drops.length < dropAmount && !this.cloned) {
            this.getDrop();
        }
    }
}
exports.BigZombieEnemy = BigZombieEnemy;
BigZombieEnemy.difficulty = 1;
BigZombieEnemy.tileX = 21;
BigZombieEnemy.tileY = 0;


/***/ }),

/***/ "./src/entity/enemy/bishopEnemy.ts":
/*!*****************************************!*\
  !*** ./src/entity/enemy/bishopEnemy.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BishopEnemy = void 0;
const game_1 = __webpack_require__(/*! ../../game */ "./src/game.ts");
const astarclass_1 = __webpack_require__(/*! ../../utility/astarclass */ "./src/utility/astarclass.ts");
const spiketrap_1 = __webpack_require__(/*! ../../tile/spiketrap */ "./src/tile/spiketrap.ts");
const door_1 = __webpack_require__(/*! ../../tile/door */ "./src/tile/door.ts");
const enemy_1 = __webpack_require__(/*! ./enemy */ "./src/entity/enemy/enemy.ts");
class BishopEnemy extends enemy_1.Enemy {
    constructor(room, game, x, y, drop) {
        super(room, game, x, y);
        this.tryMove = (x, y) => {
            let pointWouldBeIn = (someX, someY) => {
                return (someX >= x && someX < x + this.w && someY >= y && someY < y + this.h);
            };
            let enemyCollide = (enemy) => {
                if (enemy.x >= x + this.w || enemy.x + enemy.w <= x)
                    return false;
                if (enemy.y >= y + this.h || enemy.y + enemy.h <= y)
                    return false;
                return true;
            };
            for (const e of this.room.entities) {
                if (e !== this && enemyCollide(e)) {
                    return;
                }
            }
            for (const i in this.game.players) {
                if (pointWouldBeIn(this.game.players[i].x, this.game.players[i].y)) {
                    return;
                }
            }
            let tiles = [];
            for (let xx = 0; xx < this.w; xx++) {
                for (let yy = 0; yy < this.h; yy++) {
                    if (!this.room.roomArray[x + xx][y + yy].isSolid()) {
                        tiles.push(this.room.roomArray[x + xx][y + yy]);
                    }
                    else {
                        return;
                    }
                }
            }
            for (let tile of tiles) {
                tile.onCollideEnemy(this);
            }
            this.x = x;
            this.y = y;
        };
        this.hit = () => {
            return 1;
        };
        this.jump = (delta) => {
            let j = Math.max(Math.abs(this.drawX), Math.abs(this.drawY));
            let jumpY = Math.abs(Math.sin(j * Math.PI)) * this.jumpHeight;
            if (jumpY < 0.01)
                jumpY = 0;
            if (jumpY > this.jumpHeight)
                jumpY = this.jumpHeight;
            this.jumpY = jumpY;
        };
        this.behavior = () => {
            if (!this.dead) {
                if (this.skipNextTurns > 0) {
                    this.skipNextTurns--;
                    return;
                }
                this.ticks++;
                if (!this.seenPlayer)
                    this.lookForPlayer();
                else if (this.seenPlayer) {
                    if (this.room.playerTicked === this.targetPlayer) {
                        this.alertTicks = Math.max(0, this.alertTicks - 1);
                        let oldX = this.x;
                        let oldY = this.y;
                        let disablePositions = Array();
                        for (const e of this.room.entities) {
                            if (e !== this) {
                                disablePositions.push({ x: e.x, y: e.y });
                            }
                        }
                        for (let xx = this.x - 1; xx <= this.x + 1; xx++) {
                            for (let yy = this.y - 1; yy <= this.y + 1; yy++) {
                                if (this.room.roomArray[xx][yy] instanceof spiketrap_1.SpikeTrap &&
                                    this.room.roomArray[xx][yy].on) {
                                    // don't walk on active spiketraps
                                    disablePositions.push({ x: xx, y: yy });
                                }
                                if (this.room.roomArray[xx][yy] instanceof door_1.Door) {
                                    // don't walk into doorways (normally wouldn't be an issue without diagonals)
                                    disablePositions.push({ x: xx, y: yy });
                                }
                            }
                        }
                        let grid = [];
                        for (let x = 0; x < this.room.roomX + this.room.width; x++) {
                            grid[x] = [];
                            for (let y = 0; y < this.room.roomY + this.room.height; y++) {
                                if (this.room.roomArray[x] && this.room.roomArray[x][y])
                                    grid[x][y] = this.room.roomArray[x][y];
                                else
                                    grid[x][y] = false;
                            }
                        }
                        disablePositions.push({ x: this.x + 1, y: this.y });
                        disablePositions.push({ x: this.x - 1, y: this.y });
                        disablePositions.push({ x: this.x, y: this.y + 1 });
                        disablePositions.push({ x: this.x, y: this.y - 1 });
                        disablePositions.push({ x: this.x, y: this.y });
                        let moves = astarclass_1.astar.AStar.search(grid, this, this.targetPlayer, disablePositions, true);
                        moves = moves.filter((move) => {
                            const dx = Math.abs(move.pos.x - this.x);
                            const dy = Math.abs(move.pos.y - this.y);
                            return dx === 1 && dy === 1;
                        });
                        if (this.justHurt) {
                            this.retreat(oldX, oldY);
                        }
                        else if (moves.length > 0) {
                            let moveX = moves[0].pos.x;
                            let moveY = moves[0].pos.y;
                            let hitPlayer = false;
                            for (const i in this.game.players) {
                                if (this.game.rooms[this.game.players[i].levelID] === this.room &&
                                    this.game.players[i].x === moveX &&
                                    this.game.players[i].y === moveY) {
                                    this.game.players[i].hurt(this.hit(), this.name);
                                    this.drawX = 0.5 * (this.x - this.game.players[i].x);
                                    this.drawY = 0.5 * (this.y - this.game.players[i].y);
                                    hitPlayer = true;
                                    if (this.game.players[i] ===
                                        this.game.players[this.game.localPlayerID])
                                        this.game.shakeScreen(10 * this.drawX, 10 * this.drawY);
                                }
                            }
                            if (!hitPlayer) {
                                this.tryMove(moveX, moveY);
                                this.setDrawXY(oldX, oldY);
                            }
                        }
                        this.makeHitWarnings();
                    }
                    let targetPlayerOffline = Object.values(this.game.offlinePlayers).indexOf(this.targetPlayer) !==
                        -1;
                    if (!this.aggro || targetPlayerOffline) {
                        let p = this.nearestPlayer();
                        if (p !== false) {
                            let [distance, player] = p;
                            if (distance <= 4 &&
                                (targetPlayerOffline ||
                                    distance < this.playerDistance(this.targetPlayer))) {
                                if (player !== this.targetPlayer) {
                                    this.targetPlayer = player;
                                    this.facePlayer(player);
                                    if (player === this.game.players[this.game.localPlayerID])
                                        this.alertTicks = 1;
                                    this.makeHitWarnings();
                                }
                            }
                        }
                    }
                }
            }
        };
        this.draw = (delta) => {
            if (this.dead)
                return;
            game_1.Game.ctx.save();
            game_1.Game.ctx.globalAlpha = this.alpha;
            let offsetTileY = this.health <= 1 || this.cloned === true ? 2 : 0;
            if (!this.dead) {
                this.updateDrawXY(delta);
                this.frame += 0.1 * delta;
                if (this.frame >= 4)
                    this.frame = 0;
                if (this.hasShadow)
                    game_1.Game.drawMob(0, 0, 1, 1, this.x - this.drawX, this.y - this.drawY, 1, 1, this.room.shadeColor, this.shadeAmount());
                game_1.Game.drawMob(this.tileX + Math.floor(this.frame), this.tileY + offsetTileY, 1, 2, this.x - this.drawX, this.y - this.drawYOffset - this.drawY - this.jumpY, 1, 2, this.softShadeColor, this.shadeAmount() * (1 + this.jumpY / 3));
            }
            if (!this.cloned) {
                if (!this.seenPlayer) {
                    this.drawSleepingZs(delta);
                }
                if (this.alertTicks > 0) {
                    this.drawExclamation(delta);
                }
            }
            game_1.Game.ctx.restore();
        };
        this.ticks = 0;
        this.frame = 0;
        this.health = 2;
        this.maxHealth = 2;
        this.tileX = 31;
        this.tileY = 8;
        this.seenPlayer = false;
        this.aggro = false;
        this.name = "bishop";
        this.jumpHeight = 1;
        this.diagonalAttackRange = 1;
        this.diagonalAttack = true;
        this.orthogonalAttack = false;
        this.imageParticleX = 0;
        this.imageParticleY = 26;
        if (drop)
            this.drop = drop;
        this.armored = true;
        this.getDrop(["weapon", "equipment", "consumable", "tool", "coin"]);
    }
}
exports.BishopEnemy = BishopEnemy;
BishopEnemy.difficulty = 2;
BishopEnemy.tileX = 31;
BishopEnemy.tileY = 8;


/***/ }),

/***/ "./src/entity/enemy/chargeEnemy.ts":
/*!*****************************************!*\
  !*** ./src/entity/enemy/chargeEnemy.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ChargeEnemy = exports.ChargeEnemyState = void 0;
const game_1 = __webpack_require__(/*! ../../game */ "./src/game.ts");
const hitWarning_1 = __webpack_require__(/*! ../../drawable/hitWarning */ "./src/drawable/hitWarning.ts");
const door_1 = __webpack_require__(/*! ../../tile/door */ "./src/tile/door.ts");
const genericParticle_1 = __webpack_require__(/*! ../../particle/genericParticle */ "./src/particle/genericParticle.ts");
const gameConstants_1 = __webpack_require__(/*! ../../game/gameConstants */ "./src/game/gameConstants.ts");
const enemy_1 = __webpack_require__(/*! ./enemy */ "./src/entity/enemy/enemy.ts");
var ChargeEnemyState;
(function (ChargeEnemyState) {
    ChargeEnemyState[ChargeEnemyState["IDLE"] = 0] = "IDLE";
    ChargeEnemyState[ChargeEnemyState["ALERTED"] = 1] = "ALERTED";
    ChargeEnemyState[ChargeEnemyState["CHARGING"] = 2] = "CHARGING";
})(ChargeEnemyState = exports.ChargeEnemyState || (exports.ChargeEnemyState = {}));
class ChargeEnemy extends enemy_1.Enemy {
    constructor(room, game, x, y, drop) {
        super(room, game, x, y);
        this.maxChargeDistance = 3;
        this.trailAlpha = 1;
        this.hit = () => {
            return 1;
        };
        this.canMoveOver = (x, y) => {
            for (const e of this.room.entities) {
                if (e !== this && x === e.x && y === e.y)
                    return false;
            }
            let t = this.room.roomArray[x][y];
            return !(t.isSolid() || t instanceof door_1.Door);
        };
        this.behavior = () => {
            this.lastX = this.x;
            this.lastY = this.y;
            if (!this.dead) {
                if (this.skipNextTurns > 0) {
                    this.skipNextTurns--;
                    return;
                }
                this.ticks++;
                if (this.state === ChargeEnemyState.IDLE) {
                    let blocked = false;
                    let dx = 0;
                    let dy = 0;
                    for (const i in this.game.players) {
                        // Check if player is within detection range (maxChargeDistance)
                        const playerX = this.game.players[i].x;
                        const playerY = this.game.players[i].y;
                        const distanceX = Math.abs(this.x - playerX);
                        const distanceY = Math.abs(this.y - playerY);
                        // Only detect players in straight lines and within maxChargeDistance
                        if ((this.x === playerX && distanceY <= this.maxChargeDistance) ||
                            (this.y === playerY && distanceX <= this.maxChargeDistance)) {
                            if (this.x === playerX) {
                                if (this.y < playerY)
                                    dy = 1;
                                else
                                    dy = -1;
                                for (let yy = this.y; yy !== playerY; yy += dy) {
                                    if (!this.canMoveOver(this.x, yy))
                                        blocked = true;
                                }
                            }
                            else if (this.y === playerY) {
                                if (this.x < playerX)
                                    dx = 1;
                                else
                                    dx = -1;
                                for (let xx = this.x; xx !== playerX; xx += dx) {
                                    if (!this.canMoveOver(xx, this.y))
                                        blocked = true;
                                }
                            }
                            if ((dx !== 0 || dy !== 0) && !blocked) {
                                this.state = ChargeEnemyState.ALERTED;
                                this.targetX = this.x;
                                this.targetY = this.y;
                                let distanceMoved = 0;
                                while (this.canMoveOver(this.targetX + dx, this.targetY + dy) &&
                                    distanceMoved < this.maxChargeDistance) {
                                    this.targetX += dx;
                                    this.targetY += dy;
                                    distanceMoved++;
                                    if ((this.targetX === playerX && this.targetY === playerY) ||
                                        (this.targetX === playerX - 1 && this.targetY === playerY) ||
                                        (this.targetX === playerX + 1 && this.targetY === playerY) ||
                                        (this.targetX === playerX && this.targetY === playerY - 1) ||
                                        (this.targetX === playerX && this.targetY === playerY + 1))
                                        this.room.hitwarnings.push(new hitWarning_1.HitWarning(this.game, this.targetX, this.targetY, this.x, this.y));
                                }
                                this.visualTargetX = this.targetX + 0.5 * dx;
                                this.visualTargetY = this.targetY + 0.5 * dy;
                                if (dy === 1)
                                    this.visualTargetY += 0.65;
                                if (dx > 0)
                                    this.direction = game_1.Direction.RIGHT;
                                else if (dx < 0)
                                    this.direction = game_1.Direction.LEFT;
                                else if (dy < 0)
                                    this.direction = game_1.Direction.UP;
                                else if (dy > 0)
                                    this.direction = game_1.Direction.DOWN;
                                break;
                            }
                        }
                    }
                }
                else if (this.state === ChargeEnemyState.ALERTED) {
                    this.state = ChargeEnemyState.CHARGING;
                    this.trailFrame = 0;
                    for (const i in this.game.players) {
                        if ((this.y === this.game.players[i].y &&
                            ((this.x < this.game.players[i].x &&
                                this.game.players[i].x <= this.targetX) ||
                                (this.targetX <= this.game.players[i].x &&
                                    this.game.players[i].x < this.x))) ||
                            (this.x === this.game.players[i].x &&
                                ((this.y < this.game.players[i].y &&
                                    this.game.players[i].y <= this.targetY) ||
                                    (this.targetY <= this.game.players[i].y &&
                                        this.game.players[i].y < this.y)))) {
                            this.game.players[i].hurt(this.hit(), this.name);
                        }
                    }
                    this.startX = this.x;
                    this.startY = this.y;
                    this.drawX = this.targetX - this.x;
                    this.drawY = this.targetY - this.y;
                    this.x = this.targetX;
                    this.y = this.targetY;
                }
                else if (this.state === ChargeEnemyState.CHARGING) {
                    this.state = ChargeEnemyState.IDLE;
                }
            }
        };
        this.draw = (delta) => {
            if (this.dead)
                return;
            game_1.Game.ctx.save();
            game_1.Game.ctx.globalAlpha = this.alpha;
            if (!this.dead) {
                this.updateDrawXY(delta);
                this.frame += 0.1 * delta;
                if (this.frame >= 4)
                    this.frame = 0;
                if ((this.state === ChargeEnemyState.CHARGING &&
                    Math.abs(this.drawX) > 0.1) ||
                    Math.abs(this.drawY) > 0.1) {
                    genericParticle_1.GenericParticle.spawnCluster(this.room, this.x - this.drawX + 0.5, this.y - this.drawY + 0.5, "black");
                    genericParticle_1.GenericParticle.spawnCluster(this.room, this.x - this.drawX + 0.5, this.y - this.drawY + 0.5, "white");
                }
                if (this.state === ChargeEnemyState.CHARGING || this.trailAlpha < 1) {
                    this.trailFrame += 0.03 * delta;
                    let t = this.trailFrame;
                    if (t >= 0 && t <= 1) {
                        game_1.Game.ctx.strokeStyle = "white";
                        if (gameConstants_1.GameConstants.ALPHA_ENABLED) {
                            this.trailAlpha = 1 - t;
                            game_1.Game.ctx.globalAlpha = this.trailAlpha;
                        }
                        game_1.Game.ctx.lineWidth = gameConstants_1.GameConstants.TILESIZE * 0.25;
                        game_1.Game.ctx.beginPath();
                        game_1.Game.ctx.moveTo((this.startX + 0.5) * gameConstants_1.GameConstants.TILESIZE, (this.startY + 0.5) * gameConstants_1.GameConstants.TILESIZE);
                        game_1.Game.ctx.lineCap = "round";
                        game_1.Game.ctx.lineTo((this.x - this.drawX + 0.5) * gameConstants_1.GameConstants.TILESIZE, (this.y - this.drawY + 0.5) * gameConstants_1.GameConstants.TILESIZE);
                        game_1.Game.ctx.stroke();
                        game_1.Game.ctx.globalAlpha = 1;
                    }
                    if (this.trailAlpha <= 0)
                        this.trailAlpha = 1;
                }
                if (this.hasShadow)
                    game_1.Game.drawMob(0, 0, 1, 1, this.x - this.drawX, this.y - this.drawY, 1, 1, this.room.shadeColor, this.shadeAmount());
                game_1.Game.drawMob(this.tileX + Math.floor(this.frame), this.tileY + this.direction * 2, 1, 2, this.x - this.drawX, this.y - this.drawYOffset - this.drawY, 1, 2, this.softShadeColor, this.shadeAmount());
                if (!this.cloned) {
                    if (this.state === ChargeEnemyState.IDLE) {
                        this.drawSleepingZs(delta);
                    }
                    else if (this.state === ChargeEnemyState.ALERTED) {
                        this.drawExclamation(delta);
                    }
                }
            }
            this.drawChargeBeam(delta);
            game_1.Game.ctx.restore();
        };
        this.drawChargeBeam = (delta) => {
            if (this.dying)
                return;
            this.drawableY = this.y;
            this.healthBar.draw(delta, this.health, this.maxHealth, this.x, this.y, true);
            this.drawX += -0.1 * this.drawX;
            this.drawY += -0.1 * this.drawY;
            if (this.state === ChargeEnemyState.ALERTED) {
                this.trailFrame += 0.2 * delta;
                if (Math.floor(this.trailFrame) % 2 === 0) {
                    let startX = (this.x + 0.5) * gameConstants_1.GameConstants.TILESIZE;
                    let startY = (this.y - 0.25) * gameConstants_1.GameConstants.TILESIZE;
                    if (this.direction === game_1.Direction.LEFT)
                        startX -= 3;
                    else if (this.direction === game_1.Direction.RIGHT)
                        startX += 3;
                    else if (this.direction === game_1.Direction.DOWN)
                        startY += 2;
                    else if (this.direction === game_1.Direction.UP)
                        startY -= 8;
                    // Calculate end coordinates based on direction and max distance
                    let endX = this.visualTargetX;
                    let endY = this.visualTargetY;
                    // Cap the beam length to maxChargeDistance
                    const dx = this.direction === game_1.Direction.LEFT
                        ? -1
                        : this.direction === game_1.Direction.RIGHT
                            ? 1
                            : 0;
                    const dy = this.direction === game_1.Direction.UP
                        ? -1
                        : this.direction === game_1.Direction.DOWN
                            ? 1
                            : 0;
                    const distance = Math.max(Math.abs(this.visualTargetX - this.x), Math.abs(this.visualTargetY - this.y));
                    if (distance > this.maxChargeDistance) {
                        endX = this.x + dx * this.maxChargeDistance;
                        endY = this.y + dy * this.maxChargeDistance;
                        if (dy === 1)
                            endY += 0.65;
                        if (dx > 0)
                            endX += 0.5;
                        else if (dx < 0)
                            endX -= 0.5;
                    }
                    game_1.Game.ctx.strokeStyle = "white";
                    game_1.Game.ctx.lineWidth = gameConstants_1.GameConstants.TILESIZE * 0.1;
                    game_1.Game.ctx.beginPath();
                    game_1.Game.ctx.moveTo(Math.round(startX), Math.round(startY));
                    game_1.Game.ctx.lineCap = "round";
                    game_1.Game.ctx.lineTo(Math.round((endX + 0.5) * gameConstants_1.GameConstants.TILESIZE), Math.round((endY - 0.25) * gameConstants_1.GameConstants.TILESIZE));
                    game_1.Game.ctx.stroke();
                    game_1.Game.ctx.globalAlpha = 1;
                }
            }
        };
        this.ticks = 0;
        this.frame = 0;
        this.health = 1;
        this.maxHealth = 1;
        this.tileX = 13;
        this.tileY = 8;
        this.trailFrame = 0;
        this.alertTicks = 0;
        this.deathParticleColor = "#ffffff";
        this.lastX = this.x;
        this.lastY = this.y;
        this.name = "charge knight";
        this.state = ChargeEnemyState.IDLE;
        if (drop)
            this.drop = drop;
        this.getDrop(["weapon", "equipment", "consumable", "tool", "coin"]);
    }
}
exports.ChargeEnemy = ChargeEnemy;
ChargeEnemy.difficulty = 5;
ChargeEnemy.tileX = 13;
ChargeEnemy.tileY = 8;


/***/ }),

/***/ "./src/entity/enemy/crabEnemy.ts":
/*!***************************************!*\
  !*** ./src/entity/enemy/crabEnemy.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CrabEnemy = void 0;
const game_1 = __webpack_require__(/*! ../../game */ "./src/game.ts");
const astarclass_1 = __webpack_require__(/*! ../../utility/astarclass */ "./src/utility/astarclass.ts");
const spiketrap_1 = __webpack_require__(/*! ../../tile/spiketrap */ "./src/tile/spiketrap.ts");
const gameConstants_1 = __webpack_require__(/*! ../../game/gameConstants */ "./src/game/gameConstants.ts");
const enemy_1 = __webpack_require__(/*! ./enemy */ "./src/entity/enemy/enemy.ts");
class CrabEnemy extends enemy_1.Enemy {
    constructor(room, game, x, y, drop) {
        super(room, game, x, y);
        this.hit = () => {
            return 0.5;
        };
        this.behavior = () => {
            this.lastX = this.x;
            this.lastY = this.y;
            if (!this.dead) {
                if (this.skipNextTurns > 0) {
                    this.skipNextTurns--;
                    return;
                }
                if (!this.seenPlayer)
                    this.lookForPlayer();
                else if (this.seenPlayer) {
                    if (this.room.playerTicked === this.targetPlayer) {
                        this.alertTicks = Math.max(0, this.alertTicks - 1);
                        this.ticks++;
                        if (this.ticks % 2 === 1) {
                            this.rumbling = true;
                            let oldX = this.x;
                            let oldY = this.y;
                            let disablePositions = Array();
                            for (const e of this.room.entities) {
                                if (e !== this) {
                                    disablePositions.push({ x: e.x, y: e.y });
                                }
                            }
                            for (let xx = this.x - 1; xx <= this.x + 1; xx++) {
                                for (let yy = this.y - 1; yy <= this.y + 1; yy++) {
                                    if (this.room.roomArray[xx][yy] instanceof spiketrap_1.SpikeTrap &&
                                        this.room.roomArray[xx][yy].on) {
                                        // don't walk on active spiketraps
                                        disablePositions.push({ x: xx, y: yy });
                                    }
                                }
                            }
                            let grid = [];
                            for (let x = 0; x < this.room.roomX + this.room.width; x++) {
                                grid[x] = [];
                                for (let y = 0; y < this.room.roomY + this.room.height; y++) {
                                    if (this.room.roomArray[x] && this.room.roomArray[x][y])
                                        grid[x][y] = this.room.roomArray[x][y];
                                    else
                                        grid[x][y] = false;
                                }
                            }
                            this.target =
                                this.getAverageLuminance() > 0 // 0.8
                                    ? this.targetPlayer
                                    : this.room.getExtremeLuminanceFromPoint(this.x, this.y)
                                        .darkest;
                            let moves = astarclass_1.astar.AStar.search(grid, this, this.target, disablePositions, undefined, undefined, undefined, undefined, undefined, undefined, this.lastPlayerPos);
                            if (moves.length > 0) {
                                let hitPlayer = false;
                                for (const i in this.game.players) {
                                    if (this.game.rooms[this.game.players[i].levelID] === this.room &&
                                        this.game.players[i].x === moves[0].pos.x &&
                                        this.game.players[i].y === moves[0].pos.y) {
                                        this.game.players[i].hurt(this.hit(), this.name);
                                        this.drawX = 0.5 * (this.x - this.game.players[i].x);
                                        this.drawY = 0.5 * (this.y - this.game.players[i].y);
                                        if (this.game.players[i] ===
                                            this.game.players[this.game.localPlayerID])
                                            this.game.shakeScreen(10 * this.drawX, 10 * this.drawY);
                                        hitPlayer = true;
                                    }
                                }
                                if (!hitPlayer) {
                                    this.tryMove(moves[0].pos.x, moves[0].pos.y);
                                    this.setDrawXY(oldX, oldY);
                                    if (this.x > oldX)
                                        this.direction = game_1.Direction.RIGHT;
                                    else if (this.x < oldX)
                                        this.direction = game_1.Direction.LEFT;
                                    else if (this.y > oldY)
                                        this.direction = game_1.Direction.DOWN;
                                    else if (this.y < oldY)
                                        this.direction = game_1.Direction.UP;
                                }
                            }
                            this.rumbling = false;
                        }
                        else {
                            this.rumbling = true;
                            /*
                            if (
                              (this.target.x === this.targetPlayer.x &&
                                this.target.y === this.targetPlayer.y) ||
                              Utils.distance(
                                this.targetPlayer.x,
                                this.targetPlayer.y,
                                this.x,
                                this.y,
                              ) <= 2
                            )
                              */ {
                                this.makeHitWarnings();
                            }
                        }
                    }
                    let targetPlayerOffline = Object.values(this.game.offlinePlayers).indexOf(this.targetPlayer) !==
                        -1;
                    if (!this.aggro || targetPlayerOffline) {
                        let p = this.nearestPlayer();
                        if (p !== false) {
                            let [distance, player] = p;
                            if (distance <= 4 &&
                                (targetPlayerOffline ||
                                    distance < this.playerDistance(this.targetPlayer))) {
                                if (player !== this.targetPlayer) {
                                    this.targetPlayer = player;
                                    this.facePlayer(player);
                                    if (player === this.game.players[this.game.localPlayerID])
                                        this.alertTicks = 1;
                                    if (this.ticks % 2 === 0) {
                                        /*
                                        if (
                                          (this.target.x === this.targetPlayer.x &&
                                            this.target.y === this.targetPlayer.y) ||
                                          Utils.distance(
                                            this.targetPlayer.x,
                                            this.targetPlayer.y,
                                            this.x,
                                            this.y,
                                          ) <= 2
                                        ) */ {
                                            this.makeHitWarnings();
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        };
        this.draw = (delta) => {
            if (this.dead)
                return;
            game_1.Game.ctx.save();
            game_1.Game.ctx.globalAlpha = this.alpha;
            if (!this.dead) {
                this.updateDrawXY(delta);
                if (this.ticks % 2 === 0) {
                    this.tileX = 9;
                    this.tileY = 4;
                }
                else {
                    this.tileX = 8;
                    this.tileY = 4;
                }
                let rumbleX = this.rumble(this.rumbling, this.frame, this.direction).x;
                let rumbleY = this.rumble(this.rumbling, this.frame, this.direction).y;
                this.frame += 0.1 * delta;
                if (this.frame >= 4)
                    this.frame = 0;
                if (this.hasShadow)
                    game_1.Game.drawMob(0, 0, 1, 1, this.x - this.drawX, this.y - 0.25 - this.drawY, 1, 1, this.room.shadeColor, this.shadeAmount());
                game_1.Game.drawMob(this.tileX, this.tileY + this.direction, 1, 1, this.x - this.drawX + rumbleX, this.y - this.drawYOffset - this.drawY + rumbleY, 1 * this.crushX, 1 * this.crushY, this.softShadeColor, this.shadeAmount());
                if (this.crushed) {
                    this.crushAnim(delta);
                }
            }
            if (!this.cloned) {
                if (!this.seenPlayer) {
                    this.drawSleepingZs(delta, 0, 0.75 * gameConstants_1.GameConstants.TILESIZE);
                }
                if (this.alertTicks > 0) {
                    this.drawExclamation(delta, 0, 0.75 * gameConstants_1.GameConstants.TILESIZE);
                }
            }
            game_1.Game.ctx.restore();
        };
        this.ticks = 0;
        this.frame = 0;
        this.health = 1;
        this.maxHealth = 1;
        this.tileX = 8;
        this.tileY = 4;
        this.seenPlayer = false;
        this.aggro = false;
        this.name = "crab";
        this.orthogonalAttack = true;
        this.imageParticleX = 3;
        this.imageParticleY = 24;
        //if (drop) this.drop = drop;
        this.drawYOffset = 0.25;
        this.getDrop(["weapon", "equipment", "consumable", "tool", "coin"]);
    }
    get alertText() {
        return `New Enemy Spotted: Crab 
    Health: ${this.health}
    Attack Pattern: Omnidirectional
    Moves every other turn`;
    }
}
exports.CrabEnemy = CrabEnemy;
CrabEnemy.difficulty = 1;
CrabEnemy.tileX = 8;
CrabEnemy.tileY = 4;


/***/ }),

/***/ "./src/entity/enemy/enemy.ts":
/*!***********************************!*\
  !*** ./src/entity/enemy/enemy.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Enemy = void 0;
const entity_1 = __webpack_require__(/*! ../entity */ "./src/entity/entity.ts");
const game_1 = __webpack_require__(/*! ../../game */ "./src/game.ts");
const astarclass_1 = __webpack_require__(/*! ../../utility/astarclass */ "./src/utility/astarclass.ts");
const spiketrap_1 = __webpack_require__(/*! ../../tile/spiketrap */ "./src/tile/spiketrap.ts");
const entity_2 = __webpack_require__(/*! ../entity */ "./src/entity/entity.ts");
const eventBus_1 = __webpack_require__(/*! ../../event/eventBus */ "./src/event/eventBus.ts");
const utils_1 = __webpack_require__(/*! ../../utility/utils */ "./src/utility/utils.ts");
const stunAnimation_1 = __webpack_require__(/*! ../../projectile/stunAnimation */ "./src/projectile/stunAnimation.ts");
const random_1 = __webpack_require__(/*! ../../utility/random */ "./src/utility/random.ts");
var EnemyState;
(function (EnemyState) {
    EnemyState[EnemyState["SLEEP"] = 0] = "SLEEP";
    EnemyState[EnemyState["AGGRO"] = 1] = "AGGRO";
    EnemyState[EnemyState["ATTACK"] = 2] = "ATTACK";
    EnemyState[EnemyState["DEAD"] = 3] = "DEAD";
    EnemyState[EnemyState["IDLE"] = 4] = "IDLE";
})(EnemyState || (EnemyState = {}));
class Enemy extends entity_1.Entity {
    constructor(room, game, x, y) {
        super(room, game, x, y);
        this.justHurt = false;
        this.hit = () => {
            return 1;
        };
        this.handleEnemyCase = (playerHitBy) => {
            if (!playerHitBy)
                return;
            if (playerHitBy) {
                this.aggro = true;
                this.targetPlayer = playerHitBy;
                //this.facePlayer(playerHitBy);
                if (playerHitBy === this.game.players[this.game.localPlayerID])
                    this.alertTicks = 2; // this is really 1 tick, it will be decremented immediately in tick()
            }
        };
        this.poison = () => {
            if (!this.status.poison.active) {
                this.status.poison = {
                    active: true,
                    hitCount: 0,
                    startTick: this.ticks,
                    effectTick: this.ticks % 3,
                };
                this.shadeColor = "#00FF00";
            }
        };
        this.bleed = () => {
            if (!this.status.bleed.active) {
                this.status.bleed = {
                    active: true,
                    hitCount: 0,
                    startTick: this.ticks,
                    effectTick: this.ticks % 1,
                };
            }
        };
        this.tickPoison = () => {
            if (this.status.poison.active && this.targetPlayer) {
                if (this.ticks % 3 === this.status.poison.effectTick &&
                    this.ticks !== this.status.poison.startTick &&
                    this.health >= 1) {
                    this.hurt(this.targetPlayer, 1, "poison");
                    this.shadeColor = "#00FF00";
                    //this.status.poison.hitCount++;
                    /*
                    if (this.status.poison.hitCount >= 2) {
                      this.status.poison = {
                        active: false,
                        hitCount: 0,
                        startTick: 0,
                        effectTick: 0,
                      };
                    }
                    */
                }
            }
        };
        this.tickBleed = () => {
            if (this.status.bleed.active && this.targetPlayer) {
                if (this.ticks % 1 === this.status.bleed.effectTick &&
                    this.ticks !== this.status.bleed.startTick) {
                    this.hurt(this.targetPlayer, 0.5, "blood");
                    //this.targetPlayer.heal(0.5);
                    this.shadeColor = "#FF0000";
                    this.status.bleed.hitCount++;
                    if (this.status.bleed.hitCount >= 4) {
                        this.status.bleed = {
                            active: false,
                            hitCount: 0,
                            startTick: 0,
                            effectTick: 0,
                        };
                    }
                }
            }
        };
        this.tick = () => {
            this.tickPoison();
            this.tickBleed();
            this.behavior();
            if (this.x !== this.lastX || this.y !== this.lastY) {
                this.emitEntityData();
            }
            if (this.shielded)
                this.shield.updateLightSourcePos();
        };
        this.lookForPlayer = (face = true) => {
            if (this.seenPlayer)
                return;
            const p = this.nearestPlayer();
            if (p === false)
                return;
            const [distance, player] = p;
            if (distance > this.alertRange)
                return;
            this.targetPlayer = player;
            if (face)
                this.facePlayer(player);
            this.seenPlayer = true;
            eventBus_1.globalEventBus.emit("EnemySeenPlayer", {
                enemyType: this.constructor.name,
                enemyName: this.name,
            });
            if (player === this.game.players[this.game.localPlayerID]) {
                this.alertTicks = 1;
            }
            this.makeHitWarnings();
        };
        this.getDisablePositions = () => {
            let disablePositions = Array();
            for (const e of this.room.entities) {
                if (e !== this) {
                    disablePositions.push({ x: e.x, y: e.y });
                }
            }
            for (let xx = this.x - 1; xx <= this.x + 1; xx++) {
                for (let yy = this.y - 1; yy <= this.y + 1; yy++) {
                    if (this.room.roomArray[xx][yy] instanceof spiketrap_1.SpikeTrap &&
                        this.room.roomArray[xx][yy].on) {
                        // Don't walk on active spike traps
                        disablePositions.push({ x: xx, y: yy });
                    }
                }
            }
            return disablePositions;
        };
        this.findPath = () => {
            let disablePositions = Array();
            for (const e of this.room.entities) {
                if (e !== this) {
                    disablePositions.push({ x: e.x, y: e.y });
                }
            }
            for (let xx = this.x - 1; xx <= this.x + 1; xx++) {
                for (let yy = this.y - 1; yy <= this.y + 1; yy++) {
                    if (this.room.roomArray[xx][yy] instanceof spiketrap_1.SpikeTrap &&
                        this.room.roomArray[xx][yy].on) {
                        // Don't walk on active spike traps
                        disablePositions.push({ x: xx, y: yy });
                    }
                }
            }
            // Create a grid of the room
            let grid = [];
            for (let x = 0; x < this.room.roomX + this.room.width; x++) {
                grid[x] = [];
                for (let y = 0; y < this.room.roomY + this.room.height; y++) {
                    if (this.room.roomArray[x] && this.room.roomArray[x][y])
                        grid[x][y] = this.room.roomArray[x][y];
                    else
                        grid[x][y] = false;
                }
            }
            // Find a path to the target player
            let moves = astarclass_1.astar.AStar.search(grid, this, this.targetPlayer, disablePositions, false, false, true, this.direction);
        };
        this.behavior = () => {
            // Store the current position
            this.lastX = this.x;
            this.lastY = this.y;
            // If the enemy is not dead
            if (!this.dead) {
                // Skip turns if necessary
                if (this.skipNextTurns > 0) {
                    this.skipNextTurns--;
                    return;
                }
                // Increment the tick counter
                this.ticks++;
                // If the enemy has not seen the player yet
                if (!this.seenPlayer)
                    this.lookForPlayer();
                else if (this.seenPlayer) {
                    // If the target player has taken their turn
                    if (this.room.playerTicked === this.targetPlayer) {
                        // Decrement alert ticks
                        this.alertTicks = Math.max(0, this.alertTicks - 1);
                        // Store the old position
                        let oldX = this.x;
                        let oldY = this.y;
                        // Create a list of positions to avoid
                        let disablePositions = Array();
                        for (const e of this.room.entities) {
                            if (e !== this) {
                                disablePositions.push({ x: e.x, y: e.y });
                            }
                        }
                        for (let xx = this.x - 1; xx <= this.x + 1; xx++) {
                            for (let yy = this.y - 1; yy <= this.y + 1; yy++) {
                                if (this.room.roomArray[xx][yy] instanceof spiketrap_1.SpikeTrap &&
                                    this.room.roomArray[xx][yy].on) {
                                    // Don't walk on active spike traps
                                    disablePositions.push({ x: xx, y: yy });
                                }
                            }
                        }
                        // Create a grid of the room
                        let grid = [];
                        for (let x = 0; x < this.room.roomX + this.room.width; x++) {
                            grid[x] = [];
                            for (let y = 0; y < this.room.roomY + this.room.height; y++) {
                                if (this.room.roomArray[x] && this.room.roomArray[x][y])
                                    grid[x][y] = this.room.roomArray[x][y];
                                else
                                    grid[x][y] = false;
                            }
                        }
                        // Find a path to the target player
                        let moves = astarclass_1.astar.AStar.search(grid, this, this.targetPlayer, disablePositions, false, false, true, this.direction);
                        // If there are moves available
                        if (moves.length > 0) {
                            let moveX = moves[0].pos.x;
                            let moveY = moves[0].pos.y;
                            let oldDir = this.direction;
                            let player = this.targetPlayer;
                            // Face the target player
                            this.facePlayer(player);
                            // Determine the new direction based on the move
                            if (moveX > oldX)
                                this.direction = game_1.Direction.RIGHT;
                            else if (moveX < oldX)
                                this.direction = game_1.Direction.LEFT;
                            else if (moveY > oldY)
                                this.direction = game_1.Direction.DOWN;
                            else if (moveY < oldY)
                                this.direction = game_1.Direction.UP;
                            // If the direction hasn't changed, attempt to move or attack
                            if (oldDir == this.direction) {
                                let hitPlayer = false;
                                for (const i in this.game.players) {
                                    if (this.game.rooms[this.game.players[i].levelID] === this.room &&
                                        this.game.players[i].x === moveX &&
                                        this.game.players[i].y === moveY) {
                                        // Attack the player if they are in the way
                                        this.game.players[i].hurt(this.hit(), this.name);
                                        this.drawX = 0.5 * (this.x - this.game.players[i].x);
                                        this.drawY = 0.5 * (this.y - this.game.players[i].y);
                                        if (this.game.players[i] ===
                                            this.game.players[this.game.localPlayerID])
                                            this.game.shakeScreen(10 * this.drawX, 10 * this.drawY);
                                    }
                                }
                                if (!hitPlayer) {
                                    // Move to the new position
                                    this.tryMove(moveX, moveY);
                                    this.setDrawXY(moveX, moveY);
                                    if (this.x > moveX)
                                        this.direction = game_1.Direction.RIGHT;
                                    else if (this.x < moveX)
                                        this.direction = game_1.Direction.LEFT;
                                    else if (this.y > moveY)
                                        this.direction = game_1.Direction.DOWN;
                                    else if (this.y < moveY)
                                        this.direction = game_1.Direction.UP;
                                }
                            }
                        }
                        // Add positions to avoid based on the current direction
                        if (this.direction == game_1.Direction.LEFT) {
                            disablePositions.push({
                                x: this.x,
                                y: this.y + 1,
                            });
                            disablePositions.push({
                                x: this.x,
                                y: this.y - 1,
                            });
                        }
                        if (this.direction == game_1.Direction.RIGHT) {
                            disablePositions.push({
                                x: this.x,
                                y: this.y + 1,
                            });
                            disablePositions.push({
                                x: this.x,
                                y: this.y - 1,
                            });
                        }
                        if (this.direction == game_1.Direction.DOWN) {
                            disablePositions.push({
                                x: this.x + 1,
                                y: this.y,
                            });
                            disablePositions.push({
                                x: this.x - 1,
                                y: this.y,
                            });
                        }
                        if (this.direction == game_1.Direction.UP) {
                            disablePositions.push({
                                x: this.x + 1,
                                y: this.y,
                            });
                            disablePositions.push({
                                x: this.x - 1,
                                y: this.y,
                            });
                        }
                        // Make hit warnings
                        this.makeHitWarnings();
                    }
                    // Check if the target player is offline
                    let targetPlayerOffline = Object.values(this.game.offlinePlayers).indexOf(this.targetPlayer) !==
                        -1;
                    // If the enemy is not aggro or the target player is offline, find a new target player
                    if (!this.aggro || targetPlayerOffline) {
                        let p = this.nearestPlayer();
                        if (p !== false) {
                            let [distance, player] = p;
                            if (distance <= 4 &&
                                (targetPlayerOffline ||
                                    distance < this.playerDistance(this.targetPlayer))) {
                                if (player !== this.targetPlayer) {
                                    this.targetPlayer = player;
                                    this.facePlayer(player);
                                    if (player === this.game.players[this.game.localPlayerID])
                                        this.alertTicks = 1;
                                    this.makeHitWarnings();
                                }
                            }
                        }
                    }
                }
            }
        };
        this.onHurt = (damage = 1, type = "none") => {
            if (this.health > 0) {
                if (type === "none") {
                    this.justHurt = true;
                }
            }
        };
        this.stun = () => {
            if (this.stunned)
                return;
            this.stunned = true;
            this.unconscious = true;
            new stunAnimation_1.StunAnimation(this, this.x, this.y);
        };
        this.retreat = (oldX, oldY) => {
            // Calculate direction vector from player to enemy
            let dx = this.x - this.targetPlayer.x;
            let dy = this.y - this.targetPlayer.y;
            // Normalize the direction vector
            let length = Math.sqrt(dx * dx + dy * dy);
            if (length > 0) {
                dx = Math.round(dx / length);
                dy = Math.round(dy / length);
            }
            let retreatX = this.x;
            let retreatY = this.y;
            let foundValidRetreat = false;
            // Determine retreat behavior based on attack properties
            if (this.orthogonalAttack && this.diagonalAttack) {
                // Both enabled: use current behavior (try orthogonal first, then diagonal)
                retreatX = this.x + dx;
                retreatY = this.y + dy;
                if (this.room.isTileEmpty(retreatX, retreatY)) {
                    foundValidRetreat = true;
                }
                else {
                    // Try diagonal positions
                    if (dy === 0)
                        dy = random_1.Random.rand() < 0.5 ? 1 : -1;
                    if (dx === 0)
                        dx = random_1.Random.rand() < 0.5 ? 1 : -1;
                    let diagonal1X = this.x - dy;
                    let diagonal1Y = this.y + dx;
                    let diagonal2X = this.x + dy;
                    let diagonal2Y = this.y - dx;
                    // Randomly choose which diagonal to check first
                    let checkFirst = random_1.Random.rand() < 0.5;
                    let firstX = checkFirst ? diagonal1X : diagonal2X;
                    let firstY = checkFirst ? diagonal1Y : diagonal2Y;
                    let secondX = checkFirst ? diagonal2X : diagonal1X;
                    let secondY = checkFirst ? diagonal2Y : diagonal1Y;
                    // Check first diagonal
                    if (this.room.isTileEmpty(firstX, firstY)) {
                        retreatX = firstX;
                        retreatY = firstY;
                        foundValidRetreat = true;
                    }
                    // Check second diagonal if first is blocked
                    else if (this.room.isTileEmpty(secondX, secondY)) {
                        retreatX = secondX;
                        retreatY = secondY;
                        foundValidRetreat = true;
                    }
                }
            }
            else if (this.orthogonalAttack) {
                // Only orthogonal retreat allowed
                retreatX = this.x + dx;
                retreatY = this.y + dy;
                if (this.room.isTileEmpty(retreatX, retreatY)) {
                    foundValidRetreat = true;
                }
            }
            else if (this.diagonalAttack) {
                if (dy === 0)
                    dy = random_1.Random.rand() < 0.5 ? 1 : -1;
                if (dx === 0)
                    dx = random_1.Random.rand() < 0.5 ? 1 : -1;
                // Only diagonal retreat allowed
                let diagonal1X = this.x - dy;
                let diagonal1Y = this.y + dx;
                let diagonal2X = this.x + dy;
                let diagonal2Y = this.y - dx;
                // Randomly choose which diagonal to check first
                let checkFirst = random_1.Random.rand() < 0.5;
                let firstX = checkFirst ? diagonal1X : diagonal2X;
                let firstY = checkFirst ? diagonal1Y : diagonal2Y;
                let secondX = checkFirst ? diagonal2X : diagonal1X;
                let secondY = checkFirst ? diagonal2Y : diagonal1Y;
                // Check first diagonal
                if (this.room.isTileEmpty(firstX, firstY)) {
                    retreatX = firstX;
                    retreatY = firstY;
                    foundValidRetreat = true;
                }
                // Check second diagonal if first is blocked
                else if (this.room.isTileEmpty(secondX, secondY)) {
                    retreatX = secondX;
                    retreatY = secondY;
                    foundValidRetreat = true;
                }
            }
            // If neither orthogonalAttack nor diagonalAttack is true, don't retreat
            // Only move if we found a valid retreat position
            if (foundValidRetreat) {
                this.tryMove(retreatX, retreatY);
                this.setDrawXY(oldX, oldY);
            }
            this.justHurt = false;
        };
        this.jump = (delta) => {
            let j = Math.max(Math.abs(this.drawX), Math.abs(this.drawY));
            this.jumpY = Math.abs(Math.sin(j * Math.PI)) * this.jumpHeight;
            if (this.jumpY < 0.01)
                this.jumpY = 0;
            if (this.jumpY > this.jumpHeight)
                this.jumpY = this.jumpHeight;
        };
        this.updateDrawXY = (delta) => {
            //putting this here bc i'm lazy
            this.updateHurtFrame(delta);
            this.animateDying(delta);
            if (!this.doneMoving()) {
                this.drawX *= this.drawMoveSpeed ** delta;
                this.drawY *= this.drawMoveSpeed ** delta;
                this.drawX = Math.abs(this.drawX) < 0.01 ? 0 : this.drawX;
                this.drawY = Math.abs(this.drawY) < 0.01 ? 0 : this.drawY;
                this.jump(delta);
            }
            this.updateShadeColor(delta);
        };
        this.setDrawXY = (x, y) => {
            this.drawX += this.x - x;
            this.drawY += this.y - y;
        };
        this.teleport = () => {
            let newTile = this.findFarTile();
            if (newTile) {
                this.drawX = newTile.x - this.x;
                this.drawY = newTile.y - this.y;
                this.x = newTile.x;
                this.y = newTile.y;
                this.lightSource?.updatePosition(this.x + 0.5, this.y + 0.5);
                this.room.updateLighting();
            }
        };
        this.findFarTile = () => {
            // Get all empty tiles
            const emptyTiles = this.room.getEmptyTiles();
            const player = this.getPlayer();
            // Early return if no player or no empty tiles
            if (!player || emptyTiles.length === 0) {
                return null;
            }
            // Calculate distances from player
            const tilesWithDistances = emptyTiles.map((tile) => {
                const distance = utils_1.Utils.distance(tile.x, tile.y, player.x, player.y);
                return { tile, distance };
            });
            // Sort by distance (farthest first)
            tilesWithDistances.sort((a, b) => b.distance - a.distance);
            // Take only the 50% farthest tiles
            const farTiles = tilesWithDistances.slice(0, Math.floor(tilesWithDistances.length / 2));
            // If no far tiles available, return null
            if (farTiles.length === 0) {
                return null;
            }
            // Choose a random tile from the far tiles
            const randomIndex = Math.floor(random_1.Random.rand() * farTiles.length);
            return farTiles[randomIndex].tile;
        };
        this.draw = (delta) => {
            if (!this.dead) {
                this.updateDrawXY(delta);
                this.frame += 0.1 * delta;
                if (this.frame >= 4)
                    this.frame = 0;
                if (this.hasShadow)
                    game_1.Game.drawMob(0, 0, 1, 1, this.x - this.drawX, this.y - this.drawY, 1, 1, this.room.shadeColor, this.shadeAmount());
                game_1.Game.drawMob(this.tileX + Math.floor(this.frame), this.tileY + this.direction * 2, 1, 2, this.x - this.drawX, this.y - this.drawYOffset - this.drawY - this.jumpY, 1, 2, this.softShadeColor, this.shadeAmount());
            }
            if (!this.dying) {
                if (!this.seenPlayer) {
                    this.drawSleepingZs(delta);
                }
                if (this.alertTicks > 0) {
                    this.drawExclamation(delta);
                }
            }
        };
        this.drawYOffset = 1.5;
        this.name = "";
        this.seenPlayer = false;
        this.heardPlayer = false;
        this.ticks = 0;
        this.frame = 0;
        this.health = 1;
        this.maxHealth = 1;
        this.tileX = 17;
        this.tileY = 8;
        this.aggro = false;
        this.jumpY = 0;
        this.jumpHeight = 0.3;
        //this.dir = Direction.South;
        this.name = "generic enemy";
        this.dropChance = 10;
        this.status = {
            poison: { active: false, hitCount: 0, startTick: 0, effectTick: 0 },
            bleed: { active: false, hitCount: 0, startTick: 0, effectTick: 0 },
        };
        this.alertRange = 4;
        this.effectStartTick = 1;
        this.startTick = 1;
        this.isEnemy = true;
        this.poisonHitCount = 0;
        this.bleedHitCount = 0;
        this.drawMoveSpeed = 0.85; //lower is faster
        this.justHurt = false;
        this.orthogonalAttack = false;
        this.diagonalAttack = false;
        //this.getDrop(["weapon", "equipment", "consumable", "gem", "tool", "coin"]);
    }
    get lastPlayerPos() {
        return {
            x: this.targetPlayer.lastX,
            y: this.targetPlayer.lastY,
        };
    }
    get type() {
        return entity_2.EntityType.ENEMY;
    }
}
exports.Enemy = Enemy;
Enemy.difficulty = 1;


/***/ }),

/***/ "./src/entity/enemy/energyWizard.ts":
/*!******************************************!*\
  !*** ./src/entity/enemy/energyWizard.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EnergyWizardEnemy = exports.WizardState = void 0;
const game_1 = __webpack_require__(/*! ../../game */ "./src/game.ts");
const wizardEnemy_1 = __webpack_require__(/*! ./wizardEnemy */ "./src/entity/enemy/wizardEnemy.ts");
var WizardState;
(function (WizardState) {
    WizardState[WizardState["idle"] = 0] = "idle";
    WizardState[WizardState["attack"] = 1] = "attack";
    WizardState[WizardState["justAttacked"] = 2] = "justAttacked";
    WizardState[WizardState["teleport"] = 3] = "teleport";
})(WizardState = exports.WizardState || (exports.WizardState = {}));
class EnergyWizardEnemy extends wizardEnemy_1.WizardEnemy {
    constructor(room, game, x, y, drop) {
        super(room, game, x, y);
        this.draw = (delta) => {
            if (this.dead)
                return;
            game_1.Game.ctx.save();
            game_1.Game.ctx.globalAlpha = this.alpha;
            if (!this.dead) {
                this.updateDrawXY(delta);
                if (this.state === WizardState.attack)
                    this.tileX = 7;
                else
                    this.tileX = 6;
                if (this.hasShadow)
                    game_1.Game.drawMob(0, 0, 1, 1, this.x - this.drawX, this.y - this.drawY, 1, 1, this.room.shadeColor, this.shadeAmount());
                if (this.frame >= 0) {
                    game_1.Game.drawMob(Math.floor(this.frame) + 6, 2, 1, 2, this.x, this.y - 1.5, 1, 2, this.softShadeColor, this.shadeAmount());
                    this.frame += 0.4 * delta;
                    if (this.frame > 11)
                        this.frame = -1;
                }
                else {
                    game_1.Game.drawMob(this.tileX, this.tileY, 1, 2, this.x - this.drawX, this.y - 1.3 - this.drawY, 1, 2, this.softShadeColor, this.shadeAmount());
                }
                if (!this.cloned) {
                    if (!this.seenPlayer) {
                        this.drawSleepingZs(delta);
                    }
                    if (this.alertTicks > 0) {
                        this.drawExclamation(delta);
                    }
                }
            }
            game_1.Game.ctx.restore();
        };
        this.ticks = 0;
        this.health = 1;
        this.tileX = 6;
        this.tileY = 0;
        this.frame = 0;
        this.state = WizardState.attack;
        this.seenPlayer = false;
        this.alertTicks = 0;
        this.name = "wizard bomber";
        this.projectileColor = [0, 50, 150];
        if (drop)
            this.drop = drop;
        this.getDrop(["weapon", "equipment", "consumable", "tool", "coin"]);
    }
}
exports.EnergyWizardEnemy = EnergyWizardEnemy;
EnergyWizardEnemy.difficulty = 3;
EnergyWizardEnemy.tileX = 6;
EnergyWizardEnemy.tileY = 0;


/***/ }),

/***/ "./src/entity/enemy/fireWizard.ts":
/*!****************************************!*\
  !*** ./src/entity/enemy/fireWizard.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FireWizardEnemy = exports.WizardState = void 0;
const game_1 = __webpack_require__(/*! ../../game */ "./src/game.ts");
const wizardTeleportParticle_1 = __webpack_require__(/*! ../../particle/wizardTeleportParticle */ "./src/particle/wizardTeleportParticle.ts");
const wizardFireball_1 = __webpack_require__(/*! ../../projectile/wizardFireball */ "./src/projectile/wizardFireball.ts");
const random_1 = __webpack_require__(/*! ../../utility/random */ "./src/utility/random.ts");
const wizardEnemy_1 = __webpack_require__(/*! ./wizardEnemy */ "./src/entity/enemy/wizardEnemy.ts");
var WizardState;
(function (WizardState) {
    WizardState[WizardState["idle"] = 0] = "idle";
    WizardState[WizardState["attack"] = 1] = "attack";
    WizardState[WizardState["justAttacked"] = 2] = "justAttacked";
    WizardState[WizardState["teleport"] = 3] = "teleport";
})(WizardState = exports.WizardState || (exports.WizardState = {}));
class FireWizardEnemy extends wizardEnemy_1.WizardEnemy {
    constructor(room, game, x, y, drop) {
        super(room, game, x, y);
        this.ATTACK_RADIUS = 5;
        this.hit = () => {
            return 1;
        };
        this.withinAttackingRangeOfPlayer = () => {
            let withinRange = false;
            for (const i in this.game.players) {
                if ((this.x - this.game.players[i].x) ** 2 +
                    (this.y - this.game.players[i].y) ** 2 <=
                    this.ATTACK_RADIUS ** 2) {
                    withinRange = true;
                }
            }
            return withinRange;
        };
        this.shuffle = (a) => {
            let j, x, i;
            for (i = a.length - 1; i > 0; i--) {
                j = Math.floor(random_1.Random.rand() * (i + 1));
                x = a[i];
                a[i] = a[j];
                a[j] = x;
            }
            return a;
        };
        this.behavior = () => {
            this.lastX = this.x;
            this.lastY = this.y;
            if (!this.dead) {
                if (this.skipNextTurns > 0) {
                    this.skipNextTurns--;
                    return;
                }
                if (!this.seenPlayer)
                    this.lookForPlayer();
                else if (this.seenPlayer) {
                    this.alertTicks = Math.max(0, this.alertTicks - 1);
                    switch (this.state) {
                        case WizardState.attack:
                            const nearestPlayerInfo = this.nearestPlayer();
                            if (nearestPlayerInfo !== false) {
                                const [distance, targetPlayer] = nearestPlayerInfo;
                                const attackLength = 20;
                                const offsets = this.calculateProjectileOffsets(targetPlayer.x, targetPlayer.y, 10);
                                this.attemptProjectilePlacement([
                                    { x: -1, y: 0 },
                                    { x: -1, y: -1 },
                                    { x: 1, y: 0 },
                                    { x: 1, y: 1 },
                                    { x: 0, y: -1 },
                                    { x: 1, y: -1 },
                                    { x: 0, y: 1 },
                                    { x: -1, y: 1 },
                                ], wizardFireball_1.WizardFireball, false);
                            }
                            this.state = WizardState.justAttacked;
                            break;
                        case WizardState.justAttacked:
                            this.state = WizardState.idle;
                            break;
                        case WizardState.teleport:
                            let oldX = this.x;
                            let oldY = this.y;
                            let min = 100000;
                            let bestPos;
                            let emptyTiles = this.shuffle(this.room.getEmptyTiles());
                            emptyTiles = emptyTiles.filter((tile) => !this.room.projectiles.some((projectile) => projectile.x === tile.x && projectile.y === tile.y));
                            if (emptyTiles.length === 0 ||
                                Object.keys(this.game.players).length === 0) {
                                this.state = WizardState.idle;
                                break;
                            }
                            let optimalDist = game_1.Game.randTable([2, 2, 3, 3, 3, 3, 3], random_1.Random.rand);
                            let player_ids = [];
                            for (const i in this.game.players)
                                player_ids.push(i);
                            let target_player_id = game_1.Game.randTable(player_ids, random_1.Random.rand);
                            if (!this.game.players[target_player_id]) {
                                this.state = WizardState.idle;
                                break;
                            }
                            for (let t of emptyTiles) {
                                let newPos = t;
                                let dist = Math.abs(newPos.x - this.game.players[target_player_id].x) +
                                    Math.abs(newPos.y - this.game.players[target_player_id].y);
                                if (Math.abs(dist - optimalDist) < Math.abs(min - optimalDist)) {
                                    min = dist;
                                    bestPos = newPos;
                                }
                            }
                            if (!bestPos) {
                                bestPos = emptyTiles[0];
                            }
                            this.tryMove(bestPos.x, bestPos.y);
                            this.drawX = this.x - oldX;
                            this.drawY = this.y - oldY;
                            this.frame = 0;
                            this.room.particles.push(new wizardTeleportParticle_1.WizardTeleportParticle(oldX, oldY));
                            if (this.withinAttackingRangeOfPlayer()) {
                                this.state = WizardState.attack;
                            }
                            else {
                                this.state = WizardState.idle;
                            }
                            break;
                        case WizardState.idle:
                            this.state = WizardState.teleport;
                            break;
                    }
                }
            }
        };
        this.draw = (delta) => {
            this.frame += 0.1 * delta;
            game_1.Game.ctx.save();
            game_1.Game.ctx.globalAlpha = this.alpha;
            if (this.frame >= 4)
                this.frame = 0;
            if (!this.dead) {
                this.updateDrawXY(delta);
                if (this.hasShadow)
                    game_1.Game.drawMob(0, 0, 1, 1, this.x - this.drawX, this.y - this.drawY, 1, 1, this.room.shadeColor, this.shadeAmount());
                if (this.frame >= 0) {
                    game_1.Game.drawMob(this.tileX + Math.floor(this.frame), this.tileY, 1, 2, this.x - this.drawX, this.y - 1.3 - this.drawY, 1, 2, this.softShadeColor, this.shadeAmount());
                }
                else {
                    game_1.Game.drawMob(this.tileX, this.tileY, 1, 2, this.x - this.drawX, this.y - 1.3 - this.drawY, 1, 2, this.softShadeColor, this.shadeAmount());
                }
                if (!this.seenPlayer) {
                    this.drawSleepingZs(delta);
                }
                if (this.alertTicks > 0) {
                    this.drawExclamation(delta);
                }
            }
            game_1.Game.ctx.restore();
        };
        this.ticks = 0;
        this.health = 1;
        this.tileX = 35;
        this.tileY = 8;
        this.frame = 0;
        this.state = WizardState.attack;
        this.seenPlayer = false;
        this.alertTicks = 0;
        this.name = "fire wizard";
        this.projectileColor = [200, 20, 0];
        if (drop)
            this.drop = drop;
        this.jumpHeight = 0.5;
        this.getDrop(["weapon", "equipment", "consumable", "tool", "coin"]);
    }
}
exports.FireWizardEnemy = FireWizardEnemy;
FireWizardEnemy.difficulty = 3;
FireWizardEnemy.tileX = 35;
FireWizardEnemy.tileY = 8;


/***/ }),

/***/ "./src/entity/enemy/frogEnemy.ts":
/*!***************************************!*\
  !*** ./src/entity/enemy/frogEnemy.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FrogEnemy = void 0;
const game_1 = __webpack_require__(/*! ../../game */ "./src/game.ts");
const astarclass_1 = __webpack_require__(/*! ../../utility/astarclass */ "./src/utility/astarclass.ts");
const hitWarning_1 = __webpack_require__(/*! ../../drawable/hitWarning */ "./src/drawable/hitWarning.ts");
const spiketrap_1 = __webpack_require__(/*! ../../tile/spiketrap */ "./src/tile/spiketrap.ts");
const coin_1 = __webpack_require__(/*! ../../item/coin */ "./src/item/coin.ts");
const enemy_1 = __webpack_require__(/*! ./enemy */ "./src/entity/enemy/enemy.ts");
const utils_1 = __webpack_require__(/*! ../../utility/utils */ "./src/utility/utils.ts");
class FrogEnemy extends enemy_1.Enemy {
    constructor(room, game, x, y, drop) {
        super(room, game, x, y);
        this.hit = () => {
            return 0.5;
        };
        this.behavior = () => {
            this.lastX = this.x;
            this.lastY = this.y;
            this.tileX = 1;
            this.frameLength = 3;
            this.animationSpeed = 0.1;
            if (!this.dead) {
                if (this.skipNextTurns > 0) {
                    this.skipNextTurns--;
                    return;
                }
                if (!this.seenPlayer) {
                    this.tileX = 12;
                    this.lookForPlayer();
                }
                else if (this.seenPlayer) {
                    this.tileX = 1;
                    if (this.room.playerTicked === this.targetPlayer) {
                        this.alertTicks = Math.max(0, this.alertTicks - 1);
                        this.ticks++;
                        if (this.ticks % 2 === 1) {
                            this.rumbling = true;
                            let oldX = this.x;
                            let oldY = this.y;
                            let disablePositions = Array();
                            for (const e of this.room.entities) {
                                if (e !== this) {
                                    disablePositions.push({ x: e.x, y: e.y });
                                }
                            }
                            for (let xx = this.x - 1; xx <= this.x + 1; xx++) {
                                for (let yy = this.y - 1; yy <= this.y + 1; yy++) {
                                    if (this.room.roomArray[xx][yy] instanceof spiketrap_1.SpikeTrap &&
                                        this.room.roomArray[xx][yy].on) {
                                        // don't walk on active spiketraps
                                        disablePositions.push({ x: xx, y: yy });
                                    }
                                }
                            }
                            let grid = [];
                            for (let x = 0; x < this.room.roomX + this.room.width; x++) {
                                grid[x] = [];
                                for (let y = 0; y < this.room.roomY + this.room.height; y++) {
                                    if (this.room.roomArray[x] && this.room.roomArray[x][y])
                                        grid[x][y] = this.room.roomArray[x][y];
                                    else
                                        grid[x][y] = false;
                                }
                            }
                            let targetPosition = {
                                x: this.targetPlayer.x,
                                y: this.targetPlayer.y,
                            };
                            let dx = this.targetPlayer.x - this.x;
                            let dy = this.targetPlayer.y - this.y;
                            if ((dx === 0 && dy <= 1) ||
                                (dx <= 1 && dy === 0) ||
                                (dx === 0 && dy >= -1) ||
                                (dx >= -1 && dy === 0)) {
                                let jumpOverX = this.targetPlayer.x + dx;
                                let jumpOverY = this.targetPlayer.y + dy;
                                if (this.room.roomArray[jumpOverX] &&
                                    this.room.roomArray[jumpOverX][jumpOverY]) {
                                    if (!this.room.roomArray[jumpOverX][jumpOverY].isSolid()) {
                                        targetPosition = {
                                            x: jumpOverX,
                                            y: jumpOverY,
                                        };
                                    }
                                }
                            }
                            let moves = astarclass_1.astar.AStar.search(grid, this, targetPosition, disablePositions, false, false, false, undefined, undefined, false, this.lastPlayerPos);
                            //console.log(moves); //DON'T REMOVE THIS
                            if (moves[1]) {
                                let hitPlayer = false;
                                for (const i in this.game.players) {
                                    if (this.game.rooms[this.game.players[i].levelID] === this.room &&
                                        this.game.players[i].x === moves[1].pos.x &&
                                        this.game.players[i].y === moves[1].pos.y) {
                                        this.game.players[i].hurt(this.hit(), this.name);
                                        this.drawX += 1.5 * (this.x - this.game.players[i].x);
                                        this.drawY += 1.5 * (this.y - this.game.players[i].y);
                                        if (this.game.players[i] ===
                                            this.game.players[this.game.localPlayerID])
                                            this.game.shakeScreen(5 * this.drawX, 5 * this.drawY);
                                        hitPlayer = true;
                                    }
                                }
                                if (!hitPlayer) {
                                    if (moves.length > 1) {
                                        let moveX = moves[1].pos.x;
                                        let moveY = moves[1].pos.y;
                                        this.tryMove(moveX, moveY);
                                        this.setDrawXY(this.lastX, this.lastY);
                                        if (this.jumping) {
                                            this.frame = 8;
                                            this.animationSpeed = 1;
                                        }
                                        if (this.x > moveX)
                                            this.direction = game_1.Direction.RIGHT;
                                        else if (this.x < moveX)
                                            this.direction = game_1.Direction.LEFT;
                                        else if (this.y > moveY)
                                            this.direction = game_1.Direction.DOWN;
                                        else if (this.y < moveY)
                                            this.direction = game_1.Direction.UP;
                                    }
                                }
                            }
                            this.rumbling = false;
                        }
                        else {
                            this.makeHitWarnings();
                            this.rumbling = true;
                            this.tileX = 3;
                            this.frame = 0;
                            this.frameLength = 2;
                            this.animationSpeed = 0.2;
                        }
                    }
                    let targetPlayerOffline = Object.values(this.game.offlinePlayers).indexOf(this.targetPlayer) !==
                        -1;
                    if (!this.aggro || targetPlayerOffline) {
                        let p = this.nearestPlayer();
                        if (p !== false) {
                            let [distance, player] = p;
                            if (distance <= 4 &&
                                (targetPlayerOffline ||
                                    distance < this.playerDistance(this.targetPlayer))) {
                                if (player !== this.targetPlayer) {
                                    this.targetPlayer = player;
                                    this.facePlayer(player);
                                    if (player === this.game.players[this.game.localPlayerID])
                                        this.alertTicks = 1;
                                    if (this.ticks % 2 === 0) {
                                        this.makeHitWarnings();
                                    }
                                }
                            }
                        }
                    }
                }
            }
        };
        this.jump = (delta) => {
            //console.log(`this.drawX, this.drawY: ${this.drawX}, ${this.drawY}`);
            if (this.jumping) {
                let j = Math.max(Math.abs(this.drawX), Math.abs(this.drawY));
                if (j > 1) {
                    this.jumpDistance = 2;
                }
                this.jumpY =
                    Math.sin((j / this.jumpDistance) * Math.PI) * this.jumpHeight;
                if (this.jumpY < 0.01 && this.jumpY > -0.01) {
                    this.jumpY = 0;
                    this.jumpDistance = 1;
                }
                if (this.jumpY > this.jumpHeight)
                    this.jumpY = this.jumpHeight;
            }
        };
        this.makeHitWarnings = () => {
            const cullFactor = 0.25;
            const player = this.getPlayer();
            const orthogonal = this.orthogonalAttack;
            const diagonal = this.diagonalAttack;
            const forwardOnly = this.forwardOnlyAttack;
            const direction = this.direction;
            const orthoRange = this.attackRange;
            const diagRange = this.diagonalAttackRange;
            const generateOffsets = (isOrthogonal, range) => {
                const baseOffsets = isOrthogonal
                    ? [
                        [-2, 0],
                        [2, 0],
                        [0, -2],
                        [0, 2],
                    ]
                    : [
                        [-1, -1],
                        [1, 1],
                        [1, -1],
                        [-1, 1],
                    ];
                return baseOffsets.flatMap(([dx, dy]) => Array.from({ length: range }, (_, i) => [(i + 1) * dx, (i + 1) * dy]));
            };
            const directionOffsets = {
                [game_1.Direction.LEFT]: [-1, 0],
                [game_1.Direction.RIGHT]: [1, 0],
                [game_1.Direction.UP]: [0, -1],
                [game_1.Direction.DOWN]: [0, 1],
            };
            let offsets = [];
            if (forwardOnly) {
                const [dx, dy] = directionOffsets[direction];
                offsets = Array.from({ length: orthoRange }, (_, i) => [
                    (i + 1) * dx,
                    (i + 1) * dy,
                ]);
            }
            else {
                if (orthogonal)
                    offsets.push(...generateOffsets(true, orthoRange));
                if (diagonal)
                    offsets.push(...generateOffsets(false, diagRange));
            }
            const warningCoordinates = offsets
                .map(([dx, dy]) => ({
                x: dx,
                y: dy,
                distance: utils_1.Utils.distance(dx, dy, player.x - this.x, player.y - this.y),
            }))
                .sort((a, b) => a.distance - b.distance);
            const keepCount = Math.ceil(warningCoordinates.length * (1 - cullFactor));
            const culledWarnings = warningCoordinates.slice(0, keepCount);
            culledWarnings.forEach(({ x, y }) => {
                const targetX = this.x + x;
                const targetY = this.y + y;
                if (this.isWithinRoomBounds(targetX, targetY)) {
                    const hitWarning = new hitWarning_1.HitWarning(this.game, targetX, targetY, this.x, this.y, true, false, this);
                    this.room.hitwarnings.push(hitWarning);
                    //this.hitWarnings.push(hitWarning);
                }
            });
        };
        this.draw = (delta) => {
            if (this.dead)
                return;
            game_1.Game.ctx.save();
            game_1.Game.ctx.globalAlpha = this.alpha;
            if (!this.dead) {
                this.updateDrawXY(delta);
                this.frame += this.animationSpeed * delta;
                if (this.frame >= this.frameLength) {
                    this.frame = 0;
                }
                let rumbleX = this.rumble(this.rumbling, this.frame).x;
                let rumbleY = this.rumble(this.rumbling, this.frame).y;
                if (this.drawX !== 0 || this.drawY !== 0) {
                    this.jumping = true;
                }
                else {
                    this.jumping = false;
                }
                if (this.jumping) {
                    this.frameLength = 10;
                    this.animationSpeed = 0.4;
                }
                else {
                    this.frameLength = 3;
                    this.animationSpeed = 0.1;
                }
                if (this.hasShadow)
                    game_1.Game.drawMob(0, 0, 1, 1, this.x - this.drawX, this.y - this.drawY, 1, 1, this.room.shadeColor, this.shadeAmount());
                game_1.Game.drawMob(this.tileX +
                    (this.tileX !== 12 && !this.rumbling ? Math.floor(this.frame) : 0), this.tileY /*+ this.direction * 2,*/, 1, 2, this.x + rumbleX - this.drawX, this.y - this.drawYOffset - this.drawY - this.jumpY, 1, 2, this.softShadeColor, this.shadeAmount());
            }
            if (!this.cloned) {
                if (!this.seenPlayer) {
                    this.drawSleepingZs(delta);
                }
                if (this.alertTicks > 0) {
                    this.drawExclamation(delta);
                }
            }
            game_1.Game.ctx.restore();
        };
        this.ticks = 0;
        this.frame = 0;
        this.health = 1;
        this.maxHealth = 1;
        this.tileX = 12;
        this.tileY = 16;
        this.seenPlayer = false;
        this.aggro = false;
        this.deathParticleColor = "#ffffff";
        this.frameLength = 3;
        this.startFrame = 0;
        this.animationSpeed = 0.1;
        this.tickCount = 0;
        this.jumping = false;
        this.jumpDistance = 1;
        this.drop = drop ? drop : new coin_1.Coin(this.room, this.x, this.y);
        this.name = "frog";
        this.orthogonalAttack = true;
        this.diagonalAttack = true;
        this.jumpHeight = 1;
        this.imageParticleX = 3;
        this.imageParticleY = 30;
        if (drop)
            this.drop = drop;
        this.getDrop(["weapon", "consumable", "tool", "coin", "poison"]);
    }
}
exports.FrogEnemy = FrogEnemy;
FrogEnemy.difficulty = 1;
FrogEnemy.tileX = 12;
FrogEnemy.tileY = 16;


/***/ }),

/***/ "./src/entity/enemy/glowBugEnemy.ts":
/*!******************************************!*\
  !*** ./src/entity/enemy/glowBugEnemy.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GlowBugEnemy = void 0;
const game_1 = __webpack_require__(/*! ../../game */ "./src/game.ts");
const gameConstants_1 = __webpack_require__(/*! ../../game/gameConstants */ "./src/game/gameConstants.ts");
const glowBugs_1 = __webpack_require__(/*! ../../item/light/glowBugs */ "./src/item/light/glowBugs.ts");
const lightSource_1 = __webpack_require__(/*! ../../lighting/lightSource */ "./src/lighting/lightSource.ts");
const entity_1 = __webpack_require__(/*! ../entity */ "./src/entity/entity.ts");
class GlowBugEnemy extends entity_1.Entity {
    constructor(room, game, x, y, drop) {
        super(room, game, x, y);
        this.hit = () => {
            return 0.5;
        };
        this.behavior = () => {
            this.lastX = this.x;
            this.lastY = this.y;
            this.seenPlayer = true;
            this.aggro = true;
            if (!this.dead) {
                if (this.skipNextTurns > 0) {
                    this.skipNextTurns--;
                    return;
                }
                this.wander();
                this.lightSource.x = this.x + 0.5;
                this.lightSource.y = this.y + 0.5;
                this.room.updateLighting();
            }
        };
        this.draw = (delta) => {
            if (this.dead)
                return;
            game_1.Game.ctx.save();
            game_1.Game.ctx.globalAlpha = this.alpha;
            if (!this.dead) {
                this.updateDrawXY(delta);
                this.frame += 0.15 * delta;
                if (this.frame >= 4)
                    this.frame = 0;
                this.tileX = 8 + this.frame;
                if (this.hasShadow)
                    game_1.Game.drawMob(0, 0, 1, 1, this.x - this.drawX, this.y - this.drawY, 1, 1, this.room.shadeColor, this.shadeAmount());
                game_1.Game.drawMob(Math.floor(this.tileX), this.tileY, 1, 1, this.x - this.drawX, this.y - this.drawYOffset - this.drawY, 1, 1, this.softShadeColor, this.shadeAmount());
                if (this.crushed) {
                    this.crushAnim(delta);
                }
            }
            if (!this.cloned) {
                if (!this.seenPlayer) {
                    this.drawSleepingZs(delta, 0, 0.75 * gameConstants_1.GameConstants.TILESIZE);
                }
                if (this.alertTicks > 0) {
                    this.drawExclamation(delta, 0, 0.75 * gameConstants_1.GameConstants.TILESIZE);
                }
            }
            game_1.Game.ctx.restore();
        };
        this.ticks = 0;
        this.frame = 0;
        this.health = 1;
        this.maxHealth = 1;
        this.tileX = 8;
        this.tileY = 0;
        this.seenPlayer = false;
        this.aggro = false;
        this.name = "glowbug";
        this.orthogonalAttack = true;
        this.imageParticleX = 3;
        this.imageParticleY = 24;
        //if (drop) this.drop = drop;
        this.drawYOffset = 1;
        this.hasShadow = true;
        this.hasHitParticles = false;
        this.hasDamageNumbers = false;
        this.hasBloom = true;
        this.bloomAlpha = 1;
        this.bloomColor = "#054B4B";
        this.lightSource = new lightSource_1.LightSource(this.x + 0.5, this.y + 0.5, 6, [5, 75, 75]);
        this.addLightSource(this.lightSource);
        this.drops = [new glowBugs_1.GlowBugs(this.room, this.x, this.y)]; //this.getDrop(["weapon", "equipment", "consumable", "tool", "coin"]);
    }
    get alertText() {
        return `New Enemy Spotted: Crab 
    Health: ${this.health}
    Attack Pattern: Omnidirectional
    Moves every other turn`;
    }
}
exports.GlowBugEnemy = GlowBugEnemy;
GlowBugEnemy.difficulty = 1;
GlowBugEnemy.tileX = 8;
GlowBugEnemy.tileY = 4;


/***/ }),

/***/ "./src/entity/enemy/knightEnemy.ts":
/*!*****************************************!*\
  !*** ./src/entity/enemy/knightEnemy.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.KnightEnemy = void 0;
const game_1 = __webpack_require__(/*! ../../game */ "./src/game.ts");
const astarclass_1 = __webpack_require__(/*! ../../utility/astarclass */ "./src/utility/astarclass.ts");
const spiketrap_1 = __webpack_require__(/*! ../../tile/spiketrap */ "./src/tile/spiketrap.ts");
const enemy_1 = __webpack_require__(/*! ./enemy */ "./src/entity/enemy/enemy.ts");
class KnightEnemy extends enemy_1.Enemy {
    constructor(room, game, x, y, drop) {
        super(room, game, x, y);
        this.hit = () => {
            return 1;
        };
        this.behavior = () => {
            this.lastX = this.x;
            this.lastY = this.y;
            if (!this.dead) {
                if (this.skipNextTurns > 0) {
                    this.skipNextTurns--;
                    return;
                }
                if (!this.seenPlayer) {
                    const result = this.nearestPlayer();
                    if (result !== false) {
                        let [distance, p] = result;
                        if (distance < 4) {
                            this.rumbling = true;
                            this.seenPlayer = true;
                            this.targetPlayer = p;
                            this.facePlayer(p);
                            if (p === this.game.players[this.game.localPlayerID])
                                this.alertTicks = 1;
                            this.makeHitWarnings();
                        }
                    }
                }
                else if (this.seenPlayer) {
                    if (this.room.playerTicked === this.targetPlayer) {
                        this.alertTicks = Math.max(0, this.alertTicks - 1);
                        this.ticks++;
                        if (this.ticks % 2 === 1) {
                            this.rumbling = true;
                            let oldX = this.x;
                            let oldY = this.y;
                            let disablePositions = Array();
                            for (const e of this.room.entities) {
                                if (e !== this) {
                                    disablePositions.push({ x: e.x, y: e.y });
                                }
                            }
                            for (let xx = this.x - 1; xx <= this.x + 1; xx++) {
                                for (let yy = this.y - 1; yy <= this.y + 1; yy++) {
                                    if (this.room.roomArray[xx][yy] instanceof spiketrap_1.SpikeTrap &&
                                        this.room.roomArray[xx][yy].on) {
                                        // don't walk on active spiketraps
                                        disablePositions.push({ x: xx, y: yy });
                                    }
                                }
                            }
                            let grid = [];
                            for (let x = 0; x < this.room.roomX + this.room.width; x++) {
                                grid[x] = [];
                                for (let y = 0; y < this.room.roomY + this.room.height; y++) {
                                    if (this.room.roomArray[x] && this.room.roomArray[x][y])
                                        grid[x][y] = this.room.roomArray[x][y];
                                    else
                                        grid[x][y] = false;
                                }
                            }
                            let moves = astarclass_1.astar.AStar.search(grid, this, this.targetPlayer, disablePositions, undefined, undefined, undefined, undefined, undefined, undefined, this.lastPlayerPos);
                            if (moves.length > 0) {
                                let hitPlayer = false;
                                for (const i in this.game.players) {
                                    if (this.game.rooms[this.game.players[i].levelID] === this.room &&
                                        this.game.players[i].x === moves[0].pos.x &&
                                        this.game.players[i].y === moves[0].pos.y) {
                                        this.game.players[i].hurt(this.hit(), this.name);
                                        this.drawX = 0.5 * (this.x - this.game.players[i].x);
                                        this.drawY = 0.5 * (this.y - this.game.players[i].y);
                                        if (this.game.players[i] ===
                                            this.game.players[this.game.localPlayerID])
                                            this.game.shakeScreen(10 * this.drawX, 10 * this.drawY);
                                        hitPlayer = true;
                                    }
                                }
                                if (!hitPlayer) {
                                    this.tryMove(moves[0].pos.x, moves[0].pos.y);
                                    this.setDrawXY(oldX, oldY);
                                    if (this.x > oldX)
                                        this.direction = game_1.Direction.RIGHT;
                                    else if (this.x < oldX)
                                        this.direction = game_1.Direction.LEFT;
                                    else if (this.y > oldY)
                                        this.direction = game_1.Direction.DOWN;
                                    else if (this.y < oldY)
                                        this.direction = game_1.Direction.UP;
                                }
                            }
                            this.rumbling = false;
                        }
                        else {
                            this.rumbling = true;
                            this.makeHitWarnings();
                        }
                    }
                    let targetPlayerOffline = Object.values(this.game.offlinePlayers).indexOf(this.targetPlayer) !==
                        -1;
                    if (!this.aggro || targetPlayerOffline) {
                        let p = this.nearestPlayer();
                        if (p !== false) {
                            let [distance, player] = p;
                            if (distance <= 4 &&
                                (targetPlayerOffline ||
                                    distance < this.playerDistance(this.targetPlayer))) {
                                if (player !== this.targetPlayer) {
                                    this.targetPlayer = player;
                                    this.facePlayer(player);
                                    if (player === this.game.players[this.game.localPlayerID])
                                        this.alertTicks = 1;
                                    if (this.ticks % 2 === 0) {
                                        this.rumbling = true;
                                        this.makeHitWarnings();
                                    }
                                }
                            }
                        }
                    }
                }
            }
        };
        this.draw = (delta) => {
            if (this.dead)
                return;
            game_1.Game.ctx.save();
            game_1.Game.ctx.globalAlpha = this.alpha;
            let rumbleX = this.rumble(this.rumbling, this.frame).x;
            let rumbleY = this.rumble(this.rumbling, this.frame, this.direction).y;
            if (!this.dead) {
                this.updateDrawXY(delta);
                if (this.ticks % 2 === 0) {
                    this.tileX = 9;
                    this.tileY = 8;
                }
                else {
                    this.tileX = 4;
                    this.tileY = 0;
                }
                this.frame += 0.1 * delta;
                if (this.frame >= 4)
                    this.frame = 0;
                if (this.hasShadow)
                    game_1.Game.drawMob(0, 0, 1, 1, this.x - this.drawX, this.y - this.drawY, 1, 1, this.room.shadeColor, this.shadeAmount());
                game_1.Game.drawMob(this.tileX + (this.tileX === 4 ? 0 : Math.floor(this.frame)), this.tileY + this.direction * 2, 1, 2, this.x - this.drawX + rumbleX, this.y -
                    this.drawYOffset -
                    this.drawY +
                    (this.tileX === 4 ? 0.1875 : 0), 1, 2, this.softShadeColor, this.shadeAmount());
            }
            if (!this.cloned) {
                if (!this.seenPlayer) {
                    this.drawSleepingZs(delta);
                }
                if (this.alertTicks > 0) {
                    this.drawExclamation(delta);
                }
            }
            game_1.Game.ctx.restore();
        };
        this.ticks = 0;
        this.frame = 0;
        this.health = 2;
        this.maxHealth = 2;
        this.tileX = 9;
        this.tileY = 8;
        this.seenPlayer = false;
        this.aggro = false;
        this.deathParticleColor = "#ffffff";
        this.lastX = this.x;
        this.lastY = this.y;
        this.name = "burrow knight";
        this.orthogonalAttack = true;
        this.imageParticleX = 3;
        this.imageParticleY = 29;
        if (drop)
            this.drop = drop;
        this.getDrop([
            "weapon",
            "warhammer",
            "equipment",
            "consumable",
            "tool",
            "coin",
        ]);
    }
}
exports.KnightEnemy = KnightEnemy;
KnightEnemy.difficulty = 2;
KnightEnemy.tileX = 9;
KnightEnemy.tileY = 8;


/***/ }),

/***/ "./src/entity/enemy/mummyEnemy.ts":
/*!****************************************!*\
  !*** ./src/entity/enemy/mummyEnemy.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MummyEnemy = void 0;
const game_1 = __webpack_require__(/*! ../../game */ "./src/game.ts");
const astarclass_1 = __webpack_require__(/*! ../../utility/astarclass */ "./src/utility/astarclass.ts");
const spiketrap_1 = __webpack_require__(/*! ../../tile/spiketrap */ "./src/tile/spiketrap.ts");
const enemy_1 = __webpack_require__(/*! ./enemy */ "./src/entity/enemy/enemy.ts");
class MummyEnemy extends enemy_1.Enemy {
    constructor(room, game, x, y, drop) {
        super(room, game, x, y);
        this.hit = () => {
            return 1;
        };
        this.behavior = () => {
            // Store the current position
            this.lastX = this.x;
            this.lastY = this.y;
            // If the enemy is not dead
            if (!this.dead) {
                // Skip turns if necessary
                if (this.skipNextTurns > 0) {
                    this.skipNextTurns--;
                    return;
                }
                // Increment the tick counter
                this.ticks++;
                // If the enemy has not seen the player yet
                if (!this.seenPlayer)
                    this.lookForPlayer();
                else if (this.seenPlayer) {
                    // If the target player has taken their turn
                    if (this.room.playerTicked === this.targetPlayer) {
                        // Decrement alert ticks
                        this.alertTicks = Math.max(0, this.alertTicks - 1);
                        // Store the old position
                        let oldX = this.x;
                        let oldY = this.y;
                        // Create a list of positions to avoid
                        let disablePositions = Array();
                        for (const e of this.room.entities) {
                            if (e !== this) {
                                disablePositions.push({ x: e.x, y: e.y });
                            }
                        }
                        for (let xx = this.x - 1; xx <= this.x + 1; xx++) {
                            for (let yy = this.y - 1; yy <= this.y + 1; yy++) {
                                if (this.room.roomArray[xx][yy] instanceof spiketrap_1.SpikeTrap &&
                                    this.room.roomArray[xx][yy].on) {
                                    // Don't walk on active spike traps
                                    disablePositions.push({ x: xx, y: yy });
                                }
                            }
                        }
                        // Create a grid of the room
                        let grid = [];
                        for (let x = 0; x < this.room.roomX + this.room.width; x++) {
                            grid[x] = [];
                            for (let y = 0; y < this.room.roomY + this.room.height; y++) {
                                if (this.room.roomArray[x] && this.room.roomArray[x][y])
                                    grid[x][y] = this.room.roomArray[x][y];
                                else
                                    grid[x][y] = false;
                            }
                        }
                        // Find a path to the target player
                        let moves = astarclass_1.astar.AStar.search(grid, this, this.targetPlayer, disablePositions, false, false, true, this.direction);
                        // If there are moves available
                        if (moves.length > 0) {
                            let moveX = moves[0].pos.x;
                            let moveY = moves[0].pos.y;
                            let oldDir = this.direction;
                            let player = this.targetPlayer;
                            // Face the target player
                            this.facePlayer(player);
                            // Determine the new direction based on the move
                            if (moveX > oldX)
                                this.direction = game_1.Direction.RIGHT;
                            else if (moveX < oldX)
                                this.direction = game_1.Direction.LEFT;
                            else if (moveY > oldY)
                                this.direction = game_1.Direction.DOWN;
                            else if (moveY < oldY)
                                this.direction = game_1.Direction.UP;
                            // If the direction hasn't changed, attempt to move or attack
                            if (oldDir == this.direction) {
                                let hitPlayer = false;
                                for (const i in this.game.players) {
                                    if (this.game.rooms[this.game.players[i].levelID] === this.room &&
                                        this.game.players[i].x === moveX &&
                                        this.game.players[i].y === moveY) {
                                        // Attack the player if they are in the way
                                        this.game.players[i].hurt(this.hit(), this.name);
                                        this.drawX = 0.5 * (this.x - this.game.players[i].x);
                                        this.drawY = 0.5 * (this.y - this.game.players[i].y);
                                        if (this.game.players[i] ===
                                            this.game.players[this.game.localPlayerID])
                                            this.game.shakeScreen(10 * this.drawX, 10 * this.drawY);
                                    }
                                }
                                if (!hitPlayer) {
                                    // Move to the new position
                                    this.tryMove(moveX, moveY);
                                    this.setDrawXY(oldX, oldY);
                                    if (this.x > oldX)
                                        this.direction = game_1.Direction.RIGHT;
                                    else if (this.x < oldX)
                                        this.direction = game_1.Direction.LEFT;
                                    else if (this.y > oldY)
                                        this.direction = game_1.Direction.DOWN;
                                    else if (this.y < oldY)
                                        this.direction = game_1.Direction.UP;
                                }
                            }
                        }
                        // Add positions to avoid based on the current direction
                        if (this.direction == game_1.Direction.LEFT) {
                            disablePositions.push({
                                x: this.x,
                                y: this.y + 1,
                            });
                            disablePositions.push({
                                x: this.x,
                                y: this.y - 1,
                            });
                        }
                        if (this.direction == game_1.Direction.RIGHT) {
                            disablePositions.push({
                                x: this.x,
                                y: this.y + 1,
                            });
                            disablePositions.push({
                                x: this.x,
                                y: this.y - 1,
                            });
                        }
                        if (this.direction == game_1.Direction.DOWN) {
                            disablePositions.push({
                                x: this.x + 1,
                                y: this.y,
                            });
                            disablePositions.push({
                                x: this.x - 1,
                                y: this.y,
                            });
                        }
                        if (this.direction == game_1.Direction.UP) {
                            disablePositions.push({
                                x: this.x + 1,
                                y: this.y,
                            });
                            disablePositions.push({
                                x: this.x - 1,
                                y: this.y,
                            });
                        }
                        // Make hit warnings
                        this.makeHitWarnings();
                    }
                    // Check if the target player is offline
                    let targetPlayerOffline = Object.values(this.game.offlinePlayers).indexOf(this.targetPlayer) !==
                        -1;
                    // If the enemy is not aggro or the target player is offline, find a new target player
                    if (!this.aggro || targetPlayerOffline) {
                        let p = this.nearestPlayer();
                        if (p !== false) {
                            let [distance, player] = p;
                            if (distance <= 4 &&
                                (targetPlayerOffline ||
                                    distance < this.playerDistance(this.targetPlayer))) {
                                if (player !== this.targetPlayer) {
                                    this.targetPlayer = player;
                                    this.facePlayer(player);
                                    if (player === this.game.players[this.game.localPlayerID])
                                        this.alertTicks = 1;
                                    this.makeHitWarnings();
                                }
                            }
                        }
                    }
                }
            }
        };
        this.draw = (delta) => {
            if (this.dead)
                return;
            //this.updateShadeColor(delta);
            game_1.Game.ctx.globalAlpha = this.alpha;
            this.updateDrawXY(delta);
            this.frame += 0.1 * delta;
            if (this.frame >= 4)
                this.frame = 0;
            if (this.hasShadow)
                game_1.Game.drawMob(0, 0, 1, 1, this.x - this.drawX, this.y - this.drawY, 1, 1, this.shadeColor, this.shadeAmount());
            game_1.Game.drawMob(this.tileX + Math.floor(this.frame), this.tileY + this.direction * 2, 1, 2, this.x - this.drawX, this.y - this.drawYOffset - this.drawY - this.jumpY, 1, 2, this.softShadeColor, this.shadeAmount());
            if (!this.cloned) {
                if (!this.seenPlayer) {
                    this.drawSleepingZs(delta);
                }
                if (this.alertTicks > 0) {
                    this.drawExclamation(delta);
                }
            }
            game_1.Game.ctx.globalAlpha = 1;
        };
        this.ticks = 0;
        this.frame = 0;
        this.health = 1;
        this.maxHealth = 1;
        this.tileX = 17;
        this.tileY = 16;
        this.seenPlayer = false;
        this.aggro = false;
        this.dir = game_1.Direction.DOWN;
        this.name = "mummy";
        this.forwardOnlyAttack = true;
        this.jumpHeight = 0.35;
        if (drop)
            this.drop = drop;
        this.getDrop(["consumable", "tool", "coin"]);
    }
}
exports.MummyEnemy = MummyEnemy;
MummyEnemy.difficulty = 1;
MummyEnemy.tileX = 17;
MummyEnemy.tileY = 16;


/***/ }),

/***/ "./src/entity/enemy/occultistEnemy.ts":
/*!********************************************!*\
  !*** ./src/entity/enemy/occultistEnemy.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.OccultistEnemy = void 0;
const game_1 = __webpack_require__(/*! ../../game */ "./src/game.ts");
const enemy_1 = __webpack_require__(/*! ./enemy */ "./src/entity/enemy/enemy.ts");
const utils_1 = __webpack_require__(/*! ../../utility/utils */ "./src/utility/utils.ts");
const beamEffect_1 = __webpack_require__(/*! ../../projectile/beamEffect */ "./src/projectile/beamEffect.ts");
const lighting_1 = __webpack_require__(/*! ../../lighting/lighting */ "./src/lighting/lighting.ts");
const random_1 = __webpack_require__(/*! ../../utility/random */ "./src/utility/random.ts");
class OccultistEnemy extends enemy_1.Enemy {
    constructor(room, game, x, y) {
        super(room, game, x, y);
        this.hit = () => {
            return 1;
        };
        this.uniqueKillBehavior = () => {
            this.unshieldEnemies();
            this.removeLightSource(this.lightSource);
            this.lightSource = null;
        };
        this.behavior = () => {
            this.lastX = this.x;
            this.lastY = this.y;
            let enemiesToShield = this.enemyShieldCandidates();
            if (!this.dead) {
                if (this.skipNextTurns > 0) {
                    this.skipNextTurns--;
                    return;
                }
                this.ticks++;
                if (this.ticks % 2 === 0) {
                    this.shieldEnemies(enemiesToShield);
                    this.updateShieldedEnemies();
                }
            }
            if (this.shieldedEnemies.length > 0) {
                this.shadeColor = "#2E0854";
            }
            else {
                this.shadeColor = "#000000";
            }
            this.runAway();
            if (this.lightSource) {
                this.lightSource.updatePosition(this.x + 0.5, this.y + 0.5);
            }
        };
        this.onHurt = (damage = 1) => {
            if (this.health < this.lastHealth &&
                this.health % 2 === 0 &&
                this.health > 0) {
                this.teleport();
            }
            this.lastHealth = this.health;
        };
        this.updateShieldedEnemies = () => {
            this.shieldedEnemies.forEach((enemy) => {
                if (enemy.dead) {
                    this.shieldedEnemies = this.shieldedEnemies.filter((e) => e !== enemy);
                }
            });
        };
        this.shieldEnemies = (enemiesToShield) => {
            if (enemiesToShield.length > 0) {
                enemiesToShield.forEach((enemy) => {
                    const distance = utils_1.Utils.distance(this.x, this.y, enemy.x, enemy.y);
                    if (random_1.Random.rand() * 10 > distance) {
                        this.applyShieldTo(enemy);
                    }
                });
            }
        };
        this.enemyShieldCandidates = () => {
            return this.room.entities.filter((entity) => entity instanceof enemy_1.Enemy &&
                utils_1.Utils.distance(this.x, this.y, entity.x, entity.y) <= this.range &&
                !entity.shielded &&
                !entity.dead &&
                entity !== this &&
                !entity.shieldedBefore);
        };
        this.unshieldEnemies = () => {
            if (this.shieldedEnemies.length > 0) {
                for (let enemy of this.shieldedEnemies) {
                    if (!enemy.cloned) {
                        enemy.removeShield();
                    }
                }
                this.shieldedEnemies = [];
            }
        };
        this.applyShieldTo = (enemy) => {
            //this.shadeColor = "#2E0854";
            this.shadeMultiplier = 1.5;
            enemy.applyShield();
            this.shieldedEnemies.push(enemy);
            if (enemy.shielded && enemy.shield) {
                let beam = new beamEffect_1.BeamEffect(enemy.x, enemy.y, this.x, this.y, enemy);
                beam.compositeOperation = "source-over";
                beam.color = "#2E0854";
                beam.turbulence = 0.4;
                beam.gravity = 0.1;
                beam.iterations = 1;
                beam.segments = 100;
                beam.angleChange = 0.001;
                beam.springDamping = 0.01;
                beam.drawableY = enemy.drawableY;
                this.room.projectiles.push(beam);
            }
        };
        this.createBeam = (enemies) => {
            for (let enemy of enemies) {
                if (enemy.shielded && enemy.shield) {
                    let beam = new beamEffect_1.BeamEffect(enemy.x, enemy.y, this.x, this.y, enemy);
                    beam.compositeOperation = "source-over";
                    beam.color = "#2E0854";
                    beam.turbulence = 0.5;
                    beam.gravity = 0.1;
                    beam.iterations = 1;
                    beam.segments = 30;
                    beam.angleChange = 0.01;
                    beam.springDamping = 0.1;
                    beam.drawableY = enemy.drawableY;
                    this.room.projectiles.push(beam);
                }
            }
        };
        this.updateBeam = (delta) => {
            for (let beam of this.room.projectiles) {
                if (beam instanceof beamEffect_1.BeamEffect) {
                    beam.setTarget(this.x - this.drawX, this.y - this.drawY, beam.parent.x - beam.parent.drawX, beam.parent.y - beam.parent.drawY);
                    beam.drawableY = beam.parent.drawableY;
                    switch (Math.floor(this.frame)) {
                        case 0:
                            beam.color = "#2e0854";
                            break;
                        case 1:
                            beam.color = "#331988";
                            break;
                        case 2:
                            beam.color = "#4729db";
                            break;
                        case 3:
                            beam.color = "#331988";
                            break;
                    }
                }
            }
        };
        this.draw = (delta) => {
            if (this.dead)
                return;
            game_1.Game.ctx.save();
            game_1.Game.ctx.globalAlpha = this.alpha;
            this.drawableY = this.y;
            if (!this.dead) {
                this.updateDrawXY(delta);
                this.updateBeam(delta);
                this.frame += 0.1 * delta;
                if (this.frame >= 4)
                    this.frame = 0;
                if (this.hasShadow)
                    game_1.Game.drawMob(0, 0, 1, 1, this.x - this.drawX, this.y - this.drawY, 1, 1, this.room.shadeColor, this.shadeAmount());
                game_1.Game.drawMob(this.tileX + Math.floor(this.frame), this.tileY, 1, 2, this.x - this.drawX, this.y - this.drawYOffset - this.drawY, 1, 2, this.softShadeColor, this.shadeAmount());
            }
            game_1.Game.ctx.restore();
        };
        this.ticks = 0;
        this.health = 4;
        this.lastHealth = this.health;
        this.maxHealth = 4;
        this.tileX = 55;
        this.tileY = 8;
        this.seenPlayer = true;
        this.name = "occultist";
        this.range = 6;
        this.aggro = false;
        this.frame = 0;
        this.hasShadow = true;
        this.shieldedBefore = false;
        this.shieldedEnemies = [];
        this.shadeColor = "#000000";
        this.lightSource = lighting_1.Lighting.newLightSource(this.x + 0.5, this.y + 0.5, [20, 0, 40], 3.5, 20);
        this.addLightSource(this.lightSource);
        this.room.updateLighting();
        this.hasBloom = true;
        this.bloomColor = "#2E0854";
        this.bloomAlpha = 1;
        this.softBloomAlpha = 0;
        this.getDrop(["weapon", "equipment", "consumable", "tool", "coin"]);
    }
}
exports.OccultistEnemy = OccultistEnemy;
OccultistEnemy.tileX = 55;
OccultistEnemy.tileY = 8;


/***/ }),

/***/ "./src/entity/enemy/queenEnemy.ts":
/*!****************************************!*\
  !*** ./src/entity/enemy/queenEnemy.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.QueenEnemy = void 0;
const game_1 = __webpack_require__(/*! ../../game */ "./src/game.ts");
const astarclass_1 = __webpack_require__(/*! ../../utility/astarclass */ "./src/utility/astarclass.ts");
const spiketrap_1 = __webpack_require__(/*! ../../tile/spiketrap */ "./src/tile/spiketrap.ts");
const enemy_1 = __webpack_require__(/*! ./enemy */ "./src/entity/enemy/enemy.ts");
class QueenEnemy extends enemy_1.Enemy {
    constructor(room, game, x, y, drop) {
        super(room, game, x, y);
        this.justHurt = false;
        this.hit = () => {
            return 1;
        };
        this.behavior = () => {
            this.lastX = this.x;
            this.lastY = this.y;
            if (this.health <= 1)
                this.imageParticleY = 29; //no crown particle
            if (!this.dead) {
                if (this.skipNextTurns > 0) {
                    this.skipNextTurns--;
                    return;
                }
                this.ticks++;
                if (!this.seenPlayer) {
                    this.justHurt = false;
                    let p = this.nearestPlayer();
                    if (p !== false) {
                        let [distance, player] = p;
                        if (distance <= 4) {
                            this.targetPlayer = player;
                            this.facePlayer(player);
                            this.seenPlayer = true;
                            if (player === this.game.players[this.game.localPlayerID])
                                this.alertTicks = 1;
                            this.makeHitWarnings();
                        }
                    }
                }
                else if (this.seenPlayer) {
                    if (this.room.playerTicked === this.targetPlayer) {
                        this.alertTicks = Math.max(0, this.alertTicks - 1);
                        let oldX = this.x;
                        let oldY = this.y;
                        let disablePositions = Array();
                        for (const e of this.room.entities) {
                            if (e !== this) {
                                disablePositions.push({ x: e.x, y: e.y });
                            }
                        }
                        for (let xx = this.x - 1; xx <= this.x + 1; xx++) {
                            for (let yy = this.y - 1; yy <= this.y + 1; yy++) {
                                if (this.room.roomArray[xx][yy] instanceof spiketrap_1.SpikeTrap &&
                                    this.room.roomArray[xx][yy].on) {
                                    // don't walk on active spiketraps
                                    disablePositions.push({ x: xx, y: yy });
                                }
                            }
                        }
                        let grid = [];
                        for (let x = 0; x < this.room.roomX + this.room.width; x++) {
                            grid[x] = [];
                            for (let y = 0; y < this.room.roomY + this.room.height; y++) {
                                if (this.room.roomArray[x] && this.room.roomArray[x][y])
                                    grid[x][y] = this.room.roomArray[x][y];
                                else
                                    grid[x][y] = false;
                            }
                        }
                        let moves = astarclass_1.astar.AStar.search(grid, this, this.targetPlayer, disablePositions, true, //diagonals
                        false, //diagonalsOnly
                        undefined, undefined, undefined, false);
                        if (this.justHurt) {
                            this.retreat(oldX, oldY);
                        }
                        else if (moves.length > 0) {
                            disablePositions.push({ x: oldX + 1, y: oldY });
                            disablePositions.push({ x: oldX - 1, y: oldY });
                            disablePositions.push({ x: oldX, y: oldY + 1 });
                            disablePositions.push({ x: oldX, y: oldY - 1 });
                            let moveX = moves[0].pos.x;
                            let moveY = moves[0].pos.y;
                            let hitPlayer = false;
                            for (const i in this.game.players) {
                                if (this.game.rooms[this.game.players[i].levelID] === this.room &&
                                    this.game.players[i].x === moveX &&
                                    this.game.players[i].y === moveY) {
                                    this.game.players[i].hurt(this.hit(), this.name);
                                    this.drawX = 0.5 * (this.x - this.game.players[i].x);
                                    this.drawY = 0.5 * (this.y - this.game.players[i].y);
                                    if (this.game.players[i] ===
                                        this.game.players[this.game.localPlayerID])
                                        this.game.shakeScreen(10 * this.drawX, 10 * this.drawY);
                                }
                            }
                            if (!hitPlayer) {
                                //if ()
                                this.tryMove(moveX, moveY);
                                this.setDrawXY(oldX, oldY);
                            }
                        }
                        this.makeHitWarnings();
                    }
                    let targetPlayerOffline = Object.values(this.game.offlinePlayers).indexOf(this.targetPlayer) !==
                        -1;
                    if (!this.aggro || targetPlayerOffline) {
                        let p = this.nearestPlayer();
                        if (p !== false) {
                            let [distance, player] = p;
                            if (distance <= 4 &&
                                (targetPlayerOffline ||
                                    distance < this.playerDistance(this.targetPlayer))) {
                                if (player !== this.targetPlayer) {
                                    this.targetPlayer = player;
                                    this.facePlayer(player);
                                    if (player === this.game.players[this.game.localPlayerID])
                                        this.alertTicks = 1;
                                    this.makeHitWarnings();
                                }
                            }
                        }
                    }
                }
            }
        };
        this.jump = (delta) => {
            let j = Math.max(Math.abs(this.drawX), Math.abs(this.drawY));
            let jumpY = Math.abs(Math.sin(j * Math.PI)) * this.jumpHeight;
            if (jumpY < 0.01)
                jumpY = 0;
            if (jumpY > this.jumpHeight)
                jumpY = this.jumpHeight;
            this.jumpY = jumpY;
        };
        this.draw = (delta) => {
            let offsetTileY = this.health <= 1 ? 0 : -2;
            if (this.cloned)
                offsetTileY = 0;
            if (this.dead)
                return;
            game_1.Game.ctx.save();
            game_1.Game.ctx.globalAlpha = this.alpha;
            if (!this.dead) {
                this.updateDrawXY(delta);
                this.frame += 0.1 * delta;
                if (this.frame >= 4)
                    this.frame = 0;
                if (this.hasShadow)
                    game_1.Game.drawMob(0, 0, 1, 1, this.x - this.drawX, this.y - this.drawY, 1, 1, this.room.shadeColor, this.shadeAmount());
                game_1.Game.drawMob(this.tileX + Math.floor(this.frame), this.tileY + offsetTileY, 1, 2, this.x - this.drawX, this.y - this.drawYOffset - this.drawY - this.jumpY, 1, 2, this.softShadeColor, this.shadeAmount() * (1 + this.jumpY / 3));
            }
            if (!this.cloned) {
                if (!this.seenPlayer) {
                    this.drawSleepingZs(delta);
                }
                if (this.alertTicks > 0) {
                    this.drawExclamation(delta);
                }
            }
            game_1.Game.ctx.restore();
        };
        this.ticks = 0;
        this.frame = 0;
        this.health = 2;
        this.maxHealth = 2;
        this.tileX = 23;
        this.tileY = 10;
        this.seenPlayer = false;
        this.aggro = false;
        this.name = "queen";
        this.orthogonalAttack = true;
        this.diagonalAttack = true;
        this.jumpHeight = 1;
        this.imageParticleX = 6;
        this.imageParticleY = 28; //includes crown particle
        if (drop)
            this.drop = drop;
        this.armored = true;
        this.getDrop(["weapon", "equipment", "consumable", "tool", "coin"]);
    }
}
exports.QueenEnemy = QueenEnemy;
QueenEnemy.difficulty = 4;
QueenEnemy.tileX = 23;
QueenEnemy.tileY = 8;


/***/ }),

/***/ "./src/entity/enemy/rookEnemy.ts":
/*!***************************************!*\
  !*** ./src/entity/enemy/rookEnemy.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RookEnemy = void 0;
const game_1 = __webpack_require__(/*! ../../game */ "./src/game.ts");
const astarclass_1 = __webpack_require__(/*! ../../utility/astarclass */ "./src/utility/astarclass.ts");
const spiketrap_1 = __webpack_require__(/*! ../../tile/spiketrap */ "./src/tile/spiketrap.ts");
const enemy_1 = __webpack_require__(/*! ./enemy */ "./src/entity/enemy/enemy.ts");
class RookEnemy extends enemy_1.Enemy {
    constructor(room, game, x, y, drop) {
        super(room, game, x, y);
        this.hit = () => {
            return 1;
        };
        this.behavior = () => {
            this.lastX = this.x;
            this.lastY = this.y;
            if (!this.dead) {
                if (this.skipNextTurns > 0) {
                    this.skipNextTurns--;
                    return;
                }
                this.ticks++;
                if (!this.seenPlayer) {
                    let p = this.nearestPlayer();
                    if (p !== false) {
                        let [distance, player] = p;
                        if (distance <= 4) {
                            this.targetPlayer = player;
                            this.facePlayer(player);
                            this.seenPlayer = true;
                            if (player === this.game.players[this.game.localPlayerID])
                                this.alertTicks = 1;
                            this.makeHitWarnings();
                        }
                    }
                }
                else if (this.seenPlayer) {
                    if (this.room.playerTicked === this.targetPlayer) {
                        this.alertTicks = Math.max(0, this.alertTicks - 1);
                        let oldX = this.x;
                        let oldY = this.y;
                        let disablePositions = Array();
                        for (const e of this.room.entities) {
                            if (e !== this) {
                                disablePositions.push({ x: e.x, y: e.y });
                            }
                        }
                        for (let xx = this.x - 1; xx <= this.x + 1; xx++) {
                            for (let yy = this.y - 1; yy <= this.y + 1; yy++) {
                                if (this.room.roomArray[xx][yy] instanceof spiketrap_1.SpikeTrap &&
                                    this.room.roomArray[xx][yy].on) {
                                    // don't walk on active spiketraps
                                    disablePositions.push({ x: xx, y: yy });
                                }
                            }
                        }
                        let grid = [];
                        for (let x = 0; x < this.room.roomX + this.room.width; x++) {
                            grid[x] = [];
                            for (let y = 0; y < this.room.roomY + this.room.height; y++) {
                                if (this.room.roomArray[x] && this.room.roomArray[x][y])
                                    grid[x][y] = this.room.roomArray[x][y];
                                else
                                    grid[x][y] = false;
                            }
                        }
                        let moves = astarclass_1.astar.AStar.search(grid, this, this.targetPlayer, disablePositions, false, //diagonals
                        false, //diagonalsOnly
                        undefined, undefined, undefined, false, //diagonalsOmni
                        this.lastPlayerPos);
                        if (this.justHurt) {
                            this.stun();
                        }
                        else if (moves.length > 0) {
                            let moveX = moves[0].pos.x;
                            let moveY = moves[0].pos.y;
                            let hitPlayer = false;
                            for (const i in this.game.players) {
                                if (this.game.rooms[this.game.players[i].levelID] === this.room &&
                                    this.game.players[i].x === moveX &&
                                    this.game.players[i].y === moveY) {
                                    this.game.players[i].hurt(this.hit(), this.name);
                                    this.drawX = 0.5 * (this.x - this.game.players[i].x);
                                    this.drawY = 0.5 * (this.y - this.game.players[i].y);
                                    if (this.game.players[i] ===
                                        this.game.players[this.game.localPlayerID])
                                        this.game.shakeScreen(10 * this.drawX, 10 * this.drawY);
                                }
                            }
                            if (!hitPlayer) {
                                this.tryMove(moveX, moveY);
                                this.setDrawXY(oldX, oldY);
                            }
                        }
                        this.makeHitWarnings();
                    }
                    let targetPlayerOffline = Object.values(this.game.offlinePlayers).indexOf(this.targetPlayer) !==
                        -1;
                    if (!this.aggro || targetPlayerOffline) {
                        let p = this.nearestPlayer();
                        if (p !== false) {
                            let [distance, player] = p;
                            if (distance <= 4 &&
                                (targetPlayerOffline ||
                                    distance < this.playerDistance(this.targetPlayer))) {
                                if (player !== this.targetPlayer) {
                                    this.targetPlayer = player;
                                    this.facePlayer(player);
                                    if (player === this.game.players[this.game.localPlayerID])
                                        this.alertTicks = 1;
                                    this.makeHitWarnings();
                                }
                            }
                        }
                    }
                }
            }
        };
        this.draw = (delta) => {
            if (this.dead)
                return;
            game_1.Game.ctx.save();
            game_1.Game.ctx.globalAlpha = this.alpha;
            let offsetTileY = this.health <= 1 || this.cloned === true ? 2 : 0;
            if (!this.dead) {
                this.updateDrawXY(delta);
                this.frame += 0.1 * delta;
                if (this.frame >= 4)
                    this.frame = 0;
                if (this.hasShadow)
                    game_1.Game.drawMob(0, 0, 1, 1, this.x - this.drawX, this.y - this.drawY, 1, 1, this.room.shadeColor, this.shadeAmount());
                game_1.Game.drawMob(this.tileX + Math.floor(this.frame), this.tileY + offsetTileY, 1, 2, this.x - this.drawX, this.y - this.drawYOffset - this.drawY - this.jumpY, 1, 2, this.softShadeColor, this.shadeAmount());
            }
            if (!this.cloned) {
                if (!this.seenPlayer) {
                    this.drawSleepingZs(delta);
                }
                if (this.alertTicks > 0) {
                    this.drawExclamation(delta);
                }
            }
            game_1.Game.ctx.restore();
        };
        this.ticks = 0;
        this.frame = 0;
        this.health = 2;
        this.maxHealth = 2;
        this.tileX = 23 + 28;
        this.tileY = 8;
        this.seenPlayer = false;
        this.aggro = false;
        this.name = "rook";
        this.orthogonalAttack = true;
        this.diagonalAttack = false;
        this.jumpHeight = 0.5;
        if (drop)
            this.drop = drop;
        this.armored = true;
        this.getDrop(["weapon", "equipment", "consumable", "tool", "coin"]);
    }
}
exports.RookEnemy = RookEnemy;
RookEnemy.difficulty = 4;
RookEnemy.tileX = 23 + 28;
RookEnemy.tileY = 8;


/***/ }),

/***/ "./src/entity/enemy/skullEnemy.ts":
/*!****************************************!*\
  !*** ./src/entity/enemy/skullEnemy.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SkullEnemy = void 0;
const game_1 = __webpack_require__(/*! ../../game */ "./src/game.ts");
const astarclass_1 = __webpack_require__(/*! ../../utility/astarclass */ "./src/utility/astarclass.ts");
const spiketrap_1 = __webpack_require__(/*! ../../tile/spiketrap */ "./src/tile/spiketrap.ts");
const imageParticle_1 = __webpack_require__(/*! ../../particle/imageParticle */ "./src/particle/imageParticle.ts");
const enemy_1 = __webpack_require__(/*! ./enemy */ "./src/entity/enemy/enemy.ts");
class SkullEnemy extends enemy_1.Enemy {
    constructor(room, game, x, y, drop) {
        super(room, game, x, y);
        this.REGEN_TICKS = 5;
        this.hit = () => {
            return 1;
        };
        this.hurt = (playerHitBy, damage, type = "none") => {
            this.handleEnemyCase(playerHitBy);
            let hitShield = false;
            let shieldHealth = 0;
            if (this.shielded) {
                shieldHealth = this.shield.health;
                if (shieldHealth > 0) {
                    this.shield.hurt(damage);
                    hitShield = true;
                }
            }
            this.ticksSinceFirstHit = 0;
            if (this.health == 2)
                this.unconscious = false;
            this.health -= damage;
            this.maxHealth -= shieldHealth;
            this.startHurting();
            this.healthBar.hurt();
            this.createDamageNumber(damage, type);
            this.playHitSound();
            if (this.health == 1) {
                this.unconscious = true;
                imageParticle_1.ImageParticle.spawnCluster(this.room, this.x + 0.5, this.y + 0.5, 3, 28);
            }
            else {
                this.healthBar.hurt();
            }
            if (this.health <= 0) {
                imageParticle_1.ImageParticle.spawnCluster(this.room, this.x + 0.5, this.y + 0.5, 0, 24);
                this.kill();
            }
            else
                this.hurtCallback();
        };
        this.behavior = () => {
            this.lastX = this.x;
            this.lastY = this.y;
            if (!this.dead) {
                if (this.skipNextTurns > 0) {
                    this.skipNextTurns--;
                    this.ticks++;
                    return;
                }
                if (this.health <= 1) {
                    this.unconscious = true;
                    this.ticksSinceFirstHit++;
                    if (this.ticksSinceFirstHit >= this.REGEN_TICKS) {
                        this.healthBar.hurt();
                        this.health = 2;
                        this.unconscious = false;
                    }
                    this.ticks++;
                    return;
                }
                this.ticks++;
                if (!this.seenPlayer) {
                    this.lookForPlayer();
                }
                else if (this.seenPlayer) {
                    if (this.room.playerTicked === this.targetPlayer) {
                        this.alertTicks = Math.max(0, this.alertTicks - 1);
                        let oldX = this.x;
                        let oldY = this.y;
                        let disablePositions = Array();
                        for (const e of this.room.entities) {
                            if (e !== this) {
                                disablePositions.push({ x: e.x, y: e.y });
                            }
                        }
                        for (let xx = this.x - 1; xx <= this.x + 1; xx++) {
                            for (let yy = this.y - 1; yy <= this.y + 1; yy++) {
                                if (this.room.roomArray[xx][yy] instanceof spiketrap_1.SpikeTrap &&
                                    this.room.roomArray[xx][yy].on) {
                                    disablePositions.push({ x: xx, y: yy });
                                }
                            }
                        }
                        let grid = [];
                        for (let x = 0; x < this.room.roomX + this.room.width; x++) {
                            grid[x] = [];
                            for (let y = 0; y < this.room.roomY + this.room.height; y++) {
                                if (this.room.roomArray[x] && this.room.roomArray[x][y])
                                    grid[x][y] = this.room.roomArray[x][y];
                                else
                                    grid[x][y] = false;
                            }
                        }
                        let moves = astarclass_1.astar.AStar.search(grid, this, this.targetPlayer, disablePositions, false, false, true, this.direction, undefined, undefined);
                        if (moves.length > 0) {
                            let moveX = moves[0].pos.x;
                            let moveY = moves[0].pos.y;
                            let oldDir = this.direction;
                            let player = this.targetPlayer;
                            this.facePlayer(player);
                            if (moveX > oldX)
                                this.direction = game_1.Direction.RIGHT;
                            else if (moveX < oldX)
                                this.direction = game_1.Direction.LEFT;
                            else if (moveY > oldY)
                                this.direction = game_1.Direction.DOWN;
                            else if (moveY < oldY)
                                this.direction = game_1.Direction.UP;
                            if (oldDir == this.direction) {
                                let hitPlayer = false;
                                for (const i in this.game.players) {
                                    if (this.game.rooms[this.game.players[i].levelID] === this.room &&
                                        this.game.players[i].x === moveX &&
                                        this.game.players[i].y === moveY) {
                                        this.game.players[i].hurt(this.hit(), this.name);
                                        this.drawX = 0.5 * (this.x - this.game.players[i].x);
                                        this.drawY = 0.5 * (this.y - this.game.players[i].y);
                                        if (this.game.players[i] ===
                                            this.game.players[this.game.localPlayerID])
                                            this.game.shakeScreen(10 * this.drawX, 10 * this.drawY);
                                    }
                                }
                                if (!hitPlayer) {
                                    this.tryMove(moveX, moveY);
                                    this.setDrawXY(oldX, oldY);
                                    if (this.x > oldX)
                                        this.direction = game_1.Direction.RIGHT;
                                    else if (this.x < oldX)
                                        this.direction = game_1.Direction.LEFT;
                                    else if (this.y > oldY)
                                        this.direction = game_1.Direction.DOWN;
                                    else if (this.y < oldY)
                                        this.direction = game_1.Direction.UP;
                                }
                            }
                        }
                        if (this.direction == game_1.Direction.LEFT) {
                            disablePositions.push({
                                x: this.x,
                                y: this.y + 1,
                            });
                            disablePositions.push({
                                x: this.x,
                                y: this.y - 1,
                            });
                        }
                        if (this.direction == game_1.Direction.RIGHT) {
                            disablePositions.push({
                                x: this.x,
                                y: this.y + 1,
                            });
                            disablePositions.push({
                                x: this.x,
                                y: this.y - 1,
                            });
                        }
                        if (this.direction == game_1.Direction.DOWN) {
                            disablePositions.push({
                                x: this.x + 1,
                                y: this.y,
                            });
                            disablePositions.push({
                                x: this.x - 1,
                                y: this.y,
                            });
                        }
                        if (this.direction == game_1.Direction.UP) {
                            disablePositions.push({
                                x: this.x + 1,
                                y: this.y,
                            });
                            disablePositions.push({
                                x: this.x - 1,
                                y: this.y,
                            });
                        }
                        this.makeHitWarnings();
                    }
                    let targetPlayerOffline = Object.values(this.game.offlinePlayers).indexOf(this.targetPlayer) !==
                        -1;
                    if (!this.aggro || targetPlayerOffline) {
                        let p = this.nearestPlayer();
                        if (p !== false) {
                            let [distance, player] = p;
                            if (distance <= 4 &&
                                (targetPlayerOffline ||
                                    distance < this.playerDistance(this.targetPlayer))) {
                                if (player !== this.targetPlayer) {
                                    this.targetPlayer = player;
                                    this.facePlayer(player);
                                    if (player === this.game.players[this.game.localPlayerID])
                                        this.alertTicks = 1;
                                    this.makeHitWarnings();
                                }
                            }
                        }
                    }
                }
            }
        };
        this.draw = (delta) => {
            if (this.dead)
                return;
            game_1.Game.ctx.save();
            game_1.Game.ctx.globalAlpha = this.alpha;
            if (!this.dead) {
                this.updateDrawXY(delta);
                this.tileX = 5;
                this.tileY = 8;
                if (this.health <= 1 || this.dying) {
                    this.tileX = 3;
                    this.tileY = 0;
                    if (this.ticksSinceFirstHit >= 3) {
                        this.flashingFrame += 0.1 * delta;
                        if (Math.floor(this.flashingFrame) % 2 === 0) {
                            this.tileX = 2;
                        }
                    }
                }
                this.frame += 0.1 * delta;
                if (this.frame >= 4)
                    this.frame = 0;
                if (this.hasShadow)
                    game_1.Game.drawMob(0, 0, 1, 1, this.x - this.drawX, this.y - this.drawY, 1, 1, this.room.shadeColor, this.shadeAmount());
                game_1.Game.drawMob(this.tileX + (this.tileX === 5 ? Math.floor(this.frame) : 0), this.tileY + this.direction * 2, 1, 2, this.x - this.drawX, this.y - this.drawYOffset - this.drawY - this.jumpY, 1, 2, this.softShadeColor, this.shadeAmount());
            }
            if (!this.cloned) {
                if (!this.seenPlayer) {
                    this.drawSleepingZs(delta);
                }
                if (this.alertTicks > 0) {
                    this.drawExclamation(delta);
                }
            }
            game_1.Game.ctx.restore();
        };
        this.ticks = 0;
        this.frame = 0;
        this.health = 2;
        this.maxHealth = 2;
        this.tileX = 5;
        this.tileY = 8;
        this.seenPlayer = false;
        this.aggro = false;
        this.ticksSinceFirstHit = 0;
        this.flashingFrame = 0;
        this.deathParticleColor = "#ffffff";
        this.name = "skeleton";
        this.forwardOnlyAttack = true;
        if (drop)
            this.drop = drop;
        this.getDrop(["weapon", "consumable", "tool", "coin"]);
    }
}
exports.SkullEnemy = SkullEnemy;
SkullEnemy.difficulty = 2;
SkullEnemy.tileX = 5;
SkullEnemy.tileY = 8;


/***/ }),

/***/ "./src/entity/enemy/spawner.ts":
/*!*************************************!*\
  !*** ./src/entity/enemy/spawner.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Spawner = void 0;
const game_1 = __webpack_require__(/*! ../../game */ "./src/game.ts");
const floor_1 = __webpack_require__(/*! ../../tile/floor */ "./src/tile/floor.ts");
const hitWarning_1 = __webpack_require__(/*! ../../drawable/hitWarning */ "./src/drawable/hitWarning.ts");
const skullEnemy_1 = __webpack_require__(/*! ./skullEnemy */ "./src/entity/enemy/skullEnemy.ts");
const enemySpawnAnimation_1 = __webpack_require__(/*! ../../projectile/enemySpawnAnimation */ "./src/projectile/enemySpawnAnimation.ts");
const knightEnemy_1 = __webpack_require__(/*! ./knightEnemy */ "./src/entity/enemy/knightEnemy.ts");
const enemy_1 = __webpack_require__(/*! ./enemy */ "./src/entity/enemy/enemy.ts");
const random_1 = __webpack_require__(/*! ../../utility/random */ "./src/utility/random.ts");
const energyWizard_1 = __webpack_require__(/*! ./energyWizard */ "./src/entity/enemy/energyWizard.ts");
const zombieEnemy_1 = __webpack_require__(/*! ./zombieEnemy */ "./src/entity/enemy/zombieEnemy.ts");
const bishopEnemy_1 = __webpack_require__(/*! ./bishopEnemy */ "./src/entity/enemy/bishopEnemy.ts");
const crabEnemy_1 = __webpack_require__(/*! ./crabEnemy */ "./src/entity/enemy/crabEnemy.ts");
const chargeEnemy_1 = __webpack_require__(/*! ./chargeEnemy */ "./src/entity/enemy/chargeEnemy.ts");
const bigKnightEnemy_1 = __webpack_require__(/*! ./bigKnightEnemy */ "./src/entity/enemy/bigKnightEnemy.ts");
const bigSkullEnemy_1 = __webpack_require__(/*! ./bigSkullEnemy */ "./src/entity/enemy/bigSkullEnemy.ts");
const frogEnemy_1 = __webpack_require__(/*! ./frogEnemy */ "./src/entity/enemy/frogEnemy.ts");
const fireWizard_1 = __webpack_require__(/*! ./fireWizard */ "./src/entity/enemy/fireWizard.ts");
const queenEnemy_1 = __webpack_require__(/*! ./queenEnemy */ "./src/entity/enemy/queenEnemy.ts");
const armoredzombieEnemy_1 = __webpack_require__(/*! ./armoredzombieEnemy */ "./src/entity/enemy/armoredzombieEnemy.ts");
const rookEnemy_1 = __webpack_require__(/*! ./rookEnemy */ "./src/entity/enemy/rookEnemy.ts");
const room_1 = __webpack_require__(/*! ../../room/room */ "./src/room/room.ts");
const armoredSkullEnemy_1 = __webpack_require__(/*! ./armoredSkullEnemy */ "./src/entity/enemy/armoredSkullEnemy.ts");
const gameplaySettings_1 = __webpack_require__(/*! ../../game/gameplaySettings */ "./src/game/gameplaySettings.ts");
class Spawner extends enemy_1.Enemy {
    constructor(room, game, x, y, enemyTable = [0, 1, 2, 3, 4, 5, 6, 8, 9, 10, 11, 12, 13, 14, 16]) {
        super(room, game, x, y);
        this.hit = () => {
            return 1;
        };
        this.setSpawnFrequency = (maxHealth = 1) => {
            if (gameplaySettings_1.GameplaySettings.UNLIMITED_SPAWNERS) {
                this.spawnFrequency = 4;
            }
            else {
                this.spawnFrequency = Math.min(12, 4 * this.room.currentSpawnerCount);
            }
            if (gameplaySettings_1.GameplaySettings.THROTTLE_SPAWNERS) {
                this.spawnFrequency = 3 + maxHealth;
            }
            const spawners = this.room.entities.filter((e) => e instanceof Spawner);
            this.spawnOffset = (spawners.indexOf(this) + 1) * 4;
        };
        this.behavior = () => {
            let shouldSpawn = true;
            this.lastX = this.x;
            this.lastY = this.y;
            if (!this.dead) {
                if (this.skipNextTurns > 0) {
                    this.skipNextTurns--;
                    return;
                }
                this.tileX = 6;
                if ((this.ticks + this.spawnOffset) % this.spawnFrequency === 0) {
                    let positions = this.room
                        .getEmptyTiles()
                        .filter((t) => Math.abs(t.x - this.x) <= 1 && Math.abs(t.y - this.y) <= 1);
                    if (this.enemySpawnType === 8) {
                        const offLimits = [
                            { x: this.x, y: this.y },
                            { x: this.x + 1, y: this.y + 1 },
                            { x: this.x - 1, y: this.y - 1 },
                            { x: this.x + 1, y: this.y - 1 },
                            { x: this.x - 1, y: this.y + 1 },
                        ];
                        positions = positions.filter((t) => !offLimits.some((o) => o.x === t.x && o.y === t.y));
                    }
                    if (positions.length > 0) {
                        this.tileX = 7;
                        const position = game_1.Game.randTable(positions, random_1.Random.rand);
                        let spawned;
                        switch (this.enemySpawnType) {
                            case 1:
                                spawned = new crabEnemy_1.CrabEnemy(this.room, this.game, position.x, position.y);
                                break;
                            case 2:
                                spawned = new frogEnemy_1.FrogEnemy(this.room, this.game, position.x, position.y);
                                break;
                            case 3:
                                spawned = new zombieEnemy_1.ZombieEnemy(this.room, this.game, position.x, position.y);
                                break;
                            case 4:
                                spawned = new skullEnemy_1.SkullEnemy(this.room, this.game, position.x, position.y);
                                break;
                            case 5:
                                spawned = new energyWizard_1.EnergyWizardEnemy(this.room, this.game, position.x, position.y);
                                break;
                            case 6:
                                spawned = new chargeEnemy_1.ChargeEnemy(this.room, this.game, position.x, position.y);
                                break;
                            case 7:
                                spawned = new rookEnemy_1.RookEnemy(this.room, this.game, position.x, position.y);
                                break;
                            case 8:
                                spawned = new bishopEnemy_1.BishopEnemy(this.room, this.game, position.x, position.y);
                                break;
                            case 9:
                                spawned = new armoredzombieEnemy_1.ArmoredzombieEnemy(this.room, this.game, position.x, position.y);
                                break;
                            case 10:
                                if (this.room.type !== room_1.RoomType.BIGDUNGEON) {
                                    spawned = new skullEnemy_1.SkullEnemy(this.room, this.game, position.x, position.y);
                                    break;
                                }
                                spawned = new bigSkullEnemy_1.BigSkullEnemy(this.room, this.game, position.x, position.y);
                                for (let xx = 0; xx < 2; xx++) {
                                    for (let yy = 0; yy < 2; yy++) {
                                        this.room.roomArray[position.x + xx][position.y + yy] =
                                            new floor_1.Floor(this.room, position.x + xx, position.y + yy); // remove any walls
                                    }
                                }
                                break;
                            case 11:
                                spawned = new queenEnemy_1.QueenEnemy(this.room, this.game, position.x, position.y);
                                break;
                            case 12:
                                spawned = new knightEnemy_1.KnightEnemy(this.room, this.game, position.x, position.y);
                                break;
                            case 13:
                                if (this.room.type !== room_1.RoomType.BIGDUNGEON) {
                                    spawned = new knightEnemy_1.KnightEnemy(this.room, this.game, position.x, position.y);
                                    break;
                                }
                                spawned = new bigKnightEnemy_1.BigKnightEnemy(this.room, this.game, position.x, position.y);
                                for (let xx = 0; xx < 2; xx++) {
                                    for (let yy = 0; yy < 2; yy++) {
                                        this.room.roomArray[position.x + xx][position.y + yy] =
                                            new floor_1.Floor(this.room, position.x + xx, position.y + yy); // remove any walls
                                    }
                                }
                                break;
                            case 14:
                                spawned = new zombieEnemy_1.ZombieEnemy(this.room, this.game, position.x, position.y);
                                break;
                            case 15:
                                spawned = new fireWizard_1.FireWizardEnemy(this.room, this.game, position.x, position.y);
                                break;
                            case 16:
                                spawned = new armoredSkullEnemy_1.ArmoredSkullEnemy(this.room, this.game, position.x, position.y);
                                break;
                        }
                        this.setSpawnFrequency(spawned.maxHealth);
                        if (shouldSpawn) {
                            this.room.projectiles.push(new enemySpawnAnimation_1.EnemySpawnAnimation(this.room, spawned, position.x, position.y));
                            this.room.hitwarnings.push(new hitWarning_1.HitWarning(this.game, position.x, position.y, this.x, this.y));
                        }
                    }
                }
                this.ticks++;
            }
        };
        this.uniqueKillBehavior = () => {
            this.room.currentSpawnerCount--;
        };
        this.draw = (delta) => {
            game_1.Game.ctx.save();
            game_1.Game.ctx.globalAlpha = this.alpha;
            if (!this.dead) {
                this.updateDrawXY(delta);
                this.frame += 0.1 * delta;
                if (this.frame >= 4)
                    this.frame = 0;
                if (this.hasShadow)
                    game_1.Game.drawMob(0, 0, 1, 1, this.x - this.drawX, this.y - this.drawY, 1, 1, this.room.shadeColor, this.shadeAmount());
                game_1.Game.drawMob(this.tileX, this.tileY, 1, 2, this.x - this.drawX, this.y - this.drawYOffset - this.drawY, 1, 2, this.softShadeColor, this.shadeAmount());
            }
            if (!this.dying) {
                if (!this.seenPlayer) {
                    this.drawSleepingZs(delta);
                }
                if (this.alertTicks > 0) {
                    this.drawExclamation(delta);
                }
            }
            game_1.Game.ctx.restore();
        };
        this.ticks = 0;
        this.health = 4;
        this.maxHealth = 4;
        this.tileX = 6;
        this.tileY = 4;
        this.seenPlayer = true;
        this.spawnFrequency = 4;
        this.room.currentSpawnerCount++;
        this.enemyTable = enemyTable; //enemyTable.filter((t) => t !== 7);
        const randSpawnType = game_1.Game.randTable(this.enemyTable, random_1.Random.rand);
        this.enemySpawnType = randSpawnType;
        this.spawnOffset = 0;
        this.dropChance = 1;
        this.chainPushable = false;
        this.getDrop(["reaper"], false);
        /*
        switch (this.enemySpawnType) {
          case 0:
            this.getDrop(["consumable"], true);
            break;
          case 1:
            this.getDrop(["gem"], true);
            break;
          case 2:
            this.getDrop(["consumable"], true);
            break;
          case 3:
            this.getDrop(["gem"], true);
            break;
          case 4:
            this.getDrop(["gem"], true);
            break;
          case 5:
            this.getDrop(["consumable"], true);
            break;
          case 6:
            this.getDrop(["gem"], true);
            break;
          case 7:
            this.getDrop(["gem"], true);
            break;
          case 8:
            this.getDrop(["gem"], true);
            break;
          case 9:
            this.getDrop(["equipment", "weapon", "tool"], true);
            break;
          case 10:
            this.getDrop(["weapon"], true);
            break;
          case 11:
            this.getDrop(["weapon"], true);
            break;
          case 12:
            this.getDrop(["weapon"], true);
            break;
          case 13:
            this.getDrop(["weapon"], true);
            break;
          case 14:
            this.getDrop(["weapon"], true);
            break;
          case 16:
            this.getDrop(["weapon", "equipment"], true);
            break;
        }*/
        this.name = "reaper";
    }
}
exports.Spawner = Spawner;
Spawner.tileX = 6;
Spawner.tileY = 4;


/***/ }),

/***/ "./src/entity/enemy/spiderEnemy.ts":
/*!*****************************************!*\
  !*** ./src/entity/enemy/spiderEnemy.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SpiderEnemy = void 0;
const game_1 = __webpack_require__(/*! ../../game */ "./src/game.ts");
const astarclass_1 = __webpack_require__(/*! ../../utility/astarclass */ "./src/utility/astarclass.ts");
const spiketrap_1 = __webpack_require__(/*! ../../tile/spiketrap */ "./src/tile/spiketrap.ts");
const gameConstants_1 = __webpack_require__(/*! ../../game/gameConstants */ "./src/game/gameConstants.ts");
const enemy_1 = __webpack_require__(/*! ./enemy */ "./src/entity/enemy/enemy.ts");
var SpiderState;
(function (SpiderState) {
    SpiderState[SpiderState["VISIBLE"] = 0] = "VISIBLE";
    SpiderState[SpiderState["HIDING"] = 1] = "HIDING";
    SpiderState[SpiderState["HIDDEN"] = 2] = "HIDDEN";
})(SpiderState || (SpiderState = {}));
class SpiderEnemy extends enemy_1.Enemy {
    constructor(room, game, x, y, drop) {
        super(room, game, x, y);
        this.hit = () => {
            return 1;
        };
        this.toggleReveal = () => {
            let ticksSince = this.ticks - this.revealTick;
            if (this.state === SpiderState.HIDDEN && ticksSince > 8)
                this.state = SpiderState.HIDING;
            this.revealTick = this.ticks;
        };
        this.behavior = () => {
            this.lastX = this.x;
            this.lastY = this.y;
            if (!this.dead) {
                if (this.skipNextTurns > 0) {
                    this.skipNextTurns--;
                    return;
                }
                if (!this.seenPlayer)
                    this.lookForPlayer();
                else if (this.seenPlayer) {
                    if (this.room.playerTicked === this.targetPlayer) {
                        this.alertTicks = Math.max(0, this.alertTicks - 1);
                        this.ticks++;
                        if (this.ticks % 2 === 1) {
                            this.rumbling = true;
                            let oldX = this.x;
                            let oldY = this.y;
                            let disablePositions = Array();
                            for (const e of this.room.entities) {
                                if (e !== this) {
                                    disablePositions.push({ x: e.x, y: e.y });
                                }
                            }
                            for (let xx = this.x - 1; xx <= this.x + 1; xx++) {
                                for (let yy = this.y - 1; yy <= this.y + 1; yy++) {
                                    if (this.room.roomArray[xx][yy] instanceof spiketrap_1.SpikeTrap &&
                                        this.room.roomArray[xx][yy].on) {
                                        // don't walk on active spiketraps
                                        disablePositions.push({ x: xx, y: yy });
                                    }
                                }
                            }
                            let grid = [];
                            for (let x = 0; x < this.room.roomX + this.room.width; x++) {
                                grid[x] = [];
                                for (let y = 0; y < this.room.roomY + this.room.height; y++) {
                                    if (this.room.roomArray[x] && this.room.roomArray[x][y])
                                        grid[x][y] = this.room.roomArray[x][y];
                                    else
                                        grid[x][y] = false;
                                }
                            }
                            this.target =
                                this.getAverageLuminance() > 0 // 0.8
                                    ? this.targetPlayer
                                    : this.room.getExtremeLuminanceFromPoint(this.x, this.y)
                                        .darkest;
                            let moves = astarclass_1.astar.AStar.search(grid, this, this.target, disablePositions, undefined, undefined, undefined, undefined, undefined, undefined, this.lastPlayerPos);
                            if (moves.length > 0) {
                                let hitPlayer = false;
                                for (const i in this.game.players) {
                                    if (this.game.rooms[this.game.players[i].levelID] === this.room &&
                                        this.game.players[i].x === moves[0].pos.x &&
                                        this.game.players[i].y === moves[0].pos.y) {
                                        this.game.players[i].hurt(this.hit(), this.name);
                                        this.drawX = 0.5 * (this.x - this.game.players[i].x);
                                        this.drawY = 0.5 * (this.y - this.game.players[i].y);
                                        if (this.game.players[i] ===
                                            this.game.players[this.game.localPlayerID])
                                            this.game.shakeScreen(10 * this.drawX, 10 * this.drawY);
                                        hitPlayer = true;
                                    }
                                }
                                if (!hitPlayer) {
                                    this.tryMove(moves[0].pos.x, moves[0].pos.y);
                                    this.setDrawXY(oldX, oldY);
                                    if (this.x > oldX)
                                        this.direction = game_1.Direction.RIGHT;
                                    else if (this.x < oldX)
                                        this.direction = game_1.Direction.LEFT;
                                    else if (this.y > oldY)
                                        this.direction = game_1.Direction.DOWN;
                                    else if (this.y < oldY)
                                        this.direction = game_1.Direction.UP;
                                }
                            }
                            this.rumbling = false;
                        }
                        else {
                            this.rumbling = true;
                            /*
                            if (
                              (this.target.x === this.targetPlayer.x &&
                                this.target.y === this.targetPlayer.y) ||
                              Utils.distance(
                                this.targetPlayer.x,
                                this.targetPlayer.y,
                                this.x,
                                this.y,
                              ) <= 2
                            )
                              */ {
                                this.makeHitWarnings();
                            }
                        }
                    }
                    let targetPlayerOffline = Object.values(this.game.offlinePlayers).indexOf(this.targetPlayer) !==
                        -1;
                    if (!this.aggro || targetPlayerOffline) {
                        let p = this.nearestPlayer();
                        if (p !== false) {
                            let [distance, player] = p;
                            if (distance <= 4 &&
                                (targetPlayerOffline ||
                                    distance < this.playerDistance(this.targetPlayer))) {
                                if (player !== this.targetPlayer) {
                                    this.targetPlayer = player;
                                    this.facePlayer(player);
                                    if (player === this.game.players[this.game.localPlayerID])
                                        this.alertTicks = 1;
                                    if (this.ticks % 2 === 0) {
                                        /*
                                        if (
                                          (this.target.x === this.targetPlayer.x &&
                                            this.target.y === this.targetPlayer.y) ||
                                          Utils.distance(
                                            this.targetPlayer.x,
                                            this.targetPlayer.y,
                                            this.x,
                                            this.y,
                                          ) <= 2
                                        ) */ {
                                            this.makeHitWarnings();
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        };
        this.draw = (delta) => {
            if (this.dead)
                return;
            game_1.Game.ctx.save();
            game_1.Game.ctx.globalAlpha = this.alpha;
            if (!this.dead) {
                this.updateDrawXY(delta);
                if (this.ticks % 2 === 0) {
                    this.tileX = 11;
                    this.tileY = 4;
                }
                else {
                    this.tileX = 11;
                    this.tileY = 4;
                }
                switch (this.direction) {
                    case game_1.Direction.UP:
                        this.tileX = 13;
                        break;
                    case game_1.Direction.LEFT:
                        this.tileX = 13;
                        this.tileY = 6;
                        break;
                    case game_1.Direction.RIGHT:
                        this.tileY = 6;
                        break;
                }
                let rumbleX = this.rumble(this.rumbling, this.frame, this.direction).x;
                let rumbleY = this.rumble(this.rumbling, this.frame, this.direction).y;
                this.frame += 0.1 * delta;
                if (this.frame >= 4)
                    this.frame = 0;
                if (this.hasShadow)
                    game_1.Game.drawMob(0, 0, 1, 1, this.x - this.drawX, this.y - 0.25 - this.drawY, 1, 1, this.room.shadeColor, this.shadeAmount());
                if (this.state === SpiderState.VISIBLE) {
                    //only draw when visible
                    game_1.Game.drawMob(this.tileX, this.tileY, // + this.direction,
                    2, 2, this.x - this.drawX + rumbleX - 0.5, this.y - this.drawYOffset - this.drawY + rumbleY, 2 * this.crushX, 2 * this.crushY, this.softShadeColor, this.shadeAmount());
                }
                if (this.crushed) {
                    this.crushAnim(delta);
                }
            }
            if (!this.cloned) {
                if (!this.seenPlayer) {
                    this.drawSleepingZs(delta, 0, 0.75 * gameConstants_1.GameConstants.TILESIZE);
                }
                if (this.alertTicks > 0) {
                    this.drawExclamation(delta, 0, 0.75 * gameConstants_1.GameConstants.TILESIZE);
                }
            }
            game_1.Game.ctx.restore();
        };
        this.ticks = 0;
        this.frame = 0;
        this.health = 1;
        this.maxHealth = 1;
        this.tileX = 11;
        this.tileY = 4;
        this.seenPlayer = false;
        this.aggro = false;
        this.name = "spider";
        this.orthogonalAttack = true;
        this.imageParticleX = 3;
        this.imageParticleY = 24;
        this.state = SpiderState.VISIBLE;
        //if (drop) this.drop = drop;
        this.drawYOffset = 1.2;
        this.revealTick = 0;
        this.hasShadow = true;
        this.getDrop(["weapon", "equipment", "consumable", "tool", "coin"]);
    }
    get alertText() {
        return `New Enemy Spotted: Spider 
    Health: ${this.health}
    Attack Pattern: Omnidirectional
    Moves every other turn`;
    }
}
exports.SpiderEnemy = SpiderEnemy;
SpiderEnemy.difficulty = 1;
SpiderEnemy.tileX = 8;
SpiderEnemy.tileY = 4;


/***/ }),

/***/ "./src/entity/enemy/wizardEnemy.ts":
/*!*****************************************!*\
  !*** ./src/entity/enemy/wizardEnemy.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WizardEnemy = exports.WizardState = void 0;
const game_1 = __webpack_require__(/*! ../../game */ "./src/game.ts");
const wizardTeleportParticle_1 = __webpack_require__(/*! ../../particle/wizardTeleportParticle */ "./src/particle/wizardTeleportParticle.ts");
const wizardFireball_1 = __webpack_require__(/*! ../../projectile/wizardFireball */ "./src/projectile/wizardFireball.ts");
const random_1 = __webpack_require__(/*! ../../utility/random */ "./src/utility/random.ts");
const enemy_1 = __webpack_require__(/*! ./enemy */ "./src/entity/enemy/enemy.ts");
const lightSource_1 = __webpack_require__(/*! ../../lighting/lightSource */ "./src/lighting/lightSource.ts");
var WizardState;
(function (WizardState) {
    WizardState[WizardState["idle"] = 0] = "idle";
    WizardState[WizardState["attack"] = 1] = "attack";
    WizardState[WizardState["justAttacked"] = 2] = "justAttacked";
    WizardState[WizardState["teleport"] = 3] = "teleport";
})(WizardState = exports.WizardState || (exports.WizardState = {}));
class WizardEnemy extends enemy_1.Enemy {
    constructor(room, game, x, y, drop) {
        super(room, game, x, y);
        this.ATTACK_RADIUS = 5;
        this.newLightSource = (x, y, radius, color, brightness) => {
            this.lightSource = new lightSource_1.LightSource(x, y, radius, color, brightness);
        };
        this.addLightSource = (lightSource) => {
            this.room.lightSources.push(lightSource);
        };
        this.removeLightSource = (lightSource) => {
            this.room.lightSources = this.room.lightSources.filter((ls) => ls !== lightSource);
        };
        this.hit = () => {
            return 1;
        };
        this.withinAttackingRangeOfPlayer = () => {
            let withinRange = false;
            for (const i in this.game.players) {
                if ((this.x - this.game.players[i].x) ** 2 +
                    (this.y - this.game.players[i].y) ** 2 <=
                    this.ATTACK_RADIUS ** 2) {
                    withinRange = true;
                }
            }
            return withinRange;
        };
        this.shuffle = (a) => {
            let j, x, i;
            for (i = a.length - 1; i > 0; i--) {
                j = Math.floor(random_1.Random.rand() * (i + 1));
                x = a[i];
                a[i] = a[j];
                a[j] = x;
            }
            return a;
        };
        this.behavior = () => {
            this.lastX = this.x;
            this.lastY = this.y;
            if (!this.dead) {
                if (this.skipNextTurns > 0) {
                    this.skipNextTurns--;
                    return;
                }
                if (!this.seenPlayer)
                    this.lookForPlayer();
                else if (this.seenPlayer) {
                    this.alertTicks = Math.max(0, this.alertTicks - 1);
                    switch (this.state) {
                        case WizardState.attack:
                            const nearestPlayerInfo = this.nearestPlayer();
                            if (nearestPlayerInfo !== false) {
                                const [distance, targetPlayer] = nearestPlayerInfo;
                                const attackLength = 20;
                                const offsets = this.calculateProjectileOffsets(targetPlayer.x, targetPlayer.y, 10);
                                this.attemptProjectilePlacement([
                                    { x: -1, y: 0 },
                                    { x: -2, y: 0 },
                                    { x: 1, y: 0 },
                                    { x: 2, y: 0 },
                                    { x: 0, y: -1 },
                                    { x: 0, y: -2 },
                                    { x: 0, y: 1 },
                                    { x: 0, y: 2 },
                                ], wizardFireball_1.WizardFireball, false);
                            }
                            this.state = WizardState.justAttacked;
                            break;
                        case WizardState.justAttacked:
                            this.state = WizardState.idle;
                            break;
                        case WizardState.teleport:
                            let oldX = this.x;
                            let oldY = this.y;
                            let min = 100000;
                            let bestPos;
                            let emptyTiles = this.shuffle(this.room.getEmptyTiles());
                            emptyTiles = emptyTiles.filter((tile) => !this.room.projectiles.some((projectile) => projectile.x === tile.x && projectile.y === tile.y));
                            let optimalDist = game_1.Game.randTable([2, 2, 3, 3, 3, 3, 3], random_1.Random.rand);
                            // pick a random player to target
                            let player_ids = [];
                            for (const i in this.game.players)
                                player_ids.push(i);
                            let target_player_id = game_1.Game.randTable(player_ids, random_1.Random.rand);
                            for (let t of emptyTiles) {
                                let newPos = t;
                                let dist = Math.abs(newPos.x - this.game.players[target_player_id].x) +
                                    Math.abs(newPos.y - this.game.players[target_player_id].y);
                                if (Math.abs(dist - optimalDist) < Math.abs(min - optimalDist)) {
                                    min = dist;
                                    bestPos = newPos;
                                }
                            }
                            if (bestPos) {
                                this.tryMove(bestPos.x, bestPos.y);
                                this.drawX = this.x - oldX;
                                this.drawY = this.y - oldY;
                                this.frame = 0; // trigger teleport animation
                                this.room.particles.push(new wizardTeleportParticle_1.WizardTeleportParticle(oldX, oldY));
                                if (this.withinAttackingRangeOfPlayer()) {
                                    this.state = WizardState.attack;
                                }
                                else {
                                    this.state = WizardState.idle;
                                }
                            }
                            break;
                        case WizardState.idle:
                            this.state = WizardState.teleport;
                            break;
                    }
                }
            }
        };
        this.draw = (delta) => {
            if (this.dead)
                return;
            game_1.Game.ctx.save();
            game_1.Game.ctx.globalAlpha = this.alpha;
            if (!this.dead) {
                this.updateDrawXY(delta);
                if (this.state === WizardState.attack)
                    this.tileX = 7;
                else
                    this.tileX = 6;
                if (this.hasShadow)
                    game_1.Game.drawMob(0, 0, 1, 1, this.x - this.drawX, this.y - this.drawY, 1, 1, this.room.shadeColor, this.shadeAmount());
                if (this.frame >= 0) {
                    game_1.Game.drawMob(Math.floor(this.frame) + 6, 2, 1, 2, this.x, this.y - 1.5, 1, 2, this.softShadeColor, this.shadeAmount());
                    this.frame += 0.2 * delta;
                    if (this.frame > 11)
                        this.frame = -1;
                }
                else {
                    game_1.Game.drawMob(this.tileX, this.tileY, 1, 2, this.x - this.drawX, this.y - 1.3 - this.drawY, 1, 2, this.softShadeColor, this.shadeAmount());
                }
                if (!this.seenPlayer) {
                    this.drawSleepingZs(delta);
                }
                if (this.alertTicks > 0) {
                    this.drawExclamation(delta);
                }
            }
            game_1.Game.ctx.restore();
        };
        this.ticks = 0;
        this.health = 1;
        this.tileX = 6;
        this.tileY = 0;
        this.frame = 0;
        this.state = WizardState.attack;
        this.seenPlayer = false;
        this.alertTicks = 0;
        this.name = "wizard bomber";
        if (drop)
            this.drop = drop;
        this.getDrop(["weapon", "equipment", "consumable", "tool", "coin"]);
    }
}
exports.WizardEnemy = WizardEnemy;
WizardEnemy.difficulty = 3;
WizardEnemy.tileX = 6;
WizardEnemy.tileY = 0;


/***/ }),

/***/ "./src/entity/enemy/zombieEnemy.ts":
/*!*****************************************!*\
  !*** ./src/entity/enemy/zombieEnemy.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ZombieEnemy = void 0;
const game_1 = __webpack_require__(/*! ../../game */ "./src/game.ts");
const astarclass_1 = __webpack_require__(/*! ../../utility/astarclass */ "./src/utility/astarclass.ts");
const spiketrap_1 = __webpack_require__(/*! ../../tile/spiketrap */ "./src/tile/spiketrap.ts");
const enemy_1 = __webpack_require__(/*! ./enemy */ "./src/entity/enemy/enemy.ts");
class ZombieEnemy extends enemy_1.Enemy {
    constructor(room, game, x, y, drop) {
        super(room, game, x, y);
        this.hit = () => {
            return 1;
        };
        this.behavior = () => {
            // Store the current position
            this.lastX = this.x;
            this.lastY = this.y;
            // If the enemy is not dead
            if (!this.dead) {
                // Skip turns if necessary
                if (this.skipNextTurns > 0) {
                    this.skipNextTurns--;
                    return;
                }
                // Increment the tick counter
                this.ticks++;
                // If the enemy has not seen the player yet
                if (!this.seenPlayer)
                    this.lookForPlayer();
                else if (this.seenPlayer) {
                    // If the target player has taken their turn
                    if (this.room.playerTicked === this.targetPlayer) {
                        // Decrement alert ticks
                        this.alertTicks = Math.max(0, this.alertTicks - 1);
                        // Store the old position
                        let oldX = this.x;
                        let oldY = this.y;
                        // Create a list of positions to avoid
                        let disablePositions = Array();
                        for (const e of this.room.entities) {
                            if (e !== this) {
                                disablePositions.push({ x: e.x, y: e.y });
                            }
                        }
                        for (let xx = this.x - 1; xx <= this.x + 1; xx++) {
                            for (let yy = this.y - 1; yy <= this.y + 1; yy++) {
                                if (this.room.roomArray[xx][yy] instanceof spiketrap_1.SpikeTrap &&
                                    this.room.roomArray[xx][yy].on) {
                                    // Don't walk on active spike traps
                                    disablePositions.push({ x: xx, y: yy });
                                }
                            }
                        }
                        // Create a grid of the room
                        let grid = [];
                        for (let x = 0; x < this.room.roomX + this.room.width; x++) {
                            grid[x] = [];
                            for (let y = 0; y < this.room.roomY + this.room.height; y++) {
                                if (this.room.roomArray[x] && this.room.roomArray[x][y])
                                    grid[x][y] = this.room.roomArray[x][y];
                                else
                                    grid[x][y] = false;
                            }
                        }
                        // Find a path to the target player
                        let moves = astarclass_1.astar.AStar.search(grid, this, this.targetPlayer, disablePositions, false, false, true, this.direction);
                        // If there are moves available
                        if (moves.length > 0) {
                            let moveX = moves[0].pos.x;
                            let moveY = moves[0].pos.y;
                            let oldDir = this.direction;
                            let player = this.targetPlayer;
                            // Face the target player
                            this.facePlayer(player);
                            // Determine the new direction based on the move
                            if (moveX > oldX)
                                this.direction = game_1.Direction.RIGHT;
                            else if (moveX < oldX)
                                this.direction = game_1.Direction.LEFT;
                            else if (moveY > oldY)
                                this.direction = game_1.Direction.DOWN;
                            else if (moveY < oldY)
                                this.direction = game_1.Direction.UP;
                            // If the direction hasn't changed, attempt to move or attack
                            if (oldDir == this.direction) {
                                let hitPlayer = false;
                                for (const i in this.game.players) {
                                    if (this.game.rooms[this.game.players[i].levelID] === this.room &&
                                        this.game.players[i].x === moveX &&
                                        this.game.players[i].y === moveY) {
                                        // Attack the player if they are in the way
                                        this.game.players[i].hurt(this.hit(), this.name);
                                        this.drawX = 0.5 * (this.x - this.game.players[i].x);
                                        this.drawY = 0.5 * (this.y - this.game.players[i].y);
                                        if (this.game.players[i] ===
                                            this.game.players[this.game.localPlayerID])
                                            this.game.shakeScreen(10 * this.drawX, 10 * this.drawY);
                                    }
                                }
                                if (!hitPlayer) {
                                    // Move to the new position
                                    this.tryMove(moveX, moveY);
                                    this.setDrawXY(oldX, oldY);
                                    if (this.x > oldX)
                                        this.direction = game_1.Direction.RIGHT;
                                    else if (this.x < oldX)
                                        this.direction = game_1.Direction.LEFT;
                                    else if (this.y > oldY)
                                        this.direction = game_1.Direction.DOWN;
                                    else if (this.y < oldY)
                                        this.direction = game_1.Direction.UP;
                                }
                            }
                        }
                        // Add positions to avoid based on the current direction
                        if (this.direction == game_1.Direction.LEFT) {
                            disablePositions.push({
                                x: this.x,
                                y: this.y + 1,
                            });
                            disablePositions.push({
                                x: this.x,
                                y: this.y - 1,
                            });
                        }
                        if (this.direction == game_1.Direction.RIGHT) {
                            disablePositions.push({
                                x: this.x,
                                y: this.y + 1,
                            });
                            disablePositions.push({
                                x: this.x,
                                y: this.y - 1,
                            });
                        }
                        if (this.direction == game_1.Direction.DOWN) {
                            disablePositions.push({
                                x: this.x + 1,
                                y: this.y,
                            });
                            disablePositions.push({
                                x: this.x - 1,
                                y: this.y,
                            });
                        }
                        if (this.direction == game_1.Direction.UP) {
                            disablePositions.push({
                                x: this.x + 1,
                                y: this.y,
                            });
                            disablePositions.push({
                                x: this.x - 1,
                                y: this.y,
                            });
                        }
                        // Make hit warnings
                        this.makeHitWarnings();
                    }
                    // Check if the target player is offline
                    let targetPlayerOffline = Object.values(this.game.offlinePlayers).indexOf(this.targetPlayer) !==
                        -1;
                    // If the enemy is not aggro or the target player is offline, find a new target player
                    if (!this.aggro || targetPlayerOffline) {
                        let p = this.nearestPlayer();
                        if (p !== false) {
                            let [distance, player] = p;
                            if (distance <= 4 &&
                                (targetPlayerOffline ||
                                    distance < this.playerDistance(this.targetPlayer))) {
                                if (player !== this.targetPlayer) {
                                    this.targetPlayer = player;
                                    this.facePlayer(player);
                                    if (player === this.game.players[this.game.localPlayerID])
                                        this.alertTicks = 1;
                                    this.makeHitWarnings();
                                }
                            }
                        }
                    }
                }
            }
        };
        this.draw = (delta) => {
            if (this.dead)
                return;
            //this.updateShadeColor(delta);
            game_1.Game.ctx.globalAlpha = this.alpha;
            this.updateDrawXY(delta);
            this.frame += 0.1 * delta;
            if (this.frame >= 4)
                this.frame = 0;
            if (this.hasShadow)
                game_1.Game.drawMob(0, 0, 1, 1, this.x - this.drawX, this.y - this.drawY, 1, 1, this.shadeColor, this.shadeAmount());
            game_1.Game.drawMob(this.tileX + Math.floor(this.frame), this.tileY + this.direction * 2, 1, 2, this.x - this.drawX, this.y - this.drawYOffset - this.drawY - this.jumpY, 1, 2, this.softShadeColor, this.shadeAmount());
            if (!this.cloned) {
                if (!this.seenPlayer) {
                    this.drawSleepingZs(delta);
                }
                if (this.alertTicks > 0) {
                    this.drawExclamation(delta);
                }
            }
            game_1.Game.ctx.globalAlpha = 1;
        };
        this.ticks = 0;
        this.frame = 0;
        this.health = 1;
        this.maxHealth = 1;
        this.tileX = 17;
        this.tileY = 8;
        this.seenPlayer = false;
        this.aggro = false;
        this.dir = game_1.Direction.DOWN;
        this.name = "zombie";
        this.forwardOnlyAttack = true;
        this.jumpHeight = 0.35;
        if (drop)
            this.drop = drop;
        this.getDrop(["consumable", "tool", "coin"]);
    }
}
exports.ZombieEnemy = ZombieEnemy;
ZombieEnemy.difficulty = 1;
ZombieEnemy.tileX = 17;
ZombieEnemy.tileY = 8;


/***/ }),

/***/ "./src/entity/entity.ts":
/*!******************************!*\
  !*** ./src/entity/entity.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Entity = exports.EntityType = exports.EntityDirection = void 0;
const game_1 = __webpack_require__(/*! ../game */ "./src/game.ts");
const healthbar_1 = __webpack_require__(/*! ../drawable/healthbar */ "./src/drawable/healthbar.ts");
const drawable_1 = __webpack_require__(/*! ../drawable/drawable */ "./src/drawable/drawable.ts");
const gameConstants_1 = __webpack_require__(/*! ../game/gameConstants */ "./src/game/gameConstants.ts");
const hitWarning_1 = __webpack_require__(/*! ../drawable/hitWarning */ "./src/drawable/hitWarning.ts");
const utils_1 = __webpack_require__(/*! ../utility/utils */ "./src/utility/utils.ts");
const eventBus_1 = __webpack_require__(/*! ../event/eventBus */ "./src/event/eventBus.ts");
const events_1 = __webpack_require__(/*! ../event/events */ "./src/event/events.ts");
const damageNumber_1 = __webpack_require__(/*! ../particle/damageNumber */ "./src/particle/damageNumber.ts");
const downLadder_1 = __webpack_require__(/*! ../tile/downLadder */ "./src/tile/downLadder.ts");
const door_1 = __webpack_require__(/*! ../tile/door */ "./src/tile/door.ts");
const wall_1 = __webpack_require__(/*! ../tile/wall */ "./src/tile/wall.ts");
const IdGenerator_1 = __webpack_require__(/*! ../globalStateManager/IdGenerator */ "./src/globalStateManager/IdGenerator.ts");
const dropTable_1 = __webpack_require__(/*! ../item/dropTable */ "./src/item/dropTable.ts");
const weapon_1 = __webpack_require__(/*! ../item/weapon/weapon */ "./src/item/weapon/weapon.ts");
const enemyShield_1 = __webpack_require__(/*! ../projectile/enemyShield */ "./src/projectile/enemyShield.ts");
const sound_1 = __webpack_require__(/*! ../sound/sound */ "./src/sound/sound.ts");
const imageParticle_1 = __webpack_require__(/*! ../particle/imageParticle */ "./src/particle/imageParticle.ts");
const coin_1 = __webpack_require__(/*! ../item/coin */ "./src/item/coin.ts");
const random_1 = __webpack_require__(/*! ../utility/random */ "./src/utility/random.ts");
var EntityDirection;
(function (EntityDirection) {
    EntityDirection[EntityDirection["DOWN"] = 0] = "DOWN";
    EntityDirection[EntityDirection["UP"] = 1] = "UP";
    EntityDirection[EntityDirection["RIGHT"] = 2] = "RIGHT";
    EntityDirection[EntityDirection["LEFT"] = 3] = "LEFT";
})(EntityDirection = exports.EntityDirection || (exports.EntityDirection = {}));
var EntityType;
(function (EntityType) {
    EntityType[EntityType["ENEMY"] = 0] = "ENEMY";
    EntityType[EntityType["FRIENDLY"] = 1] = "FRIENDLY";
    EntityType[EntityType["RESOURCE"] = 2] = "RESOURCE";
    EntityType[EntityType["PROP"] = 3] = "PROP";
    EntityType[EntityType["CHEST"] = 4] = "CHEST";
})(EntityType = exports.EntityType || (exports.EntityType = {}));
class Entity extends drawable_1.Drawable {
    constructor(room, game, x, y) {
        super();
        this.sleepingZFrame = 0;
        this.imageParticleX = 0;
        this.imageParticleY = 26;
        this.dropChance = 1;
        //shadeColor: string;
        this.shadeMultiplier = 1;
        this.bloomColor = "#FFFFFF";
        this.bloomAlpha = 1;
        this.softBloomAlpha = 1;
        this.bloomSize = 1;
        this.bloomOffsetY = 0;
        this.opaque = false;
        this.opacity = 0;
        this.hasHitParticles = true;
        this.hasDamageNumbers = true;
        this.armored = false;
        this.justHurt = false;
        this.stunned = false;
        this.hoverText = () => {
            return this.name;
        };
        this.applyShield = (shieldHealth = 1) => {
            if (!this.shieldedBefore) {
                this.shield = new enemyShield_1.EnemyShield(this, this.x, this.y, shieldHealth);
                this.shielded = true;
                this.shieldedBefore = true;
                this.health += shieldHealth;
                this.maxHealth += shieldHealth;
                this.shadeColor = "purple";
                this.shadeMultiplier = 0.5;
                this.hasBloom = true;
                this.bloomColor = "#2E0854";
                this.bloomAlpha = 1;
            }
        };
        this.removeShield = () => {
            if (this.shield) {
                this.health -= this.shield.health;
                this.maxHealth -= this.shield.health;
                this.shield.remove();
                this.shadeColor = this.room.shadeColor;
                this.shadeMultiplier = 1;
                this.hasBloom = false;
                this.bloomAlpha = 0;
            }
        };
        this.getDrop = (useCategory = [], force = false) => {
            if (this.cloned)
                return;
            const drops = this.dropTable && this.dropTable.length > 0
                ? this.dropTable
                : useCategory;
            dropTable_1.DropTable.getDrop(this, drops, force, 3);
            //make monsters drop degraded weapons
            if (this.drop instanceof weapon_1.Weapon && this.type === EntityType.ENEMY) {
                this.drop.durability = Math.floor(random_1.Random.rand() * 0.31 * this.drop.durabilityMax);
                this.drop.durabilityMax;
            }
        };
        this.addLightSource = (lightSource) => {
            if (!this.cloned)
                this.room.lightSources.push(lightSource);
        };
        this.removeLightSource = (lightSource) => {
            this.room.lightSources = this.room.lightSources.filter((ls) => ls !== lightSource);
            //this.lightSource = null;
            this.room.updateLighting();
        };
        this.behavior = () => { };
        this.hit = () => {
            return 0;
        };
        this.hurtCallback = () => { };
        this.pointIn = (x, y) => {
            return (x >= this.x && x < this.x + this.w && y >= this.y && y < this.y + this.h);
        };
        this.createDamageNumber = (damage, type = "none") => {
            let color = "red";
            let outlineColor = gameConstants_1.GameConstants.OUTLINE;
            if (type === "poison")
                color = "green";
            if (type === "blood") {
                color = "#8B0000";
                outlineColor = "red";
            }
            if (type === "heal") {
                color = "#B8A4FF";
                outlineColor = gameConstants_1.GameConstants.OUTLINE;
            }
            this.room.particles.push(new damageNumber_1.DamageNumber(this.room, this.x, this.y, damage, color, outlineColor));
        };
        this.updateDrawXY = (delta) => {
            //putting this here bc i'm lazy
            this.updateHurtFrame(delta);
            this.animateDying(delta);
            this.updateShadeColor(delta);
            //this.updateBloom(delta);
            if (!this.doneMoving()) {
                this.drawX *= this.drawMoveSpeed ** delta;
                this.drawY *= this.drawMoveSpeed ** delta;
                this.drawX = Math.abs(this.drawX) < 0.01 ? 0 : this.drawX;
                this.drawY = Math.abs(this.drawY) < 0.01 ? 0 : this.drawY;
            }
        };
        this.setDrawXY = (x, y) => {
            this.drawX += this.x - x;
            this.drawY += this.y - y;
        };
        this.tryMove = (x, y, collide = true) => {
            let pointWouldBeIn = (someX, someY) => {
                return (someX >= x && someX < x + this.w && someY >= y && someY < y + this.h);
            };
            let entityCollide = (entity) => {
                if (entity.x >= x + this.w || entity.x + entity.w <= x)
                    return false;
                if (entity.y >= y + this.h || entity.y + entity.h <= y)
                    return false;
                return true;
            };
            for (const e of this.room.entities) {
                if (e !== this && entityCollide(e) && collide) {
                    return;
                }
            }
            for (const i in this.game.players) {
                if (pointWouldBeIn(this.game.players[i].x, this.game.players[i].y)) {
                    return;
                }
            }
            let tiles = [];
            for (let xx = 0; xx < this.w; xx++) {
                for (let yy = 0; yy < this.h; yy++) {
                    if (!this.room.roomArray[x + xx][y + yy].isSolid() &&
                        !(this.room.roomArray[x + xx][y + yy] instanceof door_1.Door) &&
                        !(this.room.roomArray[x + xx][y + yy] instanceof downLadder_1.DownLadder)) {
                        tiles.push(this.room.roomArray[x + xx][y + yy]);
                    }
                    else {
                        return;
                    }
                }
            }
            for (let tile of tiles) {
                tile.onCollideEnemy(this);
            }
            this.x = x;
            this.y = y;
        };
        this.getPlayer = () => {
            const maxDistance = 138291380921; // pulled this straight outta my ass
            let closestDistance = maxDistance;
            let closestPlayer = null;
            for (const i in this.game.players) {
                if (this.game.rooms[this.game.players[i].levelID] === this.room) {
                    let distance = this.playerDistance(this.game.players[i]);
                    if (distance < closestDistance) {
                        closestDistance = distance;
                        closestPlayer = this.game.players[i];
                    }
                }
            }
            if (closestDistance === maxDistance)
                return false;
            else
                return closestPlayer;
        };
        this.onHurt = (damage = 1, type = "none") => { };
        this.hurt = (playerHitBy, damage, type = "none") => {
            this.handleEnemyCase(playerHitBy);
            let hitShield = false;
            let shieldHealth = 0;
            if (this.shielded) {
                shieldHealth = this.shield.health;
                if (shieldHealth > 0) {
                    this.shield.hurt(damage);
                    hitShield = true;
                }
            }
            /*
            this.shadeColor = "red";
            setTimeout(() => {
              this.shadeColor = this.room.shadeColor;
            }, 100);
            */
            if (this.armored && this.health === this.maxHealth)
                sound_1.Sound.playParry();
            this.health -= damage;
            this.maxHealth -= shieldHealth;
            this.onHurt(damage, type);
            this.startHurting();
            if (this.hasDamageNumbers)
                this.createDamageNumber(damage, type);
            this.playHitSound();
            this.healthBar.hurt();
            if (type === "none" || this.health <= 0 || !this.isEnemy) {
                this.createHitParticles();
            }
            if (this.health <= 0) {
                this.kill();
                this.bloomAlpha = 0;
            }
            else
                this.hurtCallback();
        };
        this.wander = () => {
            // Store old position to check if move was successful
            const oldX = this.x;
            const oldY = this.y;
            // Try up to 4 times to find a valid move
            for (let attempts = 0; attempts < 4; attempts++) {
                // Choose a random direction
                const directions = [
                    game_1.Direction.UP,
                    game_1.Direction.DOWN,
                    game_1.Direction.LEFT,
                    game_1.Direction.RIGHT,
                ];
                const randomDirection = directions[Math.floor(random_1.Random.rand() * directions.length)];
                // Calculate target position based on direction
                let targetX = this.x;
                let targetY = this.y;
                switch (randomDirection) {
                    case game_1.Direction.UP:
                        targetY = this.y - 1;
                        break;
                    case game_1.Direction.DOWN:
                        targetY = this.y + 1;
                        break;
                    case game_1.Direction.LEFT:
                        targetX = this.x - 1;
                        break;
                    case game_1.Direction.RIGHT:
                        targetX = this.x + 1;
                        break;
                }
                // Try to move to the target position
                this.tryMove(targetX, targetY);
                this.setDrawXY(oldX, oldY);
                // If the move was successful, update direction and drawing, then break
                if (this.x !== oldX || this.y !== oldY) {
                    this.direction = randomDirection;
                    this.setDrawXY(targetX, targetY);
                    break;
                }
            }
        };
        this.runAway = () => {
            const player = this.getPlayer();
            if (!player) {
                this.wander();
                return;
            }
            const distance = utils_1.Utils.distance(this.x, this.y, player.x, player.y);
            if (distance > 10) {
                this.wander();
                return;
            }
            // Store old position to check if move was successful
            const oldX = this.x;
            const oldY = this.y;
            // Calculate all possible positions with their distances
            const newPositions = [
                { x: this.x - 1, y: this.y },
                { x: this.x + 1, y: this.y },
                { x: this.x, y: this.y - 1 },
                { x: this.x, y: this.y + 1 },
            ].map((position) => ({
                position,
                distance: utils_1.Utils.distance(player.x, player.y, position.x, position.y),
            }));
            // Sort by distance (furthest first)
            newPositions.sort((a, b) => b.distance - a.distance);
            // Choose either furthest or second furthest
            const chooseSecondFurthest = random_1.Random.rand() < 0.3;
            const chosenPosition = chooseSecondFurthest && newPositions.length > 1
                ? newPositions[1].position
                : newPositions[0].position;
            const targetX = chosenPosition.x;
            const targetY = chosenPosition.y;
            // Try to move to the target position
            this.tryMove(targetX, targetY);
            this.setDrawXY(oldX, oldY);
            // If the move was successful, update direction and drawing
            if (this.x !== oldX || this.y !== oldY) {
                // Set direction based on actual movement
                const dx = this.x - oldX;
                const dy = this.y - oldY;
                if (dx > 0) {
                    this.direction = game_1.Direction.RIGHT;
                }
                else if (dx < 0) {
                    this.direction = game_1.Direction.LEFT;
                }
                else if (dy > 0) {
                    this.direction = game_1.Direction.DOWN;
                }
                else if (dy < 0) {
                    this.direction = game_1.Direction.UP;
                }
                this.setDrawXY(targetX, targetY);
            }
            else {
                // If we couldn't move away, just wander
                this.wander();
            }
        };
        this.startHurting = () => {
            this.hurting = true;
            this.hurtFrame += 15;
            this.shadeColor = "#FF0000";
            this.shadeMultiplier = 1.5;
        };
        this.stopHurting = () => {
            this.hurting = false;
            this.hurtFrame = 0;
            this.shadeColor = "#000000";
        };
        this.interact = (player) => { };
        this.handleEnemyCase = (playerHitBy) => { };
        this.playHitSound = () => {
            if (this.hitSound)
                sound_1.Sound.delayPlay(this.hitSound, 50);
        };
        this.createHitParticles = (particleX, particleY) => {
            if (this.cloned)
                return;
            if (!this.hasHitParticles)
                return;
            if (!particleX)
                particleX = this.imageParticleX;
            if (!particleY)
                particleY = this.imageParticleY;
            imageParticle_1.ImageParticle.spawnCluster(this.room, this.x + 0.5, this.y + 0.5, particleX, particleY);
        };
        this.dropLoot = () => {
            let coordX;
            let coordY;
            if (this.crushed) {
                coordX = this.lastX;
                coordY = this.lastY;
            }
            else {
                coordX = this.x;
                coordY = this.y;
            }
            if (this.drops.length === 0 && this.isEnemy) {
                this.drops.push(new coin_1.Coin(this.room, this.x, this.y));
            }
            if (this.drops.length > 0) {
                this.drops.forEach((drop) => {
                    drop.level = this.room;
                    if (!this.room.roomArray[coordX][coordY].isSolid()) {
                        drop.x = coordX;
                        drop.y = coordY;
                    }
                    this.room.items.push(drop);
                    drop.onDrop();
                });
            }
        };
        this.kill = (player) => {
            this.dead = true;
            if (this.cloned)
                return;
            this.emitEnemyKilled();
            this.dropLoot();
            const deadEntity = this.clone();
            this.room.deadEntities.push(deadEntity);
            //this.room.entities = this.room.entities.filter((e) => e !== this);
            this.removeLightSource(this.lightSource);
            this.uniqueKillBehavior();
        };
        this.uniqueKillBehavior = () => { };
        this.updateHurtFrame = (delta) => {
            if (this.hurting) {
                this.hurtFrame -= delta;
                if (this.hurtFrame < 0) {
                    this.stopHurting();
                }
            }
        };
        this.shadeAmount = () => {
            if (gameConstants_1.GameConstants.SMOOTH_LIGHTING)
                return 0;
            let softVis = this.room.softVis[this.x][this.y] * 1;
            if (this.shadeMultiplier > 1)
                return Math.min(1, softVis * this.shadeMultiplier);
            return this.room.softVis[this.x][this.y];
        };
        this.updateShadeColor = (delta) => {
            if (this.shadeMultiplier > 1)
                this.shadeMultiplier -= 0.01 * delta;
            if (this.shadeMultiplier < 1)
                this.shadeMultiplier = 1;
            let updated = false;
            // Convert hex color to RGB
            const hexToRgb = (hex) => {
                const bigint = parseInt(hex.slice(1), 16);
                const r = (bigint >> 16) & 255;
                const g = (bigint >> 8) & 255;
                const b = bigint & 255;
                return [r, g, b];
            };
            // Convert RGB to hex color
            const rgbToHex = (rgb) => {
                const [r, g, b] = rgb;
                return ("#" +
                    ((1 << 24) + (r << 16) + (g << 8) + b)
                        .toString(16)
                        .slice(1)
                        .toUpperCase());
            };
            const [softR, softG, softB] = hexToRgb(this.softShadeColor);
            const [targetR, targetG, targetB] = hexToRgb(this.shadeColor);
            // Calculate differences
            let diffR = softR - targetR;
            let diffG = softG - targetG;
            let diffB = softB - targetB;
            let flagR = false;
            let flagG = false;
            let flagB = false;
            if (Math.abs(diffR) > 1)
                flagR = true;
            if (Math.abs(diffG) > 1)
                flagG = true;
            if (Math.abs(diffB) > 1)
                flagB = true;
            if (!flagR && !flagG && !flagB) {
                return this.softShadeColor;
            }
            let softShadeRgb = [softR, softG, softB];
            // Apply smoothing similar to fadeLighting
            if (flagR) {
                diffR *= 0.1 * delta;
                softShadeRgb[0] = this.room.clamp(Math.round(softR - diffR), 0, 255);
                updated = true;
            }
            if (flagG) {
                diffG *= 0.1 * delta;
                softShadeRgb[1] = this.room.clamp(Math.round(softG - diffG), 0, 255);
                updated = true;
            }
            if (flagB) {
                diffB *= 0.1 * delta;
                softShadeRgb[2] = this.room.clamp(Math.round(softB - diffB), 0, 255);
                updated = true;
            }
            if (updated) {
                this.softShadeColor = rgbToHex(softShadeRgb);
            }
            return this.softShadeColor;
        };
        this.emitEnemyKilled = () => {
            let depthMultiplier = Math.log((this.room.depth + 1) * 5);
            console.log(depthMultiplier);
            let multiplier = 1;
            if (this.isEnemy)
                multiplier = 5;
            const xp = Math.ceil(this.maxHealth * multiplier * depthMultiplier);
            if (this.isEnemy)
                eventBus_1.globalEventBus.emit(events_1.EVENTS.ENEMY_KILLED, {
                    enemyId: this.name,
                    xp: xp,
                });
        };
        this.doneMoving = () => {
            let EPSILON = 0.01;
            return Math.abs(this.drawX) < EPSILON && Math.abs(this.drawY) < EPSILON;
        };
        this.nearestPlayer = () => {
            const maxDistance = 138291380921; // pulled this straight outta my ass
            let closestDistance = maxDistance;
            let closestPlayer = null;
            for (const i in this.game.players) {
                if (this.game.rooms[this.game.players[i].levelID] === this.room) {
                    let distance = this.playerDistance(this.game.players[i]);
                    if (distance < closestDistance) {
                        closestDistance = distance;
                        closestPlayer = this.game.players[i];
                    }
                }
            }
            if (closestDistance === maxDistance)
                return false;
            else
                return [closestDistance, closestPlayer];
        };
        this.playerDistance = (player) => {
            return Math.max(Math.abs(this.x - player.x), Math.abs(this.y - player.y));
        };
        this.facePlayer = (player) => {
            // For 1x1 entities, use the existing perfect logic
            if (this.w === 1 && this.h === 1) {
                const entityCenterX = this.x + (this.w - 1) / 2;
                const entityCenterY = this.y + (this.h - 1) / 2;
                let dx = player.x - entityCenterX;
                let dy = player.y - entityCenterY;
                if (Math.abs(dx) === Math.abs(dy)) {
                    // just moved, already facing player
                }
                else if (Math.abs(dx) > Math.abs(dy)) {
                    if (dx > 0)
                        this.direction = game_1.Direction.RIGHT;
                    if (dx < 0)
                        this.direction = game_1.Direction.LEFT;
                }
                else {
                    if (dy > 0)
                        this.direction = game_1.Direction.DOWN;
                    if (dy < 0)
                        this.direction = game_1.Direction.UP;
                }
                return;
            }
            // For bigger entities, check if player shares any row or column
            const sharesRow = player.y >= this.y && player.y < this.y + this.h;
            const sharesColumn = player.x >= this.x && player.x < this.x + this.w;
            // If sharing both row and column, player is overlapping - don't change direction
            if (sharesRow && sharesColumn) {
                return;
            }
            // If sharing a row but not a column, face horizontally toward player
            if (sharesRow && !sharesColumn) {
                if (player.x < this.x) {
                    this.direction = game_1.Direction.LEFT;
                }
                else {
                    this.direction = game_1.Direction.RIGHT;
                }
                return;
            }
            // If sharing a column but not a row, face vertically toward player
            if (sharesColumn && !sharesRow) {
                if (player.y < this.y) {
                    this.direction = game_1.Direction.UP;
                }
                else {
                    this.direction = game_1.Direction.DOWN;
                }
                return;
            }
            // If not sharing any row or column, use distance-based logic
            const entityCenterX = this.x + (this.w - 1) / 2;
            const entityCenterY = this.y + (this.h - 1) / 2;
            let dx = player.x - entityCenterX;
            let dy = player.y - entityCenterY;
            if (Math.abs(dx) > Math.abs(dy)) {
                if (dx > 0)
                    this.direction = game_1.Direction.RIGHT;
                if (dx < 0)
                    this.direction = game_1.Direction.LEFT;
            }
            else {
                if (dy > 0)
                    this.direction = game_1.Direction.DOWN;
                if (dy < 0)
                    this.direction = game_1.Direction.UP;
            }
        };
        this.animateDying = (delta) => {
            if (this.cloned) {
                //this.frame = 0;
                this.dyingFrame -= delta / 3;
                this.alpha = Math.max(0, this.alpha - delta / 50);
                if (this.dyingFrame <= 0) {
                    this.dead = true;
                    this.dying = false;
                    this.uniqueKillBehavior();
                    this.room.clearDeadStuff();
                }
            }
        };
        this.draw = (delta) => {
            if (this.dead)
                return;
            game_1.Game.ctx.globalAlpha = this.alpha;
            this.updateDrawXY(delta);
            if (this.hasShadow) {
                game_1.Game.drawFX(0, 0, 1, 1, this.x - this.drawX, this.y - this.drawY, 1, 1, this.shadeColor, this.shadeAmount());
            }
            /*
            Game.drawMob(
              0,
              0,
              1,
              1,
              this.x - this.drawX,
              this.y - this.drawY,
              1,
              1,
              this.room.shadeColor,
              this.shadeAmount(),
            );
            */
            game_1.Game.drawMob(this.tileX, this.tileY + this.direction * 2, 1, 2, this.x - this.drawX, this.y - this.drawYOffset - this.drawY, 1, 2, this.shadeColor, this.shadeAmount());
            /*if (this.crushed) {
              this.crushAnim(delta);
            }*/
            game_1.Game.ctx.globalAlpha = 1;
        };
        this.tick = () => {
            this.behavior();
            if (this.shielded)
                this.shield.updateLightSourcePos();
        };
        this.emitEntityData = () => {
            eventBus_1.globalEventBus.emit("EntityData", {
                name: this.name,
                location: { x: this.x, y: this.y },
            });
        };
        this.drawTopLayer = (delta) => {
            //this.updateDrawXY(delta);
            this.drawableY = this.y - this.drawY;
            this.healthBar.draw(delta, this.health, this.maxHealth, this.x, this.y, true);
        };
        this.drawSleepingZs = (delta, offsetX = 0, offsetY = 0) => {
            this.sleepingZFrame += delta;
            let numZs = 2;
            let t = this.sleepingZFrame * 0.01; // 0 <= t < 1
            t -= Math.floor(t);
            //let whichway = Math.floor(this.sleepingZFrame * 0.02 / numZs) % 2;
            for (let off = numZs - 1; off >= 0; off--) {
                let yoff = (t + off) * 7;
                let alpha = Math.min(1 - (t + off) / numZs, (2 * (t + off)) / numZs);
                let xoff = 0;
                if (off === 0)
                    xoff = 1;
                if (t >= 0.33 && t < 0.66)
                    xoff = off;
                if (t >= 0.33 && t < 0.66)
                    xoff = off;
                let width = game_1.Game.measureText("Z").width;
                if (gameConstants_1.GameConstants.ALPHA_ENABLED)
                    game_1.Game.ctx.globalAlpha = alpha;
                game_1.Game.fillTextOutline("Z", (this.x + 0.5) * gameConstants_1.GameConstants.TILESIZE - width / 2 + xoff + offsetX, (this.y - 0.6) * gameConstants_1.GameConstants.TILESIZE - yoff + offsetY, gameConstants_1.GameConstants.OUTLINE, "white");
                game_1.Game.ctx.globalAlpha = 1;
            }
        };
        this.drawExclamation = (delta, offsetX = 0, offsetY = 0) => {
            this.exclamationFrame += delta;
            let yoff = 0;
            let yoffs = [0, -1, -2, -3, -5, -7, -4];
            if (this.exclamationFrame > yoffs.length)
                yoff = yoffs[yoffs.length - 1];
            else
                yoff = yoffs[this.exclamationFrame];
            let width = game_1.Game.measureText("!").width;
            game_1.Game.ctx.globalAlpha = 1;
            if (yoff !== false) {
                game_1.Game.fillTextOutline("!", (this.x + 0.5) * gameConstants_1.GameConstants.TILESIZE - width / 2 + offsetX, (this.y - 0.75) * gameConstants_1.GameConstants.TILESIZE + yoff + offsetY, gameConstants_1.GameConstants.OUTLINE, gameConstants_1.GameConstants.WARNING_RED);
            }
        };
        this.crush = () => {
            this.crushed = true;
            let player;
            for (let i in this.game.players) {
                player = this.game.players[i];
            }
            if (this.x == player.x) {
                this.crushVertical = true;
            }
            this.kill();
        };
        this.crushAnim = (delta) => {
            if (this.crushVertical && this.crushY >= 0) {
                this.crushY *= 0.95;
            }
            else if (this.crushX >= 0) {
                this.crushX *= 0.95;
            }
        };
        //set rumbling in the tick function for the enemies
        //create variables for the rumbling x and y offsets
        //return the rumbling x and y offsets
        //add the rumbling x and y offsets to the enemy's x and y in the draw function
        this.rumble = (rumbling, frame, direction) => {
            let rumbleOffset = { x: 0, y: 0 };
            if (rumbling) {
                const isOddFrame = Math.floor(frame) % 2 === 1;
                const offset = isOddFrame ? 0.0325 : 0;
                if (direction === game_1.Direction.LEFT || direction === game_1.Direction.RIGHT) {
                    rumbleOffset.y = offset;
                }
                else if (direction === game_1.Direction.UP ||
                    direction === game_1.Direction.DOWN ||
                    !direction) {
                    rumbleOffset.x = offset;
                }
                this.animationSpeed = 0.2;
            }
            return rumbleOffset;
        };
        this.attemptProjectilePlacement = (offsets, projectileClass, collide = false, clearPath = true, targetingPlayer = false) => {
            for (const offset of offsets) {
                const targetX = this.x + offset.x;
                const targetY = this.y + offset.y;
                if (!this.isValidProjectilePosition(targetX, targetY, collide, clearPath)) {
                    if (targetingPlayer)
                        break;
                    continue;
                }
                this.placeProjectile(projectileClass, targetX, targetY);
                if (targetingPlayer)
                    break;
            }
        };
        this.isValidProjectilePosition = (x, y, collide, clearPath) => {
            if (!this.isWithinRoomBounds(x, y))
                return false;
            if (clearPath && !this.isPathClear(this.x, this.y, x, y))
                return false;
            if (collide && this.isEntityColliding(x, y))
                return false;
            const targetTile = this.room.roomArray[x][y];
            return targetTile && !targetTile.isSolid() && !targetTile.isDoor;
        };
        this.isEntityColliding = (x, y) => {
            return this.room.entities.some((entity) => entity.x === x && entity.y === y);
        };
        this.placeProjectile = (projectileClass, x, y, color) => {
            this.room.projectiles.push(new projectileClass(this, x, y, color));
        };
        this.isPathClear = (startX, startY, endX, endY) => {
            const dx = Math.sign(endX - startX);
            const dy = Math.sign(endY - startY);
            let x = startX;
            let y = startY;
            while (x !== endX || y !== endY) {
                x += dx;
                y += dy;
                if (!this.isWithinRoomBounds(x, y) ||
                    this.room.roomArray[x][y]?.isSolid()) {
                    return false;
                }
            }
            return true;
        };
        this.getLuminance = () => {
            if (this.room.roomArray[this.x][this.y]) {
                return this.room.vis[this.x][this.y];
            }
            return null;
        };
        this.getAverageLuminance = () => {
            let total = 0;
            let count = 0;
            for (let x = this.x - 2; x <= this.x + 2; x++) {
                if (this.room.roomArray[x] && this.room.roomArray[x][this.y]) {
                    for (let y = this.y - 2; y <= this.y + 2; y++) {
                        if (this.room.vis[x][y]) {
                            total += this.room.vis[x][y];
                            count++;
                        }
                    }
                }
            }
            return total / count;
        };
        this.getOpenTile = () => {
            let x, y;
            do {
                x = Math.floor(random_1.Random.rand() * 3 + this.x - 1);
                y = Math.floor(random_1.Random.rand() * 3 + this.y - 1);
            } while ((x === this.x && y === this.y) ||
                this.room.roomArray[x][y].isSolid() ||
                this.room.roomArray[x][y] instanceof downLadder_1.DownLadder ||
                this.room.roomArray[x][y] instanceof door_1.Door ||
                this.room.roomArray[x][y] instanceof wall_1.Wall ||
                this.room.entities.some((e) => e.x === x && e.y === y));
            if (!x || !y)
                return { x: this.x, y: this.y };
            return { x, y };
        };
        this.makeBigHitWarnings = () => {
            switch (this.direction) {
                case game_1.Direction.LEFT:
                    this.makeHitWarnings(this.x, this.y);
                    this.makeHitWarnings(this.x, this.y + 1);
                    break;
                case game_1.Direction.RIGHT:
                    this.makeHitWarnings(this.x + 1, this.y);
                    this.makeHitWarnings(this.x + 1, this.y + 1);
                    break;
                case game_1.Direction.UP:
                    this.makeHitWarnings(this.x, this.y);
                    this.makeHitWarnings(this.x + 1, this.y);
                    break;
                case game_1.Direction.DOWN:
                    this.makeHitWarnings(this.x, this.y + 1);
                    this.makeHitWarnings(this.x + 1, this.y + 1);
                    break;
            }
        };
        this.makeHitWarnings = (hx = this.x, hy = this.y) => {
            if (this.unconscious)
                return;
            const cullFactor = 0.45;
            const player = this.getPlayer();
            const orthogonal = this.orthogonalAttack;
            const diagonal = this.diagonalAttack;
            const forwardOnly = this.forwardOnlyAttack;
            const direction = this.direction;
            const orthoRange = this.attackRange;
            const diagRange = this.diagonalAttackRange;
            const generateOffsets = (isOrthogonal, range) => {
                const baseOffsets = isOrthogonal
                    ? [
                        [-1, 0],
                        [1, 0],
                        [0, -1],
                        [0, 1],
                    ]
                    : [
                        [-1, -1],
                        [1, 1],
                        [1, -1],
                        [-1, 1],
                    ];
                return baseOffsets.flatMap(([dx, dy]) => Array.from({ length: range }, (_, i) => [(i + 1) * dx, (i + 1) * dy]));
            };
            const directionOffsets = {
                [game_1.Direction.LEFT]: [-1, 0],
                [game_1.Direction.RIGHT]: [1, 0],
                [game_1.Direction.UP]: [0, -1],
                [game_1.Direction.DOWN]: [0, 1],
            };
            let offsets = [];
            if (forwardOnly) {
                const [dx, dy] = directionOffsets[direction];
                offsets = Array.from({ length: orthoRange }, (_, i) => [
                    (i + 1) * dx,
                    (i + 1) * dy,
                ]);
            }
            else {
                if (orthogonal)
                    offsets.push(...generateOffsets(true, orthoRange));
                if (diagonal)
                    offsets.push(...generateOffsets(false, diagRange));
            }
            const warningCoordinates = offsets
                .map(([dx, dy]) => ({
                x: dx,
                y: dy,
                distance: utils_1.Utils.distance(dx, dy, player.x - hx, player.y - hy),
            }))
                .sort((a, b) => a.distance - b.distance);
            const keepCount = Math.ceil(warningCoordinates.length * (1 - cullFactor));
            const culledWarnings = warningCoordinates.slice(0, keepCount);
            culledWarnings.forEach(({ x, y }) => {
                const targetX = hx + x;
                const targetY = hy + y;
                if (this.isWithinRoomBounds(targetX, targetY)) {
                    const hitWarning = new hitWarning_1.HitWarning(this.game, targetX, targetY, hx, hy, true, false, this);
                    this.room.hitwarnings.push(hitWarning);
                    //this.hitWarnings.push(hitWarning);
                }
            });
        };
        this.isWithinRoomBounds = (x, y) => {
            const xInBounds = x >= this.room.roomX && x < this.room.roomX + this.room.width;
            const yInBounds = y >= this.room.roomY && y < this.room.roomY + this.room.height;
            const tileExists = this.room.roomArray[x] && this.room.roomArray[x][y] !== undefined;
            return xInBounds && yInBounds && tileExists;
        };
        this.globalId = IdGenerator_1.IdGenerator.generate("EN");
        // Check if we're in cloning mode
        const isCloning = this.constructor.__isCloning;
        // Set cloned status immediately if we're cloning
        if (isCloning) {
            this.cloned = true;
        }
        else
            this.cloned = false;
        // Only set the absolute minimum required properties if cloning
        this.room = room;
        this.x = x;
        this.y = y;
        this.w = 1;
        this.h = 1;
        this.game = game;
        this.drawX = 0;
        this.drawY = 0;
        this.health = 1;
        this.maxHealth = 1;
        this.tileX = 0;
        this.tileY = 0;
        this.hasShadow = false;
        this.skipNextTurns = 0;
        this.direction = game_1.Direction.DOWN;
        this.destroyable = true;
        this.pushable = false;
        this.chainPushable = true;
        this.interactable = false;
        this.healthBar = new healthbar_1.HealthBar();
        this.alertTicks = 0;
        this.exclamationFrame = 0;
        this.lastX = x;
        this.lastY = y;
        this.hitBy = null;
        this.crushX = 1;
        this.crushY = 1;
        this.crushVertical = false;
        this.crushed = false;
        this.rumbling = false;
        this.animationSpeed = 0.1;
        this.drawYOffset = 1.175;
        this.hitWarnings = [];
        this.orthogonalAttack = false;
        this.diagonalAttack = false;
        this.forwardOnlyAttack = false;
        this.attackRange = 1;
        this.diagonalAttackRange = 1;
        this.drawMoveSpeed = 0.9;
        this.unconscious = false;
        this.dropChance = 0.02;
        this.isEnemy = false;
        this.shielded = false;
        this.shield = null;
        this.frame = 0;
        this.shieldedBefore = false;
        this._imageParticleTiles = { x: 0, y: 0 };
        this.hitSound = null;
        this.shadeColor = this.room.shadeColor;
        this.hurting = false;
        this.hurtFrame = 0;
        this.softShadeColor = "#000000";
        this.dying = false;
        this.dyingFrame = 30;
        this.alpha = 1;
        this.dead = false;
        this.hasBloom = false;
        this.bloomColor = "#FFFFFF";
        this.moving = false;
        this.dropTable = [];
        this.drops = [];
        if (this.drop)
            this.drops.push(this.drop);
    }
    static add(room, game, x, y, ...rest) {
        // Safety checks: verify tile exists and is not solid
        if (!room.roomArray[x] || !room.roomArray[x][y]) {
            console.warn(`Cannot add entity: tile at (${x}, ${y}) does not exist`);
            return null;
        }
        if (room.roomArray[x][y].isSolid()) {
            console.warn(`Cannot add entity: tile at (${x}, ${y}) is solid`);
            return null;
        }
        const entity = new this(room, game, x, y, ...rest);
        room.entities.push(entity);
        return entity;
    }
    static cloneEntity(original) {
        // Set a temporary flag on the constructor to indicate we're cloning
        original.constructor.__isCloning = true;
        // Create minimal clone
        const cloned = new original.constructor(original.room, original.game, original.x, original.y);
        // Remove the temporary flag
        delete original.constructor.__isCloning;
        // Copy only properties needed for death animation
        Object.assign(cloned, {
            cloned: true,
            dead: false,
            dying: true,
            drawableY: original.drawableY,
            tileX: original.tileX,
            tileY: original.tileY,
            frame: original.frame,
            direction: original.direction,
            drawX: original.drawX,
            drawY: original.drawY,
            alpha: original.alpha,
            shadeColor: original.shadeColor,
            shadeMultiplier: original.shadeMultiplier,
            softShadeColor: original.softShadeColor,
            hasBloom: original.hasBloom,
            bloomColor: original.bloomColor,
            bloomAlpha: 1,
            softBloomAlpha: 1,
            dyingFrame: 30,
        });
        // Add to room's dead entities
        original.room.deadEntities.push(cloned);
        return cloned;
    }
    /**
     * Clones the current entity without adding it to deadEntities.
     */
    clone() {
        const cloned = Entity.cloneEntity(this);
        cloned.dead = false; // Explicitly set as not dead
        cloned.dying = true; // Ensure the clone is in a dying state
        return cloned;
    }
    get imageParticleTiles() {
        return this._imageParticleTiles;
    }
    get type() {
        return EntityType.ENEMY;
    }
    calculateProjectileOffsets(targetX, targetY, attackLength) {
        const dx = targetX - this.x;
        const dy = targetY - this.y;
        let offsets = [];
        // Normalize the direction
        const stepX = dx !== 0 ? Math.sign(dx) : 0;
        const stepY = dy !== 0 ? Math.sign(dy) : 0;
        // Generate offsets for the full attackLength
        for (let i = 1; i <= attackLength; i++) {
            offsets.push({ x: i * stepX, y: i * stepY });
        }
        return offsets;
    }
}
exports.Entity = Entity;


/***/ }),

/***/ "./src/entity/object/barrel.ts":
/*!*************************************!*\
  !*** ./src/entity/object/barrel.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Barrel = void 0;
const entity_1 = __webpack_require__(/*! ../entity */ "./src/entity/entity.ts");
const game_1 = __webpack_require__(/*! ../../game */ "./src/game.ts");
const entity_2 = __webpack_require__(/*! ../entity */ "./src/entity/entity.ts");
const weaponFragments_1 = __webpack_require__(/*! ../../item/usable/weaponFragments */ "./src/item/usable/weaponFragments.ts");
const coin_1 = __webpack_require__(/*! ../../item/coin */ "./src/item/coin.ts");
const random_1 = __webpack_require__(/*! ../../utility/random */ "./src/utility/random.ts");
class Barrel extends entity_1.Entity {
    constructor(room, game, x, y) {
        super(room, game, x, y);
        this.draw = (delta) => {
            if (this.dead)
                return;
            game_1.Game.ctx.save();
            game_1.Game.ctx.globalAlpha = this.alpha;
            if (!this.dead) {
                this.updateDrawXY(delta);
                game_1.Game.drawObj(this.tileX, this.tileY, 1, 2, this.x - this.drawX, this.y - this.drawYOffset - this.drawY, 1, 2, this.room.shadeColor, this.shadeAmount());
            }
            game_1.Game.ctx.restore();
        };
        this.drawTopLayer = (delta) => {
            this.drawableY = this.y;
        };
        this.room = room;
        this.health = 1;
        this.tileX = 1;
        this.tileY = 0;
        this.hasShadow = false;
        this.pushable = true;
        this.name = "barrel";
        this.imageParticleX = 3;
        this.imageParticleY = 25;
        if (random_1.Random.rand() < 0.1) {
            this.drops.push(new weaponFragments_1.WeaponFragments(this.room, this.x, this.y));
        }
        else {
            this.drops.push(new coin_1.Coin(this.room, this.x, this.y));
        }
    }
    get type() {
        return entity_2.EntityType.PROP;
    }
}
exports.Barrel = Barrel;


/***/ }),

/***/ "./src/entity/object/block.ts":
/*!************************************!*\
  !*** ./src/entity/object/block.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Block = void 0;
const entity_1 = __webpack_require__(/*! ../entity */ "./src/entity/entity.ts");
const game_1 = __webpack_require__(/*! ../../game */ "./src/game.ts");
const entity_2 = __webpack_require__(/*! ../entity */ "./src/entity/entity.ts");
const sound_1 = __webpack_require__(/*! ../../sound/sound */ "./src/sound/sound.ts");
const geode_1 = __webpack_require__(/*! ../../item/resource/geode */ "./src/item/resource/geode.ts");
const random_1 = __webpack_require__(/*! ../../utility/random */ "./src/utility/random.ts");
class Block extends entity_1.Entity {
    constructor(room, game, x, y) {
        super(room, game, x, y);
        this.uniqueKillBehavior = () => {
            if (this.cloned)
                return;
            sound_1.Sound.delayPlay(sound_1.Sound.breakRock, 50);
        };
        this.draw = (delta) => {
            if (this.dead)
                return;
            game_1.Game.ctx.save();
            game_1.Game.ctx.globalAlpha = this.alpha;
            if (!this.dead) {
                this.updateDrawXY(delta);
                game_1.Game.drawObj(this.tileX, this.tileY, 1, 2, this.x - this.drawX, this.y - this.drawYOffset - this.drawY, 1, 2, this.room.shadeColor, this.shadeAmount());
            }
            game_1.Game.ctx.restore();
        };
        this.drawTopLayer = (delta) => {
            this.drawableY = this.y;
        };
        this.room = room;
        this.health = 1;
        this.tileX = 10;
        this.tileY = 2;
        this.hasShadow = false;
        this.chainPushable = false;
        //this.pushable = true;
        this.name = "block";
        this.imageParticleX = 0;
        this.imageParticleY = 25;
        this.opaque = true;
        //this.hitSound = Sound.breakRock;
        if (random_1.Random.rand() < 0.01)
            this.drops.push(new geode_1.Geode(this.room, this.x, this.y));
    }
    get type() {
        return entity_2.EntityType.PROP;
    }
}
exports.Block = Block;


/***/ }),

/***/ "./src/entity/object/bomb.ts":
/*!***********************************!*\
  !*** ./src/entity/object/bomb.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Bomb = void 0;
const entity_1 = __webpack_require__(/*! ../entity */ "./src/entity/entity.ts");
const game_1 = __webpack_require__(/*! ../../game */ "./src/game.ts");
const genericParticle_1 = __webpack_require__(/*! ../../particle/genericParticle */ "./src/particle/genericParticle.ts");
const entity_2 = __webpack_require__(/*! ../entity */ "./src/entity/entity.ts");
const random_1 = __webpack_require__(/*! ../../utility/random */ "./src/utility/random.ts");
const sound_1 = __webpack_require__(/*! ../../sound/sound */ "./src/sound/sound.ts");
const lightSource_1 = __webpack_require__(/*! ../../lighting/lightSource */ "./src/lighting/lightSource.ts");
const lighting_1 = __webpack_require__(/*! ../../lighting/lighting */ "./src/lighting/lighting.ts");
const explosion_1 = __webpack_require__(/*! ../../projectile/explosion */ "./src/projectile/explosion.ts");
const utils_1 = __webpack_require__(/*! ../../utility/utils */ "./src/utility/utils.ts");
class Bomb extends entity_1.Entity {
    constructor(room, game, x, y) {
        super(room, game, x, y);
        this.fuseLength = 4;
        this.lit = false;
        this.playerHitBy = null;
        this.soundPaused = false;
        this.uniqueKillBehavior = () => {
            if (this.cloned)
                return;
            //this.room.addEntity(new Explosion(this.room, this.game, this.x, this.y));
        };
        this.tick = () => {
            if (this.lit) {
                this.fuseLength--;
                //if (this.fuseLength < 3 && this.fuseLength > 0)
                if (this.fuseLength <= 0) {
                    // Sound.playFuse();
                    this.fuseLength = 0;
                    sound_1.Sound.stopSound(this.fuseSound);
                    this.explode();
                    sound_1.Sound.playBomb();
                }
            }
        };
        this.createLightSource = () => {
            if (!this.lit)
                return;
            this.lightSource = new lightSource_1.LightSource(this.x + 0.5, this.y + 0.5, 3, [200, 200, 30], 0.75);
            this.addLightSource(this.lightSource);
            this.bloomAlpha = 1;
            this.hasBloom = true;
        };
        this.hurt = (playerHitBy, damage) => {
            if (!this.lit) {
                this.lit = true;
                this.createLightSource();
                this.playerHitBy = playerHitBy;
                sound_1.Sound.playFuse();
            }
        };
        this.explode = () => {
            sound_1.Sound.stopSound(this.fuseSound);
            for (let x = this.x - 2; x < this.x + 3; x++) {
                for (let y = this.y - 2; y < this.y + 3; y++) {
                    if (this.room.pointExists(x, y) &&
                        !this.room.roomArray[x][y].isSolid() &&
                        utils_1.Utils.distance(this.x, this.y, x, y) < 2.5) {
                        const explosion = new explosion_1.Explosion(this, x, y, this.playerHitBy);
                        this.room.projectiles.push(explosion);
                    }
                }
            }
            this.health = 0;
            lighting_1.Lighting.momentaryLight(this.room, this.x, this.y, 7, [200, 200, 50], 250, 50, 0);
            genericParticle_1.GenericParticle.spawnCluster(this.room, this.x + 0.5, this.y + 0.5, "white");
            this.kill();
            setTimeout(() => {
                this.game.shakeScreen((random_1.Random.rand() - 0.5) * 5, (random_1.Random.rand() - 0.5) * 0, false);
            }, 100);
            this.game.shakeScreen(0, 20, false);
        };
        this.draw = (delta) => {
            if (this.dead)
                return;
            this.frame += delta;
            if (this.health === 0) {
                this.frame = 0;
            }
            if (this.frame > 20)
                this.frame = 0;
            this.bloomAlpha = (this.frame / 10) % 2 === 0 ? 1 : 0.5;
            game_1.Game.ctx.save();
            game_1.Game.ctx.globalAlpha = this.alpha;
            if (!this.dead) {
                this.updateDrawXY(delta);
                if (this.lit) {
                    game_1.Game.drawObj(this.tileX +
                        6 -
                        Math.min(3, this.fuseLength) * 2 +
                        (Math.floor(this.frame / 10) % 2), this.tileY, 1, 2, this.x - this.drawX, this.y - this.drawYOffset - this.drawY, 1, 2, this.room.shadeColor, this.shadeAmount());
                }
                else {
                    game_1.Game.drawObj(this.tileX - 1, this.tileY, 1, 2, this.x - this.drawX, this.y - this.drawYOffset - this.drawY, 1, 2, this.room.shadeColor, this.shadeAmount());
                }
            }
            game_1.Game.ctx.restore();
        };
        this.drawTopLayer = (delta) => {
            this.drawableY = this.y;
        };
        this.room = room;
        this.health = 1;
        this.tileX = 15;
        this.tileY = 4;
        this.hasShadow = false;
        this.chainPushable = false;
        this.name = "bomb";
        this.frame = 0;
        this.hasBloom = false;
        this.bloomColor = "yellow";
        this.bloomAlpha = 0;
        this.bloomSize = 1;
        this.bloomOffsetY = -1;
        this.health = 1;
        this.hitSound = sound_1.Sound.potSmash;
        this.imageParticleX = 0;
        this.imageParticleY = 29;
        this.createLightSource();
        this.playerHitBy = null;
        this.fuseSound = sound_1.Sound.fuseLoopSound;
        this.soundPaused = false;
    }
    get type() {
        return entity_2.EntityType.PROP;
    }
}
exports.Bomb = Bomb;


/***/ }),

/***/ "./src/entity/object/bush.ts":
/*!***********************************!*\
  !*** ./src/entity/object/bush.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Bush = void 0;
const entity_1 = __webpack_require__(/*! ../entity */ "./src/entity/entity.ts");
const game_1 = __webpack_require__(/*! ../../game */ "./src/game.ts");
const entity_2 = __webpack_require__(/*! ../entity */ "./src/entity/entity.ts");
const sound_1 = __webpack_require__(/*! ../../sound/sound */ "./src/sound/sound.ts");
class Bush extends entity_1.Entity {
    constructor(room, game, x, y) {
        super(room, game, x, y);
        this.draw = (delta) => {
            if (this.dead)
                return;
            game_1.Game.ctx.save();
            game_1.Game.ctx.globalAlpha = this.alpha;
            if (!this.dead) {
                this.updateDrawXY(delta);
                game_1.Game.drawObj(this.tileX, this.tileY, 2, 2, this.x - this.drawX - 0.5, this.y - this.drawYOffset - this.drawY, 2, 2, this.room.shadeColor, this.shadeAmount());
            }
            game_1.Game.ctx.restore();
        };
        this.drawTopLayer = (delta) => {
            this.drawableY = this.y;
        };
        this.room = room;
        this.health = 1;
        this.tileX = 19;
        this.tileY = 2;
        this.hasShadow = false;
        this.chainPushable = false;
        this.name = "bush";
        this.imageParticleX = 0;
        this.imageParticleY = 28;
        this.opaque = true;
        this.hitSound = sound_1.Sound.playBush;
        //this.drops.push(new Shrooms(this.room, this.x, this.y));
    }
    get type() {
        return entity_2.EntityType.PROP;
    }
}
exports.Bush = Bush;


/***/ }),

/***/ "./src/entity/object/chest.ts":
/*!************************************!*\
  !*** ./src/entity/object/chest.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Chest = void 0;
const game_1 = __webpack_require__(/*! ../../game */ "./src/game.ts");
const entity_1 = __webpack_require__(/*! ../entity */ "./src/entity/entity.ts");
const entity_2 = __webpack_require__(/*! ../entity */ "./src/entity/entity.ts");
const random_1 = __webpack_require__(/*! ../../utility/random */ "./src/utility/random.ts");
const sound_1 = __webpack_require__(/*! ../../sound/sound */ "./src/sound/sound.ts");
class Chest extends entity_1.Entity {
    constructor(room, game, x, y) {
        super(room, game, x, y);
        this.interact = (playerHitBy) => {
            if (this.health === 3 && !this.opening) {
                this.health -= 1;
                this.open();
                return;
            }
            if (this.health !== 2)
                return;
            // Try to pick up items
            const pickedUpDrop = this.drops.find((drop) => {
                drop.onPickup(playerHitBy);
                return drop.pickedUp;
            });
            if (pickedUpDrop) {
                this.drops = this.drops.filter((d) => d !== pickedUpDrop);
            }
            const full = playerHitBy.inventory.isFull();
            if (this.drops.length === 0 || full) {
                this.health -= 1;
                this.destroyable = true;
            }
        };
        this.open = () => {
            this.tileX = 0;
            this.tileY = 2;
            this.opening = true;
            sound_1.Sound.chest();
            if (this.drop === null)
                this.getDrop(["consumable", "gem", "coin", "tool", "light", "weapon"], true);
            this.drops.forEach((drop) => {
                if (drop.name === "coin") {
                    let stack = game_1.Game.randTable([
                        1, 2, 2, 2, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 6, 6, 6, 6,
                        6, 7, 7, 7, 7, 7, 8, 8, 8, 8, 9, 9, 9, 10, 10, 11, 12, 13, 14, 15,
                        100,
                    ], random_1.Random.rand);
                    if (random_1.Random.rand() < 0.01)
                        stack *= Math.ceil(random_1.Random.rand() * 10);
                    drop.stackCount = stack;
                    //drop.stack = stack;
                }
            });
            this.dropLoot();
            this.drops.forEach((drop) => {
                drop.animateFromChest();
            });
        };
        this.draw = (delta) => {
            if (this.dead)
                return;
            game_1.Game.ctx.save();
            game_1.Game.ctx.globalAlpha = this.alpha;
            if (this.opening) {
                if (this.tileX <= 6) {
                    this.tileX += 0.15 * delta;
                }
                else {
                    this.opening = false;
                }
            }
            if (!this.dead) {
                this.updateDrawXY(delta);
                game_1.Game.drawObj(Math.floor(this.tileX), Math.floor(this.tileY), 1, 2, this.x - this.drawX, this.y - this.drawYOffset - this.drawY, 1, 2, this.room.shadeColor, this.shadeAmount());
            }
            game_1.Game.ctx.restore();
        };
        this.drawTopLayer = (delta) => {
            this.drawableY = this.y - 1;
        };
        this.tileX = 4;
        this.tileY = 0;
        this.health = 3;
        this.name = "chest";
        this.frame = 0;
        this.opening = false;
        this.dropX = 0;
        this.dropY = 0;
        this.drop = null;
        this.destroyable = false;
        this.pushable = false;
        this.chainPushable = false;
        this.interactable = true;
        this.imageParticleX = 3;
        this.imageParticleY = 26;
        /*
        this.layer = new ChestLayer(
          this.room,
          this.game,
          this.x,
          this.y,
        );
        this.room.entities.push(this.layer);
        */
    }
    get type() {
        return entity_2.EntityType.CHEST;
    }
}
exports.Chest = Chest;


/***/ }),

/***/ "./src/entity/object/chestLayer.ts":
/*!*****************************************!*\
  !*** ./src/entity/object/chestLayer.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ChestLayer = void 0;
const game_1 = __webpack_require__(/*! ../../game */ "./src/game.ts");
const entity_1 = __webpack_require__(/*! ../entity */ "./src/entity/entity.ts");
class ChestLayer extends entity_1.Entity {
    constructor(room, game, x, y) {
        super(room, game, x, y);
        this.setDrawableY = () => {
            for (let i of this.room.items)
                if (i.x === this.x && i.y === this.y)
                    this.drawableY ===
                        this.room.roomArray[this.x][this.y].drawableY + 0.001;
        };
        this.draw = (delta) => {
            this.drawableY = this.y - 0.01;
            this.setDrawableY;
            if (!this.dead) {
                game_1.Game.drawObj(0, 4, 1, 2, this.x - this.drawX, this.y - this.drawYOffset - this.drawY, 1, 2, this.room.shadeColor, this.shadeAmount());
            }
        };
        this.x = x;
        this.y = y;
        this.game = game;
        this.room = room;
        this.frame = 0;
    }
}
exports.ChestLayer = ChestLayer;


/***/ }),

/***/ "./src/entity/object/crate.ts":
/*!************************************!*\
  !*** ./src/entity/object/crate.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Crate = void 0;
const entity_1 = __webpack_require__(/*! ../entity */ "./src/entity/entity.ts");
const game_1 = __webpack_require__(/*! ../../game */ "./src/game.ts");
const entity_2 = __webpack_require__(/*! ../entity */ "./src/entity/entity.ts");
const weaponFragments_1 = __webpack_require__(/*! ../../item/usable/weaponFragments */ "./src/item/usable/weaponFragments.ts");
const coin_1 = __webpack_require__(/*! ../../item/coin */ "./src/item/coin.ts");
const random_1 = __webpack_require__(/*! ../../utility/random */ "./src/utility/random.ts");
class Crate extends entity_1.Entity {
    constructor(room, game, x, y) {
        super(room, game, x, y);
        this.draw = (delta) => {
            if (this.dead)
                return;
            game_1.Game.ctx.save();
            game_1.Game.ctx.globalAlpha = this.alpha;
            if (!this.dead) {
                this.updateDrawXY(delta);
                game_1.Game.drawObj(this.tileX, this.tileY, 1, 2, this.x - this.drawX, this.y - this.drawYOffset - this.drawY, 1, 2, this.room.shadeColor, this.shadeAmount());
            }
            game_1.Game.ctx.restore();
        };
        this.drawTopLayer = (delta) => {
            this.drawableY = this.y;
        };
        this.room = room;
        this.health = 1;
        this.maxHealth = 1;
        this.tileX = 0;
        this.tileY = 0;
        this.hasShadow = false;
        this.pushable = true;
        this.name = "crate";
        this.imageParticleX = 3;
        this.imageParticleY = 26;
        if (random_1.Random.rand() < 0.1) {
            this.drops.push(new weaponFragments_1.WeaponFragments(this.room, this.x, this.y, 10));
        }
        else {
            this.drops.push(new coin_1.Coin(this.room, this.x, this.y));
        }
    }
    get type() {
        return entity_2.EntityType.PROP;
    }
}
exports.Crate = Crate;


/***/ }),

/***/ "./src/entity/object/decoBlock.ts":
/*!****************************************!*\
  !*** ./src/entity/object/decoBlock.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DecoBlock = void 0;
const entity_1 = __webpack_require__(/*! ../entity */ "./src/entity/entity.ts");
const game_1 = __webpack_require__(/*! ../../game */ "./src/game.ts");
const entity_2 = __webpack_require__(/*! ../entity */ "./src/entity/entity.ts");
class DecoBlock extends entity_1.Entity {
    constructor(room, game, x, y) {
        super(room, game, x, y);
        this.draw = (delta) => {
            if (this.dead)
                return;
            game_1.Game.ctx.save();
            game_1.Game.ctx.globalAlpha = this.alpha;
            if (!this.dead) {
                this.updateDrawXY(delta);
                game_1.Game.drawObj(this.tileX, this.tileY, 1, 2, this.x - this.drawX, this.y - this.drawYOffset - this.drawY, 1, 2, this.room.shadeColor, this.shadeAmount());
            }
            game_1.Game.ctx.restore();
        };
        this.drawTopLayer = (delta) => {
            this.drawableY = this.y;
        };
        this.room = room;
        this.health = 1;
        this.tileX = 1;
        this.tileY = 4;
        this.hasShadow = false;
        this.pushable = true;
        this.name = "deco block";
        this.imageParticleX = 3;
        this.imageParticleY = 25;
    }
    get type() {
        return entity_2.EntityType.PROP;
    }
}
exports.DecoBlock = DecoBlock;


/***/ }),

/***/ "./src/entity/object/fishingSpot.ts":
/*!******************************************!*\
  !*** ./src/entity/object/fishingSpot.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FishingSpot = void 0;
const entity_1 = __webpack_require__(/*! ../entity */ "./src/entity/entity.ts");
const game_1 = __webpack_require__(/*! ../../game */ "./src/game.ts");
const heart_1 = __webpack_require__(/*! ../../item/usable/heart */ "./src/item/usable/heart.ts");
const entity_2 = __webpack_require__(/*! ../entity */ "./src/entity/entity.ts");
const random_1 = __webpack_require__(/*! ../../utility/random */ "./src/utility/random.ts");
const coin_1 = __webpack_require__(/*! ../../item/coin */ "./src/item/coin.ts");
const sound_1 = __webpack_require__(/*! ../../sound/sound */ "./src/sound/sound.ts");
const fish_1 = __webpack_require__(/*! ../../item/usable/fish */ "./src/item/usable/fish.ts");
class FishingSpot extends entity_1.Entity {
    constructor(room, game, x, y) {
        super(room, game, x, y);
        this.fishCount = 0;
        this.active = false;
        this.startFrame = 0;
        this.fish = (player) => {
            if (!player.inventory.canFish()) {
                this.game.pushMessage("You need a fishing rod to fish.");
                return;
            }
            if (!this.active) {
                this.game.pushMessage("There aren't any fish here.");
                return;
            }
            this.game.pushMessage("Fishing...");
            player.busyAnimating = true;
            player.setHitXY(this.x, this.y, 0.5);
            sound_1.Sound.playFishingCast();
            setTimeout(() => {
                let message = "";
                sound_1.Sound.playFishingReel();
                if (this.tryFish()) {
                    let added = player.inventory.addItem(new fish_1.Fish(this.room, this.x, this.y));
                    if (added === false) {
                        this.room.items.push(new fish_1.Fish(this.room, player.x, player.y));
                    }
                    message = "You catch a fish.";
                    sound_1.Sound.playFishingCatch();
                    this.fishCount--;
                    if (this.fishCount <= 0) {
                        this.active = false;
                    }
                }
                else {
                    message = "You don't catch anything.";
                }
                this.room.game.pushMessage(message);
                player.busyAnimating = false;
            }, 1200);
            this.room.tick(player);
        };
        this.tryFish = () => {
            if (random_1.Random.rand() < 0.3) {
                return true;
            }
            else {
                return false;
            }
        };
        this.interact = (player) => {
            this.fish(player);
        };
        this.draw = (delta) => {
            if (this.dead || !this.active)
                return;
            if (this.startFrame !== 0) {
                this.frame = this.startFrame;
                this.startFrame = 0;
            }
            this.frame += 0.12 * delta;
            if (this.frame >= 9)
                this.frame = 0;
            game_1.Game.drawFX(23 + Math.floor(this.frame), 0, 1, 1, this.x - this.drawX, this.y - this.drawY, 1, 1, this.room.shadeColor, this.shadeAmount());
        };
        this.drawTopLayer = (delta) => {
            this.drawableY = this.y;
        };
        this.room = room;
        this.health = 1;
        this.tileX = 11;
        this.tileY = 0;
        this.hasShadow = false;
        this.chainPushable = false;
        this.name = "fishing spot";
        this.fishCount = Math.floor(random_1.Random.rand() * 6) - 3;
        this.active = this.fishCount > 0;
        this.startFrame = Math.floor(random_1.Random.rand() * 9);
        //this.hitSound = Sound.potSmash;
        this.imageParticleX = 0;
        this.imageParticleY = 29;
        this.destroyable = false;
        this.interactable = true;
        let dropProb = random_1.Random.rand();
        if (dropProb < 0.025)
            this.drops.push(new heart_1.Heart(this.room, this.x, this.y));
        else
            this.drops.push(new coin_1.Coin(this.room, this.x, this.y));
    }
    get type() {
        return entity_2.EntityType.PROP;
    }
}
exports.FishingSpot = FishingSpot;


/***/ }),

/***/ "./src/entity/object/furnace.ts":
/*!**************************************!*\
  !*** ./src/entity/object/furnace.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Furnace = void 0;
const entity_1 = __webpack_require__(/*! ../entity */ "./src/entity/entity.ts");
const game_1 = __webpack_require__(/*! ../../game */ "./src/game.ts");
const entity_2 = __webpack_require__(/*! ../entity */ "./src/entity/entity.ts");
const lightSource_1 = __webpack_require__(/*! ../../lighting/lightSource */ "./src/lighting/lightSource.ts");
const torch_1 = __webpack_require__(/*! ../../item/light/torch */ "./src/item/light/torch.ts");
class Furnace extends entity_1.Entity {
    constructor(room, game, x, y) {
        super(room, game, x, y);
        this.draw = (delta) => {
            if (this.dead)
                return;
            game_1.Game.ctx.save();
            game_1.Game.ctx.globalAlpha = this.alpha;
            if (!this.dead) {
                this.updateDrawXY(delta);
                game_1.Game.drawObj(this.tileX, this.tileY, 1, 2, this.x - this.drawX, this.y - this.drawYOffset - this.drawY, 1, 2, this.room.shadeColor, this.shadeAmount());
            }
            game_1.Game.ctx.restore();
        };
        this.drawTopLayer = (delta) => {
            this.drawableY = this.y;
        };
        this.room = room;
        this.health = 1;
        this.tileX = 2;
        this.tileY = 4;
        this.hasShadow = false;
        this.chainPushable = false;
        this.name = "furnace";
        this.drops.push(new torch_1.Torch(this.room, this.x, this.y));
        this.imageParticleX = 0;
        this.imageParticleY = 25;
        this.bloomColor = "#FFA500";
        this.hasBloom = true;
        this.bloomAlpha = 1;
        this.softBloomAlpha = 0;
        this.lightSource = new lightSource_1.LightSource(this.x + 0.5, this.y + 0.5, 7, [200, 30, 1], 4);
        this.addLightSource(this.lightSource);
    }
    get type() {
        return entity_2.EntityType.PROP;
    }
}
exports.Furnace = Furnace;


/***/ }),

/***/ "./src/entity/object/mushrooms.ts":
/*!****************************************!*\
  !*** ./src/entity/object/mushrooms.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Mushrooms = void 0;
const entity_1 = __webpack_require__(/*! ../entity */ "./src/entity/entity.ts");
const game_1 = __webpack_require__(/*! ../../game */ "./src/game.ts");
const shrooms_1 = __webpack_require__(/*! ../../item/usable/shrooms */ "./src/item/usable/shrooms.ts");
const entity_2 = __webpack_require__(/*! ../entity */ "./src/entity/entity.ts");
class Mushrooms extends entity_1.Entity {
    constructor(room, game, x, y) {
        super(room, game, x, y);
        this.draw = (delta) => {
            if (this.dead)
                return;
            game_1.Game.ctx.save();
            game_1.Game.ctx.globalAlpha = this.alpha;
            if (!this.dead) {
                this.updateDrawXY(delta);
                game_1.Game.drawObj(this.tileX, this.tileY, 1, 2, this.x - this.drawX, this.y - this.drawYOffset - this.drawY, 1, 2, this.room.shadeColor, this.shadeAmount());
            }
            game_1.Game.ctx.restore();
        };
        this.drawTopLayer = (delta) => {
            this.drawableY = this.y;
        };
        this.room = room;
        this.health = 1;
        this.tileX = 9;
        this.tileY = 2;
        this.hasShadow = false;
        this.chainPushable = false;
        this.name = "mushrooms";
        this.imageParticleX = 0;
        this.imageParticleY = 30;
        this.drops.push(new shrooms_1.Shrooms(this.room, this.x, this.y));
    }
    get type() {
        return entity_2.EntityType.PROP;
    }
}
exports.Mushrooms = Mushrooms;


/***/ }),

/***/ "./src/entity/object/pot.ts":
/*!**********************************!*\
  !*** ./src/entity/object/pot.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Pot = void 0;
const entity_1 = __webpack_require__(/*! ../entity */ "./src/entity/entity.ts");
const game_1 = __webpack_require__(/*! ../../game */ "./src/game.ts");
const heart_1 = __webpack_require__(/*! ../../item/usable/heart */ "./src/item/usable/heart.ts");
const entity_2 = __webpack_require__(/*! ../entity */ "./src/entity/entity.ts");
const random_1 = __webpack_require__(/*! ../../utility/random */ "./src/utility/random.ts");
const coin_1 = __webpack_require__(/*! ../../item/coin */ "./src/item/coin.ts");
const sound_1 = __webpack_require__(/*! ../../sound/sound */ "./src/sound/sound.ts");
class Pot extends entity_1.Entity {
    constructor(room, game, x, y) {
        super(room, game, x, y);
        this.draw = (delta) => {
            if (this.dead)
                return;
            game_1.Game.ctx.save();
            game_1.Game.ctx.globalAlpha = this.alpha;
            if (!this.dead) {
                this.updateDrawXY(delta);
                game_1.Game.drawObj(this.tileX, this.tileY, 1, 2, this.x - this.drawX, this.y - this.drawYOffset - this.drawY, 1, 2, this.room.shadeColor, this.shadeAmount());
            }
            game_1.Game.ctx.restore();
        };
        this.drawTopLayer = (delta) => {
            this.drawableY = this.y;
        };
        this.room = room;
        this.health = 1;
        this.tileX = 11;
        this.tileY = 0;
        this.hasShadow = false;
        this.chainPushable = false;
        this.name = "pot";
        this.hitSound = sound_1.Sound.potSmash;
        this.imageParticleX = 0;
        this.imageParticleY = 29;
        let dropProb = random_1.Random.rand();
        if (dropProb < 0.025)
            this.drops.push(new heart_1.Heart(this.room, this.x, this.y));
        else
            this.drops.push(new coin_1.Coin(this.room, this.x, this.y));
    }
    get type() {
        return entity_2.EntityType.PROP;
    }
}
exports.Pot = Pot;


/***/ }),

/***/ "./src/entity/object/pottedPlant.ts":
/*!******************************************!*\
  !*** ./src/entity/object/pottedPlant.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PottedPlant = void 0;
const entity_1 = __webpack_require__(/*! ../entity */ "./src/entity/entity.ts");
const game_1 = __webpack_require__(/*! ../../game */ "./src/game.ts");
const heart_1 = __webpack_require__(/*! ../../item/usable/heart */ "./src/item/usable/heart.ts");
const coin_1 = __webpack_require__(/*! ../../item/coin */ "./src/item/coin.ts");
const entity_2 = __webpack_require__(/*! ../entity */ "./src/entity/entity.ts");
const random_1 = __webpack_require__(/*! ../../utility/random */ "./src/utility/random.ts");
class PottedPlant extends entity_1.Entity {
    constructor(room, game, x, y, drop) {
        super(room, game, x, y);
        this.uniqueKillBehavior = () => {
            this.createHitParticles(0, 29);
        };
        this.draw = (delta) => {
            if (this.dead)
                return;
            game_1.Game.ctx.save();
            game_1.Game.ctx.globalAlpha = this.alpha;
            if (!this.dead) {
                this.updateDrawXY(delta);
                if (this.health <= 1 || this.dying)
                    this.tileX = 2;
                game_1.Game.drawObj(this.tileX, this.tileY, 1, 2, this.x - this.drawX, this.y - this.drawYOffset - this.drawY, 1, 2, this.room.shadeColor, this.shadeAmount());
            }
            game_1.Game.ctx.restore();
        };
        this.drawTopLayer = (delta) => {
            this.drawableY = this.y;
        };
        this.room = room;
        this.health = 2;
        this.tileX = 3;
        this.tileY = 0;
        this.hasShadow = false;
        this.chainPushable = false;
        this.name = "plant";
        this.imageParticleX = 0;
        this.imageParticleY = 28;
        if (drop)
            this.drop = drop;
        else {
            let dropProb = random_1.Random.rand();
            if (dropProb < 0.025)
                this.drops.push(new heart_1.Heart(this.room, this.x, this.y));
            else
                this.drops.push(new coin_1.Coin(this.room, this.x, this.y));
        }
    }
    get type() {
        return entity_2.EntityType.PROP;
    }
}
exports.PottedPlant = PottedPlant;


/***/ }),

/***/ "./src/entity/object/pumpkin.ts":
/*!**************************************!*\
  !*** ./src/entity/object/pumpkin.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Pumpkin = void 0;
const entity_1 = __webpack_require__(/*! ../entity */ "./src/entity/entity.ts");
const game_1 = __webpack_require__(/*! ../../game */ "./src/game.ts");
const entity_2 = __webpack_require__(/*! ../entity */ "./src/entity/entity.ts");
const lightSource_1 = __webpack_require__(/*! ../../lighting/lightSource */ "./src/lighting/lightSource.ts");
const candle_1 = __webpack_require__(/*! ../../item/light/candle */ "./src/item/light/candle.ts");
class Pumpkin extends entity_1.Entity {
    constructor(room, game, x, y) {
        super(room, game, x, y);
        this.draw = (delta) => {
            if (this.dead)
                return;
            game_1.Game.ctx.save();
            game_1.Game.ctx.globalAlpha = this.alpha;
            if (!this.dead) {
                this.updateDrawXY(delta);
                game_1.Game.drawObj(this.tileX, this.tileY, 1, 2, this.x - this.drawX, this.y - this.drawYOffset - this.drawY, 1, 2, this.room.shadeColor, this.shadeAmount());
            }
            game_1.Game.ctx.restore();
        };
        this.drawTopLayer = (delta) => {
            this.drawableY = this.y;
        };
        this.room = room;
        this.health = 1;
        this.tileX = 15;
        this.tileY = 2;
        this.hasShadow = false;
        this.chainPushable = false;
        this.name = "pumpkin";
        this.drops.push(new candle_1.Candle(this.room, this.x, this.y));
        this.imageParticleX = 0;
        this.imageParticleY = 25;
        this.bloomColor = "#FFA500";
        this.hasBloom = true;
        this.bloomAlpha = 1;
        this.softBloomAlpha = 0;
        this.lightSource = new lightSource_1.LightSource(this.x + 0.5, this.y + 0.5, 5, [200, 30, 1], 3);
        this.addLightSource(this.lightSource);
    }
    get type() {
        return entity_2.EntityType.PROP;
    }
}
exports.Pumpkin = Pumpkin;


/***/ }),

/***/ "./src/entity/object/sprout.ts":
/*!*************************************!*\
  !*** ./src/entity/object/sprout.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Sprout = void 0;
const entity_1 = __webpack_require__(/*! ../entity */ "./src/entity/entity.ts");
const game_1 = __webpack_require__(/*! ../../game */ "./src/game.ts");
const entity_2 = __webpack_require__(/*! ../entity */ "./src/entity/entity.ts");
class Sprout extends entity_1.Entity {
    constructor(room, game, x, y) {
        super(room, game, x, y);
        this.draw = (delta) => {
            if (this.dead)
                return;
            game_1.Game.ctx.save();
            game_1.Game.ctx.globalAlpha = this.alpha;
            if (!this.dead) {
                if (this.hasShadow)
                    game_1.Game.drawMob(0, 0, 1, 1, this.x - this.drawX, this.y - this.drawY, 1, 1, this.room.shadeColor, this.shadeAmount());
                this.updateDrawXY(delta);
                game_1.Game.drawObj(this.tileX, this.tileY, 1, 2, this.x - this.drawX, this.y - this.drawYOffset - this.drawY, 1, 2, this.room.shadeColor, this.shadeAmount());
            }
            game_1.Game.ctx.restore();
        };
        this.drawTopLayer = (delta) => {
            this.drawableY = this.y;
        };
        this.room = room;
        this.health = 1;
        this.tileX = 17;
        this.tileY = 2;
        this.hasShadow = true;
        this.chainPushable = false;
        this.name = "sprout";
        this.imageParticleX = 0;
        this.imageParticleY = 28;
        //this.drops.push(new Shrooms(this.room, this.x, this.y));
    }
    get type() {
        return entity_2.EntityType.PROP;
    }
}
exports.Sprout = Sprout;


/***/ }),

/***/ "./src/entity/object/tombStone.ts":
/*!****************************************!*\
  !*** ./src/entity/object/tombStone.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TombStone = void 0;
const entity_1 = __webpack_require__(/*! ../entity */ "./src/entity/entity.ts");
const game_1 = __webpack_require__(/*! ../../game */ "./src/game.ts");
const entity_2 = __webpack_require__(/*! ../entity */ "./src/entity/entity.ts");
const skullEnemy_1 = __webpack_require__(/*! ../enemy/skullEnemy */ "./src/entity/enemy/skullEnemy.ts");
const random_1 = __webpack_require__(/*! ../../utility/random */ "./src/utility/random.ts");
const spellbook_1 = __webpack_require__(/*! ../../item/weapon/spellbook */ "./src/item/weapon/spellbook.ts");
const sound_1 = __webpack_require__(/*! ../../sound/sound */ "./src/sound/sound.ts");
const lightSource_1 = __webpack_require__(/*! ../../lighting/lightSource */ "./src/lighting/lightSource.ts");
class TombStone extends entity_1.Entity {
    constructor(room, game, x, y, skinType = 0, drop) {
        super(room, game, x, y);
        this.uniqueKillBehavior = () => {
            if (this.cloned)
                return;
            sound_1.Sound.delayPlay(sound_1.Sound.breakRock, 50);
        };
        this.onHurt = (damage = 1) => {
            if (this.health === 1) {
                const positions = this.room
                    .getEmptyTiles()
                    .filter((t) => Math.abs(t.x - this.x) <= 1 && Math.abs(t.y - this.y) <= 1);
                if (positions.length > 0) {
                    for (let position of positions) {
                        for (const i in this.game.players) {
                            const playerX = this.game.players[i].x;
                            const playerY = this.game.players[i].y;
                            if ((playerX !== position.x && playerY === position.y) ||
                                (playerX === position.x && playerY !== position.y)) {
                                this.room.entities.push(new skullEnemy_1.SkullEnemy(this.room, this.game, position.x, position.y));
                            }
                        }
                    }
                    sound_1.Sound.delayPlay(sound_1.Sound.skeleSpawn, 50);
                }
                this.tileX += 2;
                //draw half broken tombstone based on skintype after it takes one damage
            }
        };
        this.draw = (delta) => {
            if (this.dead)
                return;
            this.updateDrawXY(delta);
            game_1.Game.ctx.save();
            game_1.Game.ctx.globalAlpha = this.alpha;
            //if (!this.dead || !this.cloned) {{}
            game_1.Game.drawObj(this.tileX, this.tileY, 1, 2, this.x - this.drawX, this.y - this.drawYOffset - this.drawY, 1, 2, this.room.shadeColor, this.shadeAmount());
            game_1.Game.ctx.restore();
        };
        this.drawTopLayer = (delta) => {
            this.drawableY = this.y;
        };
        this.skinType = skinType;
        this.room = room;
        this.health = 2;
        //this.maxHealth = 2;
        this.tileX = 11 + this.skinType;
        this.tileY = 2;
        this.hasShadow = false;
        //this.pushable = false;
        //this.destroyable = true;
        //this.skinType = skinType;
        this.chainPushable = false;
        this.name = "tombstone";
        let dropProb = random_1.Random.rand();
        if (dropProb < 0.25)
            this.drops.push(new spellbook_1.Spellbook(this.room, this.x, this.y));
        this.hasBloom = true;
        this.bloomColor = "#05FF05";
        this.bloomAlpha = 1;
        this.softBloomAlpha = 0;
        this.imageParticleX = 0;
        this.imageParticleY = 25;
        this.lightSource = new lightSource_1.LightSource(this.x + 0.5, this.y + 0.5, 7, [5, 150, 5], 1);
        this.addLightSource(this.lightSource);
    }
    get type() {
        return entity_2.EntityType.PROP;
    }
}
exports.TombStone = TombStone;


/***/ }),

/***/ "./src/entity/object/tree.ts":
/*!***********************************!*\
  !*** ./src/entity/object/tree.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Tree = void 0;
const entity_1 = __webpack_require__(/*! ../entity */ "./src/entity/entity.ts");
const game_1 = __webpack_require__(/*! ../../game */ "./src/game.ts");
const entity_2 = __webpack_require__(/*! ../entity */ "./src/entity/entity.ts");
const apple_1 = __webpack_require__(/*! ../../item/usable/apple */ "./src/item/usable/apple.ts");
const sound_1 = __webpack_require__(/*! ../../sound/sound */ "./src/sound/sound.ts");
const random_1 = __webpack_require__(/*! ../../utility/random */ "./src/utility/random.ts");
class Tree extends entity_1.Entity {
    constructor(room, game, x, y) {
        super(room, game, x, y);
        this.uniqueKillBehavior = () => {
            if (this.cloned)
                return;
            sound_1.Sound.playWood();
        };
        this.draw = (delta) => {
            this.tileX = this.health === 2 ? 14 : 16;
            if (this.cloned === true)
                this.tileX = 16;
            if (this.dead)
                return;
            game_1.Game.ctx.save();
            game_1.Game.ctx.globalAlpha = this.alpha;
            if (!this.dead) {
                this.updateDrawXY(delta);
                game_1.Game.drawObj(this.tileX, this.tileY, 2, 3, this.x - this.drawX - 0.5, this.y - this.drawYOffset - this.drawY - 1, 2, 3, this.room.shadeColor, this.shadeAmount());
            }
            game_1.Game.ctx.restore();
        };
        this.drawTopLayer = (delta) => {
            this.drawableY = this.y;
        };
        this.room = room;
        this.health = 2;
        this.maxHealth = 2;
        this.tileX = 14;
        this.tileY = 6;
        this.hasShadow = false;
        this.chainPushable = false;
        this.name = "tree";
        this.imageParticleX = 0;
        this.imageParticleY = 28;
        this.opaque = true;
        this.hitSound = sound_1.Sound.playBush;
        if (random_1.Random.rand() < 0.5)
            this.drops.push(new apple_1.Apple(this.room, this.x, this.y));
        //this.drawableY = 0.1;
        //this.drops.push(new Shrooms(this.room, this.x, this.y));
    }
    get type() {
        return entity_2.EntityType.PROP;
    }
}
exports.Tree = Tree;


/***/ }),

/***/ "./src/entity/object/vendingMachine.ts":
/*!*********************************************!*\
  !*** ./src/entity/object/vendingMachine.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.VendingMachine = void 0;
const game_1 = __webpack_require__(/*! ../../game */ "./src/game.ts");
const entity_1 = __webpack_require__(/*! ../entity */ "./src/entity/entity.ts");
const coin_1 = __webpack_require__(/*! ../../item/coin */ "./src/item/coin.ts");
const greengem_1 = __webpack_require__(/*! ../../item/resource/greengem */ "./src/item/resource/greengem.ts");
const gameConstants_1 = __webpack_require__(/*! ../../game/gameConstants */ "./src/game/gameConstants.ts");
const shotgun_1 = __webpack_require__(/*! ../../item/weapon/shotgun */ "./src/item/weapon/shotgun.ts");
const armor_1 = __webpack_require__(/*! ../../item/armor */ "./src/item/armor.ts");
const heart_1 = __webpack_require__(/*! ../../item/usable/heart */ "./src/item/usable/heart.ts");
const spear_1 = __webpack_require__(/*! ../../item/weapon/spear */ "./src/item/weapon/spear.ts");
const bluegem_1 = __webpack_require__(/*! ../../item/resource/bluegem */ "./src/item/resource/bluegem.ts");
const dualdagger_1 = __webpack_require__(/*! ../../item/weapon/dualdagger */ "./src/item/weapon/dualdagger.ts");
const lantern_1 = __webpack_require__(/*! ../../item/light/lantern */ "./src/item/light/lantern.ts");
const redgem_1 = __webpack_require__(/*! ../../item/resource/redgem */ "./src/item/resource/redgem.ts");
const entity_2 = __webpack_require__(/*! ../entity */ "./src/entity/entity.ts");
const random_1 = __webpack_require__(/*! ../../utility/random */ "./src/utility/random.ts");
const warhammer_1 = __webpack_require__(/*! ../../item/weapon/warhammer */ "./src/item/weapon/warhammer.ts");
const torch_1 = __webpack_require__(/*! ../../item/light/torch */ "./src/item/light/torch.ts");
const spellbook_1 = __webpack_require__(/*! ../../item/weapon/spellbook */ "./src/item/weapon/spellbook.ts");
const candle_1 = __webpack_require__(/*! ../../item/light/candle */ "./src/item/light/candle.ts");
const pickaxe_1 = __webpack_require__(/*! ../../item/tool/pickaxe */ "./src/item/tool/pickaxe.ts");
const utils_1 = __webpack_require__(/*! ../../utility/utils */ "./src/utility/utils.ts");
let OPEN_TIME = 150;
let FILL_COLOR = "#5a595b";
let OUTLINE_COLOR = "#292c36";
let FULL_OUTLINE = "white";
class VendingMachine extends entity_1.Entity {
    constructor(room, game, x, y, item) {
        super(room, game, x, y);
        this.open = false;
        this.openTime = 0;
        this.isInf = false;
        this.quantity = 1;
        this.buyAnimAmount = 0;
        this.setCost = (value = 1, costItems, counts, quantity = 1) => {
            //value is arbitrary multiplies the stackcount to adapt to the item
            if (!costItems || !counts) {
                // Default behavior: randomly choose between gems and coins
                const possibleItems = [
                    new bluegem_1.BlueGem(this.room, 0, 0),
                    new greengem_1.GreenGem(this.room, 0, 0),
                    new redgem_1.RedGem(this.room, 0, 0),
                    new coin_1.Coin(this.room, 0, 0),
                ];
                const costItem = game_1.Game.randTable(possibleItems, random_1.Random.rand);
                if (costItem instanceof coin_1.Coin) {
                    costItem.stackCount = game_1.Game.randTable([20, 25, 30], random_1.Random.rand);
                }
                else {
                    costItem.stackCount = game_1.Game.randTable([1, 2, 3], random_1.Random.rand);
                }
                costItem.stackCount *= value;
                this.costItems = [costItem];
            }
            else {
                // Original behavior for custom costs
                const randCount = game_1.Game.randTable(counts, random_1.Random.rand);
                const costItem = game_1.Game.randTable(costItems, random_1.Random.rand);
                costItem.stackCount = randCount;
                //if (costItem instanceof Coin) {
                //costItem.stackCount *= Game.randTable([9, 10, 11], Random.rand);
                //}
                this.costItems = [costItem];
            }
            this.quantity = quantity;
        };
        this.interact = (player) => {
            if (this.isInf || this.quantity > 0) {
                if (this.open)
                    this.playerOpened.openVendingMachine = null;
                this.open = true;
                this.playerOpened = player;
                this.openTime = Date.now();
                if (this.playerOpened.openVendingMachine &&
                    this.playerOpened.openVendingMachine !== this)
                    this.playerOpened.openVendingMachine.close();
                this.playerOpened.openVendingMachine = this;
            }
        };
        this.close = () => {
            this.open = false;
            this.playerOpened.openVendingMachine = null;
        };
        this.space = () => {
            if (this.open) {
                // Check if player can pay
                for (const i of this.costItems) {
                    if (!this.playerOpened.inventory.hasItemCount(i)) {
                        let numOfItem = 0;
                        if (i instanceof coin_1.Coin) {
                            numOfItem = this.playerOpened.inventory.coinCount();
                        }
                        else {
                            this.playerOpened.inventory.items.forEach((item) => {
                                if (item instanceof i.constructor) {
                                    numOfItem += item.stackCount;
                                }
                            });
                        }
                        const difference = this.costItems[0].stackCount - numOfItem;
                        const pluralLetter = this.costItems[0].stackCount > 1 ? "s" : "";
                        this.game.pushMessage(`You need ${difference} more ${this.costItems[0].constructor.itemName}${pluralLetter} to buy that. `);
                        return;
                    }
                }
                // Create the new item instance
                let newItem = new this.item.constructor(this.room, this.x, this.y);
                //     newItem = newItem.constructor(this.room, this.x, this.y);
                // **Attempt to add the item directly to the player's inventory**
                const addedSuccessfully = this.playerOpened.inventory.addItem(newItem);
                if (!addedSuccessfully) {
                    // If adding the item failed, refund the cost items
                    //for (const i of this.costItems) {
                    //this.playerOpened.inventory.addItem(i);
                    //}
                    this.game.pushMessage("Your inventory is full. Cannot purchase the item.");
                    return;
                }
                // Subtract the cost items from player's inventory
                for (const i of this.costItems) {
                    this.playerOpened.inventory.subtractItemCount(i);
                }
                const cost = this.costItems[0].stackCount;
                const pluralLetter = cost > 1 ? "s" : "";
                // Decrement the quantity of items available in the vending machine, if not infinite
                if (!this.isInf) {
                    this.quantity--;
                    if (this.quantity <= 0)
                        this.close();
                }
                // Notify the player of the successful purchase
                this.game.pushMessage(`Purchased ${newItem.constructor.itemName} for ${cost} ${this.costItems[0].constructor.itemName}${pluralLetter}`);
                this.game.pushMessage(`${this.quantity} available to buy.`);
                // Handle visual feedback and screen shake
                this.buyAnimAmount = 0.99;
                if (this.playerOpened === this.game.players[this.game.localPlayerID])
                    this.game.shakeScreen(0, 4);
            }
        };
        this.draw = (delta) => {
            let tileX = 19;
            if (!this.isInf && this.quantity === 0)
                tileX = 20;
            game_1.Game.drawObj(tileX, 0, 1, 2, this.x, this.y - 1, 1, 2, this.room.shadeColor, this.shadeAmount());
        };
        this.drawTopLayer = (delta) => {
            if (this.open && this.playerOpened.inventory.isOpen) {
                this.close();
                return;
            }
            this.drawableY = this.y;
            if (this.open &&
                this.playerOpened === this.game.players[this.game.localPlayerID]) {
                let s = Math.min(18, (18 * (Date.now() - this.openTime)) / OPEN_TIME); // size of box
                let b = 2; // border
                let g = -2; // gap
                let hg = 3; // highlighted growth
                let ob = 1; // outer border
                let width = (this.costItems.length + 2) * (s + 2 * b + g) - g;
                let height = s + 2 * b + g - g;
                let cx = (this.x + 0.5) * gameConstants_1.GameConstants.TILESIZE;
                let cy = (this.y - 1.5) * gameConstants_1.GameConstants.TILESIZE;
                game_1.Game.ctx.fillStyle = FULL_OUTLINE;
                game_1.Game.ctx.fillRect(Math.round(cx - 0.5 * width) - ob, Math.round(cy - 0.5 * height) - ob, Math.round(width + 2 * ob), Math.round(height + 2 * ob));
                for (let x = 0; x < this.costItems.length + 2; x++) {
                    game_1.Game.ctx.fillStyle = OUTLINE_COLOR;
                    game_1.Game.ctx.fillRect(Math.round(cx - 0.5 * width + x * (s + 2 * b + g)), Math.round(cy - 0.5 * height), Math.round(s + 2 * b), Math.round(s + 2 * b));
                    if (x !== this.costItems.length) {
                        game_1.Game.ctx.fillStyle = FILL_COLOR;
                        game_1.Game.ctx.fillRect(Math.round(cx - 0.5 * width + x * (s + 2 * b + g) + b), Math.round(cy - 0.5 * height + b), Math.round(s), Math.round(s));
                    }
                }
                if (Date.now() - this.openTime >= OPEN_TIME) {
                    for (let i = 0; i < this.costItems.length + 2; i++) {
                        let drawX = Math.round(cx -
                            0.5 * width +
                            i * (s + 2 * b + g) +
                            b +
                            Math.floor(0.5 * s) -
                            0.5 * gameConstants_1.GameConstants.TILESIZE);
                        let drawY = Math.round(cy -
                            0.5 * height +
                            b +
                            Math.floor(0.5 * s) -
                            0.5 * gameConstants_1.GameConstants.TILESIZE);
                        let drawXScaled = drawX / gameConstants_1.GameConstants.TILESIZE;
                        let drawYScaled = drawY / gameConstants_1.GameConstants.TILESIZE;
                        if (i < this.costItems.length) {
                            let a = 1;
                            if (!this.playerOpened.inventory.hasItemCount(this.costItems[i]))
                                a = 0.15;
                            this.costItems[i].drawIcon(delta, drawXScaled, drawYScaled, a);
                        }
                        else if (i === this.costItems.length) {
                            game_1.Game.drawFX(2, 0, 1, 1, drawXScaled, drawYScaled, 1, 1);
                        }
                        else if (i === this.costItems.length + 1) {
                            this.item.drawIcon(delta, drawXScaled, drawYScaled, 1, this.quantity);
                        }
                    }
                }
                this.buyAnimAmount *= this.buyAnimAmount;
                if (gameConstants_1.GameConstants.ALPHA_ENABLED)
                    game_1.Game.ctx.globalAlpha = this.buyAnimAmount;
                game_1.Game.ctx.fillStyle = FULL_OUTLINE;
                game_1.Game.ctx.fillRect(Math.round(cx - 0.5 * width) - ob, Math.round(cy - 0.5 * height) - ob, Math.round(width + 2 * ob), Math.round(height + 2 * ob));
                game_1.Game.ctx.globalAlpha = 1.0;
            }
        };
        this.destroyable = false;
        this.pushable = false;
        this.chainPushable = false;
        this.interactable = true;
        this.costItems = [];
        this.item = item;
        this.name = "vending machine";
        if (this.item instanceof shotgun_1.Shotgun) {
            this.setCost(3);
        }
        else if (this.item instanceof heart_1.Heart) {
            this.setCost(1, [new coin_1.Coin(room, 0, 0)], [9, 10, 11], 3); // Uses default random cost
        }
        else if (this.item instanceof spear_1.Spear) {
            this.setCost(2); // Uses default random cost
        }
        else if (this.item instanceof armor_1.Armor) {
            this.setCost(3); // Uses default random cost
        }
        else if (this.item instanceof dualdagger_1.DualDagger) {
            this.setCost(3); // Uses default random cost
        }
        else if (this.item instanceof lantern_1.Lantern) {
            this.setCost(2); // Uses default random cost
        }
        else if (this.item instanceof warhammer_1.Warhammer) {
            this.setCost(2); // Uses default random cost
        }
        else if (this.item instanceof spellbook_1.Spellbook) {
            this.setCost(3); // Uses default random cost
        }
        else if (this.item instanceof torch_1.Torch) {
            this.setCost(2); // Uses default random cost
        }
        else if (this.item instanceof candle_1.Candle) {
            this.setCost(1, [new coin_1.Coin(room, 0, 0)], [9, 10, 11], 2);
        }
        else if (this.item instanceof pickaxe_1.Pickaxe) {
            this.setCost(1, [new coin_1.Coin(room, 0, 0)], [utils_1.Utils.randomNormalInt(15, 25)]);
        }
    }
    get type() {
        return entity_2.EntityType.PROP;
    }
}
exports.VendingMachine = VendingMachine;
VendingMachine.isPointInVendingMachineBounds = (x, y, shop) => {
    // First check if this is the currently open vending machine
    if (!shop.open || shop !== shop.playerOpened?.openVendingMachine)
        return false;
    // Get screen center coordinates
    const screenCenterX = gameConstants_1.GameConstants.WIDTH / 2;
    const screenCenterY = gameConstants_1.GameConstants.HEIGHT / 2;
    // Calculate the offset between player and shop in tile coordinates
    const offsetX = (shop.x - shop.playerOpened.x) * gameConstants_1.GameConstants.TILESIZE;
    const offsetY = (shop.y - shop.playerOpened.y) * gameConstants_1.GameConstants.TILESIZE;
    // Calculate shop's position on screen relative to the centered player
    const shopScreenX = screenCenterX + offsetX;
    const shopScreenY = screenCenterY + offsetY;
    // Use the same calculations as in drawTopLayer to determine bounds
    let s = 18; // size of box
    let b = 2; // border
    let g = -2; // gap
    let width = (shop.costItems.length + 2) * (s + 2 * b + g) - g;
    let height = s + 2 * b + g - g;
    // Calculate the center of the vending machine interface
    // Note: The -1.5 adjustment for Y matches what's in drawTopLayer
    let cx = shopScreenX;
    let cy = shopScreenY - 1.5 * gameConstants_1.GameConstants.TILESIZE;
    const leftBound = Math.round(cx - 0.5 * width);
    const rightBound = leftBound + Math.round(width);
    const topBound = Math.round(cy - 0.5 * height);
    const bottomBound = topBound + Math.round(height);
    // Check if the point is within the bounds of the vending machine UI
    return (x >= leftBound && x <= rightBound && y >= topBound && y <= bottomBound);
};


/***/ }),

/***/ "./src/entity/resource/coalResource.ts":
/*!*********************************************!*\
  !*** ./src/entity/resource/coalResource.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CoalResource = void 0;
const resource_1 = __webpack_require__(/*! ./resource */ "./src/entity/resource/resource.ts");
const coal_1 = __webpack_require__(/*! ../../item/resource/coal */ "./src/item/resource/coal.ts");
const geode_1 = __webpack_require__(/*! ../../item/resource/geode */ "./src/item/resource/geode.ts");
const random_1 = __webpack_require__(/*! ../../utility/random */ "./src/utility/random.ts");
class CoalResource extends resource_1.Resource {
    constructor(room, game, x, y) {
        super(room, game, x, y);
        this.tileX = 12;
        this.tileY = 0;
        this.health = 1;
        this.name = "coal";
        if (random_1.Random.rand() < 0.1) {
            this.drops.push(new geode_1.Geode(this.room, this.x, this.y));
        }
        this.drops.push(new coal_1.Coal(this.room, this.x, this.y));
    }
}
exports.CoalResource = CoalResource;


/***/ }),

/***/ "./src/entity/resource/emeraldResource.ts":
/*!************************************************!*\
  !*** ./src/entity/resource/emeraldResource.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EmeraldResource = void 0;
const greengem_1 = __webpack_require__(/*! ../../item/resource/greengem */ "./src/item/resource/greengem.ts");
const resource_1 = __webpack_require__(/*! ./resource */ "./src/entity/resource/resource.ts");
const geode_1 = __webpack_require__(/*! ../../item/resource/geode */ "./src/item/resource/geode.ts");
const random_1 = __webpack_require__(/*! ../../utility/random */ "./src/utility/random.ts");
class EmeraldResource extends resource_1.Resource {
    constructor(room, game, x, y) {
        super(room, game, x, y);
        this.tileX = 14;
        this.tileY = 0;
        this.health = 3;
        this.name = "emerald";
        if (random_1.Random.rand() < 0.2) {
            this.drops.push(new geode_1.Geode(this.room, this.x, this.y));
        }
        this.drops.push(new greengem_1.GreenGem(this.room, this.x, this.y));
    }
}
exports.EmeraldResource = EmeraldResource;


/***/ }),

/***/ "./src/entity/resource/goldResource.ts":
/*!*********************************************!*\
  !*** ./src/entity/resource/goldResource.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GoldResource = void 0;
const resource_1 = __webpack_require__(/*! ./resource */ "./src/entity/resource/resource.ts");
const gold_1 = __webpack_require__(/*! ../../item/resource/gold */ "./src/item/resource/gold.ts");
const geode_1 = __webpack_require__(/*! ../../item/resource/geode */ "./src/item/resource/geode.ts");
const random_1 = __webpack_require__(/*! ../../utility/random */ "./src/utility/random.ts");
class GoldResource extends resource_1.Resource {
    constructor(room, game, x, y) {
        super(room, game, x, y);
        this.tileX = 13;
        this.tileY = 0;
        this.health = 2;
        this.name = "gold";
        if (random_1.Random.rand() < 0.2) {
            this.drops.push(new geode_1.Geode(this.room, this.x, this.y));
        }
        this.drops.push(new gold_1.Gold(this.room, this.x, this.y));
    }
}
exports.GoldResource = GoldResource;


/***/ }),

/***/ "./src/entity/resource/resource.ts":
/*!*****************************************!*\
  !*** ./src/entity/resource/resource.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Resource = void 0;
const game_1 = __webpack_require__(/*! ../../game */ "./src/game.ts");
const entity_1 = __webpack_require__(/*! ../entity */ "./src/entity/entity.ts");
const entity_2 = __webpack_require__(/*! ../entity */ "./src/entity/entity.ts");
const sound_1 = __webpack_require__(/*! ../../sound/sound */ "./src/sound/sound.ts");
class Resource extends entity_1.Entity {
    constructor(room, game, x, y) {
        super(room, game, x, y);
        this.hurt = (playerHitBy, damage) => {
            if (!playerHitBy.inventory?.getWeapon().canMine)
                return;
            this.healthBar.hurt();
            this.health -= damage;
            sound_1.Sound.mine();
            this.hurtCallback();
            this.createHitParticles();
            if (this.health <= 0) {
                this.kill(playerHitBy);
            }
        };
        this.uniqueKillBehavior = () => {
            if (this.cloned)
                return;
            sound_1.Sound.delayPlay(sound_1.Sound.breakRock, 50);
        };
        this.kill = (player) => {
            this.dead = true;
            if (this.cloned)
                return;
            this.emitEnemyKilled();
            const deadEntity = this.clone();
            this.room.deadEntities.push(deadEntity);
            this.removeLightSource(this.lightSource);
            if ((player !== null && player.inventory?.canMine()) || player === null) {
                this.dropLoot();
                //this.game.pushMessage("You use your pickaxe to collect the resource.");
            }
            this.uniqueKillBehavior();
        };
        this.draw = (delta) => {
            if (this.dead)
                return;
            game_1.Game.ctx.save();
            game_1.Game.ctx.globalAlpha = this.alpha;
            if (!this.dead) {
                this.updateDrawXY(delta);
                game_1.Game.drawObj(this.tileX, this.tileY, 1, 2, this.x - this.drawX, this.y - 1.25 - this.drawY, 1, 2, this.room.shadeColor, this.shadeAmount());
            }
            game_1.Game.ctx.restore();
        };
        this.drawTopLayer = (delta) => {
            this.drawableY = this.y;
        };
        this.tileX = 12;
        this.tileY = 0;
        this.health = 1;
        this.chainPushable = false;
        this.name = "resource";
        this.imageParticleX = 0;
        this.imageParticleY = 25;
    }
    get type() {
        return entity_2.EntityType.RESOURCE;
    }
}
exports.Resource = Resource;


/***/ }),

/***/ "./src/entity/resource/rockResource.ts":
/*!*********************************************!*\
  !*** ./src/entity/resource/rockResource.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Rock = void 0;
const resource_1 = __webpack_require__(/*! ./resource */ "./src/entity/resource/resource.ts");
const geode_1 = __webpack_require__(/*! ../../item/resource/geode */ "./src/item/resource/geode.ts");
const random_1 = __webpack_require__(/*! ../../utility/random */ "./src/utility/random.ts");
class Rock extends resource_1.Resource {
    constructor(room, game, x, y) {
        super(room, game, x, y);
        this.room = room;
        this.health = 2;
        this.tileX = 8;
        this.tileY = 2;
        this.hasShadow = false;
        this.chainPushable = false;
        this.name = "rock";
        if (random_1.Random.rand() < 0.2) {
            this.drops.push(new geode_1.Geode(this.room, this.x, this.y));
        }
        //this.drops.push(new Stone(this.room, this.x, this.y));
    }
}
exports.Rock = Rock;


/***/ }),

/***/ "./src/event/eventBus.ts":
/*!*******************************!*\
  !*** ./src/event/eventBus.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.globalEventBus = void 0;
const eventEmitter_1 = __webpack_require__(/*! ./eventEmitter */ "./src/event/eventEmitter.ts");
class EventBus {
    constructor() {
        this.eventEmitter = new eventEmitter_1.EventEmitter();
    }
    static getInstance() {
        if (!EventBus.instance) {
            EventBus.instance = new EventBus();
        }
        return EventBus.instance;
    }
    emit(event, data) {
        this.eventEmitter.emit(event, data);
    }
    on(event, callback) {
        this.eventEmitter.on(event, callback);
    }
    off(event, callback) {
        this.eventEmitter.off(event, callback);
    }
}
exports.globalEventBus = EventBus.getInstance();


/***/ }),

/***/ "./src/event/eventEmitter.ts":
/*!***********************************!*\
  !*** ./src/event/eventEmitter.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EventEmitter = void 0;
class EventEmitter {
    constructor() {
        this.events = {};
    }
    on(event, listener) {
        if (!this.events[event]) {
            this.events[event] = [];
        }
        this.events[event].push(listener);
    }
    off(event, listener) {
        if (!this.events[event])
            return;
        this.events[event] = this.events[event].filter((l) => l !== listener);
    }
    emit(event, data) {
        if (!this.events[event])
            return;
        this.events[event].forEach((listener) => listener(data));
    }
    // New method to remove all listeners for an event
    removeAllListeners(event) {
        delete this.events[event];
    }
}
exports.EventEmitter = EventEmitter;


/***/ }),

/***/ "./src/event/events.ts":
/*!*****************************!*\
  !*** ./src/event/events.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EVENTS = void 0;
exports.EVENTS = {
    KEY_DOWN: "KEY_DOWN",
    KEY_UP: "KEY_UP",
    MOUSE_LEFT_CLICK: "MOUSE_LEFT_CLICK",
    MOUSE_RIGHT_CLICK: "MOUSE_RIGHT_CLICK",
    MOUSE_MOVE: "MOUSE_MOVE",
    TOUCH_START: "TOUCH_START",
    TOUCH_MOVE: "TOUCH_MOVE",
    TOUCH_END: "TOUCH_END",
    TAP: "TAP",
    TAP_HOLD: "TAP_HOLD",
    MOUSE_DOWN: "MOUSE_DOWN",
    MOUSE_UP: "MOUSE_UP",
    // **Additional Custom Events:**
    CHAT_MESSAGE: "ChatMessage",
    ENEMY_SEEN_PLAYER: "EnemySeenPlayer",
    ENEMY_KILLED: "ENEMY_KILLED",
    DAMAGE_DONE: "DAMAGE_DONE",
    DAMAGE_TAKEN: "DAMAGE_TAKEN",
    TURN_PASSED: "TURN_PASSED",
    COIN_COLLECTED: "COIN_COLLECTED",
    ITEM_COLLECTED: "ITEM_COLLECTED",
    LEVEL_GENERATION_STARTED: "LEVEL_GENERATION_STARTED",
    LEVEL_GENERATION_COMPLETED: "LEVEL_GENERATION_COMPLETED",
    // Add other custom events as needed
};


/***/ }),

/***/ "./src/game.ts":
/*!*********************!*\
  !*** ./src/game.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.gs = exports.game = exports.Game = exports.ChatMessage = exports.Direction = exports.LevelState = void 0;
const gameConstants_1 = __webpack_require__(/*! ./game/gameConstants */ "./src/game/gameConstants.ts");
const door_1 = __webpack_require__(/*! ./tile/door */ "./src/tile/door.ts");
const sound_1 = __webpack_require__(/*! ./sound/sound */ "./src/sound/sound.ts");
const levelConstants_1 = __webpack_require__(/*! ./level/levelConstants */ "./src/level/levelConstants.ts");
const levelGenerator_1 = __webpack_require__(/*! ./level/levelGenerator */ "./src/level/levelGenerator.ts");
const input_1 = __webpack_require__(/*! ./game/input */ "./src/game/input.ts");
const downLadder_1 = __webpack_require__(/*! ./tile/downLadder */ "./src/tile/downLadder.ts");
const textbox_1 = __webpack_require__(/*! ./game/textbox */ "./src/game/textbox.ts");
const gameState_1 = __webpack_require__(/*! ./game/gameState */ "./src/game/gameState.ts");
const levelImageGenerator_1 = __webpack_require__(/*! ./level/levelImageGenerator */ "./src/level/levelImageGenerator.ts");
const mouseCursor_1 = __webpack_require__(/*! ./gui/mouseCursor */ "./src/gui/mouseCursor.ts");
const postProcess_1 = __webpack_require__(/*! ./gui/postProcess */ "./src/gui/postProcess.ts");
const eventBus_1 = __webpack_require__(/*! ./event/eventBus */ "./src/event/eventBus.ts");
const reverb_1 = __webpack_require__(/*! ./sound/reverb */ "./src/sound/reverb.ts");
const stats_1 = __webpack_require__(/*! ./game/stats */ "./src/game/stats.ts");
const events_1 = __webpack_require__(/*! ./event/events */ "./src/event/events.ts");
const cameraAnimation_1 = __webpack_require__(/*! ./game/cameraAnimation */ "./src/game/cameraAnimation.ts");
const tips_1 = __webpack_require__(/*! ./tips */ "./src/tips.ts");
const gameplaySettings_1 = __webpack_require__(/*! ./game/gameplaySettings */ "./src/game/gameplaySettings.ts");
const random_1 = __webpack_require__(/*! ./utility/random */ "./src/utility/random.ts");
const IdGenerator_1 = __webpack_require__(/*! ./globalStateManager/IdGenerator */ "./src/globalStateManager/IdGenerator.ts");
var LevelState;
(function (LevelState) {
    LevelState[LevelState["IN_LEVEL"] = 0] = "IN_LEVEL";
    LevelState[LevelState["TRANSITIONING"] = 1] = "TRANSITIONING";
    LevelState[LevelState["TRANSITIONING_LADDER"] = 2] = "TRANSITIONING_LADDER";
    LevelState[LevelState["LEVEL_GENERATION"] = 3] = "LEVEL_GENERATION";
})(LevelState = exports.LevelState || (exports.LevelState = {}));
var Direction;
(function (Direction) {
    Direction[Direction["DOWN"] = 0] = "DOWN";
    Direction[Direction["UP"] = 1] = "UP";
    Direction[Direction["RIGHT"] = 2] = "RIGHT";
    Direction[Direction["LEFT"] = 3] = "LEFT";
    Direction[Direction["DOWN_RIGHT"] = 4] = "DOWN_RIGHT";
    Direction[Direction["UP_LEFT"] = 5] = "UP_LEFT";
    Direction[Direction["UP_RIGHT"] = 6] = "UP_RIGHT";
    Direction[Direction["DOWN_LEFT"] = 7] = "DOWN_LEFT";
    Direction[Direction["CENTER"] = 8] = "CENTER";
})(Direction = exports.Direction || (exports.Direction = {}));
class ChatMessage {
    constructor(message) {
        this.cachedLines = null;
        this.cachedWidth = -1;
        this.message = message;
        this.timestamp = Date.now();
    }
    // Get wrapped lines for the given max width, with caching
    getWrappedLines(maxWidth) {
        if (this.cachedLines && this.cachedWidth === maxWidth) {
            return this.cachedLines;
        }
        this.cachedLines = this.wrapText(this.message, maxWidth);
        this.cachedWidth = maxWidth;
        return this.cachedLines;
    }
    wrapText(text, maxWidth) {
        if (text === "")
            return [""];
        const words = text.split(" ");
        const lines = [];
        let currentLine = "";
        for (const word of words) {
            const testLine = currentLine === "" ? word : currentLine + " " + word;
            if (Game.measureText(testLine).width <= maxWidth) {
                currentLine = testLine;
            }
            else {
                if (currentLine !== "") {
                    lines.push(currentLine);
                    currentLine = word;
                }
                else {
                    // Single word is too long, just add it anyway
                    lines.push(word);
                }
            }
        }
        if (currentLine !== "") {
            lines.push(currentLine);
        }
        return lines.length > 0 ? lines : [""];
    }
    // Clear cache when screen resizes
    clearCache() {
        this.cachedLines = null;
        this.cachedWidth = -1;
    }
}
exports.ChatMessage = ChatMessage;
let getShadeCanvasKey = (set, sX, sY, sW, sH, opacity, shadeColor) => {
    return (set.src +
        "," +
        sX +
        "," +
        sY +
        "," +
        sW +
        "," +
        sH +
        "," +
        opacity +
        "," +
        shadeColor);
};
// fps counter
const times = [];
let fps = 60;
class Game {
    constructor() {
        this.localPlayerID = "localplayer";
        this.loginMessage = "";
        this.startScreenAlpha = 1;
        this.ellipsisFrame = 0;
        this.ellipsisStartTime = 0;
        this.justTransitioned = false;
        this.lastDroppedScythePiece = null;
        this.tip = tips_1.Tips.getRandomTip();
        this.currentLevelGenerator = null;
        this.focusTimeout = null;
        this.FOCUS_TIMEOUT_DURATION = 15000; // 5 seconds
        this.wasMuted = false;
        this.wasStarted = false;
        this.lastChatWidth = 0;
        this.savedGameState = null;
        this.updateDepth = (depth) => {
            this.previousDepth = this.currentDepth;
            this.currentDepth = depth;
            this.players[this.localPlayerID].depth = depth;
        };
        this.updateLevel = (room) => {
            if (room && room.level) {
                this.level = room.level;
            }
            if (this.level.rooms.length > 0)
                this.rooms = this.level.rooms;
        };
        this.setPlayer = () => {
            this.player = this.players[this.localPlayerID];
        };
        this.newGame = () => {
            // Clear all input listeners to prevent duplicates from previous game instances
            input_1.Input.mouseDownListeners.length = 0;
            input_1.Input.mouseUpListeners.length = 0;
            input_1.Input.mouseMoveListeners.length = 0;
            input_1.Input.mouseLeftClickListeners.length = 0;
            input_1.Input.mouseRightClickListeners.length = 0;
            input_1.Input.touchStartListeners.length = 0;
            input_1.Input.touchEndListeners.length = 0;
            stats_1.statsTracker.resetStats();
            this.currentDepth = 0;
            this.encounteredEnemies = [];
            this.levels = [];
            //gs = new GameState();
            exports.gs.seed = (Math.random() * 4294967296) >>> 0;
            exports.gs.randomState = (Math.random() * 4294967296) >>> 0;
            (0, gameState_1.loadGameState)(this, [this.localPlayerID], exports.gs, true);
            this.levelState = LevelState.LEVEL_GENERATION;
        };
        this.keyDownListener = (key) => {
            Game.inputReceived = true;
            if (!this.started) {
                this.startedFadeOut = true;
                return;
            }
            // Handle global keys
            if (!this.chatOpen) {
                switch (key.toUpperCase()) {
                    case "M":
                        sound_1.Sound.toggleMute();
                        this.pushMessage(sound_1.Sound.audioMuted ? "Audio muted" : "Audio unmuted");
                        return;
                    case "C":
                        this.chatOpen = true;
                        return;
                    case "/":
                        this.chatOpen = true;
                        this.chatTextBox.clear();
                        this.chatTextBox.handleKeyPress(key);
                        return;
                    case "1":
                        levelGenerator_1.LevelGenerator.ANIMATION_CONSTANT = 1;
                        return;
                    case "2":
                        levelGenerator_1.LevelGenerator.ANIMATION_CONSTANT = 2;
                        return;
                    case "3":
                        levelGenerator_1.LevelGenerator.ANIMATION_CONSTANT = 5;
                        return;
                    case "4":
                        levelGenerator_1.LevelGenerator.ANIMATION_CONSTANT = 10000;
                        return;
                    case "0":
                        levelGenerator_1.LevelGenerator.ANIMATION_CONSTANT = 0;
                        return;
                }
                // Forward all player input
                const player = this.players[this.localPlayerID];
                player.inputHandler.handleKeyboardKey(key);
            }
            else {
                this.chatTextBox.handleKeyPress(key);
            }
        };
        this.changeLevelThroughLadder = (player, ladder) => {
            player.map.saveOldMap();
            if (ladder instanceof downLadder_1.DownLadder && !ladder.linkedRoom)
                ladder.generate();
            const newRoom = ladder.linkedRoom;
            if (this.players[this.localPlayerID] === player) {
                player.levelID = newRoom.id;
                // Immediately deactivate the old room like door transitions do
                this.prevLevel = this.room;
                this.prevLevel.exitLevel();
            }
            if (newRoom.envType === 2)
                sound_1.Sound.playForestMusic();
            if (newRoom.envType === 1)
                sound_1.Sound.playCaveMusic();
            this.updateDepth(newRoom.depth);
            this.levelState = LevelState.TRANSITIONING_LADDER;
            this.transitionStartTime = Date.now();
            this.transitioningLadder = ladder;
        };
        this.changeLevelThroughDoor = (player, door, side) => {
            door.linkedDoor.room.entered = true;
            player.levelID = door.room.id;
            if (this.players[this.localPlayerID] === player) {
                this.levelState = LevelState.TRANSITIONING;
                this.transitionStartTime = Date.now();
                const hasDir = door.doorDir !== door.linkedDoor.doorDir;
                let oldX = this.players[this.localPlayerID].x;
                let oldY = this.players[this.localPlayerID].y;
                this.prevLevel = this.room;
                this.prevLevel.exitLevel();
                //this.level.exitLevel();
                this.room = door.room;
                door.room.enterLevelThroughDoor(player, door, side);
                this.transitionX =
                    (this.players[this.localPlayerID].x - oldX) * gameConstants_1.GameConstants.TILESIZE;
                this.transitionY =
                    (this.players[this.localPlayerID].y - oldY) * gameConstants_1.GameConstants.TILESIZE;
                this.upwardTransition = false;
                this.sideTransition = false;
                this.sideTransitionDirection = side;
                if (door instanceof door_1.Door &&
                    [Direction.RIGHT, Direction.LEFT].includes(door.doorDir) &&
                    hasDir)
                    this.sideTransition = true;
                else if (door instanceof door_1.Door &&
                    door.doorDir === Direction.DOWN &&
                    hasDir)
                    this.upwardTransition = true;
            }
            else {
                door.room.enterLevelThroughDoor(player, door, side);
            }
            player.map.saveMapData();
        };
        this.run = (timestamp) => {
            if (this.paused) {
                // Still request next frame even when paused to maintain loop
                window.requestAnimationFrame(this.run);
                return;
            }
            if (!this.previousFrameTimestamp) {
                this.previousFrameTimestamp = timestamp;
                window.requestAnimationFrame(this.run);
                return;
            }
            // Calculate elapsed time in milliseconds
            let elapsed = timestamp - this.previousFrameTimestamp;
            // Normalize delta to 60 FPS
            let delta = (elapsed * 60) / 1000.0;
            // Define minimum and maximum delta values
            const deltaMin = 1 / 10; // 600fps
            const deltaMax = 8; //7.5fps
            // Cap delta within [deltaMin, deltaMax]
            if (Game.delta)
                delta = Game.delta;
            if (delta < deltaMin) {
                delta = deltaMin;
            }
            else if (delta > deltaMax) {
                delta = deltaMax;
            }
            // Update FPS tracking
            while (times.length > 0 && times[0] <= timestamp - 1000) {
                times.shift();
            }
            times.push(timestamp);
            fps = times.length;
            // Update game logic
            if (Math.floor(timestamp / (1000 / 60)) >
                Math.floor(this.previousFrameTimestamp / (1000 / 60))) {
                this.update();
            }
            if (Math.floor(timestamp) >
                Math.floor(this.previousFrameTimestamp) + 1000) {
                this.refreshDimensions();
            }
            //delta = 0.1;
            // Render the frame with capped delta
            this.draw(delta * gameConstants_1.GameConstants.ANIMATION_SPEED * 1);
            // Request the next frame
            window.requestAnimationFrame(this.run);
            // Update the previous frame timestamp
            this.previousFrameTimestamp = timestamp;
        };
        this.update = () => {
            this.refreshDimensions();
            input_1.Input.checkIsTapHold();
            // Existing key repeat
            if (input_1.Input.lastPressTime !== 0 &&
                Date.now() - input_1.Input.lastPressTime > gameConstants_1.GameConstants.KEY_REPEAT_TIME) {
                input_1.Input.onKeydown({
                    repeat: false,
                    key: input_1.Input.lastPressKey,
                });
            }
            // Add mouse repeat for movement
            if (input_1.Input.mouseDown &&
                input_1.Input.mouseDownHandled &&
                input_1.Input.lastMouseDownTime !== 0 &&
                Date.now() - input_1.Input.lastMouseDownTime > gameConstants_1.GameConstants.KEY_REPEAT_TIME) {
                // Re-trigger mouse movement
                const player = this.players[this.localPlayerID];
                if (player &&
                    player.game.levelState === LevelState.IN_LEVEL &&
                    !player.dead &&
                    !player.menu.open &&
                    !player.busyAnimating &&
                    !player.game.cameraAnimation.active) {
                    // Update mouse position and trigger movement
                    player.moveWithMouse();
                    input_1.Input.lastMouseDownTime = Date.now(); // Reset timer for next repeat
                }
            }
            // Swipe hold repeat with initial delay
            if (input_1.Input.swipeHoldActive && input_1.Input.lastSwipeTime !== 0) {
                const timeSinceSwipe = Date.now() - input_1.Input.lastSwipeTime;
                if (!input_1.Input.swipeHoldRepeating) {
                    // Check if we've waited long enough for initial delay
                    if (timeSinceSwipe > gameConstants_1.GameConstants.SWIPE_HOLD_INITIAL_DELAY) {
                        input_1.Input.swipeHoldRepeating = true;
                        input_1.Input.lastSwipeTime = Date.now(); // Reset timer for repeat timing
                    }
                }
                else {
                    // We're in repeat mode, check if it's time to repeat
                    if (timeSinceSwipe > gameConstants_1.GameConstants.SWIPE_HOLD_REPEAT_TIME) {
                        // Trigger the swipe listener again based on last direction
                        switch (input_1.Input.lastSwipeDirection) {
                            case Direction.LEFT:
                                input_1.Input.leftSwipeListener();
                                break;
                            case Direction.RIGHT:
                                input_1.Input.rightSwipeListener();
                                break;
                            case Direction.UP:
                                input_1.Input.upSwipeListener();
                                break;
                            case Direction.DOWN:
                                input_1.Input.downSwipeListener();
                                break;
                        }
                        input_1.Input.lastSwipeTime = Date.now(); // Reset timer for next repeat
                    }
                }
            }
            if (this.levelState === LevelState.TRANSITIONING) {
                if (Date.now() - this.transitionStartTime >=
                    levelConstants_1.LevelConstants.LEVEL_TRANSITION_TIME) {
                    this.levelState = LevelState.IN_LEVEL;
                }
            }
            if (this.levelState === LevelState.TRANSITIONING_LADDER) {
                if (Date.now() - this.transitionStartTime >=
                    levelConstants_1.LevelConstants.LEVEL_TRANSITION_TIME_LADDER) {
                    this.levelState = LevelState.IN_LEVEL;
                    this.players[this.localPlayerID].map.saveMapData();
                }
            }
            if (this.levelState !== LevelState.LEVEL_GENERATION) {
                for (const i in this.players) {
                    this.players[i].update();
                    // Don't update rooms during level transitions
                    if (this.levelState !== LevelState.TRANSITIONING &&
                        this.levelState !== LevelState.TRANSITIONING_LADDER) {
                        this.levels[this.players[i].depth].rooms[this.players[i].levelID].update();
                    }
                    if (this.players[i].dead) {
                        for (const j in this.players) {
                            this.players[j].dead = true;
                        }
                    }
                }
            }
        };
        this.lerp = (a, b, t) => {
            return (1 - t) * a + t * b;
        };
        this.pushMessage = (message) => {
            this.chat.push(new ChatMessage(message));
        };
        this.commandHandler = (command) => {
            const player = this.room.game.players[0];
            command = command.toLowerCase();
            let enabled = "";
            switch (command) {
                case "devmode":
                    gameConstants_1.GameConstants.DEVELOPER_MODE = !gameConstants_1.GameConstants.DEVELOPER_MODE;
                    console.log(`Developer mode is now ${gameConstants_1.GameConstants.DEVELOPER_MODE}`);
                    break;
                case "new":
                    this.newGame();
                    break;
                case "dev":
                    gameConstants_1.GameConstants.DEVELOPER_MODE = !gameConstants_1.GameConstants.DEVELOPER_MODE;
                    console.log(`Developer mode is now ${gameConstants_1.GameConstants.DEVELOPER_MODE}`);
                    this.newGame();
                    break;
                case "kill":
                    for (const i in this.players) {
                        this.players[i].dead = true;
                    }
                    break;
                case "killall":
                    for (const i in this.players) {
                        this.players[i].game.room.entities.forEach((e) => {
                            e.kill();
                        });
                    }
                    break;
                case "bomb":
                    this.room.addBombs(1, () => random_1.Random.rand());
                    break;
                case "col":
                    gameConstants_1.GameConstants.SET_COLOR_LAYER_COMPOSITE_OPERATION(false);
                    break;
                case "scl":
                    gameConstants_1.GameConstants.SET_SCALE();
                    this.onResize();
                    break;
                case "shd":
                    gameConstants_1.GameConstants.SHADE_ENABLED = !gameConstants_1.GameConstants.SHADE_ENABLED;
                    enabled = gameConstants_1.GameConstants.SHADE_ENABLED ? "enabled" : "disabled";
                    this.pushMessage(`Shade is now ${enabled}`);
                    break;
                case "shdop":
                    gameConstants_1.GameConstants.SET_SHADE_LAYER_COMPOSITE_OPERATION(false);
                    break;
                case "smooth":
                    gameConstants_1.GameConstants.SMOOTH_LIGHTING = !gameConstants_1.GameConstants.SMOOTH_LIGHTING;
                    enabled = gameConstants_1.GameConstants.SMOOTH_LIGHTING ? "enabled" : "disabled";
                    this.pushMessage(`Smooth lighting is now ${enabled}`);
                    break;
                case "rooms":
                    gameConstants_1.GameConstants.drawOtherRooms = !gameConstants_1.GameConstants.drawOtherRooms;
                    enabled = gameConstants_1.GameConstants.drawOtherRooms ? "enabled" : "disabled";
                    this.pushMessage(`Drawing other rooms is now ${enabled}`);
                    break;
                case "opq":
                    gameConstants_1.GameConstants.ENEMIES_BLOCK_LIGHT = !gameConstants_1.GameConstants.ENEMIES_BLOCK_LIGHT;
                    enabled = gameConstants_1.GameConstants.ENEMIES_BLOCK_LIGHT ? "enabled" : "disabled";
                    this.pushMessage(`Enemies block light is now ${enabled}`);
                    break;
                case "peace":
                    gameplaySettings_1.GameplaySettings.NO_ENEMIES = !gameplaySettings_1.GameplaySettings.NO_ENEMIES;
                    this.newGame();
                    enabled = gameplaySettings_1.GameplaySettings.NO_ENEMIES ? "enabled" : "disabled";
                    this.pushMessage(`Peaceful mode is now ${enabled}`);
                    break;
                case "equip":
                    gameplaySettings_1.GameplaySettings.EQUIP_USES_TURN = !gameplaySettings_1.GameplaySettings.EQUIP_USES_TURN;
                    enabled = gameplaySettings_1.GameplaySettings.EQUIP_USES_TURN ? "enabled" : "disabled";
                    this.pushMessage(`Equipping an item takes a turn is now ${enabled}`);
                    break;
                case "webgl":
                case "hq":
                    gameConstants_1.GameConstants.TOGGLE_HIGH_QUALITY_BLUR();
                    break;
                case "genroom":
                    this.generateAndShowRoomLayout();
                    break;
                case "cleargen":
                    this.currentLevelGenerator = null;
                    this.pushMessage("Cleared generated level display");
                    break;
                case "post":
                    postProcess_1.PostProcessor.settings.enabled = !postProcess_1.PostProcessor.settings.enabled;
                    enabled = postProcess_1.PostProcessor.settings.enabled ? "enabled" : "disabled";
                    this.pushMessage(`Post processor is now ${enabled}`);
                    break;
                case "save":
                    try {
                        this.savedGameState = (0, gameState_1.createGameState)(this);
                        this.pushMessage("Game state saved successfully!");
                        console.log("Saved game state:", this.savedGameState);
                    }
                    catch (error) {
                        this.pushMessage("Error saving game state: " + error.message);
                        console.error("Save error:", error);
                    }
                    break;
                case "load":
                    if (!this.savedGameState) {
                        this.pushMessage("No saved game state found. Use 'save' command first.");
                        return;
                    }
                    try {
                        // Get current active usernames (for multiplayer support)
                        const activeUsernames = Object.keys(this.players);
                        (0, gameState_1.loadGameState)(this, activeUsernames, this.savedGameState, false);
                        this.pushMessage("Game state loaded successfully!");
                        console.log("Loaded game state");
                    }
                    catch (error) {
                        this.pushMessage("Error loading game state: " + error.message);
                        console.error("Load error:", error);
                    }
                    break;
                case "saveinfo":
                    if (!this.savedGameState) {
                        this.pushMessage("No saved game state found.");
                        return;
                    }
                    this.pushMessage(`Saved state - Seed: ${this.savedGameState.seed}, Depth: ${this.savedGameState.level.depth}, Players: ${Object.keys(this.savedGameState.players).length}`);
                    console.log("Saved game state details:", this.savedGameState);
                    break;
                case "currentinfo":
                    this.pushMessage(`Current state - Seed: ${this.levelgen.seed}, Depth: ${this.level.depth}, Players: ${Object.keys(this.players).length}`);
                    console.log("Current game state details:", {
                        seed: this.levelgen.seed,
                        depth: this.level.depth,
                        players: Object.keys(this.players),
                        rooms: this.rooms.length,
                    });
                    break;
                case "testsave":
                    // Save current state, make some changes, then load to verify
                    try {
                        this.savedGameState = (0, gameState_1.createGameState)(this);
                        const originalHealth = this.players[this.localPlayerID].health;
                        const originalX = this.players[this.localPlayerID].x;
                        const originalY = this.players[this.localPlayerID].y;
                        // Make some changes
                        this.players[this.localPlayerID].health = Math.max(1, this.players[this.localPlayerID].health - 1);
                        this.players[this.localPlayerID].x += 1;
                        this.players[this.localPlayerID].y += 1;
                        this.pushMessage(`Changes made - Health: ${originalHealth} -> ${this.players[this.localPlayerID].health}, Pos: (${originalX},${originalY}) -> (${this.players[this.localPlayerID].x},${this.players[this.localPlayerID].y})`);
                        this.pushMessage("Use 'load' to restore the saved state");
                    }
                    catch (error) {
                        this.pushMessage("Error in test save: " + error.message);
                        console.error("Test save error:", error);
                    }
                    break;
                default:
                    if (command.startsWith("new ")) {
                        this.room.addNewEnemy(command.slice(4));
                    }
                    else if (command.startsWith("fill")) {
                        while (this.room.getEmptyTiles().length > 0) {
                            this.room.addNewEnemy(command.slice(5));
                        }
                    }
                    break;
            }
        };
        this.maxScale = () => {
            let dimension = window.innerWidth;
            let measure = 130;
            for (let i = gameConstants_1.GameConstants.MIN_SCALE; i <= gameConstants_1.GameConstants.MAX_SCALE; i++) {
                if (dimension / i < measure) {
                    return i;
                }
            }
            return gameConstants_1.GameConstants.MAX_SCALE;
        };
        this.increaseScale = () => {
            gameConstants_1.GameConstants.INCREASE_SCALE();
            this.onResize();
            // Recalculate mouse position for new scale
            input_1.Input.recalculateMousePosition();
        };
        this.decreaseScale = () => {
            gameConstants_1.GameConstants.DECREASE_SCALE();
            this.onResize();
            // Recalculate mouse position for new scale
            input_1.Input.recalculateMousePosition();
        };
        this.updateScale = (delta) => {
            if (gameConstants_1.GameConstants.smoothScaling) {
                if (gameConstants_1.GameConstants.SOFT_SCALE < gameConstants_1.GameConstants.SCALE &&
                    Math.abs(gameConstants_1.GameConstants.SOFT_SCALE - gameConstants_1.GameConstants.SCALE) >= 0.1) {
                    gameConstants_1.GameConstants.SOFT_SCALE +=
                        ((gameConstants_1.GameConstants.SCALE - gameConstants_1.GameConstants.SOFT_SCALE) * delta) / 10;
                }
                if (gameConstants_1.GameConstants.SOFT_SCALE > gameConstants_1.GameConstants.SCALE &&
                    Math.abs(gameConstants_1.GameConstants.SOFT_SCALE - gameConstants_1.GameConstants.SCALE) >= 0.1) {
                    gameConstants_1.GameConstants.SOFT_SCALE -=
                        ((gameConstants_1.GameConstants.SOFT_SCALE - gameConstants_1.GameConstants.SCALE) * delta) / 10;
                }
                if (gameConstants_1.GameConstants.SOFT_SCALE < gameConstants_1.GameConstants.SCALE &&
                    Math.abs(gameConstants_1.GameConstants.SOFT_SCALE - gameConstants_1.GameConstants.SCALE) <= 0.1) {
                    gameConstants_1.GameConstants.SOFT_SCALE += delta / 25;
                }
                if (gameConstants_1.GameConstants.SOFT_SCALE > gameConstants_1.GameConstants.SCALE &&
                    Math.abs(gameConstants_1.GameConstants.SOFT_SCALE - gameConstants_1.GameConstants.SCALE) <= 0.1) {
                    gameConstants_1.GameConstants.SOFT_SCALE -= delta / 25;
                }
                if (Math.abs(gameConstants_1.GameConstants.SOFT_SCALE - gameConstants_1.GameConstants.SCALE) <= 0.01) {
                    gameConstants_1.GameConstants.SOFT_SCALE = gameConstants_1.GameConstants.SCALE;
                }
            }
            else {
                //GameConstants.SCALE = Math.floor(GameConstants.SCALE);
                gameConstants_1.GameConstants.SOFT_SCALE = gameConstants_1.GameConstants.SCALE;
            }
            this.onResize();
            // Recalculate mouse position for new scale
            input_1.Input.recalculateMousePosition();
        };
        this.refreshDimensions = () => {
            Game.ctx.canvas.setAttribute("width", `${gameConstants_1.GameConstants.WIDTH}`);
            Game.ctx.canvas.setAttribute("height", `${gameConstants_1.GameConstants.HEIGHT}`);
        };
        this.onResize = () => {
            if (this.localPlayerID !== undefined &&
                this.players?.[this.localPlayerID] &&
                this.players?.[this.localPlayerID]?.menu) {
                this.players[this.localPlayerID].menu.positionButtons();
            }
            this.isMobile =
                /iPhone|iPad|iPod|Android|webOS|BlackBerry|IEMobile|Opera Mini|Mobile|mobile|CriOS/i.test(navigator.userAgent);
            gameConstants_1.GameConstants.isIOS =
                /iPhone|iPad|iPod/i.test(navigator.userAgent) &&
                    !navigator.userAgent.includes("Chrome DevTools");
            // Detect Safari browser and enable WebGL blur
            const isSafari = /Safari/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent);
            if (isSafari) {
                gameConstants_1.GameConstants.USE_WEBGL_BLUR = true;
            }
            // Define scale adjustment based on device pixel ratio
            if (gameConstants_1.GameConstants.SCALE === null) {
                gameConstants_1.GameConstants.SCALE = gameConstants_1.GameConstants.FIND_SCALE(this.isMobile);
                gameConstants_1.GameConstants.SOFT_SCALE = gameConstants_1.GameConstants.SCALE;
            }
            let scaleOffset = 0;
            // Calculate maximum possible scale based on window size
            let maxWidthScale = Math.floor(window.innerWidth / gameConstants_1.GameConstants.DEFAULTWIDTH);
            let maxHeightScale = Math.floor(window.innerHeight / gameConstants_1.GameConstants.DEFAULTHEIGHT);
            if (this.isMobile) {
                if (this.isMobile)
                    console.log("Mobile detected");
                gameConstants_1.GameConstants.SHADE_LEVELS = 35;
                gameConstants_1.GameConstants.isMobile = true;
                levelConstants_1.LevelConstants.LIGHTING_ANGLE_STEP = 2;
                levelConstants_1.LevelConstants.LIGHTING_MAX_DISTANCE = 7;
                gameConstants_1.GameConstants.USE_WEBGL_BLUR = true;
                // Use smaller scale for mobile devices based on screen size
                // Adjust max scale with scaleOffset
                const integerScale = gameConstants_1.GameConstants.SOFT_SCALE + scaleOffset;
                Game.scale = Math.min(maxWidthScale, maxHeightScale, integerScale); // Cap at 3 + offset for mobile
            }
            else {
                gameConstants_1.GameConstants.isMobile = false;
                // For desktop, use standard scaling logic
                // Ensure GameConstants.SCALE is an integer. If not, round it.
                const integerScale = gameConstants_1.GameConstants.SOFT_SCALE + scaleOffset;
                Game.scale = Math.min(maxWidthScale, maxHeightScale, integerScale);
            }
            // Handle case where scale would be 0
            if (Game.scale === 0) {
                // Recalculate max scales without flooring to check for minimum scale
                maxWidthScale = window.innerWidth / gameConstants_1.GameConstants.DEFAULTWIDTH;
                maxHeightScale = window.innerHeight / gameConstants_1.GameConstants.DEFAULTHEIGHT;
                // Ensure Game.scale is at least 1 and an integer
                Game.scale = Math.max(1, Math.min(maxWidthScale, maxHeightScale, 1 + scaleOffset));
            }
            // Apply device pixel ratio negation by setting scale to compensate for DPI
            const NEGATE_DPR_FACTOR = 1;
            Game.scale *= NEGATE_DPR_FACTOR / window.devicePixelRatio;
            // Calculate screen width and height in tiles, ensuring integer values
            levelConstants_1.LevelConstants.SCREEN_W = Math.floor(window.innerWidth / Game.scale / gameConstants_1.GameConstants.TILESIZE);
            levelConstants_1.LevelConstants.SCREEN_H = Math.floor(window.innerHeight / Game.scale / gameConstants_1.GameConstants.TILESIZE);
            // Calculate canvas width and height in pixels
            gameConstants_1.GameConstants.WIDTH = Math.floor(window.innerWidth / Game.scale);
            gameConstants_1.GameConstants.HEIGHT = Math.floor(window.innerHeight / Game.scale);
            // Set canvas width and height attributes
            Game.ctx.canvas.setAttribute("width", `${gameConstants_1.GameConstants.WIDTH}`);
            Game.ctx.canvas.setAttribute("height", `${gameConstants_1.GameConstants.HEIGHT}`);
            // Set CSS styles for scaling, applying negated DPR factor
            Game.ctx.canvas.setAttribute("style", `width: ${gameConstants_1.GameConstants.WIDTH * Game.scale}px; height: ${gameConstants_1.GameConstants.HEIGHT * Game.scale}px;
      display: block;
      margin: 0 auto;
      image-rendering: optimizeSpeed; /* Older versions of FF */
      image-rendering: -moz-crisp-edges; /* FF 6.0+ */
      image-rendering: -webkit-optimize-contrast; /* Safari */
      image-rendering: -o-crisp-edges; /* OS X & Windows Opera (12.02+) */
      image-rendering: pixelated; /* Future-browsers */
      -ms-interpolation-mode: nearest-neighbor; /* IE */
      `);
            // Clear chat cache if width changed
            const newChatWidth = gameConstants_1.GameConstants.WIDTH - 20; // Account for margins
            if (newChatWidth !== this.lastChatWidth) {
                this.chat.forEach((msg) => msg.clearCache());
                this.lastChatWidth = newChatWidth;
            }
        };
        this.shakeScreen = (shakeX, shakeY, clamp = false) => {
            let finalX = clamp ? Math.max(-3, Math.min(3, shakeX)) : shakeX;
            let finalY = clamp ? Math.max(-3, Math.min(3, shakeY)) : shakeY;
            this.screenShakeActive = true;
            this.screenShakeX += finalX;
            this.screenShakeY += finalY;
            this.shakeAmountX += Math.abs(finalX);
            this.shakeAmountY += Math.abs(finalY);
            if (finalX < 0 || finalY < 0)
                this.shakeFrame = (3 * Math.PI) / 2;
            if (finalX > 0 || finalY > 0)
                this.shakeFrame = Math.PI / 2;
            this.screenShakeCutoff = Date.now();
        };
        this.drawRooms = (delta, skipLocalPlayer = false) => {
            if (!gameConstants_1.GameConstants.drawOtherRooms) {
                this.room.draw(delta);
                this.room.drawEntities(delta, true);
            }
            else if (gameConstants_1.GameConstants.drawOtherRooms) {
                // Create a sorted copy of the rooms array based on roomY + height
                const sortedRooms = this.levels[this.currentDepth].rooms
                    .slice()
                    .sort((a, b) => {
                    const aPosition = a.roomY + a.height;
                    const bPosition = b.roomY + b.height;
                    return aPosition - bPosition; // Ascending order
                });
                for (const room of sortedRooms) {
                    if (room.active || (room.entered && room.onScreen)) {
                        room.draw(delta);
                        room.drawEntities(delta, skipLocalPlayer);
                        //room.drawShade(delta); // this used to come after the color layer
                    }
                }
            }
        };
        this.drawRoomShadeAndColor = (delta) => {
            for (const room of this.levels[this.currentDepth].rooms) {
                if (room.active || room.entered) {
                    room.drawShadeLayer();
                    room.drawColorLayer();
                    room.drawBloomLayer(delta);
                }
            }
            for (const room of this.levels[this.currentDepth].rooms) {
                if (room.active && room.entered) {
                    room.drawOverShade(delta);
                }
            }
        };
        this.drawStartScreen = (delta) => {
            let startString = "Welcome to Turnarchist";
            Game.ctx.globalAlpha = this.startScreenAlpha;
            if (!this.started && !this.startedFadeOut) {
                this.startScreenAlpha = 1;
                if (this.startScreenAlpha <= 0)
                    this.startScreenAlpha = 0;
            }
            else if (!this.started && this.startedFadeOut) {
                this.startScreenAlpha -= delta * 0.025;
                if (this.startScreenAlpha <= 0) {
                    this.startScreenAlpha = 0;
                    this.started = true;
                    sound_1.Sound.playAmbient();
                }
            }
            Game.ctx.fillStyle = "black";
            Game.ctx.fillRect(0, 0, gameConstants_1.GameConstants.WIDTH, gameConstants_1.GameConstants.HEIGHT);
            Game.ctx.fillStyle = levelConstants_1.LevelConstants.LEVEL_TEXT_COLOR;
            Game.fillText(startString, gameConstants_1.GameConstants.WIDTH / 2 - Game.measureText(startString).width / 2, gameConstants_1.GameConstants.HEIGHT / 2 - Game.letter_height + 2);
            let restartButton = "Press space or click to start";
            if (this.isMobile)
                restartButton = "Tap to start";
            Game.fillText(restartButton, gameConstants_1.GameConstants.WIDTH / 2 - Game.measureText(restartButton).width / 2, gameConstants_1.GameConstants.HEIGHT / 2 + Game.letter_height + 5);
            Game.ctx.globalAlpha = 1;
        };
        this.drawTipScreen = (delta) => {
            let tip = this.tip;
            Game.ctx.fillStyle = "black";
            Game.ctx.fillRect(0, 0, gameConstants_1.GameConstants.WIDTH, gameConstants_1.GameConstants.HEIGHT);
            Game.ctx.fillStyle = levelConstants_1.LevelConstants.LEVEL_TEXT_COLOR;
            Game.fillText(tip, gameConstants_1.GameConstants.WIDTH / 2 - Game.measureText(tip).width / 2, gameConstants_1.GameConstants.HEIGHT / 2 - Game.letter_height + 2);
        };
        this.draw = (delta) => {
            if (gameConstants_1.GameConstants.SOFT_SCALE !== gameConstants_1.GameConstants.SCALE) {
                this.updateScale(delta);
                this.onResize();
            }
            //Game.ctx.canvas.setAttribute("role", "presentation");
            Game.ctx.clearRect(0, 0, gameConstants_1.GameConstants.WIDTH, gameConstants_1.GameConstants.HEIGHT);
            Game.ctx.save(); // Save the current canvas state
            // Reset transformations to ensure the black background covers the entire canvas
            Game.ctx.setTransform(1, 0, 0, 1, 0, 0);
            Game.ctx.globalAlpha = 1;
            Game.ctx.globalCompositeOperation = "source-over";
            Game.ctx.fillStyle = "black";
            Game.ctx.fillRect(0, 0, gameConstants_1.GameConstants.WIDTH, gameConstants_1.GameConstants.HEIGHT);
            //if (this.room) Game.ctx.fillStyle = this.room.shadeColor;
            //else Game.ctx.fillStyle = "black";
            //Game.ctx.fillRect(0, 0, GameConstants.WIDTH, GameConstants.HEIGHT);
            if (this.levelState === LevelState.TRANSITIONING) {
                this.screenShakeX = 0;
                this.screenShakeY = 0;
                this.screenShakeActive = false;
                let levelOffsetX = Math.floor(this.lerp((Date.now() - this.transitionStartTime) /
                    levelConstants_1.LevelConstants.LEVEL_TRANSITION_TIME, 0, -this.transitionX));
                let levelOffsetY = Math.floor(this.lerp((Date.now() - this.transitionStartTime) /
                    levelConstants_1.LevelConstants.LEVEL_TRANSITION_TIME, 0, -this.transitionY));
                let playerOffsetX = levelOffsetX - this.transitionX;
                let playerOffsetY = levelOffsetY - this.transitionY;
                let playerCX = (this.players[this.localPlayerID].x -
                    this.players[this.localPlayerID].drawX +
                    0.5) *
                    gameConstants_1.GameConstants.TILESIZE;
                let playerCY = (this.players[this.localPlayerID].y -
                    this.players[this.localPlayerID].drawY +
                    0.5) *
                    gameConstants_1.GameConstants.TILESIZE;
                Game.ctx.translate(-Math.round(playerCX + playerOffsetX - 0.5 * gameConstants_1.GameConstants.WIDTH), -Math.round(playerCY + playerOffsetY - 0.5 * gameConstants_1.GameConstants.HEIGHT));
                let extraTileLerp = Math.floor(this.lerp((Date.now() - this.transitionStartTime) /
                    levelConstants_1.LevelConstants.LEVEL_TRANSITION_TIME, 0, gameConstants_1.GameConstants.TILESIZE));
                let newLevelOffsetX = playerOffsetX;
                let newLevelOffsetY = playerOffsetY;
                if (this.sideTransition) {
                    if (this.sideTransitionDirection > 0) {
                        levelOffsetX += extraTileLerp;
                        newLevelOffsetX += extraTileLerp + gameConstants_1.GameConstants.TILESIZE;
                    }
                    else {
                        levelOffsetX -= extraTileLerp;
                        newLevelOffsetX -= extraTileLerp + gameConstants_1.GameConstants.TILESIZE;
                    }
                }
                else if (this.upwardTransition) {
                    levelOffsetY -= extraTileLerp;
                    newLevelOffsetY -= extraTileLerp + gameConstants_1.GameConstants.TILESIZE;
                }
                else {
                    levelOffsetY += extraTileLerp;
                    newLevelOffsetY += extraTileLerp + gameConstants_1.GameConstants.TILESIZE;
                }
                let ditherFrame = Math.floor((7 * (Date.now() - this.transitionStartTime)) /
                    levelConstants_1.LevelConstants.LEVEL_TRANSITION_TIME);
                Game.ctx.translate(levelOffsetX, levelOffsetY);
                if (!gameConstants_1.GameConstants.drawOtherRooms) {
                    this.prevLevel.draw(delta);
                    this.prevLevel.drawEntities(delta);
                    this.prevLevel.drawColorLayer();
                    this.prevLevel.drawShade(delta);
                    this.prevLevel.drawOverShade(delta);
                    /*
                    for (
                      let x = this.prevLevel.roomX - 1;
                      x <= this.prevLevel.roomX + this.prevLevel.width;
                      x++
                    ) {
                      for (
                        let y = this.prevLevel.roomY - 1;
                        y <= this.prevLevel.roomY + this.prevLevel.height;
                        y++
                      ) {
                        Game.drawFX(7 - ditherFrame, 10, 1, 1, x, y, 1, 1);
                      }
                    }
            
                  */
                }
                Game.ctx.translate(-levelOffsetX, -levelOffsetY);
                Game.ctx.translate(newLevelOffsetX, newLevelOffsetY);
                if (gameConstants_1.GameConstants.drawOtherRooms) {
                    this.drawRooms(delta, true);
                    Game.ctx.translate(-newLevelOffsetX, -newLevelOffsetY);
                    Game.ctx.translate(playerOffsetX, playerOffsetY);
                    this.players[this.localPlayerID].draw(delta); // draw the translation
                    Game.ctx.translate(-playerOffsetX, -playerOffsetY);
                    Game.ctx.translate(newLevelOffsetX, newLevelOffsetY);
                    this.drawRoomShadeAndColor(delta);
                }
                for (let x = this.room.roomX - 1; x <= this.room.roomX + this.room.width; x++) {
                    for (let y = this.room.roomY - 1; y <= this.room.roomY + this.room.height; y++) {
                        //Game.drawFX(ditherFrame, 10, 1, 1, x, y, 1, 1);
                    }
                }
                //this.drawStuff(delta);
                Game.ctx.translate(-newLevelOffsetX, -newLevelOffsetY);
                Game.ctx.translate(Math.round(playerCX + playerOffsetX - 0.5 * gameConstants_1.GameConstants.WIDTH), Math.round(playerCY + playerOffsetY - 0.5 * gameConstants_1.GameConstants.HEIGHT));
                this.players[this.localPlayerID].drawGUI(delta);
                this.justTransitioned = true;
                //for (const i in this.players) this.players[i].updateDrawXY(delta);
            }
            else if (this.levelState === LevelState.TRANSITIONING_LADDER) {
                let playerCX = (this.players[this.localPlayerID].x -
                    this.players[this.localPlayerID].drawX +
                    0.5) *
                    gameConstants_1.GameConstants.TILESIZE;
                let playerCY = (this.players[this.localPlayerID].y -
                    this.players[this.localPlayerID].drawY +
                    0.5) *
                    gameConstants_1.GameConstants.TILESIZE;
                Game.ctx.translate(-Math.round(playerCX - 0.5 * gameConstants_1.GameConstants.WIDTH), -Math.round(playerCY - 0.5 * gameConstants_1.GameConstants.HEIGHT));
                let deadFrames = 6;
                let ditherFrame = Math.floor(((7 * 2 + deadFrames) * (Date.now() - this.transitionStartTime)) /
                    levelConstants_1.LevelConstants.LEVEL_TRANSITION_TIME_LADDER);
                Game.ctx.translate(Math.round(playerCX - 0.5 * gameConstants_1.GameConstants.WIDTH), Math.round(playerCY - 0.5 * gameConstants_1.GameConstants.HEIGHT));
                if (ditherFrame < 7) {
                    this.drawRooms(delta);
                    this.drawRoomShadeAndColor(delta);
                    if (!gameConstants_1.GameConstants.drawOtherRooms) {
                        for (let x = this.room.roomX - 1; x <= this.room.roomX + this.room.width; x++) {
                            for (let y = this.room.roomY - 1; y <= this.room.roomY + this.room.height; y++) {
                                Game.drawFX(7 - ditherFrame, 10, 1, 1, x, y, 1, 1);
                            }
                        }
                    }
                }
                else if (ditherFrame >= 7 + deadFrames) {
                    if (this.transitioningLadder) {
                        // this.prevLevel = this.room;
                        // this.room.exitLevel();
                        this.room = this.transitioningLadder.linkedRoom;
                        // this.players[this.localPlayerID].levelID = this.room.id;
                        this.room.enterLevel(this.players[this.localPlayerID]);
                        this.transitioningLadder = null;
                    }
                    this.drawRooms(delta);
                    this.drawRoomShadeAndColor(delta);
                    //        this.room.draw(delta);
                    //        this.room.drawEntities(delta);
                    //        this.drawStuff(delta);
                    if (!gameConstants_1.GameConstants.drawOtherRooms) {
                        for (let x = this.room.roomX - 1; x <= this.room.roomX + this.room.width; x++) {
                            for (let y = this.room.roomY - 1; y <= this.room.roomY + this.room.height; y++) {
                                Game.drawFX(ditherFrame - (7 + deadFrames), 10, 1, 1, x, y, 1, 1);
                            }
                        }
                    }
                }
                //this.players[this.localPlayerID].drawGUI(delta);  // removed this to prevent drawing gui during level transition
                //for (const i in this.players) this.players[i].updateDrawXY(delta);
                this.drawTextScreen("loading level");
            }
            else if (this.levelState === LevelState.LEVEL_GENERATION) {
                this.levelgen.draw(delta);
            }
            else if (this.levelState === LevelState.IN_LEVEL) {
                // Start of Selection
                this.drawScreenShake(delta);
                const { cameraX, cameraY } = this.applyCamera(delta);
                Game.ctx.translate(-cameraX, -cameraY);
                this.drawRooms(delta);
                this.drawRoomShadeAndColor(delta);
                //      this.room.draw(delta);
                //      this.room.drawEntities(delta);
                // this.drawStuff(delta);
                Game.ctx.translate(cameraX, cameraY);
                this.room.drawTopLayer(delta);
                this.players[this.localPlayerID].drawGUI(delta);
                //for (const i in this.players) this.players[i].updateDrawXY(delta);
            }
            this.drawChat(delta);
            // game version
            if (gameConstants_1.GameConstants.ALPHA_ENABLED)
                Game.ctx.globalAlpha = 0.1;
            Game.ctx.fillStyle = levelConstants_1.LevelConstants.LEVEL_TEXT_COLOR;
            Game.fillText(gameConstants_1.GameConstants.VERSION, gameConstants_1.GameConstants.WIDTH - Game.measureText(gameConstants_1.GameConstants.VERSION).width - 1, 1);
            Game.ctx.globalAlpha = 1;
            // fps
            if (gameConstants_1.GameConstants.ALPHA_ENABLED)
                Game.ctx.globalAlpha = 0.1;
            Game.ctx.fillStyle = levelConstants_1.LevelConstants.LEVEL_TEXT_COLOR;
            Game.fillText(fps + "fps", 1, 1);
            Game.ctx.globalAlpha = 1;
            if (!this.started && this.levelState !== LevelState.LEVEL_GENERATION) {
                this.drawStartScreen(delta * 10);
            }
            // Draw level generator if active
            if (this.currentLevelGenerator) {
                this.currentLevelGenerator.draw(10, 10, 3);
            }
            mouseCursor_1.MouseCursor.getInstance().draw(delta, this.isMobile);
            Game.ctx.restore(); // Restore the canvas state
        };
        this.drawChat = (delta) => {
            const CHAT_X = 5;
            const CHAT_BOTTOM_Y = gameConstants_1.GameConstants.HEIGHT - Game.letter_height - 38;
            const CHAT_OPACITY = this.players?.[this.localPlayerID]?.inventory.isOpen
                ? 0.05
                : 1;
            const CHAT_MAX_WIDTH = gameConstants_1.GameConstants.WIDTH - 5; // Leave some margin
            const LINE_HEIGHT = Game.letter_height + 1;
            if (this.chatOpen) {
                Game.ctx.fillStyle = "black";
                if (gameConstants_1.GameConstants.ALPHA_ENABLED)
                    Game.ctx.globalAlpha = 0.75;
                Game.ctx.fillRect(0, 0, gameConstants_1.GameConstants.WIDTH, gameConstants_1.GameConstants.HEIGHT);
                Game.ctx.globalAlpha = 1;
                Game.ctx.fillStyle = "white";
                Game.fillText(this.chatTextBox.text, CHAT_X, CHAT_BOTTOM_Y);
                const cursorX = Game.measureText(this.chatTextBox.text.substring(0, this.chatTextBox.cursor)).width;
                Game.ctx.fillRect(CHAT_X + cursorX, CHAT_BOTTOM_Y, 1, Game.letter_height);
            }
            // Calculate total height needed for all visible messages
            let totalHeight = 0;
            const messageHeights = [];
            for (let i = 0; i < this.chat.length; i++) {
                const lines = this.chat[i].getWrappedLines(CHAT_MAX_WIDTH);
                const messageHeight = lines.length * LINE_HEIGHT;
                messageHeights.push(messageHeight);
                totalHeight += messageHeight;
            }
            // Draw messages from bottom to top
            let currentY = CHAT_BOTTOM_Y;
            if (this.chatOpen) {
                currentY -= LINE_HEIGHT; // Account for input line
            }
            for (let i = this.chat.length - 1; i >= 0; i--) {
                const message = this.chat[i];
                const lines = message.getWrappedLines(CHAT_MAX_WIDTH);
                const messageHeight = messageHeights[i];
                // Calculate opacity based on age
                const age = Date.now() - message.timestamp;
                let alpha = 1;
                if (!this.chatOpen) {
                    if (age <= gameConstants_1.GameConstants.CHAT_APPEAR_TIME) {
                        alpha = gameConstants_1.GameConstants.ALPHA_ENABLED ? CHAT_OPACITY : 1;
                    }
                    else if (age <=
                        gameConstants_1.GameConstants.CHAT_APPEAR_TIME + gameConstants_1.GameConstants.CHAT_FADE_TIME) {
                        alpha = gameConstants_1.GameConstants.ALPHA_ENABLED
                            ? CHAT_OPACITY *
                                (1 -
                                    (age - gameConstants_1.GameConstants.CHAT_APPEAR_TIME) /
                                        gameConstants_1.GameConstants.CHAT_FADE_TIME)
                            : 1;
                    }
                    else {
                        alpha = 0;
                    }
                }
                if (alpha > 0) {
                    // Set message color
                    Game.ctx.fillStyle = "white";
                    //if (message.message[0] === "/") {
                    //  Game.ctx.fillStyle = GameConstants.GREEN;
                    //}
                    Game.ctx.globalAlpha = alpha;
                    // Draw each line of the message from bottom to top
                    let lineY = currentY;
                    for (let lineIndex = lines.length - 1; lineIndex >= 0; lineIndex--) {
                        Game.fillText(lines[lineIndex], CHAT_X, lineY);
                        lineY -= LINE_HEIGHT;
                    }
                }
                // Move up by this message's height
                currentY -= messageHeight;
            }
            // Reset alpha
            Game.ctx.globalAlpha = 1;
        };
        this.targetCamera = (targetX, targetY) => {
            let cameraX = Math.round((targetX + 0.5) * gameConstants_1.GameConstants.TILESIZE - 0.5 * gameConstants_1.GameConstants.WIDTH);
            let cameraY = Math.round((targetY + 0.5) * gameConstants_1.GameConstants.TILESIZE - 0.5 * gameConstants_1.GameConstants.HEIGHT);
            this.cameraTargetX = cameraX;
            this.cameraTargetY = cameraY;
        };
        this.updateCamera = (delta) => {
            const dx = this.cameraTargetX - this.cameraX;
            const dy = this.cameraTargetY - this.cameraY;
            let speed = gameConstants_1.GameConstants.CAMERA_SPEED;
            if (this.justTransitioned) {
                speed = 1;
                this.justTransitioned = false;
            }
            if (this.cameraAnimation.active) {
                speed = 0.075;
            }
            if (Math.abs(dx) > 250 || Math.abs(dy) > 250) {
                speed = 1;
            }
            if ((Math.abs(dx) > 1 || Math.abs(dy) > 1) && speed !== 1) {
                this.cameraX += dx * speed * delta;
                this.cameraY += dy * speed * delta;
            }
            else {
                this.cameraX = this.cameraTargetX;
                this.cameraY = this.cameraTargetY;
            }
            //console.log("camera", this.cameraX, this.cameraY);
        };
        this.applyCamera = (delta) => {
            let player = this.players[this.localPlayerID];
            this.targetCamera(player.x - player.drawX, player.y - player.drawY);
            this.updateCameraAnimation(delta);
            this.updateCamera(delta);
            const roundedCameraX = Math.round(this.cameraX - this.screenShakeX);
            const roundedCameraY = Math.round(this.cameraY - this.screenShakeY);
            return {
                cameraX: roundedCameraX,
                cameraY: roundedCameraY,
            };
        };
        this.drawScreenShake = (delta) => {
            if (!this.screenShakeActive) {
                this.resetScreenShake();
                return;
            }
            this.shakeAmountX *= 0.8 ** delta;
            this.shakeAmountY *= 0.8 ** delta;
            this.screenShakeX = Math.sin(this.shakeFrame * Math.PI) * this.shakeAmountX;
            this.screenShakeY = Math.sin(this.shakeFrame * Math.PI) * this.shakeAmountY;
            this.shakeFrame += 0.15 * delta;
            if (Math.abs(this.shakeAmountX) < 0.5 &&
                Math.abs(this.shakeAmountY) < 0.5) {
                this.resetScreenShake();
            }
        };
        this.resetScreenShake = () => {
            this.shakeAmountX = 0;
            this.shakeAmountY = 0;
            this.shakeFrame = 0;
            this.screenShakeX = 0;
            this.screenShakeY = 0;
            this.screenShakeActive = false;
        };
        this.updateCameraAnimation = (delta) => {
            //console.log("updating camera animation", this.cameraAnimation.active);
            if (!this.cameraAnimation.active)
                return;
            const elapsed = this.cameraAnimation.frame / this.cameraAnimation.duration;
            if (elapsed < 0.6)
                this.targetCamera(this.cameraAnimation.x, this.cameraAnimation.y);
            this.cameraAnimation.frame += delta;
            if (this.cameraAnimation.frame > this.cameraAnimation.duration)
                this.cameraAnimation.active = false;
        };
        this.startCameraAnimation = (x, y, duration) => {
            //console.log("starting camera animation", x, y, duration);
            this.cameraAnimation.active = true;
            this.cameraAnimation.x = x;
            this.cameraAnimation.y = y;
            this.cameraAnimation.duration = duration;
            this.cameraAnimation.frame = 0;
        };
        this.drawTextScreen = (text, bg = true) => {
            if (bg) {
                Game.ctx.fillStyle = "rgb(0, 0, 0)";
                Game.ctx.fillRect(0, 0, gameConstants_1.GameConstants.WIDTH, gameConstants_1.GameConstants.HEIGHT);
            }
            const ellipsis = this.animateEllipsis();
            const dimensions = Game.measureText(text + ellipsis);
            Game.ctx.fillStyle = "rgb(255, 255, 255)";
            Game.fillText(text + ellipsis, gameConstants_1.GameConstants.WIDTH / 2 - dimensions.width / 2, gameConstants_1.GameConstants.HEIGHT / 2 - dimensions.height / 2);
        };
        this.animateEllipsis = () => {
            if (Date.now() - this.ellipsisStartTime > 150) {
                this.ellipsisStartTime = Date.now();
                this.ellipsisFrame = (this.ellipsisFrame + 1) % 4;
            }
            return ".".repeat(this.ellipsisFrame);
        };
        this.handleWindowBlur = () => {
            // Start a timeout when window loses focus
            this.focusTimeout = window.setTimeout(() => {
                // Store current state
                this.wasMuted = sound_1.Sound.audioMuted;
                this.wasStarted = this.started;
                // Mute audio and pause game
                sound_1.Sound.audioMuted = true;
                //this.started = false;
                this.paused = true;
                // Optional: Show a message in chat
                this.pushMessage("Game paused - window inactive");
            }, this.FOCUS_TIMEOUT_DURATION);
        };
        this.handleWindowFocus = () => {
            // Clear the timeout if it exists
            if (this.focusTimeout) {
                clearTimeout(this.focusTimeout);
                this.focusTimeout = null;
            }
            // If game was paused due to inactivity, restore previous state
            if (this.paused) {
                sound_1.Sound.audioMuted = this.wasMuted;
                this.started = this.wasStarted;
                this.paused = false;
                // Optional: Show a message in chat
                this.pushMessage("Game resumed");
            }
        };
        this.globalId = IdGenerator_1.IdGenerator.generate("G");
        window.addEventListener("load", () => {
            let canvas = document.getElementById("gameCanvas");
            Game.ctx = canvas.getContext("2d", {
                alpha: false,
            });
            // Create TextBox instances and associate them with HTML elements
            const usernameElement = document.createElement("input");
            usernameElement.type = "text";
            usernameElement.autocomplete = "off";
            usernameElement.autocapitalize = "off";
            usernameElement.style.position = "absolute";
            usernameElement.style.left = "-1000px"; // Position off-screen
            //const passwordElement = document.createElement("input");
            //passwordElement.type = "password";
            //passwordElement.style.position = "absolute";
            //passwordElement.style.left = "-1000px"; // Position off-screen
            const chatElement = document.createElement("input");
            chatElement.type = "text";
            chatElement.style.position = "absolute";
            chatElement.style.left = "-1000px"; // Position off-screen
            //document.body.appendChild(usernameElement);
            //document.body.appendChild(passwordElement);
            document.body.appendChild(chatElement);
            document.addEventListener("click", () => {
                usernameElement.focus();
            }, { once: true });
            this.chat = [];
            this.chatTextBox = new textbox_1.TextBox(chatElement);
            this.chatTextBox.setEnterCallback(() => {
                if (this.chatTextBox.text.length > 0) {
                    this.chat.push(new ChatMessage(this.chatTextBox.text));
                    this.chatTextBox.clear();
                }
                else {
                    this.chatOpen = false;
                }
            });
            this.chatTextBox.setEscapeCallback(() => {
                this.chatOpen = false;
            });
            this.worldCodes = [];
            this.selectedWorldCode = 0;
            Game.shade_canvases = {};
            Game.text_rendering_canvases = {};
            let resourcesLoaded = 0;
            const NUM_RESOURCES = 6;
            Game.tileset = new Image();
            Game.tileset.onload = () => {
                resourcesLoaded++;
            };
            Game.tileset.src = "res/tileset.png";
            Game.objset = new Image();
            Game.objset.onload = () => {
                resourcesLoaded++;
            };
            Game.objset.src = "res/objset.png";
            Game.mobset = new Image();
            Game.mobset.onload = () => {
                resourcesLoaded++;
            };
            Game.mobset.src = "res/mobset.png";
            Game.itemset = new Image();
            Game.itemset.onload = () => {
                resourcesLoaded++;
            };
            Game.itemset.src = "res/itemset.png";
            Game.fxset = new Image();
            Game.fxset.onload = () => {
                resourcesLoaded++;
            };
            Game.fxset.src = "res/fxset.png";
            Game.fontsheet = new Image();
            Game.fontsheet.onload = () => {
                resourcesLoaded++;
            };
            Game.fontsheet.src = "res/font.png";
            this.levelState = LevelState.LEVEL_GENERATION;
            // Initialize camera properties
            this.cameraX = 0;
            this.cameraY = 0;
            this.cameraTargetX = 0;
            this.cameraTargetY = 0;
            let checkResourcesLoaded = () => {
                if (resourcesLoaded < NUM_RESOURCES) {
                    window.setTimeout(checkResourcesLoaded, 500);
                }
                else {
                    // proceed with constructor
                    Game.scale = gameConstants_1.GameConstants.SCALE;
                    document.addEventListener("touchstart", function (e) {
                        if (e.target == canvas) {
                            e.preventDefault();
                        }
                    }, false);
                    document.addEventListener("touchend", function (e) {
                        if (e.target == canvas) {
                            e.preventDefault();
                        }
                    }, false);
                    document.addEventListener("touchmove", function (e) {
                        if (e.target == canvas) {
                            e.preventDefault();
                        }
                    }, false);
                    document.addEventListener("touchstart", input_1.Input.handleTouchStart, {
                        passive: false,
                    });
                    document.addEventListener("touchmove", input_1.Input.handleTouchMove, {
                        passive: false,
                    });
                    document.addEventListener("touchend", input_1.Input.handleTouchEnd, {
                        passive: false,
                    });
                    input_1.Input.keyDownListener = (key) => {
                        this.keyDownListener(key);
                    };
                    window.requestAnimationFrame(this.run);
                    this.onResize();
                    window.addEventListener("resize", this.onResize);
                    window.addEventListener("orientationchange", () => {
                        // Small delay to ensure new dimensions are available
                        setTimeout(this.onResize, 100);
                    });
                    //Sound.playMusic(); // loops forever
                    this.players = {};
                    this.offlinePlayers = {};
                    this.chatOpen = false;
                    this.cameraAnimation = new cameraAnimation_1.CameraAnimation(0, 0, 1000, 1, 0, false);
                    this.screenShakeX = 0;
                    this.screenShakeY = 0;
                    this.shakeAmountX = 0;
                    this.shakeAmountY = 0;
                    this.shakeFrame = (3 * Math.PI) / 2;
                    this.screenShakeCutoff = 0;
                    this.tutorialActive = false;
                    this.screenShakeActive = false;
                    this.levels = [];
                    this.encounteredEnemies = [];
                    this.newGame();
                }
            };
            checkResourcesLoaded();
        });
        reverb_1.ReverbEngine.initialize();
        sound_1.Sound.loadSounds();
        this.started = false;
        this.tutorialListener = null;
        this.setupEventListeners();
        eventBus_1.globalEventBus.on(events_1.EVENTS.LEVEL_GENERATION_STARTED, () => {
            this.levelState = LevelState.LEVEL_GENERATION;
        });
        eventBus_1.globalEventBus.on(events_1.EVENTS.LEVEL_GENERATION_COMPLETED, () => {
            this.levelState = LevelState.IN_LEVEL;
        });
        // Add focus/blur event listeners
        //window.addEventListener("blur", this.handleWindowBlur);
        //window.addEventListener("focus", this.handleWindowFocus);
    }
    setupEventListeners() {
        //console.log("Setting up event listeners");
        eventBus_1.globalEventBus.on("ChatCommand", this.commandHandler.bind(this));
    }
    generateAndShowRoomLayout() {
        // Generate different patterns
        const patterns = [
            "center",
            "split",
            "corners",
        ];
        const pattern = patterns[Math.floor(random_1.Random.rand() * patterns.length)];
        // Generate level with random parameters
        const numRooms = 8 + Math.floor(random_1.Random.rand() * 12); // 8-20 rooms
        const width = 60 + Math.floor(random_1.Random.rand() * 40); // 60-100 width
        const height = 50 + Math.floor(random_1.Random.rand() * 30); // 50-80 height
        const generator = levelImageGenerator_1.LevelImageGenerator.generateRandomLevel(width, height, numRooms, random_1.Random.rand, pattern);
        // Check accessibility
        const accessible = generator.areRoomsAccessible();
        const accessibilityText = accessible
            ? "✓ All rooms accessible"
            : "✗ Some rooms inaccessible";
        // Store generator for drawing
        this.currentLevelGenerator = generator;
        this.pushMessage(`Generated ${numRooms} rooms (${pattern} pattern) - ${accessibilityText}`);
        this.pushMessage("Level layout shown on screen. Use '/cleargen' to clear.");
        // Save PNG with organized filename
        const timestamp = new Date()
            .toISOString()
            .slice(0, 19)
            .replace(/[T:]/g, "_");
        const filename = `${pattern}_${width}x${height}_${numRooms}rooms_${timestamp}.png`;
        generator.savePNG(filename);
        this.pushMessage(`PNG saved as: generated_levels/${filename}`);
        this.pushMessage("Check browser downloads or console for data URL");
        // Log detailed info for developers
        if (gameConstants_1.GameConstants.DEVELOPER_MODE) {
            console.log("Generated level details:", {
                pattern,
                dimensions: `${width}x${height}`,
                numRooms,
                accessible,
                rooms: generator.getRooms(),
            });
        }
    }
    destroy() {
        window.removeEventListener("blur", this.handleWindowBlur);
        window.removeEventListener("focus", this.handleWindowFocus);
        if (this.focusTimeout) {
            clearTimeout(this.focusTimeout);
        }
    }
}
exports.Game = Game;
Game.inputReceived = false;
Game.letters = "abcdefghijklmnopqrstuvwxyz1234567890,.!?:'()[]%-/";
Game.letter_widths = [
    4, 4, 4, 4, 3, 3, 4, 4, 1, 4, 4, 3, 5, 5, 4, 4, 4, 4, 4, 3, 4, 5, 5, 5, 5,
    3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 1, 1, 4, 1, 1, 2, 2, 2, 2, 5, 3, 3,
];
Game.letter_height = 6;
Game.letter_positions = [];
// [min, max] inclusive
Game.rand = (min, max, rand) => {
    if (max < min)
        return min;
    return Math.floor(rand() * (max - min + 1) + min);
};
Game.randTable = (table, rand) => {
    return table[Game.rand(0, table.length - 1, rand)];
};
Game.measureText = (text) => {
    let w = 0;
    for (const letter of text.toLowerCase()) {
        if (letter === " ")
            w += 4;
        else
            for (let i = 0; i < Game.letters.length; i++) {
                if (Game.letters[i] === letter) {
                    w += Game.letter_widths[i] + 1;
                }
            }
    }
    return { width: w, height: Game.letter_height };
};
Game.fillText = (text, x, y, maxWidth) => {
    x = Math.round(x);
    y = Math.round(y);
    if (Game.letter_positions.length === 0) {
        // calculate letter positions
        for (let i = 0; i < Game.letter_widths.length; i++) {
            if (i === 0)
                Game.letter_positions[0] = 0;
            else
                Game.letter_positions[i] =
                    Game.letter_positions[i - 1] + Game.letter_widths[i - 1] + 2;
        }
    }
    else {
        let dimensions = Game.measureText(text);
        if (dimensions.width > 0) {
            let key = text + Game.ctx.fillStyle;
            if (!Game.text_rendering_canvases[key]) {
                Game.text_rendering_canvases[key] = document.createElement("canvas");
                Game.text_rendering_canvases[key].width = dimensions.width;
                Game.text_rendering_canvases[key].height = dimensions.height;
                let bx = Game.text_rendering_canvases[key].getContext("2d");
                let letter_x = 0;
                for (const letter of text.toLowerCase()) {
                    if (letter === " ")
                        letter_x += 4;
                    else
                        for (let i = 0; i < Game.letters.length; i++) {
                            if (Game.letters[i] === letter) {
                                bx.drawImage(Game.fontsheet, Game.letter_positions[i] + 1, 0, Game.letter_widths[i], Game.letter_height, letter_x, 0, Game.letter_widths[i], Game.letter_height);
                                letter_x += Game.letter_widths[i] + 1;
                            }
                        }
                }
                bx.fillStyle = Game.ctx.fillStyle;
                bx.globalCompositeOperation = "source-in";
                bx.fillRect(0, 0, Game.text_rendering_canvases[key].width, Game.text_rendering_canvases[key].height);
                Game.ctx.drawImage(Game.text_rendering_canvases[key], x, y);
            }
            else {
                Game.ctx.drawImage(Game.text_rendering_canvases[key], x, y);
            }
        }
    }
};
Game.fillTextOutline = (text, x, y, outlineColor, fillColor) => {
    Game.ctx.fillStyle = outlineColor;
    for (let xx = -1; xx <= 1; xx++) {
        for (let yy = -1; yy <= 1; yy++) {
            Game.fillText(text, x + xx, y + yy);
        }
    }
    Game.ctx.fillStyle = fillColor;
    Game.fillText(text, x, y);
};
Game.drawHelper = (set, sX, sY, sW, sH, dX, dY, dW, dH, shadeColor = "black", shadeOpacity = 0, entity = false) => {
    Game.ctx.save(); // Save the current canvas state
    // Snap to nearest shading increment
    let divisor = entity ? 10 : 1;
    shadeOpacity =
        Math.round(shadeOpacity * Math.max(gameConstants_1.GameConstants.SHADE_LEVELS / divisor, 12)) / Math.max(gameConstants_1.GameConstants.SHADE_LEVELS / divisor, 12);
    // Include shadeColor in the cache key
    let key = getShadeCanvasKey(set, sX, sY, sW, sH, shadeOpacity, shadeColor);
    if (!Game.shade_canvases[key]) {
        Game.shade_canvases[key] = document.createElement("canvas");
        Game.shade_canvases[key].width = Math.round(sW * gameConstants_1.GameConstants.TILESIZE);
        Game.shade_canvases[key].height = Math.round(sH * gameConstants_1.GameConstants.TILESIZE);
        let shCtx = Game.shade_canvases[key].getContext("2d");
        shCtx.clearRect(0, 0, Game.shade_canvases[key].width, Game.shade_canvases[key].height);
        shCtx.globalCompositeOperation = "source-over";
        shCtx.drawImage(set, Math.round(sX * gameConstants_1.GameConstants.TILESIZE), Math.round(sY * gameConstants_1.GameConstants.TILESIZE), Math.round(sW * gameConstants_1.GameConstants.TILESIZE), Math.round(sH * gameConstants_1.GameConstants.TILESIZE), 0, 0, Math.round(sW * gameConstants_1.GameConstants.TILESIZE), Math.round(sH * gameConstants_1.GameConstants.TILESIZE));
        shCtx.globalAlpha = shadeOpacity;
        shCtx.fillStyle = shadeColor;
        shCtx.fillRect(0, 0, Game.shade_canvases[key].width, Game.shade_canvases[key].height);
        shCtx.globalAlpha = 1.0;
        shCtx.globalCompositeOperation = "destination-in";
        shCtx.drawImage(set, Math.round(sX * gameConstants_1.GameConstants.TILESIZE), Math.round(sY * gameConstants_1.GameConstants.TILESIZE), Math.round(sW * gameConstants_1.GameConstants.TILESIZE), Math.round(sH * gameConstants_1.GameConstants.TILESIZE), 0, 0, Math.round(sW * gameConstants_1.GameConstants.TILESIZE), Math.round(sH * gameConstants_1.GameConstants.TILESIZE));
    }
    Game.ctx.drawImage(Game.shade_canvases[key], Math.round(dX * gameConstants_1.GameConstants.TILESIZE), Math.round(dY * gameConstants_1.GameConstants.TILESIZE), Math.round(dW * gameConstants_1.GameConstants.TILESIZE), Math.round(dH * gameConstants_1.GameConstants.TILESIZE));
    Game.ctx.restore(); // Restore the canvas state
};
Game.drawTile = (sX, sY, sW, sH, dX, dY, dW, dH, shadeColor = "black", shadeOpacity = 0) => {
    Game.drawHelper(Game.tileset, sX, sY, sW, sH, dX, dY, dW, dH, shadeColor, shadeOpacity);
};
Game.drawObj = (sX, sY, sW, sH, dX, dY, dW, dH, shadeColor = "black", shadeOpacity = 0) => {
    Game.drawHelper(Game.objset, sX, sY, sW, sH, dX, dY, dW, dH, shadeColor, shadeOpacity, true);
};
Game.drawMob = (sX, sY, sW, sH, dX, dY, dW, dH, shadeColor = "black", shadeOpacity = 0) => {
    Game.drawHelper(Game.mobset, sX, sY, sW, sH, dX, dY, dW, dH, shadeColor, shadeOpacity, true);
};
Game.drawItem = (sX, sY, sW, sH, dX, dY, dW, dH, shadeColor = "black", shadeOpacity = 0) => {
    Game.drawHelper(Game.itemset, sX, sY, sW, sH, dX, dY, dW, dH, shadeColor, shadeOpacity, true);
};
Game.drawFX = (sX, sY, sW, sH, dX, dY, dW, dH, shadeColor = "black", shadeOpacity = 0) => {
    Game.drawHelper(Game.fxset, sX, sY, sW, sH, dX, dY, dW, dH, shadeColor, shadeOpacity, true);
};
exports.game = new Game();
exports.gs = new gameState_1.GameState();


/***/ }),

/***/ "./src/game/bestiary.ts":
/*!******************************!*\
  !*** ./src/game/bestiary.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Bestiary = void 0;
const game_1 = __webpack_require__(/*! ../game */ "./src/game.ts");
const levelConstants_1 = __webpack_require__(/*! ../level/levelConstants */ "./src/level/levelConstants.ts");
const gameConstants_1 = __webpack_require__(/*! ./gameConstants */ "./src/game/gameConstants.ts");
const crabEnemy_1 = __webpack_require__(/*! ../entity/enemy/crabEnemy */ "./src/entity/enemy/crabEnemy.ts");
const frogEnemy_1 = __webpack_require__(/*! ../entity/enemy/frogEnemy */ "./src/entity/enemy/frogEnemy.ts");
const zombieEnemy_1 = __webpack_require__(/*! ../entity/enemy/zombieEnemy */ "./src/entity/enemy/zombieEnemy.ts");
const skullEnemy_1 = __webpack_require__(/*! ../entity/enemy/skullEnemy */ "./src/entity/enemy/skullEnemy.ts");
const energyWizard_1 = __webpack_require__(/*! ../entity/enemy/energyWizard */ "./src/entity/enemy/energyWizard.ts");
const chargeEnemy_1 = __webpack_require__(/*! ../entity/enemy/chargeEnemy */ "./src/entity/enemy/chargeEnemy.ts");
const rookEnemy_1 = __webpack_require__(/*! ../entity/enemy/rookEnemy */ "./src/entity/enemy/rookEnemy.ts");
const bishopEnemy_1 = __webpack_require__(/*! ../entity/enemy/bishopEnemy */ "./src/entity/enemy/bishopEnemy.ts");
const armoredzombieEnemy_1 = __webpack_require__(/*! ../entity/enemy/armoredzombieEnemy */ "./src/entity/enemy/armoredzombieEnemy.ts");
const bigSkullEnemy_1 = __webpack_require__(/*! ../entity/enemy/bigSkullEnemy */ "./src/entity/enemy/bigSkullEnemy.ts");
const queenEnemy_1 = __webpack_require__(/*! ../entity/enemy/queenEnemy */ "./src/entity/enemy/queenEnemy.ts");
const knightEnemy_1 = __webpack_require__(/*! ../entity/enemy/knightEnemy */ "./src/entity/enemy/knightEnemy.ts");
const bigKnightEnemy_1 = __webpack_require__(/*! ../entity/enemy/bigKnightEnemy */ "./src/entity/enemy/bigKnightEnemy.ts");
const fireWizard_1 = __webpack_require__(/*! ../entity/enemy/fireWizard */ "./src/entity/enemy/fireWizard.ts");
const spawner_1 = __webpack_require__(/*! ../entity/enemy/spawner */ "./src/entity/enemy/spawner.ts");
const occultistEnemy_1 = __webpack_require__(/*! ../entity/enemy/occultistEnemy */ "./src/entity/enemy/occultistEnemy.ts");
//enemy typeof to class map
const enemyClassMap = {
    CrabEnemy: crabEnemy_1.CrabEnemy,
    FrogEnemy: frogEnemy_1.FrogEnemy,
    ZombieEnemy: zombieEnemy_1.ZombieEnemy,
    SkullEnemy: skullEnemy_1.SkullEnemy,
    EnergyWizardEnemy: energyWizard_1.EnergyWizardEnemy,
    ChargeEnemy: chargeEnemy_1.ChargeEnemy,
    RookEnemy: rookEnemy_1.RookEnemy,
    BishopEnemy: bishopEnemy_1.BishopEnemy,
    ArmoredzombieEnemy: armoredzombieEnemy_1.ArmoredzombieEnemy,
    BigSkullEnemy: bigSkullEnemy_1.BigSkullEnemy,
    QueenEnemy: queenEnemy_1.QueenEnemy,
    KnightEnemy: knightEnemy_1.KnightEnemy,
    BigKnightEnemy: bigKnightEnemy_1.BigKnightEnemy,
    FireWizardEnemy: fireWizard_1.FireWizardEnemy,
    Spawner: spawner_1.Spawner,
    OccultistEnemy: occultistEnemy_1.OccultistEnemy,
};
class Bestiary {
    constructor(game, player) {
        this.isOpen = false;
        this.openTime = Date.now();
        this.frame = 0;
        this.activeEntryIndex = 0;
        /**
         * Opens the logbook window.
         */
        this.open = () => {
            if (this.seenEnemies.size === 0)
                this.seenEnemies = this.game.tutorialListener.seenEnemies;
            this.isOpen = true;
            this.openTime = Date.now();
        };
        /**
         * Closes the logbook window.
         */
        this.close = () => {
            this.isOpen = false;
        };
        this.entryUp = () => {
            this.activeEntryIndex =
                (this.activeEntryIndex - 1 + this.entries.length) % this.entries.length;
        };
        this.entryDown = () => {
            this.activeEntryIndex = (this.activeEntryIndex + 1) % this.entries.length;
        };
        /**
         * Toggles the logbook window's open state.
         */
        this.toggleOpen = () => {
            this.isOpen ? this.close() : this.open();
        };
        /**
         * Adds a new entry to the logbook.
         * @param enemy The enemy to add.
         */
        this.addEntry = (enemy) => {
            const enemyClass = enemyClassMap[enemy.name];
            this.entries.push({
                name: enemy.name,
                description: enemyClass.prototype.description,
                tileX: enemyClass.prototype.tileX,
                tileY: enemyClass.prototype.tileY,
            });
        };
        /**
         * Draws the logbook interface.
         * @param delta The time delta since the last frame.
         */
        this.draw = (delta) => {
            if (!this.isOpen)
                return;
            game_1.Game.ctx.save();
            // Draw semi-transparent background
            game_1.Game.ctx.fillStyle = "rgba(0, 0, 0, 0.8)";
            game_1.Game.ctx.fillRect(0, 0, gameConstants_1.GameConstants.WIDTH, gameConstants_1.GameConstants.HEIGHT);
            // Define dimensions similar to Inventory
            const s = Math.min(18, (18 * (Date.now() - this.openTime)) / 100); // example scaling
            const b = 2; // border
            const g = -2; // gap
            const ob = 1; // outer border
            const width = 5 * (s + 2 * b + g) - g; // assuming 5 columns
            const height = 4 * (s + 2 * b + g) - g; // assuming 4 rows
            const startX = Math.round(0.5 * gameConstants_1.GameConstants.WIDTH - 0.5 * width) - ob;
            const startY = Math.round(0.5 * gameConstants_1.GameConstants.HEIGHT - 0.5 * height) - ob;
            // Draw main logbook background
            game_1.Game.ctx.fillStyle = "white";
            game_1.Game.ctx.fillRect(startX, startY, width + 2 * ob, height + 2 * ob);
            // Draw logbook entries
            game_1.Game.ctx.fillStyle = "black";
            const padding = 10;
            if (this.entries.length === 0) {
                game_1.Game.fillText("No enemies seen yet", startX + padding, startY + padding);
            }
            else {
                this.entries.forEach((entry, index) => {
                    game_1.Game.fillText(entry.name, startX + padding, startY + padding + index * 20);
                });
                this.drawEnemySprite(this.entries[this.activeEntryIndex].tileX, this.entries[this.activeEntryIndex].tileY, delta);
            }
            // Draw logbook button
            this.drawLogbookButton(delta);
            game_1.Game.ctx.restore();
        };
        this.drawEnemySprite = (tileX, tileY, delta) => {
            this.frame += Math.round(0.1 * delta * 10) / 10;
            if (this.frame >= 4)
                this.frame = 0;
            game_1.Game.drawMob(tileX, tileY, 1, 1, 1, 1, 1, 1, "Black", 0);
        };
        /**
         * Draws the logbook button on the screen.
         * @param delta The time delta since the last frame.
         */
        this.drawLogbookButton = (delta) => {
            game_1.Game.ctx.save();
            this.buttonX = levelConstants_1.LevelConstants.SCREEN_W - 2;
            this.buttonY = levelConstants_1.LevelConstants.SCREEN_H - 2.25;
            game_1.Game.drawFX(0, 0, 2, 2, this.buttonX, this.buttonY, 2, 2);
            game_1.Game.ctx.restore();
        };
        /**
         * Handles mouse down events.
         * @param x The x-coordinate of the mouse.
         * @param y The y-coordinate of the mouse.
         * @param button The mouse button pressed.
         */
        this.handleMouseDown = (x, y, button) => {
            if (button !== 0)
                return; // Only respond to left click
            if (this.isPointInLogbookButton(x, y)) {
                this.toggleOpen();
            }
        };
        /**
         * Handles mouse up events.
         * @param x The x-coordinate of the mouse.
         * @param y The y-coordinate of the mouse.
         * @param button The mouse button released.
         */
        this.handleMouseUp = (x, y, button) => {
            // Implement if needed
        };
        /**
         * Handles hold detection.
         */
        this.onHoldDetected = () => {
            // Implement if needed
        };
        /**
         * Checks if a point is within the logbook button bounds.
         * @param x The x-coordinate to check.
         * @param y The y-coordinate to check.
         * @returns True if the point is within the button bounds, else false.
         */
        this.isPointInLogbookButton = (x, y) => {
            const tX = x / gameConstants_1.GameConstants.TILESIZE;
            const tY = y / gameConstants_1.GameConstants.TILESIZE;
            return (tX >= this.buttonX &&
                tX <= this.buttonX + 2 &&
                tY >= this.buttonY &&
                tY <= this.buttonY + 2);
        };
        /**
         * Updates the logbook state each game tick.
         */
        this.tick = () => {
            if (this.isOpen) {
                // Update logbook-related logic here
            }
        };
        this.game = game;
        this.player = player;
        this.entries = [];
        this.activeEntryIndex = 0;
        this.buttonX = Math.round((Math.round(gameConstants_1.GameConstants.WIDTH / 2) + 3) / gameConstants_1.GameConstants.TILESIZE);
        this.buttonY = Math.round(10);
        this.seenEnemies = new Set();
    }
}
exports.Bestiary = Bestiary;


/***/ }),

/***/ "./src/game/cameraAnimation.ts":
/*!*************************************!*\
  !*** ./src/game/cameraAnimation.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CameraAnimation = void 0;
class CameraAnimation {
    constructor(x, y, duration, speed, frame, active) {
        this.x = x;
        this.y = y;
        this.duration = duration;
        this.speed = speed;
        this.frame = frame;
        this.active = active;
        this.x = x;
        this.y = y;
        this.speed = speed;
        this.frame = 0;
        this.active = false;
    }
}
exports.CameraAnimation = CameraAnimation;


/***/ }),

/***/ "./src/game/gameConstants.ts":
/*!***********************************!*\
  !*** ./src/game/gameConstants.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GameConstants = void 0;
const armor_1 = __webpack_require__(/*! ../item/armor */ "./src/item/armor.ts");
const backpack_1 = __webpack_require__(/*! ../item/backpack */ "./src/item/backpack.ts");
const candle_1 = __webpack_require__(/*! ../item/light/candle */ "./src/item/light/candle.ts");
const coal_1 = __webpack_require__(/*! ../item/resource/coal */ "./src/item/resource/coal.ts");
const godStone_1 = __webpack_require__(/*! ../item/godStone */ "./src/item/godStone.ts");
const lantern_1 = __webpack_require__(/*! ../item/light/lantern */ "./src/item/light/lantern.ts");
const levelConstants_1 = __webpack_require__(/*! ../level/levelConstants */ "./src/level/levelConstants.ts");
const dagger_1 = __webpack_require__(/*! ../item/weapon/dagger */ "./src/item/weapon/dagger.ts");
const spellbook_1 = __webpack_require__(/*! ../item/weapon/spellbook */ "./src/item/weapon/spellbook.ts");
const hammer_1 = __webpack_require__(/*! ../item/tool/hammer */ "./src/item/tool/hammer.ts");
const bluegem_1 = __webpack_require__(/*! ../item/resource/bluegem */ "./src/item/resource/bluegem.ts");
const redgem_1 = __webpack_require__(/*! ../item/resource/redgem */ "./src/item/resource/redgem.ts");
const greengem_1 = __webpack_require__(/*! ../item/resource/greengem */ "./src/item/resource/greengem.ts");
const pickaxe_1 = __webpack_require__(/*! ../item/tool/pickaxe */ "./src/item/tool/pickaxe.ts");
const scythe_1 = __webpack_require__(/*! ../item/weapon/scythe */ "./src/item/weapon/scythe.ts");
const gold_1 = __webpack_require__(/*! ../item/resource/gold */ "./src/item/resource/gold.ts");
const orangegem_1 = __webpack_require__(/*! ../item/resource/orangegem */ "./src/item/resource/orangegem.ts");
const goldRing_1 = __webpack_require__(/*! ../item/jewelry/goldRing */ "./src/item/jewelry/goldRing.ts");
const fishingRod_1 = __webpack_require__(/*! ../item/tool/fishingRod */ "./src/item/tool/fishingRod.ts");
class GameConstants {
}
exports.GameConstants = GameConstants;
GameConstants.VERSION = "v1.1.0"; //"v0.6.3";
GameConstants.DEVELOPER_MODE = false;
GameConstants.isMobile = false;
GameConstants.isIOS = false;
GameConstants.CAMERA_SPEED = 1; // 1 is instant 0.1 is slow
GameConstants.FPS = 120;
GameConstants.ALPHA_ENABLED = true;
GameConstants.SHADE_LEVELS = 50; //25
GameConstants.ENTITY_SHADE_LEVELS = 25; //10
GameConstants.TILESIZE = 16;
GameConstants.SCALE = null;
GameConstants.SOFT_SCALE = 6;
GameConstants.MAX_SCALE = 16;
GameConstants.MIN_SCALE = 1;
GameConstants.smoothScaling = false;
GameConstants.SWIPE_THRESH = 25 ** 2; // (size of swipe threshold circle)^2
GameConstants.HOLD_THRESH = 250; // milliseconds
GameConstants.KEY_REPEAT_TIME = 300; // millseconds
GameConstants.SWIPE_HOLD_REPEAT_TIME = 300;
GameConstants.SWIPE_HOLD_INITIAL_DELAY = 10;
GameConstants.MOVEMENT_COOLDOWN = 200; // milliseconds
GameConstants.MOVEMENT_QUEUE_COOLDOWN = 100; // milliseconds
GameConstants.MOVE_WITH_MOUSE = true;
GameConstants.SLOW_INPUTS_NEAR_ENEMIES = false;
GameConstants.CHAT_APPEAR_TIME = 2500;
GameConstants.CHAT_FADE_TIME = 500;
GameConstants.ANIMATION_SPEED = 1;
GameConstants.DEFAULTWIDTH = GameConstants.TILESIZE;
GameConstants.DEFAULTHEIGHT = GameConstants.TILESIZE;
GameConstants.WIDTH = levelConstants_1.LevelConstants.SCREEN_W * GameConstants.TILESIZE;
GameConstants.HEIGHT = levelConstants_1.LevelConstants.SCREEN_H * GameConstants.TILESIZE;
GameConstants.drawOtherRooms = true;
GameConstants.SCRIPT_FONT_SIZE = 16;
GameConstants.FONT_SIZE = 7;
GameConstants.BIG_FONT_SIZE = 15;
GameConstants.RED = "#ac3232";
GameConstants.WARNING_RED = "#ff0000";
GameConstants.GREEN = "#6abe30";
GameConstants.ARMOR_GREY = "#9badb7";
GameConstants.OUTLINE = "#222034";
GameConstants.HIT_ENEMY_TEXT_COLOR = "#76428a";
GameConstants.HEALTH_BUFF_COLOR = "#d77bba";
GameConstants.MISS_COLOR = "#639bff";
GameConstants.CUSTOM_SHADER_COLOR_ENABLED = false;
GameConstants.SHADE_ENABLED = true;
GameConstants.COLOR_LAYER_COMPOSITE_OPERATION = "soft-light"; //"soft-light";
GameConstants.SHADE_LAYER_COMPOSITE_OPERATION = "source-over"; //"soft-light";
GameConstants.USE_OPTIMIZED_SHADING = false;
GameConstants.SMOOTH_LIGHTING = false;
GameConstants.ctxBlurEnabled = true;
GameConstants.BLUR_ENABLED = true;
GameConstants.USE_WEBGL_BLUR = false;
GameConstants.HIGH_QUALITY_BLUR = false; // true = 49 samples, false = 13 samples for performance
GameConstants.BLUR_DOWNSAMPLE_FACTOR = 8; // Blur at 1/4 size for performance (1 = full size, 4 = quarter size)
GameConstants.ENEMIES_BLOCK_LIGHT = false;
GameConstants.USE_PNG_LEVELS = true;
GameConstants.SHADE_LAYER_COMPOSITE_OPERATIONS = [
    "source-over",
    "screen",
    "multiply",
    "overlay",
    "darken",
    "lighten",
];
GameConstants.COLOR_LAYER_COMPOSITE_OPERATIONS = [
    "soft-light",
    //"addition",
    //"darken",
    "overlay",
    //"hue",
    //"source-over",
    //"screen",
    "multiply",
    //"difference",
    //"exclusion",
    //"luminosity",
    //"color-dodge",
    //"color-burn",
    //"hard-light",
    //"soft-light",
    //"lighten",
];
GameConstants.SET_COLOR_LAYER_COMPOSITE_OPERATION = (back = false) => {
    const currentIndex = GameConstants.COLOR_LAYER_COMPOSITE_OPERATIONS.indexOf(GameConstants.COLOR_LAYER_COMPOSITE_OPERATION);
    let nextIndex;
    if (back) {
        // Decrement the index to move backward in the operations array
        nextIndex =
            (currentIndex -
                1 +
                GameConstants.COLOR_LAYER_COMPOSITE_OPERATIONS.length) %
                GameConstants.COLOR_LAYER_COMPOSITE_OPERATIONS.length;
    }
    else {
        // Increment the index to move forward in the operations array
        nextIndex =
            (currentIndex + 1) %
                GameConstants.COLOR_LAYER_COMPOSITE_OPERATIONS.length;
    }
    GameConstants.COLOR_LAYER_COMPOSITE_OPERATION =
        GameConstants.COLOR_LAYER_COMPOSITE_OPERATIONS[nextIndex];
    console.log(`Color layer composite operation set to ${GameConstants.COLOR_LAYER_COMPOSITE_OPERATION}`);
};
GameConstants.SET_SHADE_LAYER_COMPOSITE_OPERATION = (back = false) => {
    const currentIndex = GameConstants.SHADE_LAYER_COMPOSITE_OPERATIONS.indexOf(GameConstants.SHADE_LAYER_COMPOSITE_OPERATION);
    let nextIndex;
    if (back) {
        // Decrement the index to move backward in the operations array
        nextIndex =
            (currentIndex -
                1 +
                GameConstants.SHADE_LAYER_COMPOSITE_OPERATIONS.length) %
                GameConstants.SHADE_LAYER_COMPOSITE_OPERATIONS.length;
    }
    else {
        // Increment the index to move forward in the operations array
        nextIndex =
            (currentIndex + 1) %
                GameConstants.SHADE_LAYER_COMPOSITE_OPERATIONS.length;
    }
    GameConstants.SHADE_LAYER_COMPOSITE_OPERATION =
        GameConstants.SHADE_LAYER_COMPOSITE_OPERATIONS[nextIndex];
    console.log(`Shade layer composite operation set to ${GameConstants.SHADE_LAYER_COMPOSITE_OPERATION}`);
};
GameConstants.TOGGLE_USE_OPTIMIZED_SHADING = () => {
    GameConstants.USE_OPTIMIZED_SHADING = !GameConstants.USE_OPTIMIZED_SHADING;
};
GameConstants.TOGGLE_ENEMIES_BLOCK_LIGHT = () => {
    GameConstants.ENEMIES_BLOCK_LIGHT = !GameConstants.ENEMIES_BLOCK_LIGHT;
};
GameConstants.TOGGLE_USE_WEBGL_BLUR = () => {
    GameConstants.USE_WEBGL_BLUR = !GameConstants.USE_WEBGL_BLUR;
    console.log(`WebGL blur is now ${GameConstants.USE_WEBGL_BLUR ? "enabled" : "disabled"}`);
};
GameConstants.TOGGLE_HIGH_QUALITY_BLUR = () => {
    GameConstants.HIGH_QUALITY_BLUR = !GameConstants.HIGH_QUALITY_BLUR;
    console.log(`High quality blur: ${GameConstants.HIGH_QUALITY_BLUR ? "ON (49 samples)" : "OFF (13 samples)"}`);
};
GameConstants.SET_SCALE = () => {
    GameConstants.SCALE++;
    if (GameConstants.SCALE > GameConstants.MAX_SCALE) {
        GameConstants.SCALE = GameConstants.MAX_SCALE;
    }
};
GameConstants.INCREASE_SCALE = () => {
    if (GameConstants.SCALE < GameConstants.MAX_SCALE) {
        GameConstants.SCALE++;
        if (GameConstants.SCALE > GameConstants.MAX_SCALE) {
            GameConstants.SCALE = GameConstants.MAX_SCALE;
        }
    }
};
GameConstants.DECREASE_SCALE = () => {
    if (GameConstants.SCALE > GameConstants.MIN_SCALE) {
        GameConstants.SCALE--;
        if (GameConstants.SCALE < GameConstants.MIN_SCALE) {
            GameConstants.SCALE = GameConstants.MIN_SCALE;
        }
    }
};
GameConstants.FIND_SCALE = (isMobile) => {
    let bestScale = GameConstants.MIN_SCALE;
    let bestDifference = Infinity;
    const measure = !isMobile || screen.orientation.type === "landscape-primary"
        ? window.innerHeight
        : window.innerWidth;
    const dimension = measure * window.devicePixelRatio;
    const tileMeasure = isMobile ? 8 : 12;
    for (let i = GameConstants.MIN_SCALE; i <= GameConstants.MAX_SCALE; i++) {
        const tiles = dimension / (i * GameConstants.TILESIZE);
        const difference = Math.abs(tiles - tileMeasure);
        if (difference < bestDifference) {
            bestDifference = difference;
            bestScale = i;
        }
    }
    return bestScale;
};
GameConstants.STARTING_INVENTORY = [dagger_1.Dagger, candle_1.Candle];
GameConstants.STARTING_DEV_INVENTORY = [
    dagger_1.Dagger,
    candle_1.Candle,
    fishingRod_1.FishingRod,
    lantern_1.Lantern,
    godStone_1.GodStone,
    spellbook_1.Spellbook,
    scythe_1.Scythe,
    armor_1.Armor,
    backpack_1.Backpack,
    hammer_1.Hammer,
    pickaxe_1.Pickaxe,
    coal_1.Coal,
    bluegem_1.BlueGem,
    orangegem_1.OrangeGem,
    redgem_1.RedGem,
    greengem_1.GreenGem,
    goldRing_1.GoldRing,
    gold_1.Gold,
    gold_1.Gold,
    gold_1.Gold,
    gold_1.Gold,
    gold_1.Gold,
    gold_1.Gold,
    gold_1.Gold,
    gold_1.Gold,
    gold_1.Gold,
    gold_1.Gold,
    gold_1.Gold,
    gold_1.Gold,
];


/***/ }),

/***/ "./src/game/gameState.ts":
/*!*******************************!*\
  !*** ./src/game/gameState.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.loadGameState = exports.createGameState = exports.GameState = exports.LevelState = exports.PlayerState = exports.InventoryState = exports.ItemState = exports.ItemType = exports.RoomState = exports.EnemyState = exports.EnemyType = exports.ProjectileState = exports.ProjectileType = exports.HitWarningState = void 0;
const barrel_1 = __webpack_require__(/*! ../entity/object/barrel */ "./src/entity/object/barrel.ts");
const bigSkullEnemy_1 = __webpack_require__(/*! ../entity/enemy/bigSkullEnemy */ "./src/entity/enemy/bigSkullEnemy.ts");
const chargeEnemy_1 = __webpack_require__(/*! ../entity/enemy/chargeEnemy */ "./src/entity/enemy/chargeEnemy.ts");
const chest_1 = __webpack_require__(/*! ../entity/object/chest */ "./src/entity/object/chest.ts");
const coalResource_1 = __webpack_require__(/*! ../entity/resource/coalResource */ "./src/entity/resource/coalResource.ts");
const crate_1 = __webpack_require__(/*! ../entity/object/crate */ "./src/entity/object/crate.ts");
const emeraldResource_1 = __webpack_require__(/*! ../entity/resource/emeraldResource */ "./src/entity/resource/emeraldResource.ts");
const goldResource_1 = __webpack_require__(/*! ../entity/resource/goldResource */ "./src/entity/resource/goldResource.ts");
const knightEnemy_1 = __webpack_require__(/*! ../entity/enemy/knightEnemy */ "./src/entity/enemy/knightEnemy.ts");
const pottedPlant_1 = __webpack_require__(/*! ../entity/object/pottedPlant */ "./src/entity/object/pottedPlant.ts");
const pot_1 = __webpack_require__(/*! ../entity/object/pot */ "./src/entity/object/pot.ts");
const skullEnemy_1 = __webpack_require__(/*! ../entity/enemy/skullEnemy */ "./src/entity/enemy/skullEnemy.ts");
const crabEnemy_1 = __webpack_require__(/*! ../entity/enemy/crabEnemy */ "./src/entity/enemy/crabEnemy.ts");
const spawner_1 = __webpack_require__(/*! ../entity/enemy/spawner */ "./src/entity/enemy/spawner.ts");
const vendingMachine_1 = __webpack_require__(/*! ../entity/object/vendingMachine */ "./src/entity/object/vendingMachine.ts");
const wizardEnemy_1 = __webpack_require__(/*! ../entity/enemy/wizardEnemy */ "./src/entity/enemy/wizardEnemy.ts");
const zombieEnemy_1 = __webpack_require__(/*! ../entity/enemy/zombieEnemy */ "./src/entity/enemy/zombieEnemy.ts");
const hitWarning_1 = __webpack_require__(/*! ../drawable/hitWarning */ "./src/drawable/hitWarning.ts");
const armor_1 = __webpack_require__(/*! ../item/armor */ "./src/item/armor.ts");
const bluegem_1 = __webpack_require__(/*! ../item/resource/bluegem */ "./src/item/resource/bluegem.ts");
const candle_1 = __webpack_require__(/*! ../item/light/candle */ "./src/item/light/candle.ts");
const coal_1 = __webpack_require__(/*! ../item/resource/coal */ "./src/item/resource/coal.ts");
const coin_1 = __webpack_require__(/*! ../item/coin */ "./src/item/coin.ts");
const equippable_1 = __webpack_require__(/*! ../item/equippable */ "./src/item/equippable.ts");
const gold_1 = __webpack_require__(/*! ../item/resource/gold */ "./src/item/resource/gold.ts");
const goldenKey_1 = __webpack_require__(/*! ../item/goldenKey */ "./src/item/goldenKey.ts");
const greengem_1 = __webpack_require__(/*! ../item/resource/greengem */ "./src/item/resource/greengem.ts");
const heart_1 = __webpack_require__(/*! ../item/usable/heart */ "./src/item/usable/heart.ts");
const key_1 = __webpack_require__(/*! ../item/key */ "./src/item/key.ts");
const lantern_1 = __webpack_require__(/*! ../item/light/lantern */ "./src/item/light/lantern.ts");
const redgem_1 = __webpack_require__(/*! ../item/resource/redgem */ "./src/item/resource/redgem.ts");
const torch_1 = __webpack_require__(/*! ../item/light/torch */ "./src/item/light/torch.ts");
const levelGenerator_1 = __webpack_require__(/*! ../level/levelGenerator */ "./src/level/levelGenerator.ts");
const player_1 = __webpack_require__(/*! ../player/player */ "./src/player/player.ts");
const enemySpawnAnimation_1 = __webpack_require__(/*! ../projectile/enemySpawnAnimation */ "./src/projectile/enemySpawnAnimation.ts");
const wizardFireball_1 = __webpack_require__(/*! ../projectile/wizardFireball */ "./src/projectile/wizardFireball.ts");
const random_1 = __webpack_require__(/*! ../utility/random */ "./src/utility/random.ts");
const dagger_1 = __webpack_require__(/*! ../item/weapon/dagger */ "./src/item/weapon/dagger.ts");
const dualdagger_1 = __webpack_require__(/*! ../item/weapon/dualdagger */ "./src/item/weapon/dualdagger.ts");
const shotgun_1 = __webpack_require__(/*! ../item/weapon/shotgun */ "./src/item/weapon/shotgun.ts");
const spear_1 = __webpack_require__(/*! ../item/weapon/spear */ "./src/item/weapon/spear.ts");
const pickaxe_1 = __webpack_require__(/*! ../item/tool/pickaxe */ "./src/item/tool/pickaxe.ts");
const backpack_1 = __webpack_require__(/*! ../item/backpack */ "./src/item/backpack.ts");
const pumpkin_1 = __webpack_require__(/*! ../entity/object/pumpkin */ "./src/entity/object/pumpkin.ts");
const block_1 = __webpack_require__(/*! ../entity/object/block */ "./src/entity/object/block.ts");
const energyWizard_1 = __webpack_require__(/*! ../entity/enemy/energyWizard */ "./src/entity/enemy/energyWizard.ts");
const level_1 = __webpack_require__(/*! ../level/level */ "./src/level/level.ts");
const eventBus_1 = __webpack_require__(/*! ../event/eventBus */ "./src/event/eventBus.ts");
const events_1 = __webpack_require__(/*! ../event/events */ "./src/event/events.ts");
const armoredSkullEnemy_1 = __webpack_require__(/*! ../entity/enemy/armoredSkullEnemy */ "./src/entity/enemy/armoredSkullEnemy.ts");
const armoredzombieEnemy_1 = __webpack_require__(/*! ../entity/enemy/armoredzombieEnemy */ "./src/entity/enemy/armoredzombieEnemy.ts");
const bigKnightEnemy_1 = __webpack_require__(/*! ../entity/enemy/bigKnightEnemy */ "./src/entity/enemy/bigKnightEnemy.ts");
const bigZombieEnemy_1 = __webpack_require__(/*! ../entity/enemy/bigZombieEnemy */ "./src/entity/enemy/bigZombieEnemy.ts");
const bishopEnemy_1 = __webpack_require__(/*! ../entity/enemy/bishopEnemy */ "./src/entity/enemy/bishopEnemy.ts");
const fireWizard_1 = __webpack_require__(/*! ../entity/enemy/fireWizard */ "./src/entity/enemy/fireWizard.ts");
const frogEnemy_1 = __webpack_require__(/*! ../entity/enemy/frogEnemy */ "./src/entity/enemy/frogEnemy.ts");
const glowBugEnemy_1 = __webpack_require__(/*! ../entity/enemy/glowBugEnemy */ "./src/entity/enemy/glowBugEnemy.ts");
const mummyEnemy_1 = __webpack_require__(/*! ../entity/enemy/mummyEnemy */ "./src/entity/enemy/mummyEnemy.ts");
const occultistEnemy_1 = __webpack_require__(/*! ../entity/enemy/occultistEnemy */ "./src/entity/enemy/occultistEnemy.ts");
const queenEnemy_1 = __webpack_require__(/*! ../entity/enemy/queenEnemy */ "./src/entity/enemy/queenEnemy.ts");
const rookEnemy_1 = __webpack_require__(/*! ../entity/enemy/rookEnemy */ "./src/entity/enemy/rookEnemy.ts");
const spiderEnemy_1 = __webpack_require__(/*! ../entity/enemy/spiderEnemy */ "./src/entity/enemy/spiderEnemy.ts");
const apple_1 = __webpack_require__(/*! ../item/usable/apple */ "./src/item/usable/apple.ts");
const bestiaryBook_1 = __webpack_require__(/*! ../item/bestiaryBook */ "./src/item/bestiaryBook.ts");
const bombItem_1 = __webpack_require__(/*! ../item/bombItem */ "./src/item/bombItem.ts");
const entitySpawner_1 = __webpack_require__(/*! ../item/entitySpawner */ "./src/item/entitySpawner.ts");
const fish_1 = __webpack_require__(/*! ../item/usable/fish */ "./src/item/usable/fish.ts");
const fishingRod_1 = __webpack_require__(/*! ../item/tool/fishingRod */ "./src/item/tool/fishingRod.ts");
const geode_1 = __webpack_require__(/*! ../item/resource/geode */ "./src/item/resource/geode.ts");
const glowBugs_1 = __webpack_require__(/*! ../item/light/glowBugs */ "./src/item/light/glowBugs.ts");
const godStone_1 = __webpack_require__(/*! ../item/godStone */ "./src/item/godStone.ts");
const goldBar_1 = __webpack_require__(/*! ../item/resource/goldBar */ "./src/item/resource/goldBar.ts");
const goldRing_1 = __webpack_require__(/*! ../item/jewelry/goldRing */ "./src/item/jewelry/goldRing.ts");
const garnetRing_1 = __webpack_require__(/*! ../item/jewelry/garnetRing */ "./src/item/jewelry/garnetRing.ts");
const zirconRing_1 = __webpack_require__(/*! ../item/jewelry/zirconRing */ "./src/item/jewelry/zirconRing.ts");
const emeraldRing_1 = __webpack_require__(/*! ../item/jewelry/emeraldRing */ "./src/item/jewelry/emeraldRing.ts");
const amberRing_1 = __webpack_require__(/*! ../item/jewelry/amberRing */ "./src/item/jewelry/amberRing.ts");
const greenPotion_1 = __webpack_require__(/*! ../item/usable/greenPotion */ "./src/item/usable/greenPotion.ts");
const greataxe_1 = __webpack_require__(/*! ../item/weapon/greataxe */ "./src/item/weapon/greataxe.ts");
const hourglass_1 = __webpack_require__(/*! ../item/usable/hourglass */ "./src/item/usable/hourglass.ts");
const orangegem_1 = __webpack_require__(/*! ../item/resource/orangegem */ "./src/item/resource/orangegem.ts");
const scythe_1 = __webpack_require__(/*! ../item/weapon/scythe */ "./src/item/weapon/scythe.ts");
const scytheHandle_1 = __webpack_require__(/*! ../item/weapon/scytheHandle */ "./src/item/weapon/scytheHandle.ts");
const scytheBlade_1 = __webpack_require__(/*! ../item/weapon/scytheBlade */ "./src/item/weapon/scytheBlade.ts");
const shrooms_1 = __webpack_require__(/*! ../item/usable/shrooms */ "./src/item/usable/shrooms.ts");
const slingshot_1 = __webpack_require__(/*! ../item/weapon/slingshot */ "./src/item/weapon/slingshot.ts");
const spellbook_1 = __webpack_require__(/*! ../item/weapon/spellbook */ "./src/item/weapon/spellbook.ts");
const spellbookPage_1 = __webpack_require__(/*! ../item/usable/spellbookPage */ "./src/item/usable/spellbookPage.ts");
const stone_1 = __webpack_require__(/*! ../item/resource/stone */ "./src/item/resource/stone.ts");
const sword_1 = __webpack_require__(/*! ../item/weapon/sword */ "./src/item/weapon/sword.ts");
const warhammer_1 = __webpack_require__(/*! ../item/weapon/warhammer */ "./src/item/weapon/warhammer.ts");
const weaponBlood_1 = __webpack_require__(/*! ../item/usable/weaponBlood */ "./src/item/usable/weaponBlood.ts");
const weaponPoison_1 = __webpack_require__(/*! ../item/usable/weaponPoison */ "./src/item/usable/weaponPoison.ts");
const weaponFragments_1 = __webpack_require__(/*! ../item/usable/weaponFragments */ "./src/item/usable/weaponFragments.ts");
const bluePotion_1 = __webpack_require__(/*! ../item/usable/bluePotion */ "./src/item/usable/bluePotion.ts");
const bush_1 = __webpack_require__(/*! ../entity/object/bush */ "./src/entity/object/bush.ts");
const fishingSpot_1 = __webpack_require__(/*! ../entity/object/fishingSpot */ "./src/entity/object/fishingSpot.ts");
const furnace_1 = __webpack_require__(/*! ../entity/object/furnace */ "./src/entity/object/furnace.ts");
const sprout_1 = __webpack_require__(/*! ../entity/object/sprout */ "./src/entity/object/sprout.ts");
const tombStone_1 = __webpack_require__(/*! ../entity/object/tombStone */ "./src/entity/object/tombStone.ts");
const decoBlock_1 = __webpack_require__(/*! ../entity/object/decoBlock */ "./src/entity/object/decoBlock.ts");
const tree_1 = __webpack_require__(/*! ../entity/object/tree */ "./src/entity/object/tree.ts");
const chestLayer_1 = __webpack_require__(/*! ../entity/object/chestLayer */ "./src/entity/object/chestLayer.ts");
const bomb_1 = __webpack_require__(/*! ../entity/object/bomb */ "./src/entity/object/bomb.ts");
const downladderMaker_1 = __webpack_require__(/*! ../entity/downladderMaker */ "./src/entity/downladderMaker.ts");
const rockResource_1 = __webpack_require__(/*! ../entity/resource/rockResource */ "./src/entity/resource/rockResource.ts");
const hammer_1 = __webpack_require__(/*! ../item/tool/hammer */ "./src/item/tool/hammer.ts");
const environmentTypes_1 = __webpack_require__(/*! ../constants/environmentTypes */ "./src/constants/environmentTypes.ts");
class HitWarningState {
    constructor(hw) {
        this.x = hw.x;
        this.y = hw.y;
        this.dead = hw.dead;
    }
}
exports.HitWarningState = HitWarningState;
let loadHitWarning = (hws, game) => {
    let hw = new hitWarning_1.HitWarning(game, hws.x, hws.y, hws.x, hws.y);
    hw.dead = hws.dead;
    return hw;
};
var ProjectileType;
(function (ProjectileType) {
    ProjectileType[ProjectileType["SPAWN"] = 0] = "SPAWN";
    ProjectileType[ProjectileType["WIZARD"] = 1] = "WIZARD";
})(ProjectileType = exports.ProjectileType || (exports.ProjectileType = {}));
class ProjectileState {
    constructor(projectile, game) {
        this.x = projectile.x;
        this.y = projectile.y;
        this.dead = projectile.dead;
        if (projectile instanceof enemySpawnAnimation_1.EnemySpawnAnimation) {
            this.type = ProjectileType.SPAWN;
            this.roomID = game.rooms.indexOf(projectile.room);
            this.enemySpawn = new EnemyState(projectile.enemy, game);
        }
        if (projectile instanceof wizardFireball_1.WizardFireball) {
            this.type = ProjectileType.WIZARD;
            this.wizardState = projectile.state;
            this.roomID = game.rooms.indexOf(projectile.parent.room);
            this.wizardParentID = projectile.parent.room.entities.indexOf(projectile.parent);
        }
    }
}
exports.ProjectileState = ProjectileState;
let loadProjectile = (ps, game) => {
    if (ps.type === ProjectileType.SPAWN) {
        let room = game.rooms[ps.roomID];
        let enemy = loadEnemy(ps.enemySpawn, game);
        let p = new enemySpawnAnimation_1.EnemySpawnAnimation(room, enemy, ps.x, ps.y);
        p.dead = ps.dead;
        return p;
    }
    if (ps.type === ProjectileType.WIZARD) {
        let wizard = game.rooms[ps.roomID].entities[ps.wizardParentID];
        let p = new wizardFireball_1.WizardFireball(wizard, ps.x, ps.y);
        p.state = ps.wizardState;
        return p;
    }
};
var EnemyType;
(function (EnemyType) {
    EnemyType[EnemyType["BARREL"] = 0] = "BARREL";
    EnemyType[EnemyType["BIGSKULL"] = 1] = "BIGSKULL";
    EnemyType[EnemyType["CHARGE"] = 2] = "CHARGE";
    EnemyType[EnemyType["CHEST"] = 3] = "CHEST";
    EnemyType[EnemyType["COAL"] = 4] = "COAL";
    EnemyType[EnemyType["CRATE"] = 5] = "CRATE";
    EnemyType[EnemyType["EMERALD"] = 6] = "EMERALD";
    EnemyType[EnemyType["GOLD"] = 7] = "GOLD";
    EnemyType[EnemyType["KNIGHT"] = 8] = "KNIGHT";
    EnemyType[EnemyType["PLANT"] = 9] = "PLANT";
    EnemyType[EnemyType["POT"] = 10] = "POT";
    EnemyType[EnemyType["SKULL"] = 11] = "SKULL";
    EnemyType[EnemyType["CRAB"] = 12] = "CRAB";
    EnemyType[EnemyType["SPAWNER"] = 13] = "SPAWNER";
    EnemyType[EnemyType["VENDINGMACHINE"] = 14] = "VENDINGMACHINE";
    EnemyType[EnemyType["WIZARD"] = 15] = "WIZARD";
    EnemyType[EnemyType["ZOMBIE"] = 16] = "ZOMBIE";
    EnemyType[EnemyType["ARMOREDSKULL"] = 17] = "ARMOREDSKULL";
    EnemyType[EnemyType["ARMOREDZOMBIE"] = 18] = "ARMOREDZOMBIE";
    EnemyType[EnemyType["BIGKNIGHT"] = 19] = "BIGKNIGHT";
    EnemyType[EnemyType["BIGZOMBIE"] = 20] = "BIGZOMBIE";
    EnemyType[EnemyType["BISHOP"] = 21] = "BISHOP";
    EnemyType[EnemyType["ENERGYWIZARD"] = 22] = "ENERGYWIZARD";
    EnemyType[EnemyType["FIREWIZARD"] = 23] = "FIREWIZARD";
    EnemyType[EnemyType["FROG"] = 24] = "FROG";
    EnemyType[EnemyType["GLOWBUG"] = 25] = "GLOWBUG";
    EnemyType[EnemyType["MUMMY"] = 26] = "MUMMY";
    EnemyType[EnemyType["OCCULTIST"] = 27] = "OCCULTIST";
    EnemyType[EnemyType["QUEEN"] = 28] = "QUEEN";
    EnemyType[EnemyType["ROOK"] = 29] = "ROOK";
    EnemyType[EnemyType["SPIDER"] = 30] = "SPIDER";
    EnemyType[EnemyType["BUSH"] = 31] = "BUSH";
    EnemyType[EnemyType["FISHING_SPOT"] = 32] = "FISHING_SPOT";
    EnemyType[EnemyType["FURNACE"] = 33] = "FURNACE";
    EnemyType[EnemyType["PUMPKIN"] = 34] = "PUMPKIN";
    EnemyType[EnemyType["SPROUT"] = 35] = "SPROUT";
    EnemyType[EnemyType["TOMBSTONE"] = 36] = "TOMBSTONE";
    EnemyType[EnemyType["DECO_BLOCK"] = 37] = "DECO_BLOCK";
    EnemyType[EnemyType["TREE"] = 38] = "TREE";
    EnemyType[EnemyType["CHEST_LAYER"] = 39] = "CHEST_LAYER";
    EnemyType[EnemyType["BOMB"] = 40] = "BOMB";
    EnemyType[EnemyType["BLOCK"] = 41] = "BLOCK";
    EnemyType[EnemyType["DOWNLADDER_MAKER"] = 42] = "DOWNLADDER_MAKER";
    EnemyType[EnemyType["ROCK"] = 43] = "ROCK";
})(EnemyType = exports.EnemyType || (exports.EnemyType = {}));
class EnemyState {
    constructor(enemy, game) {
        this.roomID = game.rooms.indexOf(enemy.room);
        this.x = enemy.x;
        this.y = enemy.y;
        this.health = enemy.health;
        this.maxHealth = enemy.maxHealth;
        this.unconscious = enemy.unconscious;
        this.direction = enemy.direction;
        this.dead = enemy.dead;
        this.skipNextTurns = enemy.skipNextTurns;
        this.hasDrop = false;
        if (enemy.drop) {
            this.hasDrop = true;
            this.drop = new ItemState(enemy.drop, game);
        }
        this.alertTicks = enemy.alertTicks;
        if (enemy instanceof barrel_1.Barrel)
            this.type = EnemyType.BARREL;
        if (enemy instanceof bigSkullEnemy_1.BigSkullEnemy) {
            this.type = EnemyType.BIGSKULL;
            this.ticks = enemy.ticks;
            this.ticksSinceFirstHit = enemy.ticksSinceFirstHit;
            this.seenPlayer = enemy.seenPlayer;
            if (enemy.seenPlayer) {
                this.targetPlayerID = Object.keys(game.players).find((key) => game.players[key] === enemy.targetPlayer);
                if (!this.targetPlayerID)
                    this.targetPlayerID = Object.keys(game.offlinePlayers).find((key) => game.offlinePlayers[key] === enemy.targetPlayer);
            }
            this.drops = [];
            for (const d of enemy.drops) {
                if (d) {
                    this.drops.push(new ItemState(d, game));
                }
            }
        }
        if (enemy instanceof chargeEnemy_1.ChargeEnemy) {
            this.type = EnemyType.CHARGE;
            this.ticks = enemy.ticks;
            this.chargeEnemyState = enemy.state;
            this.startX = enemy.startX;
            this.startY = enemy.startY;
            this.targetX = enemy.targetX;
            this.targetY = enemy.targetY;
            this.visualTargetX = enemy.visualTargetX;
            this.visualTargetY = enemy.visualTargetY;
        }
        if (enemy instanceof chest_1.Chest)
            this.type = EnemyType.CHEST;
        if (enemy instanceof coalResource_1.CoalResource)
            this.type = EnemyType.COAL;
        if (enemy instanceof crate_1.Crate)
            this.type = EnemyType.CRATE;
        if (enemy instanceof emeraldResource_1.EmeraldResource)
            this.type = EnemyType.EMERALD;
        if (enemy instanceof goldResource_1.GoldResource)
            this.type = EnemyType.GOLD;
        if (enemy instanceof knightEnemy_1.KnightEnemy) {
            this.type = EnemyType.KNIGHT;
            this.ticks = enemy.ticks;
            this.seenPlayer = enemy.seenPlayer;
            if (enemy.seenPlayer) {
                this.targetPlayerID = Object.keys(game.players).find((key) => game.players[key] === enemy.targetPlayer);
                if (!this.targetPlayerID)
                    this.targetPlayerID = Object.keys(game.offlinePlayers).find((key) => game.offlinePlayers[key] === enemy.targetPlayer);
            }
        }
        if (enemy instanceof pottedPlant_1.PottedPlant)
            this.type = EnemyType.PLANT;
        if (enemy instanceof pot_1.Pot)
            this.type = EnemyType.POT;
        if (enemy instanceof skullEnemy_1.SkullEnemy) {
            this.type = EnemyType.SKULL;
            this.ticks = enemy.ticks;
            this.ticksSinceFirstHit = enemy.ticksSinceFirstHit;
            this.seenPlayer = enemy.seenPlayer;
            if (enemy.seenPlayer) {
                this.targetPlayerID = Object.keys(game.players).find((key) => game.players[key] === enemy.targetPlayer);
                if (!this.targetPlayerID)
                    this.targetPlayerID = Object.keys(game.offlinePlayers).find((key) => game.offlinePlayers[key] === enemy.targetPlayer);
            }
        }
        if (enemy instanceof crabEnemy_1.CrabEnemy) {
            this.type = EnemyType.CRAB;
            this.ticks = enemy.ticks;
            this.seenPlayer = enemy.seenPlayer;
            if (enemy.seenPlayer) {
                this.targetPlayerID = Object.keys(game.players).find((key) => game.players[key] === enemy.targetPlayer);
                if (!this.targetPlayerID)
                    this.targetPlayerID = Object.keys(game.offlinePlayers).find((key) => game.offlinePlayers[key] === enemy.targetPlayer);
            }
        }
        if (enemy instanceof spawner_1.Spawner) {
            this.type = EnemyType.SPAWNER;
            this.ticks = enemy.ticks;
            this.seenPlayer = enemy.seenPlayer;
            this.enemySpawnType = enemy.enemySpawnType;
        }
        if (enemy instanceof vendingMachine_1.VendingMachine) {
            this.type = EnemyType.VENDINGMACHINE;
            this.isPlayerOpened = false;
            if (enemy.playerOpened) {
                this.isPlayerOpened = true;
                this.playerOpenedID = Object.keys(game.players).find((key) => game.players[key] === enemy.playerOpened);
                if (!this.playerOpenedID)
                    this.playerOpenedID = Object.keys(game.offlinePlayers).find((key) => game.offlinePlayers[key] === enemy.playerOpened);
            }
            this.open = enemy.open;
            this.costItems = [];
            for (const item of enemy.costItems) {
                if (item) {
                    this.costItems.push(new ItemState(item, game));
                }
            }
            if (enemy.item) {
                this.item = new ItemState(enemy.item, game);
            }
            this.isInf = enemy.isInf;
            this.quantity = enemy.quantity;
        }
        if (enemy instanceof wizardEnemy_1.WizardEnemy) {
            this.type = EnemyType.WIZARD;
            this.ticks = enemy.ticks;
            this.wizardState = enemy.state;
            this.seenPlayer = enemy.seenPlayer;
        }
        if (enemy instanceof zombieEnemy_1.ZombieEnemy) {
            this.type = EnemyType.ZOMBIE;
            this.ticks = enemy.ticks;
            this.seenPlayer = enemy.seenPlayer;
            if (enemy.seenPlayer) {
                this.targetPlayerID = Object.keys(game.players).find((key) => game.players[key] === enemy.targetPlayer);
                if (!this.targetPlayerID)
                    this.targetPlayerID = Object.keys(game.offlinePlayers).find((key) => game.offlinePlayers[key] === enemy.targetPlayer);
            }
        }
        if (enemy instanceof armoredSkullEnemy_1.ArmoredSkullEnemy)
            this.type = EnemyType.ARMOREDSKULL;
        if (enemy instanceof armoredzombieEnemy_1.ArmoredzombieEnemy)
            this.type = EnemyType.ARMOREDZOMBIE;
        if (enemy instanceof bigKnightEnemy_1.BigKnightEnemy)
            this.type = EnemyType.BIGKNIGHT;
        if (enemy instanceof bigZombieEnemy_1.BigZombieEnemy)
            this.type = EnemyType.BIGZOMBIE;
        if (enemy instanceof bishopEnemy_1.BishopEnemy)
            this.type = EnemyType.BISHOP;
        if (enemy instanceof energyWizard_1.EnergyWizardEnemy)
            this.type = EnemyType.ENERGYWIZARD;
        if (enemy instanceof fireWizard_1.FireWizardEnemy)
            this.type = EnemyType.FIREWIZARD;
        if (enemy instanceof frogEnemy_1.FrogEnemy)
            this.type = EnemyType.FROG;
        if (enemy instanceof glowBugEnemy_1.GlowBugEnemy)
            this.type = EnemyType.GLOWBUG;
        if (enemy instanceof mummyEnemy_1.MummyEnemy)
            this.type = EnemyType.MUMMY;
        if (enemy instanceof occultistEnemy_1.OccultistEnemy)
            this.type = EnemyType.OCCULTIST;
        if (enemy instanceof queenEnemy_1.QueenEnemy)
            this.type = EnemyType.QUEEN;
        if (enemy instanceof rookEnemy_1.RookEnemy)
            this.type = EnemyType.ROOK;
        if (enemy instanceof spiderEnemy_1.SpiderEnemy)
            this.type = EnemyType.SPIDER;
        if (enemy instanceof bush_1.Bush)
            this.type = EnemyType.BUSH;
        if (enemy instanceof fishingSpot_1.FishingSpot)
            this.type = EnemyType.FISHING_SPOT;
        if (enemy instanceof furnace_1.Furnace)
            this.type = EnemyType.FURNACE;
        if (enemy instanceof pumpkin_1.Pumpkin)
            this.type = EnemyType.PUMPKIN;
        if (enemy instanceof sprout_1.Sprout)
            this.type = EnemyType.SPROUT;
        if (enemy instanceof tombStone_1.TombStone)
            this.type = EnemyType.TOMBSTONE;
        if (enemy instanceof decoBlock_1.DecoBlock)
            this.type = EnemyType.DECO_BLOCK;
        if (enemy instanceof tree_1.Tree)
            this.type = EnemyType.TREE;
        if (enemy instanceof chestLayer_1.ChestLayer)
            this.type = EnemyType.CHEST_LAYER;
        if (enemy instanceof bomb_1.Bomb)
            this.type = EnemyType.BOMB;
        if (enemy instanceof block_1.Block)
            this.type = EnemyType.BLOCK;
        if (enemy instanceof downladderMaker_1.DownladderMaker)
            this.type = EnemyType.DOWNLADDER_MAKER;
        if (enemy instanceof rockResource_1.Rock)
            this.type = EnemyType.ROCK;
    }
}
exports.EnemyState = EnemyState;
let loadEnemy = (es, game) => {
    let enemy;
    let room = game.rooms[es.roomID];
    if (es.type === EnemyType.BARREL)
        enemy = new barrel_1.Barrel(room, game, es.x, es.y);
    if (es.type === EnemyType.BIGSKULL) {
        enemy = new bigSkullEnemy_1.BigSkullEnemy(room, game, es.x, es.y);
        enemy.ticks = es.ticks;
        enemy.ticksSinceFirstHit = es.ticksSinceFirstHit;
        enemy.seenPlayer = es.seenPlayer;
        if (es.seenPlayer) {
            enemy.targetPlayer = game.players[es.targetPlayerID];
            if (!enemy.targetPlayer)
                enemy.targetPlayer = game.offlinePlayers[es.targetPlayerID];
        }
        enemy.drops = [];
        for (const d of es.drops) {
            if (d) {
                enemy.drops.push(loadItem(d, game));
            }
        }
    }
    if (es.type === EnemyType.CHARGE) {
        enemy = new chargeEnemy_1.ChargeEnemy(room, game, es.x, es.y);
        enemy.ticks = es.ticks;
        enemy.state = es.chargeEnemyState;
        enemy.startX = es.startX;
        enemy.startY = es.startY;
        enemy.targetX = es.targetX;
        enemy.targetY = es.targetY;
        enemy.visualTargetX = es.visualTargetX;
        enemy.visualTargetY = es.visualTargetY;
    }
    if (es.type === EnemyType.CHEST)
        enemy = new chest_1.Chest(room, game, es.x, es.y);
    if (es.type === EnemyType.COAL)
        enemy = new coalResource_1.CoalResource(room, game, es.x, es.y);
    if (es.type === EnemyType.CRATE)
        enemy = new crate_1.Crate(room, game, es.x, es.y);
    if (es.type === EnemyType.EMERALD)
        enemy = new emeraldResource_1.EmeraldResource(room, game, es.x, es.y);
    if (es.type === EnemyType.GOLD)
        enemy = new goldResource_1.GoldResource(room, game, es.x, es.y);
    if (es.type === EnemyType.KNIGHT) {
        enemy = new knightEnemy_1.KnightEnemy(room, game, es.x, es.y);
        enemy.ticks = es.ticks;
        enemy.seenPlayer = es.seenPlayer;
        if (es.seenPlayer) {
            enemy.targetPlayer = game.players[es.targetPlayerID];
            if (!enemy.targetPlayer)
                enemy.targetPlayer = game.offlinePlayers[es.targetPlayerID];
        }
    }
    if (es.type === EnemyType.PLANT)
        enemy = new pottedPlant_1.PottedPlant(room, game, es.x, es.y);
    if (es.type === EnemyType.POT)
        enemy = new pot_1.Pot(room, game, es.x, es.y);
    if (es.type === EnemyType.SKULL) {
        enemy = new skullEnemy_1.SkullEnemy(room, game, es.x, es.y);
        enemy.ticks = es.ticks;
        enemy.ticksSinceFirstHit = es.ticksSinceFirstHit;
        enemy.seenPlayer = es.seenPlayer;
        if (es.seenPlayer) {
            enemy.targetPlayer = game.players[es.targetPlayerID];
            if (!enemy.targetPlayer)
                enemy.targetPlayer = game.offlinePlayers[es.targetPlayerID];
        }
    }
    if (es.type === EnemyType.CRAB) {
        enemy = new crabEnemy_1.CrabEnemy(room, game, es.x, es.y);
        enemy.ticks = es.ticks;
        enemy.seenPlayer = es.seenPlayer;
        if (es.seenPlayer) {
            enemy.targetPlayer = game.players[es.targetPlayerID];
            if (!enemy.targetPlayer)
                enemy.targetPlayer = game.offlinePlayers[es.targetPlayerID];
        }
    }
    if (es.type === EnemyType.SPAWNER) {
        enemy = new spawner_1.Spawner(room, game, es.x, es.y, [es.enemySpawnType]);
        enemy.ticks = es.ticks;
        enemy.seenPlayer = es.seenPlayer;
        enemy.enemySpawnType = es.enemySpawnType;
    }
    if (es.type === EnemyType.VENDINGMACHINE) {
        let item = loadItem(es.item, game);
        enemy = new vendingMachine_1.VendingMachine(room, game, es.x, es.y, item);
        if (es.isPlayerOpened) {
            enemy.playerOpened = game.players[es.playerOpenedID];
            if (!enemy.playerOpened)
                enemy.playerOpened = game.offlinePlayers[es.playerOpenedID];
        }
        enemy.open = es.open;
        enemy.costItems = [];
        for (const item of es.costItems) {
            if (item) {
                enemy.costItems.push(loadItem(item, game));
            }
        }
        enemy.isInf = es.isInf;
        enemy.quantity = es.quantity;
    }
    if (es.type === EnemyType.ZOMBIE) {
        enemy = new zombieEnemy_1.ZombieEnemy(room, game, es.x, es.y);
        enemy.ticks = es.ticks;
        enemy.seenPlayer = es.seenPlayer;
        if (es.seenPlayer) {
            enemy.targetPlayer = game.players[es.targetPlayerID];
            if (!enemy.targetPlayer)
                enemy.targetPlayer = game.offlinePlayers[es.targetPlayerID];
        }
    }
    if (es.type === EnemyType.ARMOREDSKULL)
        enemy = new armoredSkullEnemy_1.ArmoredSkullEnemy(room, game, es.x, es.y);
    if (es.type === EnemyType.ARMOREDZOMBIE)
        enemy = new armoredzombieEnemy_1.ArmoredzombieEnemy(room, game, es.x, es.y);
    if (es.type === EnemyType.BIGKNIGHT)
        enemy = new bigKnightEnemy_1.BigKnightEnemy(room, game, es.x, es.y);
    if (es.type === EnemyType.BIGZOMBIE)
        enemy = new bigZombieEnemy_1.BigZombieEnemy(room, game, es.x, es.y);
    if (es.type === EnemyType.BISHOP)
        enemy = new bishopEnemy_1.BishopEnemy(room, game, es.x, es.y);
    if (es.type === EnemyType.ENERGYWIZARD)
        enemy = new energyWizard_1.EnergyWizardEnemy(room, game, es.x, es.y);
    if (es.type === EnemyType.FIREWIZARD)
        enemy = new fireWizard_1.FireWizardEnemy(room, game, es.x, es.y);
    if (es.type === EnemyType.FROG)
        enemy = new frogEnemy_1.FrogEnemy(room, game, es.x, es.y);
    if (es.type === EnemyType.GLOWBUG)
        enemy = new glowBugEnemy_1.GlowBugEnemy(room, game, es.x, es.y);
    if (es.type === EnemyType.MUMMY)
        enemy = new mummyEnemy_1.MummyEnemy(room, game, es.x, es.y);
    if (es.type === EnemyType.OCCULTIST)
        enemy = new occultistEnemy_1.OccultistEnemy(room, game, es.x, es.y);
    if (es.type === EnemyType.QUEEN)
        enemy = new queenEnemy_1.QueenEnemy(room, game, es.x, es.y);
    if (es.type === EnemyType.ROOK)
        enemy = new rookEnemy_1.RookEnemy(room, game, es.x, es.y);
    if (es.type === EnemyType.SPIDER)
        enemy = new spiderEnemy_1.SpiderEnemy(room, game, es.x, es.y);
    if (es.type === EnemyType.BUSH)
        enemy = new bush_1.Bush(room, game, es.x, es.y);
    if (es.type === EnemyType.FISHING_SPOT)
        enemy = new fishingSpot_1.FishingSpot(room, game, es.x, es.y);
    if (es.type === EnemyType.FURNACE)
        enemy = new furnace_1.Furnace(room, game, es.x, es.y);
    if (es.type === EnemyType.PUMPKIN)
        enemy = new pumpkin_1.Pumpkin(room, game, es.x, es.y);
    if (es.type === EnemyType.SPROUT)
        enemy = new sprout_1.Sprout(room, game, es.x, es.y);
    if (es.type === EnemyType.TOMBSTONE)
        enemy = new tombStone_1.TombStone(room, game, es.x, es.y);
    if (es.type === EnemyType.DECO_BLOCK)
        enemy = new decoBlock_1.DecoBlock(room, game, es.x, es.y);
    if (es.type === EnemyType.TREE)
        enemy = new tree_1.Tree(room, game, es.x, es.y);
    if (es.type === EnemyType.CHEST_LAYER)
        enemy = new chestLayer_1.ChestLayer(room, game, es.x, es.y);
    if (es.type === EnemyType.BOMB)
        enemy = new bomb_1.Bomb(room, game, es.x, es.y);
    if (es.type === EnemyType.BLOCK)
        enemy = new block_1.Block(room, game, es.x, es.y);
    if (es.type === EnemyType.DOWNLADDER_MAKER)
        enemy = new downladderMaker_1.DownladderMaker(room, game, es.x, es.y);
    if (es.type === EnemyType.ROCK)
        enemy = new rockResource_1.Rock(room, game, es.x, es.y);
    if (!enemy) {
        console.error("Unknown enemy type:", es.type, "EnemyType enum value:", EnemyType[es.type], "Falling back to barrel");
        enemy = new barrel_1.Barrel(room, game, es.x, es.y);
    }
    enemy.x = es.x;
    enemy.y = es.y;
    enemy.health = es.health;
    enemy.maxHealth = es.maxHealth;
    enemy.unconscious = es.unconscious;
    enemy.direction = es.direction;
    enemy.dead = es.dead;
    enemy.skipNextTurns = es.skipNextTurns;
    if (es.hasDrop)
        enemy.drop = loadItem(es.drop, game);
    enemy.alertTicks = es.alertTicks;
    return enemy;
};
class RoomState {
    constructor(room, game) {
        this.roomID = game.rooms.indexOf(room);
        this.entered = room.entered;
        this.active = room.active;
        this.onScreen = room.onScreen;
        this.enemies = [];
        this.items = [];
        this.projectiles = [];
        this.hitwarnings = [];
        for (const enemy of room.entities)
            this.enemies.push(new EnemyState(enemy, game));
        for (const item of room.items) {
            if (item) {
                this.items.push(new ItemState(item, game));
            }
        }
        for (const projectile of room.projectiles)
            this.projectiles.push(new ProjectileState(projectile, game));
        for (const hw of room.hitwarnings)
            this.hitwarnings.push(new HitWarningState(hw));
    }
}
exports.RoomState = RoomState;
let loadRoom = (room, roomState, game) => {
    room.entered = roomState.entered;
    room.active = roomState.active;
    room.onScreen = roomState.onScreen;
    room.entities = [];
    room.items = [];
    room.projectiles = [];
    room.hitwarnings = [];
    for (const enemy of roomState.enemies)
        room.entities.push(loadEnemy(enemy, game));
    for (const item of roomState.items) {
        if (item) {
            room.items.push(loadItem(item, game));
        }
    }
    for (const projectile of roomState.projectiles)
        room.projectiles.push(loadProjectile(projectile, game));
    for (const hw of roomState.hitwarnings)
        room.hitwarnings.push(loadHitWarning(hw, game));
    // Reset lighting state to prevent recursion issues
};
var ItemType;
(function (ItemType) {
    ItemType[ItemType["ARMOR"] = 0] = "ARMOR";
    ItemType[ItemType["BLUEGEM"] = 1] = "BLUEGEM";
    ItemType[ItemType["CANDLE"] = 2] = "CANDLE";
    ItemType[ItemType["COAL"] = 3] = "COAL";
    ItemType[ItemType["COIN"] = 4] = "COIN";
    ItemType[ItemType["GOLD"] = 5] = "GOLD";
    ItemType[ItemType["GOLDENKEY"] = 6] = "GOLDENKEY";
    ItemType[ItemType["GREENGEM"] = 7] = "GREENGEM";
    ItemType[ItemType["KEY"] = 8] = "KEY";
    ItemType[ItemType["LANTERN"] = 9] = "LANTERN";
    ItemType[ItemType["REDGEM"] = 10] = "REDGEM";
    ItemType[ItemType["TORCH"] = 11] = "TORCH";
    ItemType[ItemType["DAGGER"] = 12] = "DAGGER";
    ItemType[ItemType["DUALDAGGER"] = 13] = "DUALDAGGER";
    ItemType[ItemType["SHOTGUN"] = 14] = "SHOTGUN";
    ItemType[ItemType["SPEAR"] = 15] = "SPEAR";
    ItemType[ItemType["PICKAXE"] = 16] = "PICKAXE";
    ItemType[ItemType["BACKPACK"] = 17] = "BACKPACK";
    ItemType[ItemType["SPELLBOOK"] = 18] = "SPELLBOOK";
    ItemType[ItemType["WEAPON_FRAGMENTS"] = 19] = "WEAPON_FRAGMENTS";
    ItemType[ItemType["WARHAMMER"] = 20] = "WARHAMMER";
    ItemType[ItemType["HAMMER"] = 21] = "HAMMER";
    ItemType[ItemType["WEAPON_POISON"] = 22] = "WEAPON_POISON";
    ItemType[ItemType["WEAPON_BLOOD"] = 23] = "WEAPON_BLOOD";
    ItemType[ItemType["HEART"] = 24] = "HEART";
    ItemType[ItemType["MUSHROOMS"] = 25] = "MUSHROOMS";
    ItemType[ItemType["STONE"] = 26] = "STONE";
    ItemType[ItemType["BLUE_POTION"] = 27] = "BLUE_POTION";
    ItemType[ItemType["APPLE"] = 28] = "APPLE";
    ItemType[ItemType["BESTIARY_BOOK"] = 29] = "BESTIARY_BOOK";
    ItemType[ItemType["BOMB_ITEM"] = 30] = "BOMB_ITEM";
    ItemType[ItemType["ENTITY_SPAWNER"] = 31] = "ENTITY_SPAWNER";
    ItemType[ItemType["FISH"] = 32] = "FISH";
    ItemType[ItemType["FISHING_ROD"] = 33] = "FISHING_ROD";
    ItemType[ItemType["GEODE"] = 34] = "GEODE";
    ItemType[ItemType["GLOW_BUGS"] = 35] = "GLOW_BUGS";
    ItemType[ItemType["GOD_STONE"] = 36] = "GOD_STONE";
    ItemType[ItemType["GOLD_BAR"] = 37] = "GOLD_BAR";
    ItemType[ItemType["GOLD_RING"] = 38] = "GOLD_RING";
    ItemType[ItemType["GARNET_RING"] = 39] = "GARNET_RING";
    ItemType[ItemType["ZIRCON_RING"] = 40] = "ZIRCON_RING";
    ItemType[ItemType["EMERALD_RING"] = 41] = "EMERALD_RING";
    ItemType[ItemType["AMBER_RING"] = 42] = "AMBER_RING";
    ItemType[ItemType["GREEN_POTION"] = 43] = "GREEN_POTION";
    ItemType[ItemType["GREATAXE"] = 44] = "GREATAXE";
    ItemType[ItemType["HOURGLASS"] = 45] = "HOURGLASS";
    ItemType[ItemType["ORANGE_GEM"] = 46] = "ORANGE_GEM";
    ItemType[ItemType["SCYTHE"] = 47] = "SCYTHE";
    ItemType[ItemType["SCYTHE_HANDLE"] = 48] = "SCYTHE_HANDLE";
    ItemType[ItemType["SCYTHE_BLADE"] = 49] = "SCYTHE_BLADE";
    ItemType[ItemType["SLINGSHOT"] = 50] = "SLINGSHOT";
    ItemType[ItemType["SPELLBOOK_PAGE"] = 51] = "SPELLBOOK_PAGE";
    ItemType[ItemType["SWORD"] = 52] = "SWORD";
})(ItemType = exports.ItemType || (exports.ItemType = {}));
class ItemState {
    constructor(item, game) {
        // Add null check at the beginning
        if (!item) {
            throw new Error("Cannot create ItemState from null item");
        }
        if (item instanceof armor_1.Armor)
            this.type = ItemType.ARMOR;
        if (item instanceof bluegem_1.BlueGem)
            this.type = ItemType.BLUEGEM;
        if (item instanceof candle_1.Candle)
            this.type = ItemType.CANDLE;
        if (item instanceof coal_1.Coal)
            this.type = ItemType.COAL;
        if (item instanceof coin_1.Coin)
            this.type = ItemType.COIN;
        if (item instanceof gold_1.Gold)
            this.type = ItemType.GOLD;
        if (item instanceof goldenKey_1.GoldenKey)
            this.type = ItemType.GOLDENKEY;
        if (item instanceof greengem_1.GreenGem)
            this.type = ItemType.GREENGEM;
        if (item instanceof heart_1.Heart)
            this.type = ItemType.HEART;
        if (item instanceof key_1.Key)
            this.type = ItemType.KEY;
        if (item instanceof lantern_1.Lantern)
            this.type = ItemType.LANTERN;
        if (item instanceof redgem_1.RedGem)
            this.type = ItemType.REDGEM;
        if (item instanceof torch_1.Torch)
            this.type = ItemType.TORCH;
        if (item instanceof dagger_1.Dagger)
            this.type = ItemType.DAGGER;
        if (item instanceof dualdagger_1.DualDagger)
            this.type = ItemType.DUALDAGGER;
        if (item instanceof shotgun_1.Shotgun)
            this.type = ItemType.SHOTGUN;
        if (item instanceof spear_1.Spear)
            this.type = ItemType.SPEAR;
        if (item instanceof pickaxe_1.Pickaxe)
            this.type = ItemType.PICKAXE;
        if (item instanceof backpack_1.Backpack)
            this.type = ItemType.BACKPACK;
        // Add new item type checks:
        if (item instanceof apple_1.Apple)
            this.type = ItemType.APPLE;
        if (item instanceof bestiaryBook_1.BestiaryBook)
            this.type = ItemType.BESTIARY_BOOK;
        if (item instanceof bombItem_1.BombItem)
            this.type = ItemType.BOMB_ITEM;
        if (item instanceof entitySpawner_1.EntitySpawner)
            this.type = ItemType.ENTITY_SPAWNER;
        if (item instanceof fish_1.Fish)
            this.type = ItemType.FISH;
        if (item instanceof fishingRod_1.FishingRod)
            this.type = ItemType.FISHING_ROD;
        if (item instanceof geode_1.Geode)
            this.type = ItemType.GEODE;
        if (item instanceof glowBugs_1.GlowBugs)
            this.type = ItemType.GLOW_BUGS;
        if (item instanceof godStone_1.GodStone)
            this.type = ItemType.GOD_STONE;
        if (item instanceof goldBar_1.GoldBar)
            this.type = ItemType.GOLD_BAR;
        if (item instanceof goldRing_1.GoldRing)
            this.type = ItemType.GOLD_RING;
        if (item instanceof garnetRing_1.GarnetRing)
            this.type = ItemType.GARNET_RING;
        if (item instanceof zirconRing_1.ZirconRing)
            this.type = ItemType.ZIRCON_RING;
        if (item instanceof emeraldRing_1.EmeraldRing)
            this.type = ItemType.EMERALD_RING;
        if (item instanceof amberRing_1.AmberRing)
            this.type = ItemType.AMBER_RING;
        if (item instanceof greenPotion_1.GreenPotion)
            this.type = ItemType.GREEN_POTION;
        if (item instanceof greataxe_1.Greataxe)
            this.type = ItemType.GREATAXE;
        if (item instanceof hourglass_1.Hourglass)
            this.type = ItemType.HOURGLASS;
        if (item instanceof orangegem_1.OrangeGem)
            this.type = ItemType.ORANGE_GEM;
        if (item instanceof scythe_1.Scythe)
            this.type = ItemType.SCYTHE;
        if (item instanceof scytheHandle_1.ScytheHandle)
            this.type = ItemType.SCYTHE_HANDLE;
        if (item instanceof scytheBlade_1.ScytheBlade)
            this.type = ItemType.SCYTHE_BLADE;
        if (item instanceof shrooms_1.Shrooms)
            this.type = ItemType.MUSHROOMS; // Maps to existing MUSHROOMS
        if (item instanceof slingshot_1.Slingshot)
            this.type = ItemType.SLINGSHOT;
        if (item instanceof spellbook_1.Spellbook)
            this.type = ItemType.SPELLBOOK; // Maps to existing SPELLBOOK
        if (item instanceof spellbookPage_1.SpellbookPage)
            this.type = ItemType.SPELLBOOK_PAGE;
        if (item instanceof stone_1.Stone)
            this.type = ItemType.STONE; // Maps to existing STONE
        if (item instanceof sword_1.Sword)
            this.type = ItemType.SWORD;
        if (item instanceof warhammer_1.Warhammer)
            this.type = ItemType.WARHAMMER; // Maps to existing WARHAMMER
        if (item instanceof weaponBlood_1.WeaponBlood)
            this.type = ItemType.WEAPON_BLOOD; // Maps to existing WEAPON_BLOOD
        if (item instanceof weaponPoison_1.WeaponPoison)
            this.type = ItemType.WEAPON_POISON; // Maps to existing WEAPON_POISON
        if (item instanceof weaponFragments_1.WeaponFragments)
            this.type = ItemType.WEAPON_FRAGMENTS; // Maps to existing WEAPON_FRAGMENTS
        if (item instanceof bluePotion_1.BluePotion)
            this.type = ItemType.BLUE_POTION; // Maps to existing BLUE_POTION
        this.equipped = item instanceof equippable_1.Equippable && item.equipped;
        this.x = item.x;
        this.y = item.y;
        this.roomID = game.rooms.indexOf(item.level);
        this.stackCount = item.stackCount;
        this.pickedUp = item.pickedUp;
    }
}
exports.ItemState = ItemState;
let loadItem = (i, game, player) => {
    let room = i.roomID !== -1 ? game.rooms[i.roomID] : null;
    let item;
    if (i.type === ItemType.ARMOR)
        item = new armor_1.Armor(room, i.x, i.y);
    if (i.type === ItemType.BLUEGEM)
        item = new bluegem_1.BlueGem(room, i.x, i.y);
    if (i.type === ItemType.CANDLE)
        item = new candle_1.Candle(room, i.x, i.y);
    if (i.type === ItemType.COAL)
        item = new coal_1.Coal(room, i.x, i.y);
    if (i.type === ItemType.COIN)
        item = new coin_1.Coin(room, i.x, i.y);
    if (i.type === ItemType.GOLD)
        item = new gold_1.Gold(room, i.x, i.y);
    if (i.type === ItemType.GOLDENKEY)
        item = new goldenKey_1.GoldenKey(room, i.x, i.y);
    if (i.type === ItemType.GREENGEM)
        item = new greengem_1.GreenGem(room, i.x, i.y);
    if (i.type === ItemType.HEART)
        item = new heart_1.Heart(room, i.x, i.y);
    if (i.type === ItemType.KEY)
        item = new key_1.Key(room, i.x, i.y);
    if (i.type === ItemType.LANTERN)
        item = new lantern_1.Lantern(room, i.x, i.y);
    if (i.type === ItemType.REDGEM)
        item = new redgem_1.RedGem(room, i.x, i.y);
    if (i.type === ItemType.TORCH)
        item = new torch_1.Torch(room, i.x, i.y);
    if (i.type === ItemType.DAGGER)
        item = new dagger_1.Dagger(room, i.x, i.y);
    if (i.type === ItemType.DUALDAGGER)
        item = new dualdagger_1.DualDagger(room, i.x, i.y);
    if (i.type === ItemType.SHOTGUN)
        item = new shotgun_1.Shotgun(room, i.x, i.y);
    if (i.type === ItemType.SPEAR)
        item = new spear_1.Spear(room, i.x, i.y);
    if (i.type === ItemType.PICKAXE)
        item = new pickaxe_1.Pickaxe(room, i.x, i.y);
    if (i.type === ItemType.BACKPACK)
        item = new backpack_1.Backpack(room, i.x, i.y);
    // Add new item loading cases:
    if (i.type === ItemType.APPLE)
        item = new apple_1.Apple(room, i.x, i.y);
    if (i.type === ItemType.BESTIARY_BOOK)
        item = new bestiaryBook_1.BestiaryBook(room, i.x, i.y);
    if (i.type === ItemType.BOMB_ITEM)
        item = new bombItem_1.BombItem(room, i.x, i.y);
    if (i.type === ItemType.ENTITY_SPAWNER)
        item = new entitySpawner_1.EntitySpawner(room, i.x, i.y);
    if (i.type === ItemType.FISH)
        item = new fish_1.Fish(room, i.x, i.y);
    if (i.type === ItemType.FISHING_ROD)
        item = new fishingRod_1.FishingRod(room, i.x, i.y);
    if (i.type === ItemType.GEODE)
        item = new geode_1.Geode(room, i.x, i.y);
    if (i.type === ItemType.GLOW_BUGS)
        item = new glowBugs_1.GlowBugs(room, i.x, i.y);
    if (i.type === ItemType.GOD_STONE)
        item = new godStone_1.GodStone(room, i.x, i.y);
    if (i.type === ItemType.GOLD_BAR)
        item = new goldBar_1.GoldBar(room, i.x, i.y);
    if (i.type === ItemType.GOLD_RING)
        item = new goldRing_1.GoldRing(room, i.x, i.y);
    if (i.type === ItemType.GARNET_RING)
        item = new garnetRing_1.GarnetRing(room, i.x, i.y);
    if (i.type === ItemType.ZIRCON_RING)
        item = new zirconRing_1.ZirconRing(room, i.x, i.y);
    if (i.type === ItemType.EMERALD_RING)
        item = new emeraldRing_1.EmeraldRing(room, i.x, i.y);
    if (i.type === ItemType.AMBER_RING)
        item = new amberRing_1.AmberRing(room, i.x, i.y);
    if (i.type === ItemType.GREEN_POTION)
        item = new greenPotion_1.GreenPotion(room, i.x, i.y);
    if (i.type === ItemType.GREATAXE)
        item = new greataxe_1.Greataxe(room, i.x, i.y);
    if (i.type === ItemType.HOURGLASS)
        item = new hourglass_1.Hourglass(room, i.x, i.y);
    if (i.type === ItemType.ORANGE_GEM)
        item = new orangegem_1.OrangeGem(room, i.x, i.y);
    if (i.type === ItemType.SCYTHE)
        item = new scythe_1.Scythe(room, i.x, i.y);
    if (i.type === ItemType.SCYTHE_HANDLE)
        item = new scytheHandle_1.ScytheHandle(room, i.x, i.y);
    if (i.type === ItemType.SCYTHE_BLADE)
        item = new scytheBlade_1.ScytheBlade(room, i.x, i.y);
    if (i.type === ItemType.MUSHROOMS)
        item = new shrooms_1.Shrooms(room, i.x, i.y);
    if (i.type === ItemType.SLINGSHOT)
        item = new slingshot_1.Slingshot(room, i.x, i.y);
    if (i.type === ItemType.SPELLBOOK)
        item = new spellbook_1.Spellbook(room, i.x, i.y);
    if (i.type === ItemType.SPELLBOOK_PAGE)
        item = new spellbookPage_1.SpellbookPage(room, i.x, i.y);
    if (i.type === ItemType.STONE)
        item = new stone_1.Stone(room, i.x, i.y);
    if (i.type === ItemType.SWORD)
        item = new sword_1.Sword(room, i.x, i.y);
    if (i.type === ItemType.BLUE_POTION)
        item = new bluePotion_1.BluePotion(room, i.x, i.y);
    if (i.type === ItemType.WEAPON_FRAGMENTS)
        item = new weaponFragments_1.WeaponFragments(room, i.x, i.y);
    if (i.type === ItemType.WARHAMMER)
        item = new warhammer_1.Warhammer(room, i.x, i.y);
    if (i.type === ItemType.HAMMER)
        item = new hammer_1.Hammer(room, i.x, i.y);
    if (i.type === ItemType.WEAPON_POISON)
        item = new weaponPoison_1.WeaponPoison(room, i.x, i.y);
    if (i.type === ItemType.WEAPON_BLOOD)
        item = new weaponBlood_1.WeaponBlood(room, i.x, i.y);
    if (!item) {
        console.error("Unknown item type:", i.type, "ItemType enum value:", ItemType[i.type], "Falling back to coal");
        item = new coal_1.Coal(room, i.x, i.y);
    }
    if (i.equipped)
        item.equipped = true;
    if (item instanceof equippable_1.Equippable)
        item.setWielder(player);
    item.stackCount = i.stackCount;
    item.pickedUp = i.pickedUp;
    return item;
};
class InventoryState {
    constructor(inventory, game) {
        this.isOpen = inventory.isOpen;
        this.cols = inventory.cols;
        this.rows = inventory.rows;
        this.equipAnimAmount = inventory.equipAnimAmount.map((x) => x);
        this.isWeaponEquipped = false;
        if (inventory.weapon) {
            this.isWeaponEquipped = true;
            this.weaponI = inventory.items.indexOf(inventory.weapon);
        }
        this.coins = inventory.coins;
        this.selX = inventory.selX;
        this.selY = inventory.selY;
        this.items = Array();
        for (const item of inventory.items) {
            // Filter out null items
            if (item) {
                this.items.push(new ItemState(item, game));
            }
        }
    }
}
exports.InventoryState = InventoryState;
let loadInventory = (inventory, i, game) => {
    inventory.clear();
    inventory.isOpen = i.isOpen;
    inventory.cols = i.cols;
    inventory.rows = i.rows;
    inventory.selX = i.selX;
    inventory.selY = i.selY;
    inventory.equipAnimAmount = i.equipAnimAmount.map((x) => x);
    inventory.coins = i.coins;
    // Load items - make sure to maintain proper inventory structure
    for (const itemState of i.items) {
        if (itemState) {
            // Additional null check
            const loadedItem = loadItem(itemState, game, inventory.player);
            if (loadedItem) {
                inventory.items.push(loadedItem);
            }
        }
    }
    // Set weapon reference after all items are loaded
    if (i.isWeaponEquipped && i.weaponI < inventory.items.length) {
        inventory.weapon = inventory.items[i.weaponI];
    }
};
class PlayerState {
    constructor(player, game) {
        this.x = player.x;
        this.y = player.y;
        this.dead = player.dead;
        this.roomID = player.levelID;
        this.direction = player.direction;
        this.health = player.health;
        this.maxHealth = player.maxHealth;
        this.lastTickHealth = player.lastTickHealth;
        this.inventory = new InventoryState(player.inventory, game);
        this.hasOpenVendingMachine = false;
        if (player.openVendingMachine) {
            this.hasOpenVendingMachine = true;
            this.openVendingMachineRoomID = game.rooms.indexOf(player.openVendingMachine.room);
            this.openVendingMachineID =
                player.openVendingMachine.room.entities.indexOf(player.openVendingMachine);
        }
        this.sightRadius = player.sightRadius;
    }
}
exports.PlayerState = PlayerState;
let loadPlayer = (id, p, game) => {
    let player = new player_1.Player(game, p.x, p.y, id === game.localPlayerID);
    player.dead = p.dead;
    player.levelID = p.roomID;
    if (player.levelID < game.levelgen.currentFloorFirstLevelID) {
        // catch up to the current level
        player.levelID = game.levelgen.currentFloorFirstLevelID;
        player.x =
            game.rooms[player.levelID].roomX +
                Math.floor(game.rooms[player.levelID].width / 2);
        player.y =
            game.rooms[player.levelID].roomY +
                Math.floor(game.rooms[player.levelID].height / 2);
    }
    player.direction = p.direction;
    player.health = p.health;
    player.maxHealth = p.maxHealth;
    player.lastTickHealth = p.lastTickHealth;
    loadInventory(player.inventory, p.inventory, game);
    if (p.hasOpenVendingMachine) {
        player.openVendingMachine = game.rooms[p.openVendingMachineRoomID].entities[p.openVendingMachineID];
    }
    player.sightRadius = p.sightRadius;
    // Set the player's room reference (this might be needed by some player methods)
    // Note: This will be set properly when the game.room is assigned in loadGameState
    // but we can set it here for consistency
    // player.room = game.rooms[player.levelID]; // Only if Player class has a room property
    return player;
};
class LevelState {
    constructor(level) {
        this.depth = level.depth;
        this.width = level.width;
        this.height = level.height;
        this.isMainPath = level.isMainPath;
        this.mapGroup = level.mapGroup;
        this.envType = level.environment.type;
    }
}
exports.LevelState = LevelState;
const loadLevel = (level, levelState) => {
    level.depth = levelState.depth;
    level.width = levelState.width;
    level.height = levelState.height;
    level.isMainPath = levelState.isMainPath;
    level.mapGroup = levelState.mapGroup;
    level.environment.type = levelState.envType;
    level.environment.skin = levelState.envType;
};
class GameState {
    constructor() {
        this.seed = 0;
        this.randomState = 0;
        this.players = {};
        this.offlinePlayers = {};
        this.level = null;
        this.rooms = [];
    }
}
exports.GameState = GameState;
const createGameState = (game) => {
    let gs = new GameState();
    gs.seed = game.levelgen.seed; // random state for generating levels
    gs.randomState = random_1.Random.state; // current random state
    gs.level = new LevelState(game.level);
    for (const i in game.players)
        gs.players[i] = new PlayerState(game.players[i], game);
    for (const i in game.offlinePlayers) {
        gs.offlinePlayers[i] = new PlayerState(game.offlinePlayers[i], game);
    }
    for (let room of game.rooms) {
        room.catchUp();
        gs.rooms.push(new RoomState(room, game));
    }
    return gs;
};
exports.createGameState = createGameState;
const loadGameState = (game, activeUsernames, gameState, newWorld) => {
    game.rooms = Array();
    game.levelgen = new levelGenerator_1.LevelGenerator();
    game.levelgen.setSeed(gameState.seed);
    // If gameState.level is null, we need to create a default level state
    if (!gameState.level) {
        // This is a simplified assumption. We create a new level with default parameters
        // since we don't have a level object to create a state from.
        // This part might need adjustment based on how a "default" level is defined.
        const tempLevel = new level_1.Level(game, 0, 1, 1, true, 0, environmentTypes_1.EnvType.DUNGEON);
        gameState.level = new LevelState(tempLevel);
    }
    if (newWorld)
        gameState.level.depth = 0;
    eventBus_1.globalEventBus.emit(events_1.EVENTS.LEVEL_GENERATION_STARTED, {});
    game.levelgen.generateFirstNFloors(game, gameState.level.depth).then(() => {
        eventBus_1.globalEventBus.emit(events_1.EVENTS.LEVEL_GENERATION_COMPLETED, {});
        if (!newWorld) {
            if (gameState.level) {
                loadLevel(game.level, gameState.level);
            }
            if (gameState.players) {
                for (const i in gameState.players) {
                    if (activeUsernames.includes(i))
                        game.players[i] = loadPlayer(i, gameState.players[i], game);
                    else
                        game.offlinePlayers[i] = loadPlayer(i, gameState.players[i], game);
                }
            }
            if (gameState.offlinePlayers) {
                for (const i in gameState.offlinePlayers) {
                    if (i === game.localPlayerID)
                        game.players[i] = loadPlayer(i, gameState.offlinePlayers[i], game);
                    else if (activeUsernames.includes(i))
                        game.players[i] = loadPlayer(i, gameState.offlinePlayers[i], game);
                    else
                        game.offlinePlayers[i] = loadPlayer(i, gameState.offlinePlayers[i], game);
                }
            }
            for (let roomState of gameState.rooms) {
                for (let i = 0; i < game.rooms.length; i++) {
                    if (i === roomState.roomID) {
                        loadRoom(game.rooms[i], roomState, game);
                    }
                }
            }
            if (!(game.localPlayerID in gameState.players) &&
                !(game.localPlayerID in gameState.offlinePlayers)) {
                // we're not in the gamestate, create a new player
                game.players[game.localPlayerID] = new player_1.Player(game, 0, 0, true);
                game.players[game.localPlayerID].levelID =
                    game.levelgen.currentFloorFirstLevelID;
                game.players[game.localPlayerID].x =
                    game.rooms[game.levelgen.currentFloorFirstLevelID].roomX +
                        Math.floor(game.rooms[game.levelgen.currentFloorFirstLevelID].width / 2);
                game.players[game.localPlayerID].y =
                    game.rooms[game.levelgen.currentFloorFirstLevelID].roomY +
                        Math.floor(game.rooms[game.levelgen.currentFloorFirstLevelID].height / 2);
                game.room = game.rooms[game.levelgen.currentFloorFirstLevelID];
                game.room.enterLevel(game.players[game.localPlayerID]);
                game.players[game.localPlayerID].map.updateSeenTiles();
                game.players[game.localPlayerID].map.saveMapData();
            }
            else {
                // Set the current room based on the loaded player's levelID
                const localPlayer = game.players[game.localPlayerID];
                game.room = game.rooms[localPlayer.levelID];
                // Properly initialize the room for the loaded player
                // Update the game level reference
                game.updateLevel(game.room);
                // Do the room setup without moving the player (keep saved position)
                game.room.onEnterRoom(localPlayer);
                // Update the player's map data
                localPlayer.map.updateSeenTiles();
                localPlayer.map.saveMapData();
                // Optional: Add validation after the room setup
                const tile = game.room.roomArray[localPlayer.x]?.[localPlayer.y];
                if (!tile || tile.isSolid()) {
                    console.warn("Player loaded in invalid position, moving to room center");
                    const roomCenter = game.room.getRoomCenter();
                    localPlayer.moveSnap(roomCenter.x, roomCenter.y);
                }
            }
        }
        else {
            // stub game state, start a new world
            game.players[game.localPlayerID] = new player_1.Player(game, 0, 0, true);
            game.room = game.rooms[game.players[game.localPlayerID].levelID];
            game.room.enterLevel(game.players[game.localPlayerID]);
            game.players[game.localPlayerID].map.updateSeenTiles();
            game.players[game.localPlayerID].map.saveMapData();
        }
        random_1.Random.setState(gameState.randomState);
        game.room.updateLighting();
        let p = game.players[game.localPlayerID];
        //game.room.items.push(new Key(game.room, p.x - 1, p.y + 1));
        //choose one door to lock
        /*
        let locked = false;
        game.room.doors.forEach((door) => {
          if (!locked) {
            door.lock();
            locked = true;
          }
        });
        */
        game.chat = [];
    });
};
exports.loadGameState = loadGameState;


/***/ }),

/***/ "./src/game/gameplaySettings.ts":
/*!**************************************!*\
  !*** ./src/game/gameplaySettings.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GameplaySettings = void 0;
class GameplaySettings {
}
exports.GameplaySettings = GameplaySettings;
GameplaySettings.LIMIT_ENEMY_TYPES = true;
GameplaySettings.MEDIAN_ROOM_DENSITY = 0.25;
GameplaySettings.UNLIMITED_SPAWNERS = true;
GameplaySettings.THROTTLE_SPAWNERS = true;
GameplaySettings.NO_ENEMIES = false;
GameplaySettings.EQUIP_USES_TURN = false;
GameplaySettings.UNBREAKABLE_ITEMGROUP_LOOT = false;
// === ENEMY POOL SETTINGS ===
// Enemy Type Progression
GameplaySettings.NEW_ENEMIES_PER_LEVEL = 2; // How many new enemy types to add per level when LIMIT_ENEMY_TYPES is true
GameplaySettings.ENEMY_TYPES_BASE_COUNT = 4; // Base number added to sqrt formula for enemy type calculation
GameplaySettings.DEPTH_ZERO_ENEMY_TYPES = 3; // Number of enemy types available at depth 0
// Special Enemy Depth Requirements
GameplaySettings.SPAWNER_MIN_DEPTH = 0; // Minimum depth before spawners can appear (depth > this value)
GameplaySettings.OCCULTIST_MIN_DEPTH = 1; // Minimum depth before occultists can appear (depth > this value)
// Special Enemy Spawn Probabilities
GameplaySettings.SPAWNER_SPAWN_CHANCE = 0.1; // Probability per attempt to spawn a spawner (10%)
GameplaySettings.OCCULTIST_SPAWN_CHANCE = 0.1; // Probability per attempt to spawn an occultist (10%)
// Special Enemy Area Thresholds
GameplaySettings.SPAWNER_AREA_THRESHOLD = 50; // Room area divided by this = max possible spawners
GameplaySettings.OCCULTIST_AREA_THRESHOLD = 200; // Room area divided by this = max possible occultists
// Enemy Density Settings
GameplaySettings.ENEMY_DENSITY_DEPTH_MULTIPLIER = 0.05; // Multiplied by (depth + 2) for base density
GameplaySettings.ENEMY_DENSITY_DEPTH_OFFSET = 2; // Added to depth before multiplying
GameplaySettings.MAX_ENEMY_DENSITY = 0.3; // Maximum enemy density cap
GameplaySettings.FOREST_ENEMY_REDUCTION = 0.5; // Multiplier for enemy count in forest environments


/***/ }),

/***/ "./src/game/input.ts":
/*!***************************!*\
  !*** ./src/game/input.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Input = exports.InputEnum = void 0;
const gameConstants_1 = __webpack_require__(/*! ./gameConstants */ "./src/game/gameConstants.ts");
const game_1 = __webpack_require__(/*! ../game */ "./src/game.ts");
const mouseCursor_1 = __webpack_require__(/*! ../gui/mouseCursor */ "./src/gui/mouseCursor.ts");
const game_2 = __webpack_require__(/*! ../game */ "./src/game.ts");
var InputEnum;
(function (InputEnum) {
    InputEnum[InputEnum["I"] = 0] = "I";
    InputEnum[InputEnum["M"] = 1] = "M";
    InputEnum[InputEnum["M_UP"] = 2] = "M_UP";
    InputEnum[InputEnum["Q"] = 3] = "Q";
    InputEnum[InputEnum["LEFT"] = 4] = "LEFT";
    InputEnum[InputEnum["RIGHT"] = 5] = "RIGHT";
    InputEnum[InputEnum["UP"] = 6] = "UP";
    InputEnum[InputEnum["DOWN"] = 7] = "DOWN";
    InputEnum[InputEnum["SPACE"] = 8] = "SPACE";
    InputEnum[InputEnum["COMMA"] = 9] = "COMMA";
    InputEnum[InputEnum["PERIOD"] = 10] = "PERIOD";
    InputEnum[InputEnum["LEFT_CLICK"] = 11] = "LEFT_CLICK";
    InputEnum[InputEnum["RIGHT_CLICK"] = 12] = "RIGHT_CLICK";
    InputEnum[InputEnum["MOUSE_MOVE"] = 13] = "MOUSE_MOVE";
    InputEnum[InputEnum["NUMBER_1"] = 14] = "NUMBER_1";
    InputEnum[InputEnum["NUMBER_2"] = 15] = "NUMBER_2";
    InputEnum[InputEnum["NUMBER_3"] = 16] = "NUMBER_3";
    InputEnum[InputEnum["NUMBER_4"] = 17] = "NUMBER_4";
    InputEnum[InputEnum["NUMBER_5"] = 18] = "NUMBER_5";
    InputEnum[InputEnum["NUMBER_6"] = 19] = "NUMBER_6";
    InputEnum[InputEnum["NUMBER_7"] = 20] = "NUMBER_7";
    InputEnum[InputEnum["NUMBER_8"] = 21] = "NUMBER_8";
    InputEnum[InputEnum["NUMBER_9"] = 22] = "NUMBER_9";
    InputEnum[InputEnum["MINUS"] = 23] = "MINUS";
    InputEnum[InputEnum["EQUALS"] = 24] = "EQUALS";
    InputEnum[InputEnum["ESCAPE"] = 25] = "ESCAPE";
    InputEnum[InputEnum["F"] = 26] = "F";
})(InputEnum = exports.InputEnum || (exports.InputEnum = {}));
exports.Input = {
    _pressed: {},
    isTapHold: false,
    tapStartTime: null,
    IS_TAP_HOLD_THRESH: 300,
    keyDownListener: function (key) { },
    iListener: function () { },
    mListener: function () { },
    mUpListener: function () { },
    qListener: function () { },
    leftListener: function () { },
    rightListener: function () { },
    upListener: function () { },
    downListener: function () { },
    aListener: function () {
        exports.Input.leftListener();
    },
    dListener: function () {
        exports.Input.rightListener();
    },
    wListener: function () {
        exports.Input.upListener();
    },
    sListener: function () {
        exports.Input.downListener();
    },
    spaceListener: function () { },
    leftSwipeListener: function () { },
    rightSwipeListener: function () { },
    upSwipeListener: function () { },
    downSwipeListener: function () { },
    tapListener: function () { },
    commaListener: function () { },
    periodListener: function () { },
    numKeyListener: function (num) { },
    equalsListener: function () { },
    minusListener: function () { },
    escapeListener: function () { },
    fListener: function () { },
    mouseLeftClickListeners: [],
    mouseRightClickListeners: [],
    mouseMoveListeners: [],
    mouseDownListeners: [],
    mouseUpListeners: [],
    touchStartListeners: [],
    touchEndListeners: [],
    mouseX: 0,
    mouseY: 0,
    mouseDown: false,
    lastPressTime: 0,
    lastPressKey: "",
    // Add mouse repeat tracking
    lastMouseDownTime: 0,
    lastMouseDownX: 0,
    lastMouseDownY: 0,
    mouseDownHandled: false,
    SPACE: "Space",
    LEFT: "ArrowLeft",
    UP: "ArrowUp",
    RIGHT: "ArrowRight",
    DOWN: "ArrowDown",
    W: "KeyW",
    A: "KeyA",
    S: "KeyS",
    D: "KeyD",
    M: "KeyM",
    N: "KeyN",
    I: "KeyI",
    Q: "KeyQ",
    NUMBER_1: "Digit1",
    NUMBER_2: "Digit2",
    NUMBER_3: "Digit3",
    NUMBER_4: "Digit4",
    NUMBER_5: "Digit5",
    NUMBER_6: "Digit6",
    NUMBER_7: "Digit7",
    NUMBER_8: "Digit8",
    NUMBER_9: "Digit9",
    COMMA: "Comma",
    PERIOD: "Period",
    MINUS: "Minus",
    EQUALS: "Equal",
    ESCAPE: "Escape",
    F: "KeyF",
    rawMouseX: 0,
    rawMouseY: 0,
    isDown: function (keyCode) {
        return this._pressed[keyCode];
    },
    onKeydown: (event) => {
        if (event.repeat)
            return; // ignore repeat keypresses
        if (event.key)
            exports.Input.keyDownListener(event.key);
        if (event.cancelable && event.key != "F12" && event.key != "F5")
            event.preventDefault();
        exports.Input.lastPressTime = Date.now();
        exports.Input.lastPressKey = event.key;
        exports.Input._pressed[event.code] = true;
        switch (event.code) {
            case exports.Input.LEFT:
                exports.Input.leftListener();
                break;
            case exports.Input.A:
                exports.Input.aListener();
                break;
            case exports.Input.RIGHT:
                exports.Input.rightListener();
                break;
            case exports.Input.D:
                exports.Input.dListener();
                break;
            case exports.Input.UP:
                exports.Input.upListener();
                break;
            case exports.Input.W:
                exports.Input.wListener();
                break;
            case exports.Input.DOWN:
                exports.Input.downListener();
                break;
            case exports.Input.S:
                exports.Input.sListener();
                break;
            case exports.Input.SPACE:
                exports.Input.spaceListener();
                break;
            case exports.Input.M:
                exports.Input.mListener();
                break;
            case exports.Input.I:
                exports.Input.iListener();
                break;
            case exports.Input.Q:
                exports.Input.qListener();
                break;
            case exports.Input.COMMA:
                exports.Input.commaListener();
                break;
            case exports.Input.PERIOD:
                exports.Input.periodListener();
                break;
            case exports.Input.NUMBER_1:
            case exports.Input.NUMBER_2:
            case exports.Input.NUMBER_3:
            case exports.Input.NUMBER_4:
            case exports.Input.NUMBER_5:
            case exports.Input.NUMBER_6:
            case exports.Input.NUMBER_7:
            case exports.Input.NUMBER_8:
            case exports.Input.NUMBER_9:
                exports.Input.numKeyListener(parseInt(event.code.slice(-1)));
                break;
            case exports.Input.EQUALS:
                exports.Input.equalsListener();
                break;
            case exports.Input.MINUS:
                exports.Input.minusListener();
                break;
            case exports.Input.ESCAPE:
                exports.Input.escapeListener();
                break;
            case exports.Input.F:
                exports.Input.fListener();
                break;
        }
    },
    onKeyup: function (event) {
        delete this._pressed[event.code];
        if (event.key === this.lastPressKey) {
            this.lastPressTime = 0;
            this.lastPressKey = 0;
        }
        if (event.code === exports.Input.M)
            exports.Input.mUpListener();
    },
    mouseLeftClickListener: function (x, y) {
        for (let i = 0; i < exports.Input.mouseLeftClickListeners.length; i++)
            exports.Input.mouseLeftClickListeners[i](x, y);
    },
    mouseRightClickListener: function (x, y) {
        for (let i = 0; i < exports.Input.mouseRightClickListeners.length; i++)
            exports.Input.mouseRightClickListeners[i](x, y);
    },
    mouseMoveListener: function (x, y) {
        for (let i = 0; i < exports.Input.mouseMoveListeners.length; i++)
            exports.Input.mouseMoveListeners[i](x, y);
    },
    mouseDownListener: function (x, y, button) {
        for (let i = 0; i < exports.Input.mouseDownListeners.length; i++)
            exports.Input.mouseDownListeners[i](x, y, button);
    },
    mouseUpListener: function (x, y, button) {
        for (let i = 0; i < exports.Input.mouseUpListeners.length; i++)
            exports.Input.mouseUpListeners[i](x, y, button);
    },
    mouseClickListener: function (event) {
        if (event.button === 0 || event.button === 2) {
            let rect = window.document
                .getElementById("gameCanvas")
                .getBoundingClientRect();
            let x = event.clientX - rect.left;
            let y = event.clientY - rect.top;
            let scaledX = Math.floor(x / game_1.Game.scale);
            let scaledY = Math.floor(y / game_1.Game.scale);
            console.log(`Input.mouseClickListener: raw x: ${x}, y: ${y}, scale: ${game_1.Game.scale}, scaledX: ${scaledX}, scaledY: ${scaledY}`);
            if (event.button === 0) {
                exports.Input.mouseLeftClickListener(scaledX, scaledY);
            }
            else if (event.button === 2) {
                exports.Input.mouseRightClickListener(scaledX, scaledY);
            }
        }
    },
    updateMousePos: function (event) {
        game_1.Game.inputReceived = true;
        let rect = window.document
            .getElementById("gameCanvas")
            .getBoundingClientRect();
        let x = event.clientX - rect.left;
        let y = event.clientY - rect.top;
        // Store raw coordinates
        exports.Input.rawMouseX = x;
        exports.Input.rawMouseY = y;
        // Calculate scaled coordinates
        exports.Input.mouseX = Math.floor(x / game_1.Game.scale);
        exports.Input.mouseY = Math.floor(y / game_1.Game.scale);
        exports.Input.mouseMoveListener(exports.Input.mouseX, exports.Input.mouseY);
    },
    recalculateMousePosition: function () {
        if (exports.Input.rawMouseX !== undefined && exports.Input.rawMouseY !== undefined) {
            exports.Input.mouseX = Math.floor(exports.Input.rawMouseX / game_1.Game.scale);
            exports.Input.mouseY = Math.floor(exports.Input.rawMouseY / game_1.Game.scale);
            // Also recalculate click animation position
            mouseCursor_1.MouseCursor.getInstance().recalculateClickPosition();
        }
    },
    handleMouseDown: function (event) {
        if (exports.Input.mouseDown)
            return; // Prevent multiple triggers
        mouseCursor_1.MouseCursor.getInstance().startClickAnim();
        exports.Input.mouseDown = true;
        exports.Input.mouseDownStartTime = Date.now();
        exports.Input.isMouseHold = false;
        exports.Input.mouseDownListener(exports.Input.mouseX, exports.Input.mouseY, event.button);
        // Start checking for hold
        if (!exports.Input._holdCheckInterval) {
            exports.Input._holdCheckInterval = setInterval(exports.Input.checkIsMouseHold, 16); // Check every frame
        }
    },
    handleMouseUp: function (event) {
        exports.Input.mouseDown = false;
        exports.Input.mouseDownStartTime = null;
        exports.Input.mouseUpListener(exports.Input.mouseX, exports.Input.mouseY, event.button);
        // Reset mouse repeat tracking
        exports.Input.lastMouseDownTime = 0;
        exports.Input.mouseDownHandled = false;
        // Clear hold check interval
        if (exports.Input._holdCheckInterval) {
            clearInterval(exports.Input._holdCheckInterval);
            exports.Input._holdCheckInterval = null;
        }
        // Clear isMouseHold after a short delay to ensure click handler sees it
        setTimeout(() => {
            exports.Input.isMouseHold = false;
        }, 50);
    },
    _holdCheckInterval: null,
    checkIsMouseHold: function () {
        if (!exports.Input.mouseDown || exports.Input.mouseDownStartTime === null)
            return;
        if (Date.now() >= exports.Input.mouseDownStartTime + exports.Input.HOLD_THRESH) {
            if (!exports.Input.isMouseHold) {
                exports.Input.isMouseHold = true;
                // Call the hold callback if one is registered
                if (exports.Input.holdCallback) {
                    exports.Input.holdCallback();
                }
            }
        }
    },
    getTouches: function (evt) {
        game_1.Game.inputReceived = true;
        return (evt.touches || evt.originalEvent.touches // browser API
        ); // jQuery
    },
    xDown: null,
    yDown: null,
    currentX: 0,
    currentY: 0,
    swiped: false,
    handleTouchStart: function (evt) {
        //console.log("handleTouchStart triggered");
        game_1.Game.inputReceived = true;
        evt.preventDefault();
        const firstTouch = exports.Input.getTouches(evt)[0];
        exports.Input.xDown = firstTouch.clientX;
        exports.Input.yDown = firstTouch.clientY;
        exports.Input.currentX = firstTouch.clientX;
        exports.Input.currentY = firstTouch.clientY;
        exports.Input.tapStartTime = Date.now();
        exports.Input.updateMousePos({
            clientX: exports.Input.currentX,
            clientY: exports.Input.currentY,
        });
        exports.Input.swiped = false;
        // Unify with mouseDown logic, but force button=0 (left-click equivalent)
        exports.Input.mouseDown = true;
        exports.Input.mouseDownStartTime = Date.now();
        exports.Input.isMouseHold = false;
        exports.Input.mouseDownListener(exports.Input.mouseX, exports.Input.mouseY, 0);
        if (!exports.Input._holdCheckInterval) {
            exports.Input._holdCheckInterval = setInterval(exports.Input.checkIsMouseHold, 16);
            // console.log("_holdCheckInterval started");
        }
    },
    handleTouchMove: function (evt) {
        evt.preventDefault();
        exports.Input.currentX = evt.touches[0].clientX;
        exports.Input.currentY = evt.touches[0].clientY;
        exports.Input.updateMousePos({
            clientX: exports.Input.currentX,
            clientY: exports.Input.currentY,
        });
        if (exports.Input.swiped)
            return;
        var xDiff = exports.Input.xDown - exports.Input.currentX;
        var yDiff = exports.Input.yDown - exports.Input.currentY;
        // Check if we've swiped
        if (xDiff ** 2 + yDiff ** 2 >= gameConstants_1.GameConstants.SWIPE_THRESH) {
            if (Math.abs(xDiff) > Math.abs(yDiff)) {
                if (xDiff > 0) {
                    exports.Input.leftSwipeListener();
                    exports.Input.lastSwipeDirection = game_2.Direction.LEFT;
                }
                else {
                    exports.Input.rightSwipeListener();
                    exports.Input.lastSwipeDirection = game_2.Direction.RIGHT;
                }
                exports.Input.swiped = true;
                exports.Input.lastSwipeTime = Date.now();
                exports.Input.swipeHoldActive = true;
                exports.Input.swipeHoldRepeating = false; // Start in non-repeating state
            }
            else {
                if (yDiff > 0) {
                    exports.Input.upSwipeListener();
                    exports.Input.lastSwipeDirection = game_2.Direction.UP;
                }
                else {
                    exports.Input.downSwipeListener();
                    exports.Input.lastSwipeDirection = game_2.Direction.DOWN;
                }
                exports.Input.swiped = true;
                exports.Input.lastSwipeTime = Date.now();
                exports.Input.swipeHoldActive = true;
                exports.Input.swipeHoldRepeating = false; // Start in non-repeating state
            }
        }
    },
    handleTouchEnd: function (evt) {
        evt.preventDefault();
        if (!exports.Input.isTapHold && !exports.Input.swiped)
            exports.Input.tapListener();
        exports.Input.isTapHold = false;
        exports.Input.tapStartTime = null;
        // Reset swipe hold tracking
        exports.Input.swipeHoldActive = false;
        exports.Input.swipeHoldRepeating = false;
        exports.Input.lastSwipeTime = 0;
        exports.Input.lastSwipeDirection = null;
        // Also unify with mouseUp logic, again forcing button=0
        exports.Input.mouseDown = false;
        exports.Input.mouseDownStartTime = null;
        exports.Input.mouseUpListener(exports.Input.mouseX, exports.Input.mouseY, 0);
        if (exports.Input._holdCheckInterval) {
            clearInterval(exports.Input._holdCheckInterval);
            exports.Input._holdCheckInterval = null;
            //console.log("_holdCheckInterval cleared");
        }
        setTimeout(() => {
            exports.Input.isMouseHold = false;
            //console.log("isMouseHold reset");
        }, 50);
    },
    checkIsTapHold: function () {
        if (exports.Input.tapStartTime !== null &&
            Date.now() >= exports.Input.tapStartTime + exports.Input.IS_TAP_HOLD_THRESH)
            exports.Input.isTapHold = true;
    },
    set isMouseHold(value) {
        //console.log(`isMouseHold set to: ${value}`);
        this._isMouseHold = value;
    },
    get isMouseHold() {
        return this._isMouseHold;
    },
    _isMouseHold: false,
    mouseDownStartTime: null,
    HOLD_THRESH: 200,
    holdCallback: null,
    // Swipe hold tracking
    lastSwipeTime: 0,
    lastSwipeDirection: null,
    swipeHoldActive: false,
    swipeHoldRepeating: false, // Track if we're in repeat mode yet
};
window.addEventListener("keyup", function (event) {
    exports.Input.onKeyup(event);
}, false);
window.addEventListener("keydown", function (event) {
    exports.Input.onKeydown(event);
}, false);
/**

window.addEventListener(
  "touchstart",
  function (event) {
    Input.handleTouchStart(event);
  },
  false,
);

window.addEventListener(
  "touchend",
  function (event) {
    Input.handleTouchEnd(event);
  },
  false,
);
*/
window.document
    .getElementById("gameCanvas")
    .addEventListener("mousemove", (event) => exports.Input.updateMousePos(event), false);
window.document
    .getElementById("gameCanvas")
    .addEventListener("mousedown", (event) => exports.Input.handleMouseDown(event), false);
window.document
    .getElementById("gameCanvas")
    .addEventListener("mouseup", (event) => exports.Input.handleMouseUp(event), false);
window.document
    .getElementById("gameCanvas")
    .addEventListener("contextmenu", (event) => event.preventDefault(), false);
/**
window.document
  .getElementById("gameCanvas")
  .addEventListener(
    "touchstart",
    (event) => Input.handleTouchStart(event),
    false,
  );
window.document
  .getElementById("gameCanvas")
  .addEventListener("touchend", (event) => Input.handleTouchEnd(event), false);
  */


/***/ }),

/***/ "./src/game/stats.ts":
/*!***************************!*\
  !*** ./src/game/stats.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.statsTracker = void 0;
const eventBus_1 = __webpack_require__(/*! ../event/eventBus */ "./src/event/eventBus.ts");
const events_1 = __webpack_require__(/*! ../event/events */ "./src/event/events.ts");
class StatsTracker {
    constructor() {
        this.stats = {
            enemiesKilled: 0,
            damageDone: 0,
            damageTaken: 0,
            turnsPassed: 0,
            coinsCollected: 0,
            itemsCollected: 0,
            enemies: [],
            xp: 0,
            level: 1,
        };
        this.handleEnemyKilled = (payload) => {
            this.stats.enemiesKilled += 1;
            this.stats.enemies.push(payload.enemyId);
            this.stats.xp += payload.xp;
            this.stats.level = Math.floor(this.stats.xp / 100) + 1;
            //console.log(`Enemy killed: ${payload.enemyId}`);
        };
        this.handleDamageDone = (payload) => {
            this.stats.damageDone += payload.amount;
            //console.log(`Damage done: ${payload.amount}`);
        };
        this.handleDamageTaken = (payload) => {
            this.stats.damageTaken += payload.amount;
            //console.log(`Damage taken: ${payload.amount}`);
        };
        this.handleTurnPassed = () => {
            this.stats.turnsPassed += 1;
            //console.log(`Turn passed: ${this.stats.turnsPassed}`);
        };
        this.handleCoinCollected = (payload) => {
            this.stats.coinsCollected += payload.amount;
            //console.log(`Coins collected: ${payload.amount}`);
        };
        this.handleItemCollected = (payload) => {
            this.stats.itemsCollected += 1;
            //console.log(`Item collected: ${payload.itemId}`);
        };
        this.initializeListeners();
    }
    initializeListeners() {
        eventBus_1.globalEventBus.on(events_1.EVENTS.ENEMY_KILLED, this.handleEnemyKilled);
        eventBus_1.globalEventBus.on(events_1.EVENTS.DAMAGE_DONE, this.handleDamageDone);
        eventBus_1.globalEventBus.on(events_1.EVENTS.DAMAGE_TAKEN, this.handleDamageTaken);
        eventBus_1.globalEventBus.on(events_1.EVENTS.TURN_PASSED, this.handleTurnPassed);
        eventBus_1.globalEventBus.on(events_1.EVENTS.COIN_COLLECTED, this.handleCoinCollected);
        eventBus_1.globalEventBus.on(events_1.EVENTS.ITEM_COLLECTED, this.handleItemCollected);
    }
    getStats() {
        return this.stats;
    }
    getXp() {
        return this.stats.xp;
    }
    resetStats() {
        this.stats = {
            enemiesKilled: 0,
            damageDone: 0,
            damageTaken: 0,
            turnsPassed: 0,
            coinsCollected: 0,
            itemsCollected: 0,
            enemies: [],
            xp: 0,
            level: 1,
        };
        //console.log("Stats have been reset.");
    }
}
exports.statsTracker = new StatsTracker();


/***/ }),

/***/ "./src/game/textbox.ts":
/*!*****************************!*\
  !*** ./src/game/textbox.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TextBox = void 0;
const eventBus_1 = __webpack_require__(/*! ../event/eventBus */ "./src/event/eventBus.ts");
class TextBox {
    constructor(element) {
        this.allowedCharacters = "all";
        this.message = "";
        this.currentMessageIndex = -1;
        this.MAX_HISTORY = 50;
        this.handleKeyPress = (key) => {
            const fontHas = "abcdefghijklmnopqrstuvwxyz1234567890,.!?:'()[]%-/ ".split("");
            if (key.length === 1) {
                key = key.toLowerCase();
                if (fontHas.includes(key)) {
                    if (this.allowedCharacters === "all" ||
                        this.allowedCharacters.includes(key)) {
                        this.text =
                            this.text.substring(0, this.cursor) +
                                key +
                                this.text.substring(this.cursor, this.text.length);
                        this.cursor += 1;
                        this.updateElement();
                        this.message =
                            this.message.substring(0, this.cursor - 1) +
                                key +
                                this.message.substring(this.cursor - 1, this.message.length);
                    }
                }
                //console.log(`Current message: "${this.message}"`);
                return;
            }
            else {
                switch (key) {
                    case "Backspace":
                        if (this.cursor > 0) {
                            this.text =
                                this.text.substring(0, this.cursor - 1) +
                                    this.text.substring(this.cursor, this.text.length);
                            this.cursor = Math.max(0, this.cursor - 1);
                            this.updateElement();
                            this.message =
                                this.message.substring(0, this.cursor) +
                                    this.message.substring(this.cursor + 1, this.message.length);
                        }
                        break;
                    case "Delete":
                        if (this.cursor < this.text.length) {
                            this.text =
                                this.text.substring(0, this.cursor) +
                                    this.text.substring(this.cursor + 1, this.text.length);
                            this.updateElement();
                            this.message =
                                this.message.substring(0, this.cursor) +
                                    this.message.substring(this.cursor + 1, this.message.length);
                        }
                        break;
                    case "ArrowLeft":
                        this.cursor = Math.max(0, this.cursor - 1);
                        this.updateCursorPosition();
                        break;
                    case "ArrowRight":
                        this.cursor = Math.min(this.text.length, this.cursor + 1);
                        this.updateCursorPosition();
                        break;
                    case "ArrowUp":
                        if (this.sentMessages.length > 0 &&
                            this.currentMessageIndex < this.sentMessages.length - 1) {
                            this.currentMessageIndex++;
                            this.text =
                                this.sentMessages[this.sentMessages.length - 1 - this.currentMessageIndex];
                            this.updateElement();
                            this.message = this.text;
                        }
                        break;
                    case "ArrowDown":
                        if (this.currentMessageIndex > 0) {
                            this.currentMessageIndex--;
                            this.text =
                                this.sentMessages[this.sentMessages.length - 1 - this.currentMessageIndex];
                            this.updateElement();
                            this.message = this.text;
                        }
                        else if (this.currentMessageIndex === 0) {
                            this.currentMessageIndex = -1;
                            this.clear();
                        }
                        break;
                    case "Enter":
                        this.sendMessage();
                        this.escapeCallback();
                        break;
                    case "Escape":
                        this.escapeCallback();
                        break;
                }
            }
            //console.log(`Current message: "${this.message}"`);
        };
        this.handleTouchStart = (e) => {
            this.focus();
            e.preventDefault();
        };
        this.text = "";
        this.cursor = 0;
        this.enterCallback = () => { };
        this.escapeCallback = () => { };
        this.element = element;
        this.sentMessages = [];
        //this.element.addEventListener("touchstart", this.handleTouchStart);
    }
    setEnterCallback(callback) {
        this.enterCallback = callback;
    }
    setEscapeCallback(callback) {
        this.escapeCallback = callback;
    }
    clear() {
        this.text = "";
        this.cursor = 0;
        this.message = "";
        this.updateElement();
    }
    focus() {
        // Create a temporary input element to trigger the on-screen keyboard
        const tempInput = document.createElement("input");
        tempInput.type = "text";
        tempInput.style.position = "absolute";
        tempInput.style.opacity = "0";
        tempInput.style.zIndex = "-1"; // Ensure it doesn't interfere with the game UI
        document.body.appendChild(tempInput);
        tempInput.focus();
        tempInput.addEventListener("blur", () => {
            document.body.removeChild(tempInput);
        });
    }
    sendMessage() {
        let message = this.message.trim();
        if (message) {
            // Add the new message to the history
            this.sentMessages.push(message);
            // Ensure the history size doesn't exceed the maximum limit
            if (this.sentMessages.length > this.MAX_HISTORY) {
                this.sentMessages.shift(); // Remove the oldest message
            }
            eventBus_1.globalEventBus.emit("ChatMessageSent", message);
            console.log(this.sentMessages);
            this.enterCallback();
            if (message.startsWith("/")) {
                message = message.substring(1);
                eventBus_1.globalEventBus.emit("ChatCommand", message);
            }
            this.clear();
            // Reset the navigation index
            this.currentMessageIndex = -1;
        }
    }
    updateElement() {
        // Update the HTML element with the current text
        // Modify to handle multiple lines if necessary
        this.element.textContent = this.text;
        // Optionally, update cursor position in the UI
    }
    updateCursorPosition() {
        // Implement cursor position update in the UI if necessary
    }
}
exports.TextBox = TextBox;


/***/ }),

/***/ "./src/globalStateManager/IdGenerator.ts":
/*!***********************************************!*\
  !*** ./src/globalStateManager/IdGenerator.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IdGenerator = void 0;
/**
 * Global, monotonic ID generator.
 * ------------------------------------------------------------------
 * • Uses a 64-bit counter encoded in base-36 for compact, url-safe IDs.
 * • Optional prefix lets you create type hints: "IT-abc" for items,
 *   "EN-def" for entities, etc.  All prefixes still share one namespace.
 * • Keeps an in-memory registry so any accidental duplication throws
 *   immediately—very useful during integration and debugging.
 * ------------------------------------------------------------------
 */
class IdGenerator {
    /**
     * Generate a fresh globally-unique ID.
     * @param prefix Optional type prefix, e.g. "IT" for Item.
     */
    static generate(prefix = "") {
        let id;
        // Loop is almost always single-pass; guarantees collision-free result.
        do {
            const raw = (this._next++).toString(36); // base-36 for brevity
            id = prefix ? `${prefix}-${raw}` : raw;
        } while (this._registry.has(id));
        this._registry.add(id);
        return id;
    }
    /**
     * Reserve an existing ID during deserialization.
     * Throws if that ID is already in use for this session.
     */
    static reserve(existingId) {
        if (this._registry.has(existingId)) {
            throw new Error(`Duplicate ID detected while reserving: ${existingId}`);
        }
        this._registry.add(existingId);
    }
    /** Quick check: has the ID been claimed already? */
    static isReserved(id) {
        return this._registry.has(id);
    }
    /**
     * Reset generator and registry—intended only for automated tests.
     */
    static resetForTest() {
        this._next = BigInt(1);
        this._registry.clear();
    }
}
exports.IdGenerator = IdGenerator;
/** Next numeric value to assign (BigInt for 64-bit range). */
IdGenerator._next = BigInt(1);
/** Registry of every ID produced or reserved this session. */
IdGenerator._registry = new Set();


/***/ }),

/***/ "./src/gui/guiButton.ts":
/*!******************************!*\
  !*** ./src/gui/guiButton.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.guiButton = void 0;
const sound_1 = __webpack_require__(/*! ../sound/sound */ "./src/sound/sound.ts");
const muteButton_1 = __webpack_require__(/*! ./muteButton */ "./src/gui/muteButton.ts");
class guiButton {
    constructor(x, y, width, height, text, onClick, toggleable = false, parent) {
        // Add a method to update the button's own text based on mute state
        this.toggleMuteText = () => {
            // 'this' refers to the guiButton instance
            muteButton_1.MuteButton.toggleMute();
            this.text = sound_1.Sound.audioMuted ? "Sound Muted" : "Sound Unmuted";
            this.parent.player.game.pushMessage(this.text);
        };
        this.toggleable = toggleable;
        this.toggled = false;
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
        this.text = text;
        this.onClick = onClick;
        this.parent = parent;
    }
}
exports.guiButton = guiButton;


/***/ }),

/***/ "./src/gui/hoverText.ts":
/*!******************************!*\
  !*** ./src/gui/hoverText.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HoverText = void 0;
const game_1 = __webpack_require__(/*! ../game */ "./src/game.ts");
const gameConstants_1 = __webpack_require__(/*! ../game/gameConstants */ "./src/game/gameConstants.ts");
const input_1 = __webpack_require__(/*! ../game/input */ "./src/game/input.ts");
class HoverText {
    static getHoverText(x, y, room, player) {
        // Handle undefined mouse coordinates
        if (input_1.Input.mouseX === undefined || input_1.Input.mouseY === undefined) {
            return [];
        }
        // Get screen center coordinates
        const screenCenterX = gameConstants_1.GameConstants.WIDTH / 2;
        const screenCenterY = gameConstants_1.GameConstants.HEIGHT / 2;
        // Convert pixel offset to tile offset
        const tileOffsetX = Math.floor((input_1.Input.mouseX - screenCenterX + gameConstants_1.GameConstants.TILESIZE / 2) /
            gameConstants_1.GameConstants.TILESIZE);
        const tileOffsetY = Math.floor((input_1.Input.mouseY - screenCenterY + gameConstants_1.GameConstants.TILESIZE / 2) /
            gameConstants_1.GameConstants.TILESIZE);
        const offsetX = x + tileOffsetX;
        const offsetY = y + tileOffsetY;
        const strings = [];
        for (const entity of room.entities) {
            if (entity.x === offsetX && entity.y === offsetY) {
                strings.push(entity.hoverText());
            }
        }
        for (const item of room.items) {
            if (item.x === offsetX && item.y === offsetY) {
                strings.push(item.hoverText());
            }
        }
        const tile = room.getTile(offsetX, offsetY);
        if (tile) {
            strings.push(tile.getName());
        }
        return strings;
    }
    static draw(delta, x, y, room, player) {
        const strings = HoverText.getHoverText(x, y, room, player);
        if (strings.length === 0) {
            return;
        }
        game_1.Game.ctx.save();
        for (const string of strings) {
            const offsetY = strings.indexOf(string) * 6;
            game_1.Game.ctx.fillStyle = "yellow";
            game_1.Game.ctx.globalAlpha = 0.1;
            game_1.Game.fillText(string, 1, 20 + offsetY);
        }
        game_1.Game.ctx.restore();
    }
}
exports.HoverText = HoverText;


/***/ }),

/***/ "./src/gui/map.ts":
/*!************************!*\
  !*** ./src/gui/map.ts ***!
  \************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Map = void 0;
const game_1 = __webpack_require__(/*! ../game */ "./src/game.ts");
const gameConstants_1 = __webpack_require__(/*! ../game/gameConstants */ "./src/game/gameConstants.ts");
const room_1 = __webpack_require__(/*! ../room/room */ "./src/room/room.ts");
const entity_1 = __webpack_require__(/*! ../entity/entity */ "./src/entity/entity.ts");
class Map {
    constructor(game, player) {
        this.mapData = [];
        this.oldMapData = [];
        this.offsetX = 0;
        this.offsetY = 0;
        this.softOffsetX = 0;
        this.softOffsetY = 0;
        // Fog of war properties - now stored per mapGroup
        this.seenTilesByMapGroup = new globalThis.Map();
        this.visibilityRadius = 4;
        // Add helper method to collect down ladders from room array
        this.getDownLaddersFromRoom = (room) => {
            const downLadders = [];
            // Safely iterate through the room array to find down ladders
            if (room.roomArray) {
                for (let x = room.roomX; x < room.roomX + room.width; x++) {
                    for (let y = room.roomY; y < room.roomY + room.height; y++) {
                        // Check bounds to avoid undefined access
                        if (room.roomArray[x] && room.roomArray[x][y]) {
                            const tile = room.roomArray[x][y];
                            // Check if tile is a DownLadder instance
                            if (tile &&
                                tile.constructor &&
                                tile.constructor.name === "DownLadder") {
                                downLadders.push(tile);
                            }
                        }
                    }
                }
            }
            return downLadders;
        };
        this.saveMapData = () => {
            this.clearMap();
            const currentMapGroup = this.game.room.mapGroup.toString();
            for (const room of this.game.levels[this.player.depth].rooms) {
                if (currentMapGroup === room.mapGroup.toString() &&
                    (room.entered === true || gameConstants_1.GameConstants.DEVELOPER_MODE)) {
                    this.mapData.push({
                        room: room,
                        walls: room.innerWalls,
                        doors: room.doors,
                        entities: room.entities,
                        items: room.items,
                        players: this.game.players,
                        downLadders: this.getDownLaddersFromRoom(room),
                        seenTiles: this.seenTilesByMapGroup.get(currentMapGroup) || new Set(), // Add seen tiles to map data
                    });
                }
            }
            const enteredRooms = this.mapData
                .map((data) => data.room)
                .filter((room) => room.entered);
            if (enteredRooms.length > 0) {
                const sortedByX = [...enteredRooms].sort((a, b) => a.roomX - b.roomX);
                const sortedByY = [...enteredRooms].sort((a, b) => a.roomY - b.roomY);
                const maxX = sortedByX[sortedByX.length - 1].roomX;
                const minY = sortedByY[0].roomY;
                this.offsetX = maxX;
                this.offsetY = minY;
            }
            else {
                this.offsetX = 0;
                this.offsetY = 0;
            }
        };
        this.clearMap = () => {
            this.mapData = [];
        };
        this.saveOldMap = () => {
            this.oldMapData = [...this.mapData];
        };
        this.renderMap = (delta) => {
            game_1.Game.ctx.save(); // Save the current canvas state
            this.setInitialCanvasSettings(1);
            this.translateCanvas(0);
            for (const data of this.mapData) {
                this.drawRoom(data, delta);
            }
            /*for (const data of this.oldMapData) {
              this.drawRoom(data);
            }*/
            this.resetCanvasTransform();
            game_1.Game.ctx.restore(); // Restore the canvas state
        };
        this.updateOffsetXY = () => {
            let diffX = this.offsetX - this.softOffsetX;
            let diffY = this.offsetY - this.softOffsetY;
            if (Math.abs(diffX) > 0.01) {
                this.softOffsetX += diffX * 0.1;
                this.softOffsetX = this.softOffsetX;
            }
            else
                this.softOffsetX = this.offsetX;
            if (Math.abs(diffY) > 0.01) {
                this.softOffsetY += diffY * 0.1;
                this.softOffsetY = this.softOffsetY;
            }
            else
                this.softOffsetY = this.offsetY;
        };
        // Fog of war methods
        this.updateSeenTiles = () => {
            const playerX = Math.floor(this.player.x);
            const playerY = Math.floor(this.player.y);
            const currentMapGroup = this.game.room.mapGroup.toString();
            // Get or create seen tiles set for current map group
            if (!this.seenTilesByMapGroup.has(currentMapGroup)) {
                this.seenTilesByMapGroup.set(currentMapGroup, new Set());
            }
            const seenTiles = this.seenTilesByMapGroup.get(currentMapGroup);
            // Add tiles within circular radius around player to seen tiles
            for (let dx = -this.visibilityRadius; dx <= this.visibilityRadius; dx++) {
                for (let dy = -this.visibilityRadius; dy <= this.visibilityRadius; dy++) {
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    if (distance <= this.visibilityRadius) {
                        const tileKey = `${playerX + dx},${playerY + dy}`;
                        seenTiles.add(tileKey);
                    }
                }
            }
        };
        this.isTileSeen = (x, y) => {
            const currentMapGroup = this.game.room.mapGroup.toString();
            const seenTiles = this.seenTilesByMapGroup.get(currentMapGroup);
            if (!seenTiles)
                return false;
            const tileKey = `${Math.floor(x)},${Math.floor(y)}`;
            return seenTiles.has(tileKey);
        };
        this.draw = (delta) => {
            this.updateSeenTiles(); // Update fog of war
            this.updateOffsetXY();
            this.renderMap(delta);
        };
        this.setInitialCanvasSettings = (alpha) => {
            game_1.Game.ctx.globalAlpha = alpha;
            game_1.Game.ctx.globalCompositeOperation = "source-over";
        };
        this.translateCanvas = (offset) => {
            game_1.Game.ctx.translate(Math.floor(0.95 * gameConstants_1.GameConstants.WIDTH) -
                //this.game.room.roomX -
                //Math.floor(0.5 * this.game.room.width) +
                15 * this.scale -
                Math.floor(this.softOffsetX), Math.floor(0.05 * gameConstants_1.GameConstants.HEIGHT) -
                //this.game.room.roomY -
                //Math.floor(0.5 * this.game.room.height) -
                1 * this.scale -
                offset -
                Math.floor(this.softOffsetY));
        };
        this.drawRoom = (data, delta) => {
            //this.drawUnderRoomPlayers(data.players, delta);
            this.drawRoomOutline(data.room);
            this.drawRoomWalls(data.walls);
            this.drawRoomDoors(data.doors);
            this.drawRoomEntities(data.entities);
            this.drawRoomItems(data.items);
            this.drawRoomPlayers(data.players, delta);
            this.drawRoomDownLadders(data.downLadders);
            // Render fog of war on top of everything
            this.drawFogOfWar(data.room);
        };
        // Add fog of war overlay method
        this.drawFogOfWar = (room) => {
            const s = this.scale;
            game_1.Game.ctx.save();
            game_1.Game.ctx.fillStyle = "#1a1a1a";
            // Use the seen tiles from the current mapData if available
            const currentMapGroup = this.game.room.mapGroup.toString();
            let seenTiles = this.seenTilesByMapGroup.get(currentMapGroup);
            // If we have mapData, use the seen tiles from there (for consistency)
            if (this.mapData.length > 0 && this.mapData[0].seenTiles) {
                seenTiles = this.mapData[0].seenTiles;
            }
            // Draw fog over all tiles in the room that haven't been seen
            for (let x = room.roomX; x < room.roomX + room.width; x++) {
                for (let y = room.roomY; y < room.roomY + room.height; y++) {
                    const tileKey = `${Math.floor(x)},${Math.floor(y)}`;
                    if (!seenTiles || !seenTiles.has(tileKey)) {
                        game_1.Game.ctx.fillRect(x * s, y * s, 1 * s, 1 * s);
                    }
                }
            }
            game_1.Game.ctx.restore();
        };
        this.drawRoomOutline = (level) => {
            const s = this.scale;
            game_1.Game.ctx.fillStyle = "#5A5A5A";
            game_1.Game.ctx.fillRect(level.roomX * s + 0, level.roomY * s + 0, level.width * s - 0, level.height * s - 0);
            if (level.type === room_1.RoomType.UPLADDER)
                game_1.Game.ctx.fillStyle = "#101460";
            if (level.type === room_1.RoomType.DOWNLADDER)
                game_1.Game.ctx.fillStyle = "#601410";
            game_1.Game.ctx.fillStyle = "black";
            game_1.Game.ctx.fillRect(level.roomX * s + 1, level.roomY * s + 1, level.width * s - 2, level.height * s - 2);
        };
        this.drawRoomWalls = (walls) => {
            const s = this.scale;
            game_1.Game.ctx.save(); // Save the current canvas state
            for (const wall of walls) {
                game_1.Game.ctx.fillStyle = "#404040";
                game_1.Game.ctx.fillRect(wall.x * s, wall.y * s, 1 * s, 1 * s);
            }
            game_1.Game.ctx.restore(); // Restore the canvas state
        };
        this.drawRoomDoors = (doors) => {
            const s = this.scale;
            game_1.Game.ctx.save(); // Save the current canvas state
            for (const door of doors) {
                if (door.opened === false)
                    game_1.Game.ctx.fillStyle = "#5A5A5A";
                if (door.opened === true) {
                    game_1.Game.ctx.fillStyle = "black";
                    game_1.Game.ctx.fillRect(door.x * s, door.y * s, 1 * s, 1 * s);
                }
                game_1.Game.ctx.fillStyle = "#5A5A5A"; // Reset to default after each door
            }
            game_1.Game.ctx.restore(); // Restore the canvas state
        };
        this.drawRoomPlayers = (players, delta) => {
            const s = this.scale;
            game_1.Game.ctx.save(); // Save the current canvas state
            for (const i in players) {
                game_1.Game.ctx.fillStyle = "white";
                if (this.game.levels[players[i].depth].rooms[players[i].levelID]
                    .mapGroup === this.game.room.mapGroup) {
                    game_1.Game.ctx.fillRect(players[i].x * s, players[i].y * s, 1 * s, 1 * s);
                }
            }
            game_1.Game.ctx.restore(); // Restore the canvas state
        };
        this.drawUnderRoomPlayers = (players, delta) => {
            const s = this.scale;
            game_1.Game.ctx.save(); // Save the current canvas state
            for (const i in players) {
                this.game.rooms[players[i].levelID].mapGroup === this.game.room.mapGroup;
                {
                    if (Math.floor(Date.now() / 300) % 2) {
                        game_1.Game.ctx.fillStyle = "#4D8C8C";
                        // Draw 3x3 outline box around player
                        game_1.Game.ctx.fillRect((players[i].x - 1) * s, (players[i].y - 1) * s, 1 * s, 1 * s); // Top left
                        game_1.Game.ctx.fillRect(players[i].x * s, (players[i].y - 1) * s, 1 * s, 1 * s); // Top middle
                        game_1.Game.ctx.fillRect((players[i].x + 1) * s, (players[i].y - 1) * s, 1 * s, 1 * s); // Top right
                        game_1.Game.ctx.fillRect((players[i].x - 1) * s, players[i].y * s, 1 * s, 1 * s); // Middle left
                        game_1.Game.ctx.fillRect((players[i].x + 1) * s, players[i].y * s, 1 * s, 1 * s); // Middle right
                        game_1.Game.ctx.fillRect((players[i].x - 1) * s, (players[i].y + 1) * s, 1 * s, 1 * s); // Bottom left
                        game_1.Game.ctx.fillRect(players[i].x * s, (players[i].y + 1) * s, 1 * s, 1 * s); // Bottom middle
                        game_1.Game.ctx.fillRect((players[i].x + 1) * s, (players[i].y + 1) * s, 1 * s, 1 * s); // Bottom right
                    }
                }
            }
            game_1.Game.ctx.restore(); // Restore the canvas state
        };
        this.drawRoomEntities = (entities) => {
            const s = this.scale;
            game_1.Game.ctx.save(); // Save the current canvas state
            for (const enemy of entities) {
                this.setEntityColor(enemy);
                game_1.Game.ctx.fillRect(enemy.x * s, enemy.y * s, 1 * s, 1 * s);
            }
            game_1.Game.ctx.restore(); // Restore the canvas state
        };
        this.drawRoomDownLadders = (downLadders) => {
            const s = this.scale;
            game_1.Game.ctx.save(); // Save the current canvas state
            for (const downLadder of downLadders) {
                game_1.Game.ctx.fillStyle = "#00FFFF";
                game_1.Game.ctx.fillRect(downLadder.x * s, downLadder.y * s, 1 * s, 1 * s);
            }
            game_1.Game.ctx.restore(); // Restore the canvas state
        };
        this.setEntityColor = (enemy) => {
            // No need to save/restore here as only fillStyle is being set
            if (enemy.type === entity_1.EntityType.ENEMY) {
                game_1.Game.ctx.fillStyle = "yellow";
            }
            if (enemy.type === entity_1.EntityType.PROP) {
                game_1.Game.ctx.fillStyle = "#847e87";
            }
            if (enemy.type === entity_1.EntityType.RESOURCE) {
                game_1.Game.ctx.fillStyle = "#5a595b";
            }
            if (enemy.type === entity_1.EntityType.FRIENDLY) {
                game_1.Game.ctx.fillStyle = "cyan";
            }
        };
        this.drawRoomItems = (items) => {
            const s = this.scale;
            game_1.Game.ctx.save(); // Save the current canvas state
            for (const item of items) {
                let x = item.x;
                let y = item.y;
                game_1.Game.ctx.fillStyle = "#ac3232";
                if (!item.pickedUp) {
                    game_1.Game.ctx.fillRect(item.x * s, item.y * s, 1 * s, 1 * s);
                }
            }
            game_1.Game.ctx.restore(); // Restore the canvas state
        };
        this.resetCanvasTransform = () => {
            game_1.Game.ctx.setTransform(1, 0, 0, 1, 0, 0);
        };
        this.game = game;
        this.scale = 1;
        this.player = player;
        //this.depth = player.game.level.depth
    }
}
exports.Map = Map;


/***/ }),

/***/ "./src/gui/menu.ts":
/*!*************************!*\
  !*** ./src/gui/menu.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Menu = void 0;
const game_1 = __webpack_require__(/*! ../game */ "./src/game.ts");
const guiButton_1 = __webpack_require__(/*! ./guiButton */ "./src/gui/guiButton.ts");
const input_1 = __webpack_require__(/*! ../game/input */ "./src/game/input.ts");
const gameConstants_1 = __webpack_require__(/*! ../game/gameConstants */ "./src/game/gameConstants.ts");
const mouseCursor_1 = __webpack_require__(/*! ../gui/mouseCursor */ "./src/gui/mouseCursor.ts");
class Menu {
    constructor(player) {
        this.selectionTimeoutId = null;
        // Add debouncing properties
        this.lastButtonClickTime = 0;
        this.lastButtonClickIndex = -1;
        this.BUTTON_CLICK_DEBOUNCE_TIME = 150; // milliseconds
        // Action methods
        this.startGame = () => {
            this.close();
            // Implement game start logic
        };
        this.exitGame = () => {
            // Implement exit game logic
        };
        this.openSettings = () => {
            // Implement settings logic later
        };
        this.scaleUp = () => {
            this.player.game.increaseScale();
            // Add scale up functionality here
        };
        this.scaleDown = () => {
            this.player.game.decreaseScale();
            // Add scale down functionality here
        };
        this.buttons = [];
        this.open = false;
        this.selectedButton = 0;
        this.initializeCloseButton();
        this.initializeMainMenu();
        this.player = player;
    }
    static drawOpenMenuButton() {
        game_1.Game.ctx.save();
        game_1.Game.ctx.fillStyle = "rgba(255, 255, 0, 1)";
        game_1.Game.ctx.globalAlpha = 0.1;
        // Position in top right corner, 2 tiles away from right edge
        const buttonWidth = Math.round(gameConstants_1.GameConstants.TILESIZE * 1.5 - 2);
        const buttonHeight = Math.round(gameConstants_1.GameConstants.TILESIZE / 2 - 1);
        const rightMargin = 2 * gameConstants_1.GameConstants.TILESIZE; // 2 tiles from right edge
        const buttonX = gameConstants_1.GameConstants.WIDTH / 2;
        const buttonY = gameConstants_1.GameConstants.TILESIZE / 2;
        game_1.Game.drawFX(18, 0, 1, 1, 0, 0.5, 1, 1);
        //Game.ctx.fillRect(buttonX, buttonY, buttonWidth, buttonHeight);
        game_1.Game.ctx.globalAlpha = 1;
        game_1.Game.ctx.fillStyle = "rgb(0, 0, 0)"; //yellow text
        //Game.fillText("Menu", buttonX + 1, buttonY + 1);
        game_1.Game.ctx.restore();
    }
    initializeCloseButton() {
        // Match the menu button dimensions
        const buttonWidth = Math.round(gameConstants_1.GameConstants.TILESIZE * 1.5 - 2);
        const buttonHeight = Math.round(gameConstants_1.GameConstants.TILESIZE * 1.5 - 2);
        this.closeButton = new guiButton_1.guiButton(0, -1, Math.round(buttonWidth), Math.round(buttonHeight), "X", () => this.close(), false, this);
    }
    initializeMainMenu() {
        // Don't set fixed dimensions - let positionButtons() calculate optimal sizes
        //this.addButton(new guiButton(0, 0, 0, 0, "Start Game", this.startGame));
        //this.addButton(new guiButton(0, 0, 0, 0, "Settings", this.openSettings));
        this.addButton(new guiButton_1.guiButton(0, 0, 0, 0, "- Scale", this.scaleDown, false, this));
        this.addButton(new guiButton_1.guiButton(0, 0, 0, 0, "+ Scale", this.scaleUp, false, this));
        const muteButton = new guiButton_1.guiButton(0, 0, 0, 0, "Mute Sound", () => { }, false, this);
        muteButton.onClick = muteButton.toggleMuteText;
        this.addButton(muteButton);
        //this.addButton(new guiButton(0, 0, 0, 0, "Exit", this.exitGame));
        this.positionButtons();
    }
    addButton(button) {
        this.buttons.push(button);
    }
    draw() {
        if (this.open) {
            game_1.Game.ctx.save();
            game_1.Game.ctx.fillStyle = "rgba(0, 0, 0, 0.5)";
            game_1.Game.ctx.fillRect(0, 0, gameConstants_1.GameConstants.WIDTH, gameConstants_1.GameConstants.HEIGHT);
            // Draw main menu buttons
            this.buttons.forEach((button) => {
                this.drawButton(button);
            });
            // Draw close button
            this.drawCloseButton();
            game_1.Game.ctx.restore();
        }
    }
    drawButton(button) {
        game_1.Game.ctx.save();
        game_1.Game.ctx.imageSmoothingEnabled = false;
        // Clear any stroke settings to prevent unwanted outlines
        game_1.Game.ctx.strokeStyle = "transparent";
        game_1.Game.ctx.lineWidth = 0;
        game_1.Game.ctx.fillStyle =
            this.selectedButton === this.buttons.indexOf(button)
                ? "rgba(75, 75, 75, 1)"
                : "rgba(100, 100, 100, 1)";
        // Round coordinates to prevent anti-aliasing outlines
        game_1.Game.ctx.fillRect(Math.round(button.x), Math.round(button.y), Math.round(button.width), Math.round(button.height));
        game_1.Game.ctx.fillStyle = "rgba(0, 0, 0, 1)";
        const textWidth = game_1.Game.measureText(button.text).width;
        const textX = button.x + (button.width - textWidth) / 2;
        // Center text vertically in the button, accounting for varying button heights
        const textY = button.y + button.height / 2 - game_1.Game.letter_height / 2;
        game_1.Game.fillText(button.text, Math.round(textX), Math.round(textY));
        game_1.Game.ctx.restore();
    }
    drawCloseButton() {
        game_1.Game.ctx.save();
        game_1.Game.ctx.imageSmoothingEnabled = false;
        // Close button styling - make it red-ish for better visibility
        game_1.Game.ctx.fillStyle = "rgba(220, 60, 60, 1)"; // Red background
        game_1.Game.ctx.fillRect(Math.round(this.closeButton.x), Math.round(this.closeButton.y), Math.round(this.closeButton.width), Math.round(this.closeButton.height));
        // Border for the close button
        game_1.Game.ctx.strokeStyle = "rgba(0, 0, 0, 1)";
        game_1.Game.ctx.lineWidth = 1;
        game_1.Game.ctx.strokeRect(this.closeButton.x, this.closeButton.y, this.closeButton.width, this.closeButton.height);
        // Draw X text
        game_1.Game.ctx.fillStyle = "rgba(255, 255, 255, 1)"; // White X
        const textWidth = game_1.Game.measureText(this.closeButton.text).width;
        const textX = this.closeButton.x + (this.closeButton.width - textWidth) / 2;
        const textY = this.closeButton.y + this.closeButton.height / 2 - game_1.Game.letter_height / 2;
        game_1.Game.fillText(this.closeButton.text, textX, textY);
        game_1.Game.ctx.restore();
    }
    inputHandler(input) {
        if (!this.open)
            return;
        switch (input) {
            case input_1.InputEnum.ESCAPE:
                this.open = false;
                break;
            case input_1.InputEnum.UP:
                this.up();
                break;
            case input_1.InputEnum.DOWN:
                this.down();
                break;
            case input_1.InputEnum.SPACE:
                this.select();
                break;
            case input_1.InputEnum.LEFT_CLICK:
                // Handle mouse clicks by getting current mouse position and calling mouseInputHandler
                const { x, y } = mouseCursor_1.MouseCursor.getInstance().getPosition();
                this.mouseInputHandler(x, y);
                break;
            case input_1.InputEnum.RIGHT_CLICK:
                // Handle right clicks if needed (for now just log)
                break;
            default:
                break;
        }
    }
    mouseInputHandler(x, y) {
        if (!this.open) {
            return;
        }
        // Check close button first
        if (this.isPointInCloseButton(x, y)) {
            // Add debouncing for close button too
            const currentTime = Date.now();
            if (currentTime - this.lastButtonClickTime <
                this.BUTTON_CLICK_DEBOUNCE_TIME) {
                return;
            }
            this.lastButtonClickTime = currentTime;
            this.closeButton.onClick();
            return;
        }
        // Check main menu buttons
        const bounds = this.isPointInMenuBounds(x, y);
        if (bounds.inBounds && bounds.buttonIndex >= 0) {
            const button = this.buttons[bounds.buttonIndex];
            const currentTime = Date.now();
            // Debounce check: prevent multiple rapid clicks on the same button
            if (bounds.buttonIndex === this.lastButtonClickIndex &&
                currentTime - this.lastButtonClickTime < this.BUTTON_CLICK_DEBOUNCE_TIME) {
                return; // Ignore this click as it's too soon after the last one
            }
            // Update debounce tracking
            this.lastButtonClickTime = currentTime;
            this.lastButtonClickIndex = bounds.buttonIndex;
            // Clear any existing timeout
            if (this.selectionTimeoutId !== null) {
                clearTimeout(this.selectionTimeoutId);
            }
            // Set the selected button for visual feedback
            this.selectedButton = bounds.buttonIndex;
            // Set timeout to reset selection after 100ms
            this.selectionTimeoutId = setTimeout(() => {
                this.selectedButton = -1; // Reset to invalid index so no button appears selected
                this.selectionTimeoutId = null;
            }, 100);
            button.onClick();
        }
    }
    close() {
        this.open = false;
    }
    openMenu() {
        this.open = true;
        this.selectedButton = -1;
        this.buttons.forEach((button, index) => { });
    }
    toggleOpen() {
        if (this.open) {
            this.close();
        }
        else {
            this.openMenu();
        }
    }
    select() {
        if (this.buttons[this.selectedButton]) {
            this.buttons[this.selectedButton].onClick();
        }
    }
    up() {
        if (this.buttons.length > 0) {
            this.selectedButton =
                (this.selectedButton - 1 + this.buttons.length) % this.buttons.length;
        }
    }
    down() {
        if (this.buttons.length > 0) {
            this.selectedButton = (this.selectedButton + 1) % this.buttons.length;
        }
    }
    positionButtons() {
        const screenWidth = gameConstants_1.GameConstants.WIDTH;
        const screenHeight = gameConstants_1.GameConstants.HEIGHT;
        const buttonCount = this.buttons.length;
        // Position close button to match menu button position
        this.closeButton.x = 1;
        this.closeButton.y = gameConstants_1.GameConstants.TILESIZE / 2;
        // Button sizing - make them responsive to screen size
        const maxButtonWidth = Math.min(200, screenWidth * 0.6); // Max 60% of screen width
        // Calculate available space
        const horizontalMargin = (screenWidth - maxButtonWidth) / 2;
        const verticalMargin = 20; // Top and bottom margin
        const availableHeight = screenHeight - verticalMargin * 2;
        // Calculate button slots (scale buttons share one slot)
        const scaleButtonIndices = this.getScaleButtonIndices();
        const buttonSlots = buttonCount - (scaleButtonIndices.length > 0 ? 1 : 0); // Scale buttons share one slot
        const heightPerButtonSlot = availableHeight / buttonSlots;
        // Make each button take up ~80% of its slot, leaving 20% for spacing
        // Add maximum height constraint - reduce by 40% from what could be very tall buttons
        const maxButtonHeight = 30; // Maximum button height in pixels
        const calculatedHeight = Math.floor(heightPerButtonSlot * 0.8);
        const buttonHeight = Math.min(calculatedHeight, maxButtonHeight);
        // Update button dimensions and positions
        let currentSlot = 0;
        for (let i = 0; i < this.buttons.length; i++) {
            const button = this.buttons[i];
            if (button.text === "- Scale" || button.text === "+ Scale") {
                // Handle scale buttons specially - they share one slot side by side
                const isMinusButton = button.text === "- Scale";
                const buttonWidth = Math.floor(maxButtonWidth / 2) - 2; // Split width with small gap
                button.x = horizontalMargin + (isMinusButton ? 0 : buttonWidth + 4);
                button.y =
                    verticalMargin +
                        currentSlot * heightPerButtonSlot +
                        (heightPerButtonSlot - buttonHeight) / 2;
                button.width = buttonWidth;
                button.height = buttonHeight;
                // Only advance slot after both scale buttons are positioned
                if (button.text === "+ Scale") {
                    currentSlot++;
                }
            }
            else {
                // Regular button positioning
                button.x = horizontalMargin;
                button.y =
                    verticalMargin +
                        currentSlot * heightPerButtonSlot +
                        (heightPerButtonSlot - buttonHeight) / 2;
                button.width = maxButtonWidth;
                button.height = buttonHeight;
                currentSlot++;
            }
        }
    }
    getScaleButtonIndices() {
        const indices = [];
        this.buttons.forEach((button, index) => {
            if (button.text === "- Scale" || button.text === "+ Scale") {
                indices.push(index);
            }
        });
        return indices;
    }
    isPointInMenuBounds(x, y) {
        if (!this.open) {
            return { inBounds: false, buttonIndex: -1 };
        }
        for (let i = 0; i < this.buttons.length; i++) {
            const button = this.buttons[i];
            if (x >= button.x &&
                x <= button.x + button.width &&
                y >= button.y &&
                y <= button.y + button.height) {
                return { inBounds: true, buttonIndex: i };
            }
        }
        return { inBounds: false, buttonIndex: -1 };
    }
    isPointInCloseButton(x, y) {
        return (x >= this.closeButton.x &&
            x <= this.closeButton.x + this.closeButton.width &&
            y >= this.closeButton.y &&
            y <= this.closeButton.y + this.closeButton.height);
    }
}
exports.Menu = Menu;


/***/ }),

/***/ "./src/gui/mouseCursor.ts":
/*!********************************!*\
  !*** ./src/gui/mouseCursor.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MouseCursor = void 0;
const game_1 = __webpack_require__(/*! ../game */ "./src/game.ts");
const input_1 = __webpack_require__(/*! ../game/input */ "./src/game/input.ts");
const gameConstants_1 = __webpack_require__(/*! ../game/gameConstants */ "./src/game/gameConstants.ts");
class MouseCursor {
    constructor() {
        this.cursorSize = 5; // Size of the cursor rectangle
        this.clickX = 0;
        this.clickY = 0;
        this.rawClickX = 0;
        this.rawClickY = 0;
        this.tileX = 6;
        this.lastMouseX = 0;
        this.lastMouseY = 0;
        this.posChangeTime = Date.now();
        this.cursorTimeout = 5000;
        this.frame = 0;
        this.setIcon = (icon) => {
            switch (icon) {
                case "arrow":
                    this.tileX = 8;
                    break;
                case "sword":
                    this.tileX = 7;
                    break;
                case "hand":
                    this.tileX = 6;
                    break;
                case "wait":
                    this.tileX = 9;
                    break;
                case "grab":
                    this.tileX = 10;
                    break;
                case "up":
                    this.tileX = 11;
                    break;
                case "right":
                    this.tileX = 12;
                    break;
                case "down":
                    this.tileX = 13;
                    break;
                case "left":
                    this.tileX = 14;
                    break;
                case "mine":
                    this.tileX = 15;
                    break;
            }
        };
        this.draw = (delta, mobile = false) => {
            if (!mobile && Date.now() - this.posChangeTime < this.cursorTimeout)
                this.drawCursor();
            this.drawAnimation(delta);
        };
    }
    static getInstance() {
        if (!MouseCursor.instance) {
            MouseCursor.instance = new MouseCursor();
        }
        return MouseCursor.instance;
    }
    drawCursor() {
        game_1.Game.ctx.save();
        const timeSinceChange = Date.now() - this.posChangeTime;
        const fadeStartTime = this.cursorTimeout - 200; // Start fade 200ms before timeout
        let alpha = 1;
        if (timeSinceChange > fadeStartTime) {
            // Only fade in the last 200ms
            const fadeProgress = (timeSinceChange - fadeStartTime) / 200;
            alpha = 1 - fadeProgress;
        }
        game_1.Game.ctx.globalAlpha = alpha;
        //Game.ctx.fillRect(Input.mouseX, Input.mouseY, 1, 1);
        game_1.Game.drawFX(this.tileX, 0, 1, 1, input_1.Input.mouseX / gameConstants_1.GameConstants.TILESIZE - 8 / gameConstants_1.GameConstants.TILESIZE, input_1.Input.mouseY / gameConstants_1.GameConstants.TILESIZE - 8 / gameConstants_1.GameConstants.TILESIZE, 1, 1);
        game_1.Game.ctx.restore();
    }
    drawAnimation(delta) {
        if (this.frame > 5) {
            //14 is max frame for animation
            return;
        }
        game_1.Game.drawFX(9 + Math.ceil(this.frame), 1, 1, 1, this.clickX / gameConstants_1.GameConstants.TILESIZE - 8 / gameConstants_1.GameConstants.TILESIZE, this.clickY / gameConstants_1.GameConstants.TILESIZE - 8 / gameConstants_1.GameConstants.TILESIZE, 1, 1);
        this.frame = this.frame + delta / 5;
    }
    startClickAnim() {
        this.frame = 0;
        this.clickX = input_1.Input.mouseX;
        this.clickY = input_1.Input.mouseY;
        this.rawClickX = input_1.Input.rawMouseX;
        this.rawClickY = input_1.Input.rawMouseY;
    }
    recalculateClickPosition() {
        if (this.rawClickX !== undefined && this.rawClickY !== undefined) {
            const canvas = document.getElementById("gameCanvas");
            const rect = canvas.getBoundingClientRect();
            this.clickX = Math.floor(this.rawClickX / game_1.Game.scale);
            this.clickY = Math.floor(this.rawClickY / game_1.Game.scale);
        }
    }
    getPosition() {
        if (input_1.Input.mouseX !== this.lastMouseX || input_1.Input.mouseY !== this.lastMouseY) {
            this.posChangeTime = Date.now();
        }
        this.lastMouseX = input_1.Input.mouseX;
        this.lastMouseY = input_1.Input.mouseY;
        return { x: input_1.Input.mouseX, y: input_1.Input.mouseY };
    }
    getTilePosition() {
        return {
            x: Math.floor(input_1.Input.mouseX / gameConstants_1.GameConstants.TILESIZE),
            y: Math.floor(input_1.Input.mouseY / gameConstants_1.GameConstants.TILESIZE),
        };
    }
    getInventoryPosition() {
        return {
            x: input_1.Input.mouseX,
            y: input_1.Input.mouseY,
        };
    }
}
exports.MouseCursor = MouseCursor;


/***/ }),

/***/ "./src/gui/muteButton.ts":
/*!*******************************!*\
  !*** ./src/gui/muteButton.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MuteButton = void 0;
const game_1 = __webpack_require__(/*! ../game */ "./src/game.ts");
const gameConstants_1 = __webpack_require__(/*! ../game/gameConstants */ "./src/game/gameConstants.ts");
const sound_1 = __webpack_require__(/*! ../sound/sound */ "./src/sound/sound.ts");
class MuteButton {
    static draw() {
        const tile = gameConstants_1.GameConstants.TILESIZE;
        game_1.Game.ctx.save();
        game_1.Game.ctx.globalAlpha = 0.1;
        if (sound_1.Sound.audioMuted) {
            game_1.Game.drawFX(17, 0, 1, 1, 0, 0.5, 1, 1);
        }
        else {
            game_1.Game.drawFX(16, 0, 1, 1, 0, 0.5, 1, 1);
        }
        game_1.Game.ctx.restore();
    }
    static toggleMute() {
        sound_1.Sound.toggleMute();
    }
}
exports.MuteButton = MuteButton;


/***/ }),

/***/ "./src/gui/postProcess.ts":
/*!********************************!*\
  !*** ./src/gui/postProcess.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PostProcessor = void 0;
const game_1 = __webpack_require__(/*! ../game */ "./src/game.ts");
const gameConstants_1 = __webpack_require__(/*! ../game/gameConstants */ "./src/game/gameConstants.ts");
class PostProcessor {
}
exports.PostProcessor = PostProcessor;
PostProcessor.settings = {
    enabled: true,
    globalAlpha: 0.15,
    fillStyle: "#006A6E",
    globalCompositeOperation: "screen",
};
PostProcessor.underwater = false;
PostProcessor.draw = (delta) => {
    if (!PostProcessor.settings.enabled)
        return;
    if (PostProcessor.underwater) {
        PostProcessor.settings.globalAlpha = 0.3;
        PostProcessor.settings.fillStyle = "#003B6F"; //deep underwater blue
        PostProcessor.settings.globalCompositeOperation = "source-over";
    }
    game_1.Game.ctx.save();
    game_1.Game.ctx.globalAlpha = PostProcessor.settings.globalAlpha;
    game_1.Game.ctx.globalCompositeOperation =
        PostProcessor.settings.globalCompositeOperation;
    // GameConstants.SHADE_LAYER_COMPOSITE_OPERATION as GlobalCompositeOperation; //"soft-light";
    game_1.Game.ctx.fillStyle = PostProcessor.settings.fillStyle;
    //Game.ctx.fillStyle = "#003B6F"; //deep underwater blue
    //Game.ctx.fillStyle = "#2F2F2F"; //smoky fog prison
    //Game.ctx.fillStyle = "#4a6c4b"; //darker muddy green
    //Game.ctx.fillStyle = "#800000"; // lighter red for dungeon hell theme
    game_1.Game.ctx.fillRect(0, 0, gameConstants_1.GameConstants.WIDTH, gameConstants_1.GameConstants.HEIGHT);
    game_1.Game.ctx.restore();
};


/***/ }),

/***/ "./src/gui/webglBlurRenderer.ts":
/*!**************************************!*\
  !*** ./src/gui/webglBlurRenderer.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebGLBlurRenderer = void 0;
const gameConstants_1 = __webpack_require__(/*! ../game/gameConstants */ "./src/game/gameConstants.ts");
class WebGLBlurRenderer {
    constructor() {
        // Add texture size tracking for texSubImage2D optimization
        this.textureWidth = 0;
        this.textureHeight = 0;
        this.tempTextureWidth = 0;
        this.tempTextureHeight = 0;
        // Cache for result canvases to avoid recreation
        this.resultCanvasCache = new Map();
        this.maxCacheSize = 10;
        // Vertex shader source (shared)
        this.vertexShaderSource = `
    precision mediump float;
    attribute vec2 a_position;
    attribute vec2 a_texCoord;
    uniform vec2 u_resolution;
    varying vec2 v_texCoord;
    
    void main() {
      vec2 zeroToOne = a_position / u_resolution;
      vec2 zeroToTwo = zeroToOne * 2.0;
      vec2 clipSpace = zeroToTwo - 1.0;
      gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);
      v_texCoord = a_texCoord;
    }
  `;
        // High quality fragment shader (49 samples)
        this.highQualityFragmentShaderSource = `
    precision mediump float;
    uniform sampler2D u_texture;
    uniform vec2 u_resolution;
    uniform vec2 u_direction;
    uniform float u_radius;
    varying vec2 v_texCoord;
    
    void main() {
      vec2 texelSize = u_direction / u_resolution;
      vec4 color = vec4(0.0);
      float totalWeight = 0.0;
      
      // High quality blur with original 49 samples
      float sigma = u_radius * 0.4;
      float twoSigmaSquare = 2.0 * sigma * sigma;
      
      for (float i = -24.0; i <= 24.0; i++) {
        if (abs(i) > u_radius) continue;
        
        vec2 offset = texelSize * i;
        float weight = exp(-i * i / twoSigmaSquare);
        
        color += texture2D(u_texture, v_texCoord + offset) * weight;
        totalWeight += weight;
      }
      
      gl_FragColor = color / totalWeight;
    }
  `;
        // Performance fragment shader (13 samples)
        this.performanceFragmentShaderSource = `
    precision mediump float;
    uniform sampler2D u_texture;
    uniform vec2 u_resolution;
    uniform vec2 u_direction;
    uniform float u_radius;
    varying vec2 v_texCoord;
    
    void main() {
      vec2 texelSize = u_direction / u_resolution;
      vec4 color = vec4(0.0);
      float totalWeight = 0.0;
      
      // Performance blur with 13 samples
      float sigma = u_radius * 0.9;
      float twoSigmaSquare = 2.0 * sigma * sigma;
      
      for (float i = -12.0; i <= 12.0; i++) {
        if (abs(i) > u_radius) continue;
        
        vec2 offset = texelSize * i;
        float weight = exp(-i * i / twoSigmaSquare);
        
        color += texture2D(u_texture, v_texCoord + offset) * weight;
        totalWeight += weight;
      }
      
      gl_FragColor = color / totalWeight;
    }
  `;
        this.canvas = document.createElement("canvas");
        this.canvas.width = gameConstants_1.GameConstants.WIDTH;
        this.canvas.height = gameConstants_1.GameConstants.HEIGHT;
        // Initialize downsampling canvas
        this.downsampleCanvas = document.createElement("canvas");
        this.downsampleCtx = this.downsampleCanvas.getContext("2d");
        if (!this.downsampleCtx) {
            throw new Error("Failed to initialize downsample canvas context.");
        }
        const context = this.canvas.getContext("webgl", {
            antialias: false,
            depth: false,
            stencil: false,
            alpha: true,
            premultipliedAlpha: false,
            preserveDrawingBuffer: false,
            powerPreference: "high-performance",
        });
        const experimentalContext = this.canvas.getContext("experimental-webgl", {
            antialias: false,
            depth: false,
            stencil: false,
            alpha: true,
            premultipliedAlpha: false,
            preserveDrawingBuffer: false,
            powerPreference: "high-performance",
        });
        this.gl = context || experimentalContext;
        if (!this.gl) {
            throw new Error("WebGL not supported");
        }
        // Optimize GL state
        this.gl.disable(this.gl.DEPTH_TEST);
        this.gl.disable(this.gl.CULL_FACE);
        this.gl.disable(this.gl.BLEND);
        this.initShaders();
        this.initBuffers();
        this.initTextures();
    }
    static getInstance() {
        if (!WebGLBlurRenderer.instance) {
            WebGLBlurRenderer.instance = new WebGLBlurRenderer();
        }
        return WebGLBlurRenderer.instance;
    }
    initShaders() {
        const vertexShader = this.createShader(this.gl.VERTEX_SHADER, this.vertexShaderSource);
        // Create high quality shader program
        const highQualityFragmentShader = this.createShader(this.gl.FRAGMENT_SHADER, this.highQualityFragmentShaderSource);
        this.highQualityShaderProgram = this.gl.createProgram();
        this.gl.attachShader(this.highQualityShaderProgram, vertexShader);
        this.gl.attachShader(this.highQualityShaderProgram, highQualityFragmentShader);
        this.gl.linkProgram(this.highQualityShaderProgram);
        if (!this.gl.getProgramParameter(this.highQualityShaderProgram, this.gl.LINK_STATUS)) {
            throw new Error("Unable to initialize high quality shader program: " +
                this.gl.getProgramInfoLog(this.highQualityShaderProgram));
        }
        // Create performance shader program
        const performanceFragmentShader = this.createShader(this.gl.FRAGMENT_SHADER, this.performanceFragmentShaderSource);
        this.performanceShaderProgram = this.gl.createProgram();
        this.gl.attachShader(this.performanceShaderProgram, vertexShader);
        this.gl.attachShader(this.performanceShaderProgram, performanceFragmentShader);
        this.gl.linkProgram(this.performanceShaderProgram);
        if (!this.gl.getProgramParameter(this.performanceShaderProgram, this.gl.LINK_STATUS)) {
            throw new Error("Unable to initialize performance shader program: " +
                this.gl.getProgramInfoLog(this.performanceShaderProgram));
        }
        // Set default to high quality
        this.currentShaderProgram = this.highQualityShaderProgram;
        this.updateShaderProgram();
    }
    updateShaderProgram() {
        const useHighQuality = gameConstants_1.GameConstants.HIGH_QUALITY_BLUR;
        const targetProgram = useHighQuality
            ? this.highQualityShaderProgram
            : this.performanceShaderProgram;
        if (this.currentShaderProgram !== targetProgram) {
            this.currentShaderProgram = targetProgram;
            this.gl.useProgram(this.currentShaderProgram);
            // Get attribute locations
            this.positionLocation = this.gl.getAttribLocation(this.currentShaderProgram, "a_position");
            this.texCoordLocation = this.gl.getAttribLocation(this.currentShaderProgram, "a_texCoord");
            // Get uniform locations
            this.resolutionLocation = this.gl.getUniformLocation(this.currentShaderProgram, "u_resolution");
            this.textureLocation = this.gl.getUniformLocation(this.currentShaderProgram, "u_texture");
            this.directionLocation = this.gl.getUniformLocation(this.currentShaderProgram, "u_direction");
            this.radiusLocation = this.gl.getUniformLocation(this.currentShaderProgram, "u_radius");
            // Set texture unit
            this.gl.uniform1i(this.textureLocation, 0);
        }
    }
    createShader(type, source) {
        const shader = this.gl.createShader(type);
        this.gl.shaderSource(shader, source);
        this.gl.compileShader(shader);
        if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {
            const error = this.gl.getShaderInfoLog(shader);
            this.gl.deleteShader(shader);
            throw new Error("Unable to compile shader: " + error);
        }
        return shader;
    }
    initBuffers() {
        // Position buffer
        this.positionBuffer = this.gl.createBuffer();
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.positionBuffer);
        this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array([
            0,
            0,
            gameConstants_1.GameConstants.WIDTH,
            0,
            0,
            gameConstants_1.GameConstants.HEIGHT,
            0,
            gameConstants_1.GameConstants.HEIGHT,
            gameConstants_1.GameConstants.WIDTH,
            0,
            gameConstants_1.GameConstants.WIDTH,
            gameConstants_1.GameConstants.HEIGHT,
        ]), this.gl.STATIC_DRAW);
        // Texture coordinate buffer
        this.texCoordBuffer = this.gl.createBuffer();
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.texCoordBuffer);
        this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array([0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1]), this.gl.STATIC_DRAW);
    }
    initTextures() {
        this.texture = this.gl.createTexture();
        this.gl.bindTexture(this.gl.TEXTURE_2D, this.texture);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR);
        this.tempTexture = this.gl.createTexture();
        this.gl.bindTexture(this.gl.TEXTURE_2D, this.tempTexture);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR);
        this.framebuffer = this.gl.createFramebuffer();
        this.tempFramebuffer = this.gl.createFramebuffer();
    }
    // Optimized texture allocation/update method
    updateTexture(texture, width, height, currentWidth, currentHeight, data = null) {
        this.gl.bindTexture(this.gl.TEXTURE_2D, texture);
        // Only reallocate if dimensions changed
        if (currentWidth !== width || currentHeight !== height) {
            // Reallocate texture with new dimensions
            if (data) {
                // Use 6-parameter overload for HTMLCanvasElement
                this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, data);
            }
            else {
                // Use 9-parameter overload for null data
                this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, width, height, 0, this.gl.RGBA, this.gl.UNSIGNED_BYTE, null);
            }
            return { width, height };
        }
        else if (data) {
            // Reuse existing texture, just update the content
            this.gl.texSubImage2D(this.gl.TEXTURE_2D, 0, 0, 0, this.gl.RGBA, this.gl.UNSIGNED_BYTE, data);
            return { width: currentWidth, height: currentHeight };
        }
        return { width: currentWidth, height: currentHeight };
    }
    getCachedCanvas(width, height) {
        const key = `${width}x${height}`;
        let canvas = this.resultCanvasCache.get(key);
        if (!canvas) {
            canvas = document.createElement("canvas");
            canvas.width = width;
            canvas.height = height;
            // Manage cache size
            if (this.resultCanvasCache.size >= this.maxCacheSize) {
                const firstKey = this.resultCanvasCache.keys().next().value;
                this.resultCanvasCache.delete(firstKey);
            }
            this.resultCanvasCache.set(key, canvas);
        }
        return canvas;
    }
    /**
     * Apply blur with downsampling and texSubImage2D optimization
     */
    applyBlur(sourceCanvas, blurRadius) {
        const originalWidth = sourceCanvas.width;
        const originalHeight = sourceCanvas.height;
        // Calculate downsampled dimensions
        const downsampleFactor = gameConstants_1.GameConstants.BLUR_DOWNSAMPLE_FACTOR;
        const downsampledWidth = Math.max(1, Math.floor(originalWidth / downsampleFactor));
        const downsampledHeight = Math.max(1, Math.floor(originalHeight / downsampleFactor));
        // Prepare downsampled canvas
        if (this.downsampleCanvas.width !== downsampledWidth ||
            this.downsampleCanvas.height !== downsampledHeight) {
            this.downsampleCanvas.width = downsampledWidth;
            this.downsampleCanvas.height = downsampledHeight;
        }
        // Downsample the source canvas using canvas 2D (GPU accelerated)
        this.downsampleCtx.clearRect(0, 0, downsampledWidth, downsampledHeight);
        this.downsampleCtx.drawImage(sourceCanvas, 0, 0, originalWidth, originalHeight, 0, 0, downsampledWidth, downsampledHeight);
        // Apply blur to the downsampled canvas
        const blurredDownsampledCanvas = this.applyBlurToCanvas(this.downsampleCanvas, blurRadius / downsampleFactor, // Adjust blur radius for smaller canvas
        downsampledWidth, downsampledHeight);
        // Return result at original size - the caller will handle upscaling
        // For now, we'll create a canvas at original size and let the GPU upscale
        const resultCanvas = this.getCachedCanvas(originalWidth, originalHeight);
        const resultCtx = resultCanvas.getContext("2d");
        resultCtx.clearRect(0, 0, originalWidth, originalHeight);
        // Use bilinear filtering for upscaling (GPU accelerated)
        resultCtx.imageSmoothingEnabled = true;
        resultCtx.imageSmoothingQuality = "high";
        resultCtx.drawImage(blurredDownsampledCanvas, 0, 0, downsampledWidth, downsampledHeight, 0, 0, originalWidth, originalHeight);
        return resultCanvas;
    }
    /**
     * Internal method to apply blur to a specific canvas
     */
    applyBlurToCanvas(sourceCanvas, blurRadius, width, height) {
        // Reduce the multiplier significantly for bloom visibility
        const enhancedRadius = blurRadius * 1;
        // Update shader program if quality setting changed
        const expectedShader = gameConstants_1.GameConstants.HIGH_QUALITY_BLUR
            ? this.highQualityShaderProgram
            : this.performanceShaderProgram;
        if (this.currentShaderProgram !== expectedShader) {
            this.updateShaderProgram();
        }
        if (this.canvas.width !== width || this.canvas.height !== height) {
            this.canvas.width = width;
            this.canvas.height = height;
            this.gl.viewport(0, 0, width, height);
            // Update position buffer for new dimensions
            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.positionBuffer);
            this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array([
                0,
                0,
                width,
                0,
                0,
                height,
                0,
                height,
                width,
                0,
                width,
                height,
            ]), this.gl.STATIC_DRAW);
        }
        // OPTIMIZED: Use texSubImage2D to avoid GPU memory reallocation
        const updatedTexture = this.updateTexture(this.texture, width, height, this.textureWidth, this.textureHeight, sourceCanvas);
        this.textureWidth = updatedTexture.width;
        this.textureHeight = updatedTexture.height;
        const updatedTempTexture = this.updateTexture(this.tempTexture, width, height, this.tempTextureWidth, this.tempTextureHeight, null);
        this.tempTextureWidth = updatedTempTexture.width;
        this.tempTextureHeight = updatedTempTexture.height;
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.positionBuffer);
        this.gl.enableVertexAttribArray(this.positionLocation);
        this.gl.vertexAttribPointer(this.positionLocation, 2, this.gl.FLOAT, false, 0, 0);
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.texCoordBuffer);
        this.gl.enableVertexAttribArray(this.texCoordLocation);
        this.gl.vertexAttribPointer(this.texCoordLocation, 2, this.gl.FLOAT, false, 0, 0);
        this.gl.uniform2f(this.resolutionLocation, width, height);
        this.gl.uniform1f(this.radiusLocation, enhancedRadius);
        // First pass: horizontal blur
        this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, this.tempFramebuffer);
        this.gl.framebufferTexture2D(this.gl.FRAMEBUFFER, this.gl.COLOR_ATTACHMENT0, this.gl.TEXTURE_2D, this.tempTexture, 0);
        this.gl.bindTexture(this.gl.TEXTURE_2D, this.texture);
        this.gl.uniform2f(this.directionLocation, 1.0, 0.0);
        this.gl.drawArrays(this.gl.TRIANGLES, 0, 6);
        // Second pass: vertical blur
        this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, this.framebuffer);
        this.gl.framebufferTexture2D(this.gl.FRAMEBUFFER, this.gl.COLOR_ATTACHMENT0, this.gl.TEXTURE_2D, this.texture, 0);
        this.gl.bindTexture(this.gl.TEXTURE_2D, this.tempTexture);
        this.gl.uniform2f(this.directionLocation, 0.0, 1.0);
        this.gl.drawArrays(this.gl.TRIANGLES, 0, 6);
        // Final pass: render to screen
        this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null);
        this.gl.bindTexture(this.gl.TEXTURE_2D, this.texture);
        this.gl.drawArrays(this.gl.TRIANGLES, 0, 6);
        return this.canvas;
    }
    clearCache() {
        this.resultCanvasCache.clear();
    }
    dispose() {
        this.clearCache();
        if (this.gl) {
            this.gl.deleteProgram(this.highQualityShaderProgram);
            this.gl.deleteProgram(this.performanceShaderProgram);
            this.gl.deleteBuffer(this.positionBuffer);
            this.gl.deleteBuffer(this.texCoordBuffer);
            this.gl.deleteTexture(this.texture);
            this.gl.deleteTexture(this.tempTexture);
            this.gl.deleteFramebuffer(this.framebuffer);
            this.gl.deleteFramebuffer(this.tempFramebuffer);
        }
    }
}
exports.WebGLBlurRenderer = WebGLBlurRenderer;


/***/ }),

/***/ "./src/gui/xpCounter.ts":
/*!******************************!*\
  !*** ./src/gui/xpCounter.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.XPCounter = void 0;
const game_1 = __webpack_require__(/*! ../game */ "./src/game.ts");
const stats_1 = __webpack_require__(/*! ../game/stats */ "./src/game/stats.ts");
class XPCounter {
    constructor() {
        this.xp = 0;
        this.level = 1;
    }
    static draw(delta) {
        const xp = stats_1.statsTracker.getXp();
        // draw the xp counter
        game_1.Game.ctx.save();
        game_1.Game.ctx.fillStyle = "rgba(255, 255, 0, 1)";
        game_1.Game.ctx.globalAlpha = 0.1;
        game_1.Game.fillText(`XP: ${xp}`, 10, 10);
        game_1.Game.ctx.restore();
    }
}
exports.XPCounter = XPCounter;


/***/ }),

/***/ "./src/inventory/inventory.ts":
/*!************************************!*\
  !*** ./src/inventory/inventory.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Inventory = void 0;
const item_1 = __webpack_require__(/*! ../item/item */ "./src/item/item.ts");
const game_1 = __webpack_require__(/*! ../game */ "./src/game.ts");
const gameConstants_1 = __webpack_require__(/*! ../game/gameConstants */ "./src/game/gameConstants.ts");
const equippable_1 = __webpack_require__(/*! ../item/equippable */ "./src/item/equippable.ts");
const armor_1 = __webpack_require__(/*! ../item/armor */ "./src/item/armor.ts");
const coin_1 = __webpack_require__(/*! ../item/coin */ "./src/item/coin.ts");
const weapon_1 = __webpack_require__(/*! ../item/weapon/weapon */ "./src/item/weapon/weapon.ts");
const usable_1 = __webpack_require__(/*! ../item/usable/usable */ "./src/item/usable/usable.ts");
const mouseCursor_1 = __webpack_require__(/*! ../gui/mouseCursor */ "./src/gui/mouseCursor.ts");
const input_1 = __webpack_require__(/*! ../game/input */ "./src/game/input.ts");
const pickaxe_1 = __webpack_require__(/*! ../item/tool/pickaxe */ "./src/item/tool/pickaxe.ts");
const menu_1 = __webpack_require__(/*! ../gui/menu */ "./src/gui/menu.ts");
const xpCounter_1 = __webpack_require__(/*! ../gui/xpCounter */ "./src/gui/xpCounter.ts");
const fishingRod_1 = __webpack_require__(/*! ../item/tool/fishingRod */ "./src/item/tool/fishingRod.ts");
const IdGenerator_1 = __webpack_require__(/*! ../globalStateManager/IdGenerator */ "./src/globalStateManager/IdGenerator.ts");
let OPEN_TIME = 100; // milliseconds
// Dark gray color used for the background of inventory slots
let FILL_COLOR = "#5a595b";
// Very dark blue-gray color used for outlines and borders
let OUTLINE_COLOR = "#292c36";
// Light blue color used to indicate equipped items
let EQUIP_COLOR = "#85a8e6";
// White color used for the outer border of the inventory
let FULL_OUTLINE = "white";
class Inventory {
    constructor(game, player) {
        this.rows = 4;
        this.cols = 5;
        this.selX = 0;
        this.selY = 0;
        this.isOpen = false;
        this.openTime = Date.now();
        this.coins = 0;
        this.weapon = null;
        this._expansion = 0;
        this.grabbedItem = null;
        this._mouseDownStartX = null;
        this._mouseDownStartY = null;
        this._mouseDownItem = null;
        this._wasHoldDetected = false;
        this._isDragging = false;
        this._dragStartItem = null;
        this._dragStartSlot = null;
        this.itemEquipAnimations = new Map();
        this.foundItems = [];
        this.dragEndTime = Date.now();
        this.closeTime = Date.now();
        // New state for using items on other items
        this.usingItem = null;
        this.usingItemIndex = null;
        this.mostRecentInput = "keyboard";
        this.clear = () => {
            this.items.fill(null);
            this.equipAnimAmount.fill(0);
        };
        this.open = () => {
            this.isOpen = !this.isOpen;
            if (this.isOpen)
                this.openTime = Date.now();
        };
        this.toggleOpen = () => {
            if (this.isOpen) {
                this.close();
            }
            else {
                this.open();
            }
        };
        this.close = () => {
            if (!this.isOpen)
                return;
            this.isOpen = false;
            this.closeTime = Date.now();
            if (this.selY > 0) {
                this.selY = 0;
            }
            this.usingItem = null;
            this.usingItemIndex = null;
        };
        this.left = () => {
            if (this.selX > 0) {
                this.selX--;
            }
        };
        this.right = () => {
            if (this.selX < this.cols - 1) {
                this.selX++;
            }
        };
        this.up = () => {
            if (this.selY > 0) {
                this.selY--;
            }
        };
        this.down = () => {
            if (this.selY < this.rows + this._expansion - 1) {
                this.selY++;
            }
        };
        this.space = () => {
            this.itemUse();
        };
        this.itemAtSelectedSlot = () => {
            let index = this.selX + this.selY * this.cols;
            if (index < 0 || index >= this.items.length) {
                return null;
            }
            return this.items[index];
        };
        this.getIndexOfItem = (item) => {
            if (item === null)
                return -1;
            return this.items.indexOf(item);
        };
        this.itemUse = () => {
            let index = this.selX + this.selY * this.cols;
            if (index < 0 || index >= this.items.length)
                return;
            const item = this.items[index];
            if (this.usingItem) {
                // Attempt to use 'usingItem' on the currently selected item
                if (item === null) {
                    // Clicked on empty slot; cancel the using state
                    this.usingItem = null;
                    this.usingItemIndex = null;
                    return;
                }
                // Attempt to use on other
                if (item instanceof item_1.Item) {
                    this.usingItem.useOnOther(this.player, item);
                }
                // Exit tryingToUse state
                this.usingItem = null;
                this.usingItemIndex = null;
            }
            else {
                // Not in tryingToUse state
                if (item instanceof usable_1.Usable) {
                    if (item.canUseOnOther) {
                        // Enter tryingToUse state
                        this.usingItem = item;
                        this.usingItemIndex = index;
                    }
                    else {
                        // Use normally
                        item.onUse(this.player);
                        // Optionally remove the item
                        // this.items[index] = null;
                    }
                }
                else if (item instanceof equippable_1.Equippable) {
                    // Existing equipping logic
                    item.toggleEquip();
                    if (item instanceof weapon_1.Weapon) {
                        if (item.broken || item.cooldown > 0)
                            return;
                        this.weapon = item.equipped ? item : null;
                    }
                    if (item.equipped) {
                        this.items.forEach((i, idx) => {
                            if (i instanceof equippable_1.Equippable &&
                                i !== item &&
                                !item.coEquippable(i)) {
                                i.equipped = false;
                                this.equipAnimAmount[idx] = 0;
                            }
                        });
                    }
                }
            }
        };
        this.leftQuickbar = () => {
            this.mostRecentInput = "keyboard";
            this.left();
        };
        this.rightQuickbar = () => {
            this.mostRecentInput = "keyboard";
            this.right();
        };
        this.spaceQuickbar = () => {
            this.mostRecentInput = "keyboard";
            this.itemUse();
        };
        this.mouseMove = () => {
            this.mostRecentInput = "mouse";
            const { x, y } = mouseCursor_1.MouseCursor.getInstance().getPosition();
            const bounds = this.isPointInInventoryBounds(x, y);
            if (bounds.inBounds) {
                const s = this.isOpen
                    ? Math.min(18, (18 * (Date.now() - this.openTime)) / OPEN_TIME)
                    : 18;
                const b = 2;
                const g = -2;
                const oldSelX = this.selX;
                const oldSelY = this.selY;
                this.selX = Math.max(0, Math.min(Math.floor((x - bounds.startX) / (s + 2 * b + g)), this.cols - 1));
                this.selY = this.isOpen
                    ? Math.max(0, Math.min(Math.floor((y - bounds.startY) / (s + 2 * b + g)), this.rows + this._expansion - 1))
                    : 0;
                if (oldSelX !== this.selX || oldSelY !== this.selY) {
                    // Optional: Handle selection change
                }
            }
        };
        this.moveItemToSlot = (item, index, otherItem, otherIndex) => {
            if (item === null)
                return;
            // Preserve animation states before moving
            const itemAnim = this.equipAnimAmount[index];
            const otherAnim = otherItem ? this.equipAnimAmount[otherIndex] : 0;
            if (otherItem === null) {
                this.items[index] = item;
                this.equipAnimAmount[index] = this.itemEquipAnimations.get(item) ?? 0;
            }
            else {
                this.items[index] = otherItem;
                this.items[otherIndex] = item;
                this.equipAnimAmount[index] =
                    this.itemEquipAnimations.get(otherItem) ?? 0;
                this.equipAnimAmount[otherIndex] =
                    this.itemEquipAnimations.get(item) ?? 0;
            }
        };
        this.grabItem = (item) => {
            if (item === null) {
                return;
            }
            if (this.grabbedItem !== null) {
                return;
            }
            // Remove the item from its slot when grabbed
            const index = this.getIndexOfItem(item);
            if (index !== -1) {
                this.items[index] = null;
                this.grabbedItem = item;
            }
            else {
            }
        };
        this.releaseItem = () => {
            if (this.grabbedItem === null) {
                return;
            }
            const targetIndex = this.selX + this.selY * this.cols;
            const existingItem = this.items[targetIndex];
            // If target slot is empty, place item there
            if (existingItem === null) {
                this.items[targetIndex] = this.grabbedItem;
            }
            else {
                // Swap items
                this.items[targetIndex] = this.grabbedItem;
            }
            this.grabbedItem = null;
        };
        this.drawDraggedItem = (delta) => {
            if (this.grabbedItem === null)
                return;
            const { x, y } = mouseCursor_1.MouseCursor.getInstance().getPosition();
            const drawX = Math.round(x - 0.5 * gameConstants_1.GameConstants.TILESIZE);
            const drawY = Math.round(y - 0.5 * gameConstants_1.GameConstants.TILESIZE);
            const drawXScaled = drawX / gameConstants_1.GameConstants.TILESIZE;
            const drawYScaled = drawY / gameConstants_1.GameConstants.TILESIZE;
            this.grabbedItem.drawIcon(delta, drawXScaled, drawYScaled);
        };
        this.drop = () => {
            if (!this.isOpen)
                return;
            let index = this.selX + this.selY * this.cols;
            if (index < 0 || index >= this.items.length)
                return;
            const item = this.items[index];
            if (item === null)
                return;
            this.dropItem(item, index);
        };
        this.dropItem = (item, index) => {
            item.level = this.game.levels[this.player.depth].rooms[this.player.levelID];
            item.x = this.player.x;
            item.y = this.player.y;
            item.alpha = 1;
            item.pickedUp = false;
            item.dropFromInventory();
            this.equipAnimAmount[index] = 0;
            item.drawableY = this.player.y;
            this.game.levels[this.player.depth].rooms[this.player.levelID].items.push(item);
            this.items[index] = null;
        };
        this.dropFromInventory = () => {
            // Intentionally left blank or implement if needed
        };
        this.hasItem = (itemType) => {
            return this.items.find((i) => i instanceof itemType) || null;
        };
        this.hasItemCount = (item) => {
            if (item === null)
                return false;
            if (item instanceof coin_1.Coin)
                return this.coinCount() >= item.stackCount;
            return this.items.some((i) => i !== null &&
                i.constructor === item.constructor &&
                i.stackCount >= item.stackCount);
        };
        this.subtractItemCount = (item) => {
            if (item === null)
                return;
            if (item instanceof coin_1.Coin) {
                this.subtractCoins(item.stackCount);
                return;
            }
            this.items.forEach((i, idx) => {
                if (i === null)
                    return;
                if (i.constructor === item.constructor) {
                    i.stackCount -= item.stackCount;
                    if (i.stackCount <= 0) {
                        this.items[idx] = null;
                    }
                }
            });
        };
        this.subtractItem = (item, count) => {
            if (item === null)
                return;
            if (item instanceof coin_1.Coin) {
                this.subtractCoins(item.stackCount);
                return;
            }
            this.items.forEach((i, idx) => {
                if (i === null)
                    return;
                if (i.constructor === item.constructor) {
                    i.stackCount -= count;
                    if (i.stackCount <= 0) {
                        this.items[idx] = null;
                    }
                }
            });
        };
        this.coinCount = () => {
            return this.coins;
        };
        this.subtractCoins = (n) => {
            this.coins = Math.max(0, this.coins - n);
        };
        this.addCoins = (n) => {
            this.coins += n;
        };
        this.isFull = () => {
            return (this.items.filter((i) => i !== null).length >=
                (this.rows + this._expansion) * this.cols);
        };
        this.addItem = (item, stackCount = null) => {
            if (item === null)
                return false;
            if (item instanceof coin_1.Coin) {
                this.coins += item.stackCount;
                return true;
            }
            if (item instanceof equippable_1.Equippable) {
                item.setWielder(this.player);
            }
            if (item.stackable) {
                if (stackCount) {
                    item.stackCount = stackCount;
                }
                for (let i = 0; i < this.items.length; i++) {
                    if (this.items[i] !== null &&
                        this.items[i].constructor === item.constructor) {
                        this.items[i].stackCount += item.stackCount;
                        return true;
                    }
                }
            }
            if (!this.isFull()) {
                for (let i = 0; i < this.items.length; i++) {
                    if (this.items[i] === null) {
                        this.items[i] = item;
                        return true;
                    }
                }
            }
            return false;
        };
        this.removeItem = (item) => {
            if (item === null)
                return;
            const index = this.items.indexOf(item);
            if (index !== -1) {
                this.items[index] = null;
            }
        };
        this.canMine = () => {
            return this.hasItem(pickaxe_1.Pickaxe) !== null;
        };
        this.canFish = () => {
            return this.hasItem(fishingRod_1.FishingRod) !== null;
        };
        this.getArmor = () => {
            return (this.items.find((i) => i instanceof armor_1.Armor && i.equipped) ||
                null);
        };
        this.hasWeapon = () => {
            return this.weapon !== null;
        };
        this.getWeapon = () => {
            return this.weapon;
        };
        this.tick = () => {
            this.items.forEach((i) => {
                if (i !== null)
                    i.tickInInventory();
            });
            // Check for drag initiation
            this.checkForDragStart();
        };
        this.textWrap = (text, x, y, maxWidth) => {
            // Returns y value for next line
            if (text === "")
                return y;
            let words = text.split(" ");
            let line = "";
            while (words.length > 0) {
                if (game_1.Game.measureText(line + words[0]).width > maxWidth) {
                    game_1.Game.fillText(line, x, y);
                    line = "";
                    y += 8;
                }
                else {
                    if (line !== "")
                        line += " ";
                    line += words[0];
                    words.splice(0, 1);
                }
            }
            if (line.trim() !== "") {
                game_1.Game.fillText(line, x, y);
                y += 8;
            }
            return y;
        };
        this.drawCoins = (delta) => {
            let coinTileX = 19;
            if (this.coins >= 3)
                coinTileX = 20;
            if (this.coins >= 7)
                coinTileX = 21;
            // Calculate the right edge of the quickbar
            const quickbarStartX = this.getQuickbarStartX();
            const s = 18; // size of box
            const b = 2; // border
            const g = -2; // gap
            const quickbarWidth = this.cols * (s + 2 * b + g) - g;
            const quickbarRightEdge = quickbarStartX + quickbarWidth;
            // Position coin slightly to the right of the quickbar
            let coinX = (quickbarRightEdge - 5) / gameConstants_1.GameConstants.TILESIZE - 1;
            let coinY = gameConstants_1.GameConstants.HEIGHT / gameConstants_1.GameConstants.TILESIZE - 1.3;
            // Ensure coin doesn't go off the right edge of the screen
            const maxCoinX = (gameConstants_1.GameConstants.WIDTH - 36) / gameConstants_1.GameConstants.TILESIZE;
            if (coinX > maxCoinX) {
                coinX = maxCoinX;
            }
            if (gameConstants_1.GameConstants.WIDTH < 180) {
                coinY -= 1.25;
                coinX += 1.15;
            }
            else {
                coinX += 1.5;
            }
            if (gameConstants_1.GameConstants.WIDTH < 145) {
                coinX -= 1.15;
            }
            game_1.Game.drawItem(coinTileX, 0, 1, 2, coinX, coinY - 1, 1, 2);
            const countText = `${this.coins}`;
            const width = game_1.Game.measureText(countText).width;
            const countX = 10;
            const countY = 9;
            game_1.Game.fillTextOutline(countText, coinX * gameConstants_1.GameConstants.TILESIZE +
                countX -
                game_1.Game.measureText(this.coins.toString()).width +
                5, coinY * gameConstants_1.GameConstants.TILESIZE + countY + 2, gameConstants_1.GameConstants.OUTLINE, "white");
            /*
            const turnCountText = `${this.player.turnCount}`;
            Game.fillTextOutline(
              turnCountText,
              coinX * GameConstants.TILESIZE + countX,
              coinY * GameConstants.TILESIZE + countY - 15,
              GameConstants.OUTLINE,
              "white",
            );
            */
        };
        this.pointInside = (x, y) => {
            const s = Math.min(18, (18 * (Date.now() - this.openTime)) / OPEN_TIME); // size of box
            const b = 2; // border
            const g = -2; // gap
            const hg = 1 + Math.round(0.5 * Math.sin(Date.now() * 0.01) + 0.5); // highlighted growth
            const ob = 1; // outer border
            const width = this.cols * (s + 2 * b + g) - g;
            const height = (this.rows + this._expansion) * (s + 2 * b + g) - g;
            const startX = Math.round(0.5 * gameConstants_1.GameConstants.WIDTH - 0.5 * width) - ob;
            const startY = this.isOpen
                ? Math.round(0.5 * gameConstants_1.GameConstants.HEIGHT - 0.5 * height) - ob
                : gameConstants_1.GameConstants.HEIGHT - (s + 2 * b) - 5 - ob;
            const checkHeight = this.isOpen ? height + 2 * ob : s + 2 * b + 2 * ob;
            return (x >= startX &&
                x <= startX + width + 2 * ob &&
                y >= startY &&
                y <= startY + checkHeight);
        };
        this.drawQuickbar = (delta) => {
            const { x, y } = mouseCursor_1.MouseCursor.getInstance().getPosition();
            const isInBounds = this.isPointInInventoryBounds(x, y).inBounds;
            const s = 18; // size of box
            const b = 2; // border
            const g = -2; // gap
            const hg = 1; // + Math.round(0.5 * Math.sin(Date.now() * 0.01) + 0.5); // highlighted growth
            const ob = 1; // outer border
            const width = Math.floor(this.cols * (s + 2 * b + g) - g);
            const height = Math.floor(s + 2 * b);
            const startX = Math.round(0.5 * gameConstants_1.GameConstants.WIDTH - 0.5 * width);
            const startY = Math.floor(gameConstants_1.GameConstants.HEIGHT - height - 2);
            // Draw main background
            /*
            Game.ctx.fillStyle = FULL_OUTLINE;
            Game.ctx.fillRect(startX - ob, startY - 1, width + 2, height + 2);
            */
            //Game.ctx.globalCompositeOperation = "xor";
            // Draw highlighted background for selected item only if mouse is in bounds
            if (isInBounds || this.mostRecentInput === "keyboard") {
                /*
                Game.ctx.fillRect(
                  Math.floor(startX + this.selX * (s + 2 * b + g) - hg - ob),
                  Math.floor(startY - hg - ob),
                  Math.floor(s + 2 * b + 2 * hg + 2 * ob),
                  Math.floor(s + 2 * b + 2 * hg + 2 * ob),
                );
                */
            }
            // Draw individual item slots
            for (let xIdx = 0; xIdx < this.cols; xIdx++) {
                // Skip drawing normal background and icon if this is the selected slot
                const idx = xIdx;
                // Draw slot background
                if (xIdx !== this.selX) {
                    game_1.Game.ctx.fillStyle = FILL_COLOR;
                    game_1.Game.ctx.fillRect(Math.floor(startX + xIdx * (s + 2 * b + g) + b), Math.floor(startY + b), Math.floor(s), Math.floor(s));
                    game_1.Game.ctx.clearRect(Math.floor(startX + xIdx * (s + 2 * b + g) + b + 1), Math.floor(startY + b + 1), Math.floor(s - 2), Math.floor(s - 2));
                    // Draw equip animation (this should always show)
                    game_1.Game.ctx.fillStyle = EQUIP_COLOR;
                    game_1.Game.ctx.globalAlpha = 0.3;
                    const yOff = Math.floor(s * (1 - this.equipAnimAmount[idx]));
                    game_1.Game.ctx.fillRect(Math.floor(startX + xIdx * (s + 2 * b + g) + b), Math.floor(startY + b + yOff), Math.floor(s), Math.floor(s - yOff));
                    game_1.Game.ctx.globalAlpha = 1;
                    /*
                    Game.ctx.clearRect(
                      Math.floor(startX + xIdx * (s + 2 * b + g) + b + 1),
                      Math.floor(startY + b + 1),
                      Math.floor(s - 2),
                      Math.floor(s - 2),
                    );
                    */
                }
                // Draw item icon if exists
                if (idx < this.items.length && this.items[idx] !== null) {
                    const drawX = startX +
                        xIdx * (s + 2 * b + g) +
                        b +
                        Math.floor(0.5 * s) -
                        0.5 * gameConstants_1.GameConstants.TILESIZE;
                    const drawY = startY + b + Math.floor(0.5 * s) - 0.5 * gameConstants_1.GameConstants.TILESIZE;
                    const drawXScaled = drawX / gameConstants_1.GameConstants.TILESIZE;
                    const drawYScaled = drawY / gameConstants_1.GameConstants.TILESIZE;
                    this.items[idx]?.drawIcon(delta, drawXScaled, drawYScaled);
                }
            }
            // Draw selection box only if mouse is in bounds
            if (true) {
                const selStartX = Math.floor(startX + this.selX * (s + 2 * b + g));
                const selStartY = Math.floor(startY);
                const hg2 = isInBounds ? hg : 0;
                /*
                // Outer selection box (dark)
                Game.ctx.fillStyle = OUTLINE_COLOR;
                Game.ctx.fillRect(
                  selStartX - hg,
                  selStartY - hg,
                  s + 2 * b + 2 * hg,
                  s + 2 * b + 2 * hg,
                );
                */
                // Inner selection box (light grey)
                game_1.Game.ctx.fillStyle = FILL_COLOR;
                game_1.Game.ctx.fillRect(Math.floor(selStartX + b - hg2), Math.floor(selStartY + b - hg2), Math.floor(s + 2 * hg2), Math.floor(s + 2 * hg2));
                // Clear inner rectangle - use normal size when not in bounds
                const clearSize = isInBounds ? s : s - 2;
                const selOffset = isInBounds ? 0 : 1;
                game_1.Game.ctx.clearRect(Math.floor(startX + this.selX * (s + 2 * b + g) + b + selOffset), Math.floor(startY + b + selOffset), Math.floor(clearSize), Math.floor(clearSize));
                // Draw equip animation for selected slot with highlight
                const idx = this.selX;
                game_1.Game.ctx.fillStyle = EQUIP_COLOR;
                game_1.Game.ctx.globalAlpha = 0.3;
                const yOff = (s + 2 * hg2) * (1 - this.equipAnimAmount[idx]);
                game_1.Game.ctx.fillRect(Math.round(startX + this.selX * (s + 2 * b + g) + b - hg2), Math.round(startY + b + yOff - hg2), Math.round(s + 2 * hg2), Math.round(s + 2 * hg2 - yOff));
                game_1.Game.ctx.globalAlpha = 1;
                /*
                Game.ctx.clearRect(
                  Math.floor(startX + this.selX * (s + 2 * b + g) + b),
                  Math.floor(startY + b),
                  Math.floor(s),
                  Math.floor(s),
                );
                */
                this.drawUsingItem(delta, startX, startY, s, b, g);
                // Redraw the selected item
                if (idx < this.items.length && this.items[idx] !== null) {
                    const drawX = selStartX + b + Math.floor(0.5 * s) - 0.5 * gameConstants_1.GameConstants.TILESIZE;
                    const drawY = selStartY + b + Math.floor(0.5 * s) - 0.5 * gameConstants_1.GameConstants.TILESIZE;
                    const drawXScaled = drawX / gameConstants_1.GameConstants.TILESIZE;
                    const drawYScaled = drawY / gameConstants_1.GameConstants.TILESIZE;
                    this.items[idx]?.drawIcon(delta, drawXScaled, drawYScaled);
                }
                this.drawUsingItem(delta, startX, startY, s, b, g);
            }
            this.drawUsingItem(delta, startX, startY, s, b, g);
        };
        this.drawUsingItem = (delta, startX, startY, s, b, g) => {
            // Highlight the usingItem's slot if in using state and it's different from current selection
            game_1.Game.ctx.globalCompositeOperation = "source-over";
            if (this.usingItem && this.usingItemIndex !== null) {
                const usingX = this.usingItemIndex % this.cols;
                const usingY = Math.floor(this.usingItemIndex / this.cols);
                const highlightStartX = startX + usingX * (s + 2 * b + g);
                const highlightStartY = startY + usingY * (s + 2 * b + g);
                game_1.Game.ctx.strokeStyle = "yellow"; // Choose a distinct color for using item
                game_1.Game.ctx.lineWidth = 2;
                game_1.Game.ctx.strokeRect(highlightStartX, highlightStartY, s + 2 * b, s + 2 * b);
                game_1.Game.ctx.lineWidth = 1; // Reset line width
            }
        };
        this.updateEquipAnimAmount = (delta) => {
            this.equipAnimAmount.forEach((amount, idx) => {
                const item = this.items[idx];
                if (item instanceof equippable_1.Equippable) {
                    let targetAmount = item.equipped ? 1 : 0;
                    let currentAmount = this.itemEquipAnimations.get(item) ?? amount;
                    currentAmount += 0.2 * delta * (targetAmount - currentAmount);
                    currentAmount = Math.max(0, Math.min(1, currentAmount));
                    this.itemEquipAnimations.set(item, currentAmount);
                    this.equipAnimAmount[idx] = currentAmount;
                }
                else {
                    this.equipAnimAmount[idx] = 0;
                    if (item)
                        this.itemEquipAnimations.delete(item);
                }
            });
        };
        this.draw = (delta) => {
            game_1.Game.ctx.imageSmoothingEnabled = false;
            game_1.Game.ctx.imageSmoothingQuality = "low";
            const { x, y } = mouseCursor_1.MouseCursor.getInstance().getPosition();
            const isInBounds = this.isPointInInventoryBounds(x, y).inBounds;
            const s = Math.floor(Math.min(18, (18 * (Date.now() - this.openTime)) / OPEN_TIME)); // size of box
            const b = 2; // border
            const g = -2; // gap
            const hg = 1 + Math.round(0.5 * Math.sin(Date.now() * 0.01) + 0.5); // highlighted growth
            const invRows = Math.floor(this.rows + this._expansion);
            const ob = 1; // outer border
            const width = Math.floor(this.cols * (s + 2 * b + g) - g);
            const height = Math.floor(invRows * (s + 2 * b + g) - g);
            const mainBgX = Math.round(0.5 * gameConstants_1.GameConstants.WIDTH - 0.5 * width) - ob;
            const mainBgY = Math.round(0.5 * gameConstants_1.GameConstants.HEIGHT - 0.5 * height) - ob;
            // Draw coins and quickbar (these are always visible)
            this.drawCoins(delta);
            this.drawQuickbar(delta);
            this.updateEquipAnimAmount(delta);
            this.drawInventoryButton(delta);
            menu_1.Menu.drawOpenMenuButton();
            xpCounter_1.XPCounter.draw(delta);
            if (this.isOpen) {
                // Draw semi-transparent background for full inventory
                game_1.Game.ctx.fillStyle = "rgba(0, 0, 0, 0.8)";
                game_1.Game.ctx.fillRect(0, 0, gameConstants_1.GameConstants.WIDTH, gameConstants_1.GameConstants.HEIGHT);
                game_1.Game.ctx.globalAlpha = 1;
                // Define dimensions and styling variables (similar to drawQuickbar)
                const s = Math.floor(Math.min(18, (18 * (Date.now() - this.openTime)) / OPEN_TIME)); // size of box
                const b = 2; // border
                const g = -2; // gap
                const hg = Math.floor(1 + Math.round(0.5 * Math.sin(Date.now() * 0.01) + 0.5)); // highlighted growth
                const invRows = this.rows + this._expansion;
                const ob = 1; // outer border
                const width = Math.floor(this.cols * (s + 2 * b + g) - g);
                const height = Math.floor(invRows * (s + 2 * b + g) - g);
                // Draw main inventory background (similar to drawQuickbar)
                game_1.Game.ctx.fillStyle = FULL_OUTLINE;
                const mainBgX = Math.round(0.5 * gameConstants_1.GameConstants.WIDTH - 0.5 * width) - ob;
                const mainBgY = Math.round(0.5 * gameConstants_1.GameConstants.HEIGHT - 0.5 * height) - ob;
                game_1.Game.ctx.fillRect(mainBgX, mainBgY, width + 2 * ob, height + 2 * ob);
                // Draw highlighted background for selected item only if mouse is in bounds
                if (isInBounds || this.mostRecentInput === "keyboard") {
                    const highlightX = Math.round(0.5 * gameConstants_1.GameConstants.WIDTH -
                        0.5 * width +
                        this.selX * (s + 2 * b + g)) -
                        hg -
                        ob;
                    const highlightY = Math.round(0.5 * gameConstants_1.GameConstants.HEIGHT -
                        0.5 * height +
                        this.selY * (s + 2 * b + g)) -
                        hg -
                        ob;
                    game_1.Game.ctx.fillRect(highlightX, highlightY, s + 2 * b + 2 * hg + 2 * ob, s + 2 * b + 2 * hg + 2 * ob);
                }
                // Draw individual inventory slots (similar to drawQuickbar, but for all rows)
                for (let xIdx = 0; xIdx < this.cols; xIdx++) {
                    for (let yIdx = 0; yIdx < this.rows + this._expansion; yIdx++) {
                        // Draw slot outline
                        const slotX = Math.round(0.5 * gameConstants_1.GameConstants.WIDTH - 0.5 * width + xIdx * (s + 2 * b + g));
                        const slotY = Math.round(0.5 * gameConstants_1.GameConstants.HEIGHT - 0.5 * height + yIdx * (s + 2 * b + g));
                        game_1.Game.ctx.fillStyle = OUTLINE_COLOR;
                        game_1.Game.ctx.fillRect(slotX, slotY, s + 2 * b, s + 2 * b);
                        // Draw slot background
                        game_1.Game.ctx.fillStyle = FILL_COLOR;
                        game_1.Game.ctx.fillRect(slotX + b, slotY + b, s, s);
                        // Draw equip animation (unique to full inventory view)
                        const idx = xIdx + yIdx * this.cols;
                        game_1.Game.ctx.fillStyle = EQUIP_COLOR;
                        const yOff = Math.round(s * (1 - this.equipAnimAmount[idx]));
                        game_1.Game.ctx.fillRect(slotX + b, slotY + b + yOff, s, s - yOff);
                        // Draw item icon if exists
                        if (idx < this.items.length && this.items[idx] !== null) {
                            const drawX = Math.round(0.5 * gameConstants_1.GameConstants.WIDTH -
                                0.5 * width +
                                xIdx * (s + 2 * b + g) +
                                b +
                                Math.floor(0.5 * s) -
                                0.5 * gameConstants_1.GameConstants.TILESIZE);
                            const drawY = Math.round(0.5 * gameConstants_1.GameConstants.HEIGHT -
                                0.5 * height +
                                yIdx * (s + 2 * b + g) +
                                b +
                                Math.floor(0.5 * s) -
                                0.5 * gameConstants_1.GameConstants.TILESIZE);
                            const drawXScaled = drawX / gameConstants_1.GameConstants.TILESIZE;
                            const drawYScaled = drawY / gameConstants_1.GameConstants.TILESIZE;
                            this.items[idx]?.drawIcon(delta, drawXScaled, drawYScaled);
                        }
                    }
                }
                // Draw item icons after animation delay (similar to drawQuickbar, but for all items)
                if (Date.now() - this.openTime >= OPEN_TIME) {
                    this.items.forEach((item, idx) => {
                        if (item === null)
                            return;
                        const x = idx % this.cols;
                        const y = Math.floor(idx / this.cols);
                        const drawX = Math.round(0.5 * gameConstants_1.GameConstants.WIDTH -
                            0.5 * width +
                            x * (s + 2 * b + g) +
                            b +
                            Math.floor(0.5 * s) -
                            0.5 * gameConstants_1.GameConstants.TILESIZE);
                        const drawY = Math.round(0.5 * gameConstants_1.GameConstants.HEIGHT -
                            0.5 * height +
                            y * (s + 2 * b + g) +
                            b +
                            Math.floor(0.5 * s) -
                            0.5 * gameConstants_1.GameConstants.TILESIZE);
                        const drawXScaled = drawX / gameConstants_1.GameConstants.TILESIZE;
                        const drawYScaled = drawY / gameConstants_1.GameConstants.TILESIZE;
                        item.drawIcon(delta, drawXScaled, drawYScaled);
                    });
                    // Draw selection box and related elements only if mouse is in bounds
                    if (isInBounds || this.mostRecentInput === "keyboard") {
                        // Draw selection box
                        game_1.Game.ctx.fillStyle = OUTLINE_COLOR;
                        game_1.Game.ctx.fillRect(Math.round(0.5 * gameConstants_1.GameConstants.WIDTH -
                            0.5 * width +
                            this.selX * (s + 2 * b + g) -
                            hg), Math.round(0.5 * gameConstants_1.GameConstants.HEIGHT -
                            0.5 * height +
                            this.selY * (s + 2 * b + g) -
                            hg), s + 2 * b + 2 * hg, s + 2 * b + 2 * hg);
                        const slotX = Math.round(0.5 * gameConstants_1.GameConstants.WIDTH -
                            0.5 * width +
                            this.selX * (s + 2 * b + g) +
                            b -
                            hg);
                        const slotY = Math.round(0.5 * gameConstants_1.GameConstants.HEIGHT -
                            0.5 * height +
                            this.selY * (s + 2 * b + g) +
                            b -
                            hg);
                        game_1.Game.ctx.fillStyle = FILL_COLOR;
                        game_1.Game.ctx.fillRect(slotX, slotY, s + 2 * hg, s + 2 * hg);
                        // Draw equip animation for selected item (unique to full inventory view)
                        const idx = this.selX + this.selY * this.cols;
                        if (idx < this.items.length && this.items[idx] !== null) {
                            game_1.Game.ctx.fillStyle = EQUIP_COLOR;
                            const yOff = Math.round((s + 2 * hg) * (1 - this.equipAnimAmount[idx]));
                            game_1.Game.ctx.fillRect(Math.round(0.5 * gameConstants_1.GameConstants.WIDTH -
                                0.5 * width +
                                this.selX * (s + 2 * b + g) +
                                b -
                                hg), Math.round(0.5 * gameConstants_1.GameConstants.HEIGHT -
                                0.5 * height +
                                this.selY * (s + 2 * b + g) +
                                b -
                                hg +
                                yOff), s + 2 * hg, s + 2 * hg - yOff);
                            // Redraw selected item icon (similar to drawQuickbar)
                            const drawX = Math.round(0.5 * gameConstants_1.GameConstants.WIDTH -
                                0.5 * width +
                                this.selX * (s + 2 * b + g) +
                                b +
                                Math.floor(0.5 * s) -
                                0.5 * gameConstants_1.GameConstants.TILESIZE);
                            const drawY = Math.round(0.5 * gameConstants_1.GameConstants.HEIGHT -
                                0.5 * height +
                                this.selY * (s + 2 * b + g) +
                                b +
                                Math.floor(0.5 * s) -
                                0.5 * gameConstants_1.GameConstants.TILESIZE);
                            const drawXScaled = drawX / gameConstants_1.GameConstants.TILESIZE;
                            const drawYScaled = drawY / gameConstants_1.GameConstants.TILESIZE;
                            this.items[idx]?.drawIcon(delta, drawXScaled, drawYScaled);
                        }
                        // **Move drawUsingItem here, after the main selection box**
                    }
                    // **Ensure drawUsingItem is not called again here**
                    // this.drawUsingItem(delta, mainBgX, mainBgY, s, b, g);
                }
                // **Ensure drawUsingItem is not called again here**
                // this.drawUsingItem(delta, mainBgX, mainBgY, s, b, g);
                // Draw item description and action text (unique to full inventory view)
                const selectedIdx = this.selX + this.selY * this.cols;
                if (selectedIdx < this.items.length && this.items[selectedIdx] !== null) {
                    const item = this.items[selectedIdx];
                    game_1.Game.ctx.fillStyle = "white";
                    // Determine action text
                    let topPhrase = "";
                    if (item instanceof equippable_1.Equippable) {
                        topPhrase = item.equipped ? "[SPACE] to unequip" : "[SPACE] to equip";
                    }
                    if (item instanceof usable_1.Usable) {
                        topPhrase = "[SPACE] to use";
                    }
                    // Draw action text
                    const actionTextWidth = game_1.Game.measureText(topPhrase).width;
                    game_1.Game.fillText(topPhrase, Math.round(0.5 * (gameConstants_1.GameConstants.WIDTH - actionTextWidth)), 5);
                    // Draw item description
                    const lines = item.getDescription().split("\n");
                    let nextY = Math.round(0.5 * gameConstants_1.GameConstants.HEIGHT -
                        0.5 * height +
                        (this.rows + this.expansion) * (s + 2 * b + g) +
                        b +
                        5);
                    lines.forEach((line) => {
                        nextY = this.textWrap(line, 5, nextY, gameConstants_1.GameConstants.WIDTH - 10);
                    });
                }
            }
            if (this.isOpen) {
                this.drawUsingItem(delta, mainBgX + 1, mainBgY + 1, s, b, g);
            }
            this.drawDraggedItem(delta);
        };
        this.isPointInInventoryBounds = (x, y) => {
            const s = this.isOpen
                ? Math.min(18, (18 * (Date.now() - this.openTime)) / OPEN_TIME)
                : 18;
            const b = 2; // border
            const g = -2; // gap
            const hg = 1 + Math.round(0.5 * Math.sin(Date.now() * 0.01) + 0.5); // highlighted growth
            const ob = 1; // outer border
            const width = this.cols * (s + 2 * b + g) - g;
            let startX;
            let startY;
            let height;
            if (this.isOpen) {
                // Full inventory bounds
                height = (this.rows + this._expansion) * (s + 2 * b + g) - g;
                startX = Math.round(0.5 * gameConstants_1.GameConstants.WIDTH - 0.5 * width);
                startY = Math.round(0.5 * gameConstants_1.GameConstants.HEIGHT - 0.5 * height);
            }
            else {
                // Quickbar bounds
                height = s + 2 * b;
                startX = Math.round(0.5 * gameConstants_1.GameConstants.WIDTH - 0.5 * width);
                startY = Math.round(gameConstants_1.GameConstants.HEIGHT - height - 5);
            }
            const inBounds = x >= startX - ob &&
                x <= startX + width + ob &&
                y >= startY - ob &&
                y <= startY + height + ob;
            return {
                inBounds,
                startX,
                startY,
            };
        };
        this.isPointInQuickbarBounds = (x, y) => {
            const s = this.isOpen
                ? Math.min(18, (18 * (Date.now() - this.openTime)) / OPEN_TIME)
                : 18;
            const b = 2; // border
            const g = -2; // gap
            const width = this.cols * (s + 2 * b + g) - g;
            const startX = Math.round(0.5 * gameConstants_1.GameConstants.WIDTH - 0.5 * width);
            const startY = Math.round(gameConstants_1.GameConstants.HEIGHT - (s + 2 * b) - 5);
            const quickbarHeight = s + 2 * b;
            const inBounds = x >= startX &&
                x <= startX + width &&
                y >= startY &&
                y <= startY + quickbarHeight;
            return {
                inBounds,
                startX,
                startY,
            };
        };
        this.isPointInInventoryButton = (x, y) => {
            const tX = x / gameConstants_1.GameConstants.TILESIZE;
            const tY = y / gameConstants_1.GameConstants.TILESIZE;
            return (tX >= this.buttonX &&
                tX <= this.buttonX + 1 &&
                tY >= this.buttonY &&
                tY <= this.buttonY + 1);
        };
        /**
         * Draws the inventory button to the canvas.
         * Added `ctx.save()` at the beginning and `ctx.restore()` at the end
         * to ensure canvas state is preserved.
         */
        this.drawInventoryButton = (delta) => {
            game_1.Game.ctx.save(); // Save the current canvas state
            this.buttonX = gameConstants_1.GameConstants.WIDTH / gameConstants_1.GameConstants.TILESIZE - 1.25;
            this.buttonY = gameConstants_1.GameConstants.HEIGHT / gameConstants_1.GameConstants.TILESIZE - 1.25;
            if (gameConstants_1.GameConstants.WIDTH < 145) {
                //this.buttonX -= 1;
                this.buttonY -= 1.25;
            }
            game_1.Game.drawFX(0, 0, 1, 1, this.buttonX, this.buttonY, 1, 1);
            game_1.Game.ctx.restore(); // Restore the canvas state
        };
        this.getQuickbarStartX = () => {
            const s = 18; // size of box
            const b = 2; // border
            const g = -2; // gap
            const width = Math.floor(this.cols * (s + 2 * b + g) - g);
            return Math.round(0.5 * gameConstants_1.GameConstants.WIDTH - 0.5 * width);
        };
        this.handleMouseDown = (x, y, button) => {
            if (this.player.menu.open)
                return;
            // Ignore if not left click
            if (button !== 0)
                return;
            const bounds = this.isPointInInventoryBounds(x, y);
            if (bounds.inBounds) {
                const selectedItem = this.itemAtSelectedSlot();
                if (selectedItem !== null) {
                    this._dragStartItem = selectedItem;
                    this._dragStartSlot = this.selX + this.selY * this.cols;
                }
            }
        };
        /**
         * Unified method to initiate dragging.
         */
        this.initiateDrag = () => {
            if (this._dragStartItem === null || this._isDragging) {
                return;
            }
            this._isDragging = true;
            this.grabbedItem = this._dragStartItem;
            // Remove item from original slot
            if (this._dragStartSlot !== null) {
                this.items[this._dragStartSlot] = null;
            }
        };
        /**
         * Handle hold detection for both mouse and touch.
         */
        this.onHoldDetected = () => {
            this.initiateDrag();
        };
        /**
         * Continuously check for mouse hold during tick.
         */
        this.checkForDragStart = () => {
            if (input_1.Input.mouseDown && input_1.Input.isMouseHold) {
                this.initiateDrag();
            }
            else if (input_1.Input.isTapHold) {
                this.initiateDrag();
            }
        };
        this.handleMouseUp = (x, y, button) => {
            if (this.player.menu.open)
                return;
            // Ignore if not left click
            if (button !== 0)
                return;
            const invBounds = this.isPointInInventoryBounds(x, y);
            const quickbarBounds = this.isPointInQuickbarBounds(x, y);
            const isValidDropZone = this.isOpen
                ? invBounds.inBounds
                : quickbarBounds.inBounds;
            if (isValidDropZone) {
                if (this._isDragging && this.grabbedItem !== null) {
                    // We were dragging, place the item
                    const targetSlot = this.selX + this.selY * this.cols;
                    this.placeItemInSlot(targetSlot);
                }
                else if (this._dragStartItem !== null) {
                    // We had an item but weren't dragging (quick click)
                    this.itemUse();
                }
            }
            else if (this.grabbedItem !== null) {
                // Drop the item in the world
                this.dropItem(this.grabbedItem, this._dragStartSlot);
                this.grabbedItem = null;
                this.items[this._dragStartSlot] = null;
                this.dragEndTime = Date.now();
            }
            // Reset all drag/hold state
            this._isDragging = false;
            this._dragStartItem = null;
            this._dragStartSlot = null;
            this.grabbedItem = null;
        };
        this.placeItemInSlot = (targetSlot) => {
            if (this.grabbedItem === null)
                return;
            const existingItem = this.items[targetSlot];
            // If target slot is empty
            if (existingItem === null) {
                this.items[targetSlot] = this.grabbedItem;
            }
            else {
                // Swap items
                if (this._dragStartSlot !== null) {
                    this.items[this._dragStartSlot] = existingItem;
                }
                this.items[targetSlot] = this.grabbedItem;
            }
            this.grabbedItem = null;
        };
        this.globalId = IdGenerator_1.IdGenerator.generate("INV");
        this.game = game;
        this.player = player;
        this.buttonX =
            (Math.round(gameConstants_1.GameConstants.WIDTH / 2) + 3) / gameConstants_1.GameConstants.TILESIZE;
        this.buttonY = 10;
        input_1.Input.mouseDownListeners.push((x, y, button) => this.handleMouseDown(x, y, button));
        input_1.Input.mouseUpListeners.push((x, y, button) => this.handleMouseUp(x, y, button));
        input_1.Input.holdCallback = () => this.onHoldDetected();
        this.items = new Array((this.rows + this._expansion) * this.cols).fill(null);
        this.equipAnimAmount = new Array((this.rows + this._expansion) * this.cols).fill(0);
        let a = (i) => {
            if (i === null)
                return;
            if (i instanceof equippable_1.Equippable) {
                i.setWielder(this.player);
            }
            if (i instanceof weapon_1.Weapon && this.weapon === null) {
                i.toggleEquip();
                this.weapon = i;
                //this.player.weapon = this.weapon;
            }
            this.addItem(i);
        };
        let startingInv = gameConstants_1.GameConstants.DEVELOPER_MODE
            ? gameConstants_1.GameConstants.STARTING_DEV_INVENTORY
            : gameConstants_1.GameConstants.STARTING_INVENTORY;
        startingInv.forEach((item) => {
            a(new item({ game: this.game }, 0, 0));
        });
    }
    get isDragging() {
        return this._isDragging;
    }
    get expansion() {
        return this._expansion;
    }
    set expansion(value) {
        if (value !== this._expansion) {
            const oldTotalSlots = (this.rows + this._expansion) * this.cols;
            this._expansion = value;
            const newTotalSlots = (this.rows + this._expansion) * this.cols;
            // Resize items array
            if (newTotalSlots > oldTotalSlots) {
                this.items.push(...Array(newTotalSlots - oldTotalSlots).fill(null));
                this.equipAnimAmount.push(...Array(newTotalSlots - oldTotalSlots).fill(0));
            }
            else if (newTotalSlots < oldTotalSlots) {
                this.items.length = newTotalSlots;
                this.equipAnimAmount.length = newTotalSlots;
            }
        }
    }
    expandInventory(additionalRows) {
        this.expansion += additionalRows;
    }
}
exports.Inventory = Inventory;


/***/ }),

/***/ "./src/item/armor.ts":
/*!***************************!*\
  !*** ./src/item/armor.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Armor = void 0;
const game_1 = __webpack_require__(/*! ../game */ "./src/game.ts");
const equippable_1 = __webpack_require__(/*! ./equippable */ "./src/item/equippable.ts");
const gameConstants_1 = __webpack_require__(/*! ../game/gameConstants */ "./src/game/gameConstants.ts");
class Armor extends equippable_1.Equippable {
    constructor(level, x, y) {
        super(level, x, y);
        this.RECHARGE_TURNS = 25;
        this.coEquippable = (other) => {
            if (other instanceof Armor)
                return false;
            return true;
        };
        this.getDescription = () => {
            return ("ENCHANTED ARMOR\nA magic suit of armor. Absorbs one hit and regenerates after " +
                this.RECHARGE_TURNS +
                " turns.");
        };
        this.tickInInventory = () => {
            if (this.rechargeTurnCounter > 0) {
                this.rechargeTurnCounter--;
                if (this.rechargeTurnCounter === 0) {
                    this.rechargeTurnCounter = -1;
                    this.health = 1;
                }
            }
        };
        this.hurt = (damage) => {
            if (this.health <= 0)
                return;
            this.health -= Math.max(damage, 1);
            this.rechargeTurnCounter = this.RECHARGE_TURNS + 1;
        };
        this.drawGUI = (delta, playerMaxHealth, quickbarStartX) => {
            // Get the quickbar's left edge position (same as in playerRenderer)
            // Convert to tile coordinates
            const heartStartX = (quickbarStartX - 7) / gameConstants_1.GameConstants.TILESIZE;
            // Position after the hearts
            const shieldX = Math.max(heartStartX, -0.2) + playerMaxHealth / 1.5 + 0.5;
            let offsetY = gameConstants_1.GameConstants.WIDTH > 175 ? 0 : -1.25;
            if (this.rechargeTurnCounter === -1)
                game_1.Game.drawFX(5, 2, 0.75, 0.75, shieldX, gameConstants_1.GameConstants.HEIGHT / gameConstants_1.GameConstants.TILESIZE - 1 + offsetY, 0.75, 0.75);
            else {
                let rechargeProportion = 1 - this.rechargeTurnCounter / this.RECHARGE_TURNS;
                if (rechargeProportion < 0.5)
                    game_1.Game.drawFX(7, 2, 0.75, 0.75, shieldX, gameConstants_1.GameConstants.HEIGHT / gameConstants_1.GameConstants.TILESIZE - 1 + offsetY, 0.75, 0.75);
                else
                    game_1.Game.drawFX(8, 2, 0.75, 0.75, shieldX, gameConstants_1.GameConstants.HEIGHT / gameConstants_1.GameConstants.TILESIZE - 1 + offsetY, 0.75, 0.75);
            }
        };
        this.health = 1;
        this.rechargeTurnCounter = -1;
        this.tileX = 5;
        this.tileY = 0;
        this.name = "armor";
    }
}
exports.Armor = Armor;
Armor.itemName = "armor";


/***/ }),

/***/ "./src/item/backpack.ts":
/*!******************************!*\
  !*** ./src/item/backpack.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Backpack = void 0;
const sound_1 = __webpack_require__(/*! ../sound/sound */ "./src/sound/sound.ts");
const usable_1 = __webpack_require__(/*! ./usable/usable */ "./src/item/usable/usable.ts");
class Backpack extends usable_1.Usable {
    constructor(level, x, y) {
        super(level, x, y);
        this.onUse = (player) => {
            if (this.level.game.rooms[player.levelID] === this.level.game.room)
                sound_1.Sound.playBackpack();
            player.inventory.removeItem(this);
            player.inventory.expansion += 1;
            this.level.game.pushMessage("You equip the backpack, increasing the amount you can carry.");
            //this.level.items = this.level.items.filter((x) => x !== this); // removes itself from the level
        };
        this.getDescription = () => {
            return "BACKPACK\nA normal looking backpack. Increases the amount you can carry. ";
        };
        this.tileX = 4;
        this.tileY = 0;
        this.offsetY = 0;
    }
}
exports.Backpack = Backpack;
Backpack.itemName = "backpack";


/***/ }),

/***/ "./src/item/bestiaryBook.ts":
/*!**********************************!*\
  !*** ./src/item/bestiaryBook.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BestiaryBook = void 0;
const usable_1 = __webpack_require__(/*! ./usable/usable */ "./src/item/usable/usable.ts");
const bestiary_1 = __webpack_require__(/*! ../game/bestiary */ "./src/game/bestiary.ts");
class BestiaryBook extends usable_1.Usable {
    constructor(level, x, y) {
        super(level, x, y);
        this.onUse = (player) => {
            if (player.bestiary === null) {
                player.bestiary = new bestiary_1.Bestiary(player.game, player);
            }
            player.bestiary.toggleOpen();
        };
        this.tileX = 8;
        this.tileY = 0;
        this.offsetY = -0.3;
        this.name = BestiaryBook.itemName;
        this.description = "opens the bestiary";
    }
}
exports.BestiaryBook = BestiaryBook;
BestiaryBook.itemName = "bestiary book";


/***/ }),

/***/ "./src/item/bombItem.ts":
/*!******************************!*\
  !*** ./src/item/bombItem.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BombItem = void 0;
const sound_1 = __webpack_require__(/*! ../sound/sound */ "./src/sound/sound.ts");
const usable_1 = __webpack_require__(/*! ./usable/usable */ "./src/item/usable/usable.ts");
//import { Bomb } from "../entity/object/bomb";
class BombItem extends usable_1.Usable {
    constructor(level, x, y) {
        super(level, x, y);
        this.onUse = (player) => {
            const { Bomb } = __webpack_require__(/*! ../entity/object/bomb */ "./src/entity/object/bomb.ts");
            Bomb.add(player.game.room, player.game, player.x, player.y);
            player.inventory.removeItem(this);
            sound_1.Sound.mine();
        };
        this.tileX = 20;
        this.tileY = 2;
        this.offsetY = -0.3;
        this.name = BombItem.itemName;
        this.description = "explodes";
    }
}
exports.BombItem = BombItem;
BombItem.itemName = "bomb";


/***/ }),

/***/ "./src/item/coin.ts":
/*!**************************!*\
  !*** ./src/item/coin.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Coin = void 0;
const item_1 = __webpack_require__(/*! ./item */ "./src/item/item.ts");
const sound_1 = __webpack_require__(/*! ../sound/sound */ "./src/sound/sound.ts");
class Coin extends item_1.Item {
    //checked: boolean;
    constructor(level, x, y) {
        super(level, x, y);
        this.onDrop = () => {
            const coinList = []; //array to store coin objects
            for (const item of this.level.items) {
                if (item instanceof Coin)
                    coinList.push(item);
            }
            for (const otherCoin of coinList) {
                if (this !== otherCoin &&
                    this.x === otherCoin.x &&
                    this.y === otherCoin.y) {
                    this.stackCount += otherCoin.stackCount;
                    this.level.items = this.level.items.filter((x) => x !== otherCoin);
                }
                if (this.stackCount >= 3)
                    this.tileX = 20;
                if (this.stackCount >= 7)
                    this.tileX = 21;
            }
        };
        this.pickupSound = () => {
            if (this.level === this.level.game.room)
                sound_1.Sound.pickupCoin();
        };
        this.tileX = 19;
        this.tileY = 0;
        this.stackCount = 1;
        this.stackable = true;
        this.name = Coin.itemName;
    }
    get distanceToBottomRight() {
        return Math.sqrt((this.x + this.w - window.innerWidth) ** 2 +
            (this.y + this.h - window.innerHeight) ** 2);
    }
}
exports.Coin = Coin;
Coin.itemName = "coin";


/***/ }),

/***/ "./src/item/dropTable.ts":
/*!*******************************!*\
  !*** ./src/item/dropTable.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DropTable = exports.ItemTypeMap = void 0;
const armor_1 = __webpack_require__(/*! ./armor */ "./src/item/armor.ts");
const bluegem_1 = __webpack_require__(/*! ./resource/bluegem */ "./src/item/resource/bluegem.ts");
const candle_1 = __webpack_require__(/*! ./light/candle */ "./src/item/light/candle.ts");
const coin_1 = __webpack_require__(/*! ./coin */ "./src/item/coin.ts");
const greengem_1 = __webpack_require__(/*! ./resource/greengem */ "./src/item/resource/greengem.ts");
const heart_1 = __webpack_require__(/*! ./usable/heart */ "./src/item/usable/heart.ts");
const redgem_1 = __webpack_require__(/*! ./resource/redgem */ "./src/item/resource/redgem.ts");
const weaponFragments_1 = __webpack_require__(/*! ./usable/weaponFragments */ "./src/item/usable/weaponFragments.ts");
const spear_1 = __webpack_require__(/*! ./weapon/spear */ "./src/item/weapon/spear.ts");
const warhammer_1 = __webpack_require__(/*! ./weapon/warhammer */ "./src/item/weapon/warhammer.ts");
const dualdagger_1 = __webpack_require__(/*! ./weapon/dualdagger */ "./src/item/weapon/dualdagger.ts");
const weaponPoison_1 = __webpack_require__(/*! ./usable/weaponPoison */ "./src/item/usable/weaponPoison.ts");
const weaponBlood_1 = __webpack_require__(/*! ./usable/weaponBlood */ "./src/item/usable/weaponBlood.ts");
const gold_1 = __webpack_require__(/*! ./resource/gold */ "./src/item/resource/gold.ts");
const stone_1 = __webpack_require__(/*! ./resource/stone */ "./src/item/resource/stone.ts");
const pickaxe_1 = __webpack_require__(/*! ./tool/pickaxe */ "./src/item/tool/pickaxe.ts");
const hammer_1 = __webpack_require__(/*! ./tool/hammer */ "./src/item/tool/hammer.ts");
const coal_1 = __webpack_require__(/*! ./resource/coal */ "./src/item/resource/coal.ts");
const torch_1 = __webpack_require__(/*! ./light/torch */ "./src/item/light/torch.ts");
const lantern_1 = __webpack_require__(/*! ./light/lantern */ "./src/item/light/lantern.ts");
const spellbook_1 = __webpack_require__(/*! ./weapon/spellbook */ "./src/item/weapon/spellbook.ts");
const spellbookPage_1 = __webpack_require__(/*! ./usable/spellbookPage */ "./src/item/usable/spellbookPage.ts");
const backpack_1 = __webpack_require__(/*! ./backpack */ "./src/item/backpack.ts");
const bombItem_1 = __webpack_require__(/*! ./bombItem */ "./src/item/bombItem.ts");
const greataxe_1 = __webpack_require__(/*! ./weapon/greataxe */ "./src/item/weapon/greataxe.ts");
const random_1 = __webpack_require__(/*! ../utility/random */ "./src/utility/random.ts");
const utils_1 = __webpack_require__(/*! ../utility/utils */ "./src/utility/utils.ts");
const geode_1 = __webpack_require__(/*! ./resource/geode */ "./src/item/resource/geode.ts");
const scythe_1 = __webpack_require__(/*! ./weapon/scythe */ "./src/item/weapon/scythe.ts");
const hourglass_1 = __webpack_require__(/*! ./usable/hourglass */ "./src/item/usable/hourglass.ts");
const scytheHandle_1 = __webpack_require__(/*! ./weapon/scytheHandle */ "./src/item/weapon/scytheHandle.ts");
const scytheBlade_1 = __webpack_require__(/*! ./weapon/scytheBlade */ "./src/item/weapon/scytheBlade.ts");
const fishingRod_1 = __webpack_require__(/*! ./tool/fishingRod */ "./src/item/tool/fishingRod.ts");
exports.ItemTypeMap = {
    dualdagger: dualdagger_1.DualDagger,
    warhammer: warhammer_1.Warhammer,
    spear: spear_1.Spear,
    spellbook: spellbook_1.Spellbook,
    greataxe: greataxe_1.Greataxe,
    scythe: scythe_1.Scythe,
    hourglass: hourglass_1.Hourglass,
    fishingrod: fishingRod_1.FishingRod,
    scytheblade: scytheBlade_1.ScytheBlade,
    scythehandle: scytheHandle_1.ScytheHandle,
    armor: armor_1.Armor,
    pickaxe: pickaxe_1.Pickaxe,
    hammer: hammer_1.Hammer,
    heart: heart_1.Heart,
    weaponpoison: weaponPoison_1.WeaponPoison,
    weaponblood: weaponBlood_1.WeaponBlood,
    coin: coin_1.Coin,
    weaponfragments: weaponFragments_1.WeaponFragments,
    spellbookPage: spellbookPage_1.SpellbookPage,
    backpack: backpack_1.Backpack,
    candle: candle_1.Candle,
    torch: torch_1.Torch,
    lantern: lantern_1.Lantern,
    redgem: redgem_1.RedGem,
    bluegem: bluegem_1.BlueGem,
    greengem: greengem_1.GreenGem,
    geode: geode_1.Geode,
    gold: gold_1.Gold,
    stone: stone_1.Stone,
    coal: coal_1.Coal,
    bomb: bombItem_1.BombItem,
};
class DropTable {
}
exports.DropTable = DropTable;
_a = DropTable;
DropTable.drops = [
    // Weapons - Higher numbers = rarer
    {
        itemType: "dualdagger",
        dropRate: 500,
        category: ["weapon", "melee"],
        unique: true,
    },
    {
        itemType: "warhammer",
        dropRate: 250,
        category: ["weapon", "melee"],
        unique: true,
    },
    {
        itemType: "spear",
        dropRate: 150,
        category: ["weapon", "melee"],
        unique: true,
    },
    {
        itemType: "spellbook",
        dropRate: 250,
        category: ["weapon", "magic"],
        unique: true,
    },
    {
        itemType: "greataxe",
        dropRate: 500,
        category: ["weapon", "melee"],
        unique: true,
    },
    {
        itemType: "scythe",
        dropRate: 500,
        category: ["reaper"],
        unique: true,
    },
    {
        itemType: "scytheblade",
        dropRate: 10,
        category: ["reaper"],
        unique: true,
    },
    {
        itemType: "scythehandle",
        dropRate: 10,
        category: ["reaper"],
        unique: true,
    },
    // Equipment
    { itemType: "armor", dropRate: 350, category: ["equipment"], unique: true },
    // Tools
    { itemType: "pickaxe", dropRate: 25, category: ["tool"] },
    { itemType: "hammer", dropRate: 25, category: ["tool"] },
    { itemType: "fishingrod", dropRate: 10, category: ["tool"] },
    { itemType: "hourglass", dropRate: 10, category: ["reaper"], unique: true },
    // Consumables
    { itemType: "heart", dropRate: 20, category: ["consumable"] },
    { itemType: "weaponpoison", dropRate: 100, category: ["consumable"] },
    { itemType: "weaponblood", dropRate: 100, category: ["consumable"] },
    // Common items
    { itemType: "coin", dropRate: 10, category: ["coin"] },
    // Crafting materials
    {
        itemType: "weaponfragments",
        dropRate: 100,
        category: ["consumable", "melee"],
    },
    {
        itemType: "spellbookPage",
        dropRate: 100,
        category: ["consumable", "magic"],
    },
    // Upgrades
    { itemType: "backpack", dropRate: 100, category: ["upgrade"] },
    // Light sources
    { itemType: "candle", dropRate: 100, category: ["light"] },
    { itemType: "torch", dropRate: 250, category: ["light"] },
    { itemType: "lantern", dropRate: 500, category: ["light"] },
    // Gems and minerals
    { itemType: "redgem", dropRate: 25, category: ["gem", "resource"] },
    { itemType: "bluegem", dropRate: 25, category: ["gem", "resource"] },
    { itemType: "greengem", dropRate: 25, category: ["gem", "resource"] },
    { itemType: "geode", dropRate: 100, category: ["gem", "resource"] },
    { itemType: "gold", dropRate: 200, category: ["resource"] },
    { itemType: "stone", dropRate: 200, category: ["resource"] },
    {
        itemType: "coal",
        dropRate: 100,
        category: ["fuel", "lantern", "resource", "light"],
    },
    { itemType: "bomb", dropRate: 100, category: ["bomb", "weapon"] },
];
DropTable.getDrop = (entity, useCategory = [], force = false, increaseDepth = 0, maxDrops = 1) => {
    if (entity.cloned) {
        return;
    }
    const currentDepth = entity.room.depth + increaseDepth;
    const dropChance = entity.dropChance || 1;
    // Skip initial drop chance check if forced
    if (!force && dropChance > 1 && random_1.Random.rand() > 1 / dropChance) {
        return null;
    }
    // Filter eligible drops by depth
    let eligibleDrops = _a.drops.filter((drop) => drop.minDepth === undefined || drop.minDepth <= currentDepth);
    // Filter out unique items if no categories are specified (default drop table)
    if (useCategory.length === 0) {
        eligibleDrops = eligibleDrops.filter((drop) => drop.unique === undefined || drop.unique === false);
    }
    // Filter by categories or specific items if provided
    if (useCategory.length > 0) {
        eligibleDrops = eligibleDrops.filter((drop) => useCategory.includes(drop.itemType) || // Match specific item
            drop.category.some((cat) => useCategory.includes(cat)));
    }
    // Handle case with no eligible drops
    if (eligibleDrops.length === 0) {
        return null;
    }
    // Track how many items we've dropped
    let droppedCount = 0;
    let droppedItems = [];
    // Try to drop items based on drop rates, up to maxDrops
    for (const drop of eligibleDrops) {
        const randomRoll = random_1.Random.rand();
        const threshold = 1 / drop.dropRate;
        if (randomRoll < threshold) {
            const item = _a.addNewItem(drop.itemType, entity);
            if (item) {
                droppedItems.push(item);
                droppedCount++;
                // Stop if we've reached the maximum number of drops
                if (droppedCount >= maxDrops) {
                    break;
                }
            }
            else {
            }
        }
    }
    // Force drop the most common item if needed and we haven't dropped anything yet
    if (force && droppedCount === 0 && eligibleDrops.length > 0) {
        const mostCommonDrop = eligibleDrops.reduce((prev, curr) => prev.dropRate < curr.dropRate ? prev : curr);
        const item = _a.addNewItem(mostCommonDrop.itemType, entity);
        if (item) {
            droppedItems.push(item);
        }
    }
    return droppedItems.length > 0 ? droppedItems : null;
};
DropTable.addNewItem = (itemType, entity) => {
    const ItemClass = exports.ItemTypeMap[itemType];
    if (!ItemClass) {
        console.error(`Item type "${itemType}" is not recognized.`);
        return null;
    }
    let drop = ItemClass.add(entity.room, entity.x, entity.y);
    if (drop.name === "coin") {
        // Generate random number between 0-14 with normal distribution around 7
        drop.stackCount = utils_1.Utils.randomNormalInt(0, 14);
    }
    if (drop instanceof bluegem_1.BlueGem ||
        drop instanceof redgem_1.RedGem ||
        drop instanceof greengem_1.GreenGem) {
        // Generate random number between 0-14 with normal distribution around 7
        drop.stackCount = utils_1.Utils.randomNormalInt(0, 5);
    }
    entity.drops.push(drop);
    return drop;
};


/***/ }),

/***/ "./src/item/entitySpawner.ts":
/*!***********************************!*\
  !*** ./src/item/entitySpawner.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EntitySpawner = void 0;
const usable_1 = __webpack_require__(/*! ./usable/usable */ "./src/item/usable/usable.ts");
const entity_1 = __webpack_require__(/*! ../entity/entity */ "./src/entity/entity.ts");
const eventBus_1 = __webpack_require__(/*! ../event/eventBus */ "./src/event/eventBus.ts");
const bishopEnemy_1 = __webpack_require__(/*! ../entity/enemy/bishopEnemy */ "./src/entity/enemy/bishopEnemy.ts");
class EntitySpawner extends usable_1.Usable {
    constructor(level, x, y) {
        super(level, x, y);
        this.onUse = (player) => { };
        this.spawnEntity = (entity) => {
            entity_1.Entity.add(this.room, this.player.game, this.player.x, this.player.y);
            //console.log("Entity spawned");
        };
        this.commandHandler = (command) => {
            const player = this.room.game.players[0];
            command = command.toLowerCase();
            if (!command.startsWith("/new")) {
                return;
            }
            switch (command.split(" ")[1]) {
                case "bishop":
                    this.spawnEntity(new bishopEnemy_1.BishopEnemy(this.room, this.player.game, this.player.x, this.player.y));
                    break;
                default:
                    //console.log(`Unknown command: ${command}`);
                    break;
            }
            //console.log(`Command executed: ${command}`);
        };
        this.getDescription = () => {
            return "YOU SHOULD NOT HAVE THIS";
        };
        this.room = level;
        this.count = 0;
        this.tileX = 31;
        this.tileY = 0;
        this.setupEventListeners();
        this.player = this.room.game.players[0];
        this.stackable = false;
    }
    setupEventListeners() {
        //console.log("Setting up event listeners");
        eventBus_1.globalEventBus.on("ChatMessage", this.commandHandler.bind(this));
        //console.log("Event listeners set up");
    }
}
exports.EntitySpawner = EntitySpawner;


/***/ }),

/***/ "./src/item/equippable.ts":
/*!********************************!*\
  !*** ./src/item/equippable.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Equippable = void 0;
const item_1 = __webpack_require__(/*! ./item */ "./src/item/item.ts");
const game_1 = __webpack_require__(/*! ../game */ "./src/game.ts");
const gameplaySettings_1 = __webpack_require__(/*! ../game/gameplaySettings */ "./src/game/gameplaySettings.ts");
class Equippable extends item_1.Item {
    constructor(level, x, y) {
        super(level, x, y);
        this.equipTick = false;
        this.useCost = 1;
        this.cooldown = 0;
        this.cooldownMax = 0;
        this.previousWeapon = null;
        this.setWielder = (wielder) => {
            this.wielder = wielder;
        };
        this.coEquippable = (other) => {
            return true;
        };
        this.toggleEquip = () => {
            if (!this.broken && this.cooldown === 0) {
                if (!this.equipped && this.wielder.inventory?.weapon) {
                    this.previousWeapon = this.wielder.inventory.weapon;
                }
                this.equipped = !this.equipped;
                if (gameplaySettings_1.GameplaySettings.EQUIP_USES_TURN && this.equipped === true)
                    this.wielder?.stall();
            }
            else if (this.broken) {
                this.equipped = false;
                let pronoun = this.name.endsWith("s") ? "them" : "it";
                this.level.game.pushMessage("You'll have to fix your " +
                    this.name +
                    " before you can use " +
                    pronoun +
                    ".");
            }
            else if (this.cooldown > 0) {
                this.level.game.pushMessage("Cooldown: " + this.cooldown);
            }
        };
        this.drawEquipped = (delta, x, y) => {
            game_1.Game.drawItem(this.tileX, this.tileY, 1, 2, x, y - 1, this.w, this.h);
        };
        this.degrade = (degradeAmount = 1) => {
            if (!this.degradeable)
                return;
            this.durability -= degradeAmount * this.useCost;
            if (this.durability <= 0)
                this.break();
        };
        this.break = () => {
            this.durability = 0;
            this.broken = true;
            this.toggleEquip();
            //this.wielder.inventory.removeItem(this);
            //this.wielder = null;
        };
        this.onDrop = () => { };
        this.dropFromInventory = () => {
            this.wielder = null;
            this.equipped = false;
        };
        this.equipped = false;
    }
}
exports.Equippable = Equippable;


/***/ }),

/***/ "./src/item/godStone.ts":
/*!******************************!*\
  !*** ./src/item/godStone.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GodStone = void 0;
const room_1 = __webpack_require__(/*! ../room/room */ "./src/room/room.ts");
const usable_1 = __webpack_require__(/*! ./usable/usable */ "./src/item/usable/usable.ts");
class GodStone extends usable_1.Usable {
    constructor(level, x, y) {
        super(level, x, y);
        this.onUse = (player) => {
            this.teleportToExit(player);
        };
        this.teleportToExit = (player) => {
            let downLadders = this.room.game.rooms.filter((room) => room.type === room_1.RoomType.DOWNLADDER);
            console.log("downLadders", downLadders);
            const room = downLadders[downLadders.length - 1];
            this.room.game.rooms.forEach((room) => {
                room.entered = true;
                room.calculateWallInfo();
            });
            room.game.changeLevelThroughDoor(player, room.doors[0], 1);
            player.x = room.roomX + 2;
            player.y = room.roomY + 3;
        };
        this.getDescription = () => {
            return "YOU SHOULD NOT HAVE THIS";
        };
        this.room = level;
        this.count = 0;
        this.tileX = 31;
        this.tileY = 0;
        this.stackable = true;
    }
}
exports.GodStone = GodStone;


/***/ }),

/***/ "./src/item/goldenKey.ts":
/*!*******************************!*\
  !*** ./src/item/goldenKey.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GoldenKey = void 0;
const equippable_1 = __webpack_require__(/*! ./equippable */ "./src/item/equippable.ts");
class GoldenKey extends equippable_1.Equippable {
    constructor(level, x, y) {
        super(level, x, y);
        this.getDescription = () => {
            return "GOLD KEY\nA heavy gold key.";
        };
        this.tileX = 6;
        this.tileY = 0;
        this.name = "goldenKey";
    }
}
exports.GoldenKey = GoldenKey;
GoldenKey.itemName = "goldenKey";


/***/ }),

/***/ "./src/item/item.ts":
/*!**************************!*\
  !*** ./src/item/item.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Item = void 0;
const game_1 = __webpack_require__(/*! ../game */ "./src/game.ts");
const gameConstants_1 = __webpack_require__(/*! ../game/gameConstants */ "./src/game/gameConstants.ts");
const sound_1 = __webpack_require__(/*! ../sound/sound */ "./src/sound/sound.ts");
const drawable_1 = __webpack_require__(/*! ../drawable/drawable */ "./src/drawable/drawable.ts");
const utils_1 = __webpack_require__(/*! ../utility/utils */ "./src/utility/utils.ts");
const random_1 = __webpack_require__(/*! ../utility/random */ "./src/utility/random.ts");
const IdGenerator_1 = __webpack_require__(/*! ../globalStateManager/IdGenerator */ "./src/globalStateManager/IdGenerator.ts");
// Item class extends Drawable class and represents an item in the game
class Item extends drawable_1.Drawable {
    // Constructor for the Item class
    constructor(level, x, y) {
        super();
        this.group = null;
        this.degradeable = true;
        this.cooldown = 0;
        this.hoverText = () => {
            return this.name;
        };
        // Empty tick function to be overridden by subclasses
        this.tick = () => { };
        // Empty tick function for inventory behavior to be overridden by subclasses
        this.tickInInventory = () => { };
        // Function to get description of the item, to be overridden by subclasses
        this.getDescription = () => {
            const stackText = this.stackable ? `\nAmount: ${this.stackCount}` : "";
            return `${this.name} \n${this.description} \n${stackText}`;
        };
        this.animateFromChest = () => {
            this.chestOffsetY = 0.5;
            this.alpha = 0;
            this.inChest = true;
            this.sineAnimateFactor = 0;
            this.setDrawOffset();
        };
        // Function to play sound when item is picked up
        this.pickupSound = () => {
            if (this.level === this.level.game.room)
                sound_1.Sound.genericPickup();
        };
        // Empty function to be called when item is dropped, to be overridden by subclasses
        this.onDrop = () => { };
        // Function to be called when item is picked up
        this.onPickup = (player) => {
            if (!this.pickedUp) {
                this.startY = player.y;
                this.drawableY = this.y;
                this.alpha = 1;
                this.pickedUp = player.inventory.addItem(this);
                if (this.pickedUp) {
                    if (this.isNewItem(player)) {
                        this.pickupMessage();
                        player.inventory.foundItems.push(this);
                    }
                    this.pickupSound();
                    if (this.grouped) {
                        this.group.destroyOtherItems(this);
                        this.grouped = false;
                        this.group = null;
                    }
                }
            }
        };
        this.pickupMessage = () => {
            const name = this.constructor.itemName;
            let message = this.stackable
                ? `You find ${this.stackCount} ${name}.`
                : `You find a ${name}.`;
            if (this.stackCount > 1 && this.name === "coin") {
                message = `You find ${this.stackCount} ${name}s.`;
            }
            this.level.game.pushMessage(message);
        };
        this.isNewItem = (player) => {
            for (let item of player.inventory.foundItems) {
                if (item.constructor === this.constructor) {
                    return false;
                }
            }
            return true;
        };
        this.dropFromInventory = () => {
            this.setDrawOffset();
        };
        // Function to get the amount of shade at the item's location
        this.shadeAmount = () => {
            if (gameConstants_1.GameConstants.SMOOTH_LIGHTING)
                return 0;
            return this.level.softVis[this.x][this.y];
        };
        this.drawStatus = (x, y) => { };
        this.drawBrokenSymbol = (x, y) => {
            if (this.broken) {
                game_1.Game.drawFX(5, 0, 1, 1, x - 0.5 / gameConstants_1.GameConstants.TILESIZE, y - 0.5 / gameConstants_1.GameConstants.TILESIZE, 1, 1);
            }
        };
        // Function to draw the item
        this.draw = (delta) => {
            game_1.Game.ctx.save();
            if (!this.pickedUp) {
                game_1.Game.ctx.globalAlpha = this.alpha;
                if (this.alpha < 1)
                    this.alpha += 0.01 * delta;
                this.drawableY = this.y;
                if (this.inChest) {
                    this.chestOffsetY -= Math.abs(this.chestOffsetY + 0.5) * 0.035 * delta;
                    if (this.chestOffsetY < -0.47) {
                        this.chestOffsetY = -0.5;
                    }
                }
                if (this.sineAnimateFactor < 1 && this.chestOffsetY < -0.45)
                    this.sineAnimateFactor += 0.2 * delta;
                if (this.scaleFactor > 0) {
                    this.scaleFactor *= 0.5 ** delta;
                    if (this.scaleFactor < 0.01)
                        this.scaleFactor = 0;
                }
                const scale = 1 / (this.scaleFactor + 1);
                game_1.Game.ctx.imageSmoothingEnabled = false;
                game_1.Game.drawItem(0, 0, 1, 1, this.x, this.y, 1, 1);
                this.frame += (delta * (Math.PI * 2)) / 60;
                game_1.Game.drawItem(this.tileX, this.tileY, 1, 2, this.x + this.w * (scale * -0.5 + 0.5) + this.drawOffset, this.y +
                    this.sineAnimateFactor * Math.sin(this.frame) * 0.07 -
                    1 +
                    this.offsetY +
                    this.h * (scale * -0.5 + 0.5) +
                    this.chestOffsetY, this.w * scale, this.h * scale, this.level.shadeColor, this.shadeAmount());
            }
            game_1.Game.ctx.restore();
        };
        this.setDrawOffset = () => {
            const itemsOnTile = this.level.items.filter((item) => item.x === this.x && item.y === this.y);
            if (itemsOnTile.length > 1) {
                itemsOnTile.forEach((item) => {
                    item.drawOffset =
                        (-itemsOnTile.length / 2 + itemsOnTile.indexOf(item) + 1) /
                            itemsOnTile.length;
                });
            }
        };
        this.degrade = () => {
            if (this.degradeable)
                this.durability -= 1;
        };
        // Function to draw the top layer of the item
        this.drawTopLayer = (delta) => {
            if (this.pickedUp) {
                this.pickupOffsetY += (4.5 - this.pickupOffsetY) * 0.1 * delta;
                //this.x += (Math.sin(Date.now() / 50) * delta) / 10;
                this.alpha *= 0.9 ** delta;
                if (Math.abs(this.alpha) < 0.01) {
                    this.drawOffset = 0;
                    this.pickupOffsetY = 1;
                    this.level.items = this.level.items.filter((x) => x !== this);
                }
                if (gameConstants_1.GameConstants.ALPHA_ENABLED)
                    game_1.Game.ctx.globalAlpha = Math.max(0, this.alpha);
                game_1.Game.drawItem(this.tileX, this.tileY, 1, 2, this.x, this.y - this.pickupOffsetY, this.w, this.h);
                game_1.Game.ctx.globalAlpha = 1.0;
            }
        };
        // Function to draw the item's icon
        this.drawIcon = (delta, x, y, opacity = 1, count) => {
            if (gameConstants_1.GameConstants.ALPHA_ENABLED)
                game_1.Game.ctx.globalAlpha = opacity;
            this.drawDurability(x, y);
            let shake = 0;
            if (this.durability <= 1 && !this.broken)
                shake =
                    Math.round(Math.sin(Date.now() / 25) + 1 / 2) /
                        2 /
                        gameConstants_1.GameConstants.TILESIZE;
            if (this.cooldown > 0) {
                game_1.Game.ctx.globalAlpha = 0.35;
            }
            game_1.Game.drawItem(this.tileX, this.tileY, 1, 2, x + shake, y - 1 + this.iconOffset, this.w, this.h);
            game_1.Game.ctx.globalAlpha = 1;
            let countToUse = count ? count : this.stackCount;
            let countText = countToUse <= 1 ? "" : "" + countToUse;
            let width = game_1.Game.measureText(countText).width;
            let countX = 16 - width;
            let countY = 10;
            game_1.Game.fillTextOutline(countText, x * gameConstants_1.GameConstants.TILESIZE + countX, y * gameConstants_1.GameConstants.TILESIZE + countY, gameConstants_1.GameConstants.OUTLINE, "white");
            this.drawCooldown(x, y);
            this.drawStatus(x, y);
            this.drawBrokenSymbol(x, y);
        };
        this.drawCooldown = (x, y) => {
            if (this.cooldown > 0) {
                game_1.Game.fillTextOutline(this.cooldown.toString(), x * gameConstants_1.GameConstants.TILESIZE + 10, y * gameConstants_1.GameConstants.TILESIZE + 10, gameConstants_1.GameConstants.OUTLINE, "white");
            }
        };
        // Function to draw the item's durability bar with color transitioning from green to red
        this.drawDurability = (x, y) => {
            if (this.durability < this.durabilityMax) {
                // Calculate durability ratio (1 = full, 0 = broken)
                const durabilityRatio = this.durability / this.durabilityMax;
                // Map durability ratio to hue (120 = green, 0 = red)
                let color = utils_1.Utils.hsvToHex(120 * durabilityRatio, // Hue from 120 (green) to 0 (red)
                1, // Full saturation
                1);
                const iconWidth = gameConstants_1.GameConstants.TILESIZE;
                const barWidth = Math.ceil(durabilityRatio * iconWidth); // Round to nearest pixel
                const barHeight = 2; // 2 pixels tall
                // Calculate the position of the durability bar
                const barX = Math.ceil(x * gameConstants_1.GameConstants.TILESIZE); // Round to nearest pixel
                const barY = Math.ceil(y * gameConstants_1.GameConstants.TILESIZE + gameConstants_1.GameConstants.TILESIZE - 2); // Round to nearest pixel
                // Set the fill style for the durability bar
                game_1.Game.ctx.fillStyle = color;
                game_1.Game.ctx.imageSmoothingEnabled = false;
                // Draw the durability bar
                game_1.Game.ctx.fillRect(barX, barY, barWidth, barHeight);
                // Reset settings
                game_1.Game.ctx.fillStyle = "white";
            }
        };
        this.globalId = IdGenerator_1.IdGenerator.generate("IT");
        // Initialize properties
        this.level = level;
        this.x = x;
        this.y = y;
        this.drawableY = y;
        this.w = 1;
        this.h = 2;
        this.tileX = 0;
        this.tileY = 0;
        this.frame = 0;
        this.stackable = false;
        this.stackCount = 1;
        this.pickedUp = false;
        this.alpha = 1;
        this.scaleFactor = 5;
        this.offsetY = -0.25;
        this.name = "item";
        this.startY = y;
        this.randomOffset = random_1.Random.rand();
        this.durability = 50;
        this.durabilityMax = 50;
        this.broken = false;
        this.description = "";
        this.drawOffset = 0;
        this.pickupOffsetY = 1;
        this.chestOffsetY = 0;
        this.sineAnimateFactor = 1;
        this.iconOffset = 0;
        this.grouped = false;
        this.group = null;
    }
    static add(room, x, y, ...rest) {
        return new this(room, x, y, ...rest);
    }
    destroy() {
        this.pickedUp = true;
        //this.level.items = this.level.items.filter((x) => x !== this);
    }
}
exports.Item = Item;


/***/ }),

/***/ "./src/item/itemGroup.ts":
/*!*******************************!*\
  !*** ./src/item/itemGroup.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ItemGroup = void 0;
const gameplaySettings_1 = __webpack_require__(/*! ../game/gameplaySettings */ "./src/game/gameplaySettings.ts");
class ItemGroup {
    constructor(items) {
        this.items = items;
    }
    destroyOtherItems(item) {
        for (const i of this.items) {
            if (i !== item) {
                i.destroy();
            }
        }
        item.level.game.pushMessage(`You choose to keep the ${item.name}.`);
        if (gameplaySettings_1.GameplaySettings.UNBREAKABLE_ITEMGROUP_LOOT) {
            item.degradeable = false;
            item.level.game.pushMessage(`This one won't break.`);
            item.description += " Unbreakable.";
        }
    }
}
exports.ItemGroup = ItemGroup;


/***/ }),

/***/ "./src/item/jewelry/amberRing.ts":
/*!***************************************!*\
  !*** ./src/item/jewelry/amberRing.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AmberRing = void 0;
const equippable_1 = __webpack_require__(/*! ../equippable */ "./src/item/equippable.ts");
class AmberRing extends equippable_1.Equippable {
    constructor(level, x, y) {
        super(level, x, y);
        this.tileX = 14;
        this.tileY = 2;
        this.name = AmberRing.itemName;
        this.stackable = false;
        this.description = "A ring of amber";
    }
}
exports.AmberRing = AmberRing;
AmberRing.itemName = "amber ring";


/***/ }),

/***/ "./src/item/jewelry/emeraldRing.ts":
/*!*****************************************!*\
  !*** ./src/item/jewelry/emeraldRing.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EmeraldRing = void 0;
const equippable_1 = __webpack_require__(/*! ../equippable */ "./src/item/equippable.ts");
class EmeraldRing extends equippable_1.Equippable {
    constructor(level, x, y) {
        super(level, x, y);
        this.tileX = 11;
        this.tileY = 2;
        this.name = EmeraldRing.itemName;
        this.stackable = false;
        this.description = "A ring of emerald";
    }
}
exports.EmeraldRing = EmeraldRing;
EmeraldRing.itemName = "emerald ring";


/***/ }),

/***/ "./src/item/jewelry/garnetRing.ts":
/*!****************************************!*\
  !*** ./src/item/jewelry/garnetRing.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GarnetRing = void 0;
const equippable_1 = __webpack_require__(/*! ../equippable */ "./src/item/equippable.ts");
class GarnetRing extends equippable_1.Equippable {
    constructor(level, x, y) {
        super(level, x, y);
        this.tileX = 12;
        this.tileY = 2;
        this.name = GarnetRing.itemName;
        this.stackable = false;
        this.description = "A ring of garnet";
    }
}
exports.GarnetRing = GarnetRing;
GarnetRing.itemName = "garnet ring";


/***/ }),

/***/ "./src/item/jewelry/goldRing.ts":
/*!**************************************!*\
  !*** ./src/item/jewelry/goldRing.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GoldRing = void 0;
const equippable_1 = __webpack_require__(/*! ../equippable */ "./src/item/equippable.ts");
const emeraldRing_1 = __webpack_require__(/*! ./emeraldRing */ "./src/item/jewelry/emeraldRing.ts");
const zirconRing_1 = __webpack_require__(/*! ./zirconRing */ "./src/item/jewelry/zirconRing.ts");
const amberRing_1 = __webpack_require__(/*! ./amberRing */ "./src/item/jewelry/amberRing.ts");
const garnetRing_1 = __webpack_require__(/*! ./garnetRing */ "./src/item/jewelry/garnetRing.ts");
class GoldRing extends equippable_1.Equippable {
    constructor(level, x, y) {
        super(level, x, y);
        this.embed = (player, gem) => {
            player.inventory.subtractItem(gem, 1);
            player.inventory.removeItem(this);
            switch (gem.name) {
                case "emerald":
                    player.inventory.addItem(new emeraldRing_1.EmeraldRing(this.level, this.x, this.y));
                    break;
                case "zircon":
                    player.inventory.addItem(new zirconRing_1.ZirconRing(this.level, this.x, this.y));
                    break;
                case "amber":
                    player.inventory.addItem(new amberRing_1.AmberRing(this.level, this.x, this.y));
                    break;
                case "garnet":
                    player.inventory.addItem(new garnetRing_1.GarnetRing(this.level, this.x, this.y));
                    break;
            }
            this.level.game.pushMessage(`You embed the gem into the ring.`);
        };
        this.tileX = 19;
        this.tileY = 2;
        this.name = GoldRing.itemName;
        this.stackable = false;
        this.description = "Embed a gem within this ring to imbue it with magic.";
    }
}
exports.GoldRing = GoldRing;
GoldRing.itemName = "gold ring";


/***/ }),

/***/ "./src/item/jewelry/zirconRing.ts":
/*!****************************************!*\
  !*** ./src/item/jewelry/zirconRing.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ZirconRing = void 0;
const equippable_1 = __webpack_require__(/*! ../equippable */ "./src/item/equippable.ts");
class ZirconRing extends equippable_1.Equippable {
    constructor(level, x, y) {
        super(level, x, y);
        this.tileX = 13;
        this.tileY = 2;
        this.name = ZirconRing.itemName;
        this.stackable = false;
        this.description = "A ring of zircon";
    }
}
exports.ZirconRing = ZirconRing;
ZirconRing.itemName = "zircon ring";


/***/ }),

/***/ "./src/item/key.ts":
/*!*************************!*\
  !*** ./src/item/key.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Key = void 0;
const item_1 = __webpack_require__(/*! ./item */ "./src/item/item.ts");
const sound_1 = __webpack_require__(/*! ../sound/sound */ "./src/sound/sound.ts");
class Key extends item_1.Item {
    constructor(level, x, y) {
        super(level, x, y);
        this.getDescription = () => {
            //const ID = this.doorID === 0 ? "" : "ID: " + this.doorID.toString();
            const depth = this.depth !== null ? "Depth: " + this.depth.toString() : "";
            return `KEY\nA key. ${depth}`;
        };
        this.onPickup = (player) => {
            if (!this.pickedUp) {
                this.pickedUp = player.inventory.addItem(this);
                if (this.pickedUp) {
                    this.level.game.pushMessage("You found a key!");
                    sound_1.Sound.keyPickup();
                    if (this.depth === null)
                        this.depth = player.depth;
                    console.log(this.depth);
                }
            }
        };
        this.tileX = 1;
        this.tileY = 0;
        this.name = "key";
        this.doorID = 0;
        this.depth = null;
    }
}
exports.Key = Key;
Key.itemName = "key";


/***/ }),

/***/ "./src/item/light/candle.ts":
/*!**********************************!*\
  !*** ./src/item/light/candle.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Candle = void 0;
const light_1 = __webpack_require__(/*! ./light */ "./src/item/light/light.ts");
class Candle extends light_1.Light {
    constructor(level, x, y) {
        super(level, x, y);
        this.fuel = 100; //how many turns before it burns out
        this.tileX = 27;
        this.tileY = 0;
        this.name = "candle";
        this.fuelCap = 100;
        this.radius = 4;
        this.stackable = true;
        this.maxBrightness = 2;
        this.maxBrightness = 0.25;
    }
}
exports.Candle = Candle;
Candle.itemName = "candle";


/***/ }),

/***/ "./src/item/light/glowBugs.ts":
/*!************************************!*\
  !*** ./src/item/light/glowBugs.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GlowBugs = void 0;
const light_1 = __webpack_require__(/*! ./light */ "./src/item/light/light.ts");
class GlowBugs extends light_1.Light {
    constructor(level, x, y) {
        super(level, x, y);
        this.fuel = 100; //how many turns before it burns out
        this.tileX = 27;
        this.tileY = 2;
        this.name = "glow bugs";
        this.fuelCap = 100;
        this.radius = 6;
        this.stackable = true;
        this.maxBrightness = 2;
        this.maxBrightness = 0.25;
        //teal blue green rgb 0-255
        this.color = [5, 75, 75];
    }
}
exports.GlowBugs = GlowBugs;
GlowBugs.itemName = "glow bugs";


/***/ }),

/***/ "./src/item/light/lantern.ts":
/*!***********************************!*\
  !*** ./src/item/light/lantern.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Lantern = void 0;
const light_1 = __webpack_require__(/*! ./light */ "./src/item/light/light.ts");
class Lantern extends light_1.Light {
    constructor(level, x, y) {
        super(level, x, y);
        this.getDescription = () => {
            const percentage = Math.round((this.fuel / this.fuelCap) * 100);
            return `LANTERN - Fuel: ${percentage}%, Capacity: ${this.fuelCap / 50}`;
        };
        this.fuel = 250;
        this.tileX = 29;
        this.tileY = 0;
        this.fuelCap = 250;
        this.name = "lantern";
        this.canRefuel = true;
        this.maxBrightness = 20;
        this.minBrightness = 5;
        this.radius = 7;
        this.broken = this.fuel <= 0 ? true : false;
    }
}
exports.Lantern = Lantern;
Lantern.itemName = "lantern";


/***/ }),

/***/ "./src/item/light/light.ts":
/*!*********************************!*\
  !*** ./src/item/light/light.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Light = void 0;
const game_1 = __webpack_require__(/*! ../../game */ "./src/game.ts");
const equippable_1 = __webpack_require__(/*! ../equippable */ "./src/item/equippable.ts");
const gameConstants_1 = __webpack_require__(/*! ../../game/gameConstants */ "./src/game/gameConstants.ts");
const utils_1 = __webpack_require__(/*! ../../utility/utils */ "./src/utility/utils.ts");
const levelConstants_1 = __webpack_require__(/*! ../../level/levelConstants */ "./src/level/levelConstants.ts");
class Light extends equippable_1.Equippable {
    constructor(level, x, y) {
        super(level, x, y);
        this.canRefuel = false;
        this.updateLighting = () => {
            this.wielder.game.rooms[this.wielder.levelID].updateLighting();
        };
        this.isIgnited = () => {
            if (this.fuel > 0 && this.equipped) {
                return true;
            }
            return false;
        };
        this.dropFromInventory = () => {
            console.log("onDrop");
            if (this.equipped) {
                this.toggleEquip();
            }
        };
        this.setRadius = () => {
            this.wielder.sightRadius = this.radius + this.fuelPercentage * this.radius;
        };
        this.setBrightness = () => {
            this.wielder.lightBrightness =
                this.minBrightness + this.fuelPercentage * this.maxBrightness;
        };
        this.toggleEquip = () => {
            if (this.fuel > 0) {
                this.equipped = !this.equipped;
                if (this.isIgnited()) {
                    //this.setRadius();
                    this.setBrightness();
                    this.wielder.lightEquipped = true;
                    this.wielder.lightColor = this.color;
                }
                else {
                    //this.resetRadius();
                    this.resetBrightness();
                    this.wielder.lightEquipped = false;
                    this.wielder.lightColor = levelConstants_1.LevelConstants.AMBIENT_LIGHT_COLOR;
                }
            }
            else {
                this.wielder.game.pushMessage("I'll need some fuel before I can use this");
            }
            this.updateLighting();
        };
        this.coEquippable = (other) => {
            return !(other instanceof Light);
        };
        this.resetRadius = () => {
            this.wielder.sightRadius = this.wielder.defaultSightRadius;
        };
        this.resetBrightness = () => {
            this.wielder.lightBrightness = 0.5;
        };
        this.burn = () => {
            // Handle active burning, don't burn fuel in empty rooms
            if (this.isIgnited()) {
                const roomCleared = this.wielder.game.rooms[this.wielder.levelID].roomCleared();
                if (!roomCleared)
                    this.fuel--;
                else
                    this.fuel -= 0.2;
                this.setRadius();
                this.setBrightness();
            }
            // Handle depleted fuel
            if (this.fuel <= 0) {
                if (this.stackable) {
                    this.stackCount--;
                    this.fuel = this.fuelCap;
                }
                // Check if item should be removed after stack reduction
                if (this.equipped) {
                    if ((this.stackable && this.stackCount <= 0) ||
                        (!this.stackable && !this.canRefuel)) {
                        this.resetRadius();
                        this.wielder.lightEquipped = false;
                        this.wielder.inventory.removeItem(this);
                        this.wielder.game.pushMessage(`${this.name} depletes.`);
                    }
                    else if (this.canRefuel) {
                        this.wielder.game.pushMessage(`${this.name} depletes.`);
                        this.equipped = false;
                        this.resetRadius();
                        this.wielder.lightEquipped = false;
                        this.broken = true;
                    }
                    this.updateLighting();
                }
            }
        };
        this.drawDurability = (x, y) => {
            if (this.fuel < this.fuelCap) {
                // Calculate durability ratio (1 = full, 0 = broken)
                const durabilityRatio = this.fuel / this.fuelCap;
                // Map durability ratio to hue (120 = green, 0 = red)
                let color = utils_1.Utils.hsvToHex(120 * durabilityRatio, // Hue from 120 (green) to 0 (red)
                1, // Full saturation
                1);
                const iconWidth = gameConstants_1.GameConstants.TILESIZE;
                const barWidth = durabilityRatio * iconWidth;
                const barHeight = 2; // 2 pixels tall
                // Calculate the position of the durability bar
                const barX = x * gameConstants_1.GameConstants.TILESIZE;
                const barY = y * gameConstants_1.GameConstants.TILESIZE + gameConstants_1.GameConstants.TILESIZE - 2;
                // Set the fill style for the durability bar
                game_1.Game.ctx.fillStyle = color;
                // Set the interpolation mode to nearest neighbor
                game_1.Game.ctx.imageSmoothingEnabled = false;
                // Draw the durability bar
                game_1.Game.ctx.fillRect(barX, barY, barWidth, barHeight);
                // Reset fill style to default
                game_1.Game.ctx.fillStyle = "white";
            }
        };
        this.tickInInventory = () => {
            this.burn();
        };
        this.getDescription = () => {
            return `${this.name}: ${Math.ceil(this.fuelPercentage * 100)}%`;
        };
        this.tileX = 28;
        this.tileY = 0;
        this.fuel = 0;
        this.fuelCap = 250;
        this.maxBrightness = 5;
        this.minBrightness = 2;
        this.radius = 6;
        this.equipped = false;
        this.color = levelConstants_1.LevelConstants.TORCH_LIGHT_COLOR;
    }
    get fuelPercentage() {
        return this.fuel / this.fuelCap;
    }
}
exports.Light = Light;


/***/ }),

/***/ "./src/item/light/torch.ts":
/*!*********************************!*\
  !*** ./src/item/light/torch.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Torch = void 0;
const light_1 = __webpack_require__(/*! ./light */ "./src/item/light/light.ts");
class Torch extends light_1.Light {
    constructor(level, x, y) {
        super(level, x, y);
        this.tileX = 28;
        this.tileY = 0;
        this.name = "torch";
        this.fuelCap = 500;
        this.fuel = 500;
        this.radius = 7;
        this.maxBrightness = 5;
        this.minBrightness = 2;
    }
}
exports.Torch = Torch;
Torch.itemName = "torch";


/***/ }),

/***/ "./src/item/resource/bluegem.ts":
/*!**************************************!*\
  !*** ./src/item/resource/bluegem.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BlueGem = void 0;
const usable_1 = __webpack_require__(/*! ../usable/usable */ "./src/item/usable/usable.ts");
class BlueGem extends usable_1.Usable {
    constructor(level, x, y) {
        super(level, x, y);
        this.useOnOther = (player, other) => {
            if (other.name === "gold ring") {
                let goldRing = other;
                goldRing.embed(player, this);
            }
        };
        this.getDescription = () => {
            return "A gem of zircon. Embed it into a gold ring to imbue it with magic.";
        };
        this.tileX = 13;
        this.tileY = 0;
        this.name = BlueGem.itemName;
        this.canUseOnOther = true;
        this.stackable = true;
    }
}
exports.BlueGem = BlueGem;
BlueGem.itemName = "zircon";


/***/ }),

/***/ "./src/item/resource/coal.ts":
/*!***********************************!*\
  !*** ./src/item/resource/coal.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Coal = void 0;
const usable_1 = __webpack_require__(/*! ../usable/usable */ "./src/item/usable/usable.ts");
const lantern_1 = __webpack_require__(/*! ../light/lantern */ "./src/item/light/lantern.ts");
const light_1 = __webpack_require__(/*! ../light/light */ "./src/item/light/light.ts");
const random_1 = __webpack_require__(/*! ../../utility/random */ "./src/utility/random.ts");
class Coal extends usable_1.Usable {
    constructor(level, x, y) {
        super(level, x, y);
        this.onUse = (player) => {
            let l = player.inventory.hasItem(lantern_1.Lantern);
            if (l instanceof lantern_1.Lantern) {
                if (l.fuel <= l.fuelCap - 50) {
                    player.game.pushMessage("You add some fuel to your lantern.");
                    this.stackCount -= 1;
                    if (this.stackCount <= 0) {
                        player.inventory.removeItem(this);
                    }
                }
            }
        };
        this.useOnOther = (player, other) => {
            if (other instanceof light_1.Light) {
                if (other.canRefuel && other.fuel <= 0 && other.broken) {
                    let amountToRefuel = Math.min(this.stackCount * 25, other.fuelCap);
                    other.fuel += amountToRefuel;
                    this.stackCount -= amountToRefuel / 25;
                    other.broken = false;
                    this.level.game.pushMessage(`You add refuel your ${other.name} with ${amountToRefuel / 25} coal.`);
                    if (this.stackCount <= 0)
                        player.inventory.removeItem(this);
                }
            }
        };
        this.tileX = 17;
        this.tileY = 0;
        this.stackable = true;
        this.stackCount = Math.ceil(random_1.Random.rand() * 7 + 3);
        this.name = Coal.itemName;
        this.description = "A piece of coal. Fuels lantern.";
        this.canUseOnOther = true;
    }
}
exports.Coal = Coal;
Coal.itemName = "coal";


/***/ }),

/***/ "./src/item/resource/geode.ts":
/*!************************************!*\
  !*** ./src/item/resource/geode.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Geode = void 0;
const item_1 = __webpack_require__(/*! ../item */ "./src/item/item.ts");
const redgem_1 = __webpack_require__(/*! ./redgem */ "./src/item/resource/redgem.ts");
const bluegem_1 = __webpack_require__(/*! ./bluegem */ "./src/item/resource/bluegem.ts");
const greengem_1 = __webpack_require__(/*! ./greengem */ "./src/item/resource/greengem.ts");
const utils_1 = __webpack_require__(/*! ../../utility/utils */ "./src/utility/utils.ts");
const random_1 = __webpack_require__(/*! ../../utility/random */ "./src/utility/random.ts");
class Geode extends item_1.Item {
    constructor(level, x, y) {
        super(level, x, y);
        this.getDescription = () => {
            return "GEODE\nWhen in doubt hit it with a hammer.";
        };
        this.split = (inventory) => {
            if (inventory.isFull()) {
                this.level.game.pushMessage(`You don't have enough space in your inventory to split the geode.`);
            }
            else {
                const numGems = Math.min(1, utils_1.Utils.randomNormalInt(1, 3));
                let gemTypes = [bluegem_1.BlueGem, redgem_1.RedGem, greengem_1.GreenGem];
                let gemType = gemTypes[Math.floor(random_1.Random.rand() * gemTypes.length)];
                this.level.game.pushMessage(`You split the geode and find ${numGems} ${gemType.itemName}.`);
                for (let i = 0; i < numGems; i++) {
                    inventory.addItem(new gemType(this.level, this.x, this.y));
                }
                inventory.removeItem(this);
            }
        };
        this.tileX = 15;
        this.tileY = 2;
        this.name = Geode.itemName;
        this.stackable = false;
    }
}
exports.Geode = Geode;
Geode.itemName = "geode";


/***/ }),

/***/ "./src/item/resource/gold.ts":
/*!***********************************!*\
  !*** ./src/item/resource/gold.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Gold = void 0;
const item_1 = __webpack_require__(/*! ../item */ "./src/item/item.ts");
const goldBar_1 = __webpack_require__(/*! ./goldBar */ "./src/item/resource/goldBar.ts");
const sound_1 = __webpack_require__(/*! ../../sound/sound */ "./src/sound/sound.ts");
class Gold extends item_1.Item {
    constructor(level, x, y) {
        super(level, x, y);
        this.smelt = (player) => {
            if (this.stackCount >= 3) {
                player.inventory.subtractItem(this, 3);
                player.inventory.addItem(new goldBar_1.GoldBar(this.level, this.x, this.y));
                sound_1.Sound.playSmith();
                this.level.game.pushMessage(`You smelt the gold ore into a gold bar.`);
            }
        };
        this.tileX = 18;
        this.tileY = 0;
        this.name = Gold.itemName;
        this.stackable = true;
        this.description = "Some gold ore";
    }
}
exports.Gold = Gold;
Gold.itemName = "gold";


/***/ }),

/***/ "./src/item/resource/goldBar.ts":
/*!**************************************!*\
  !*** ./src/item/resource/goldBar.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GoldBar = void 0;
const item_1 = __webpack_require__(/*! ../item */ "./src/item/item.ts");
const goldRing_1 = __webpack_require__(/*! ../jewelry/goldRing */ "./src/item/jewelry/goldRing.ts");
const sound_1 = __webpack_require__(/*! ../../sound/sound */ "./src/sound/sound.ts");
class GoldBar extends item_1.Item {
    constructor(level, x, y) {
        super(level, x, y);
        this.smith = (player) => {
            player.inventory.subtractItem(this, 1);
            player.inventory.addItem(new goldRing_1.GoldRing(this.level, this.x, this.y));
            this.level.game.pushMessage(`You hammer the gold bar into a ring.`);
            sound_1.Sound.playSmith();
        };
        this.tileX = 18;
        this.tileY = 2;
        this.name = GoldBar.itemName;
        this.stackable = true;
        this.description = "A bar of gold. Hit it with a hammer to make a ring.";
    }
}
exports.GoldBar = GoldBar;
GoldBar.itemName = "gold bar";


/***/ }),

/***/ "./src/item/resource/greengem.ts":
/*!***************************************!*\
  !*** ./src/item/resource/greengem.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GreenGem = void 0;
const usable_1 = __webpack_require__(/*! ../usable/usable */ "./src/item/usable/usable.ts");
class GreenGem extends usable_1.Usable {
    constructor(level, x, y) {
        super(level, x, y);
        this.useOnOther = (player, other) => {
            if (other.name === "gold ring") {
                let goldRing = other;
                goldRing.embed(player, this);
            }
        };
        this.getDescription = () => {
            return "An emerald gem. Embed it into a gold ring to imbue it with magic.";
        };
        this.tileX = 11;
        this.tileY = 0;
        this.name = GreenGem.itemName;
        this.canUseOnOther = true;
        this.stackable = true;
    }
}
exports.GreenGem = GreenGem;
GreenGem.itemName = "emerald";


/***/ }),

/***/ "./src/item/resource/orangegem.ts":
/*!****************************************!*\
  !*** ./src/item/resource/orangegem.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.OrangeGem = void 0;
const usable_1 = __webpack_require__(/*! ../usable/usable */ "./src/item/usable/usable.ts");
class OrangeGem extends usable_1.Usable {
    constructor(level, x, y) {
        super(level, x, y);
        this.useOnOther = (player, other) => {
            if (other.name === "gold ring") {
                let goldRing = other;
                goldRing.embed(player, this);
            }
        };
        this.getDescription = () => {
            return "An amber gem. Embed it into a gold ring to imbue it with magic.";
        };
        this.tileX = 14;
        this.tileY = 0;
        this.name = OrangeGem.itemName;
        this.canUseOnOther = true;
        this.stackable = true;
    }
}
exports.OrangeGem = OrangeGem;
OrangeGem.itemName = "amber";


/***/ }),

/***/ "./src/item/resource/redgem.ts":
/*!*************************************!*\
  !*** ./src/item/resource/redgem.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RedGem = void 0;
const usable_1 = __webpack_require__(/*! ../usable/usable */ "./src/item/usable/usable.ts");
class RedGem extends usable_1.Usable {
    constructor(level, x, y) {
        super(level, x, y);
        this.useOnOther = (player, other) => {
            if (other.name === "gold ring") {
                let goldRing = other;
                goldRing.embed(player, this);
            }
        };
        this.getDescription = () => {
            return "A garnet gem. Embed it into a gold ring to imbue it with magic.";
        };
        this.tileX = 12;
        this.tileY = 0;
        this.name = RedGem.itemName;
        this.canUseOnOther = true;
        this.stackable = true;
    }
}
exports.RedGem = RedGem;
RedGem.itemName = "garnet";


/***/ }),

/***/ "./src/item/resource/stone.ts":
/*!************************************!*\
  !*** ./src/item/resource/stone.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Stone = void 0;
const item_1 = __webpack_require__(/*! ../item */ "./src/item/item.ts");
class Stone extends item_1.Item {
    constructor(level, x, y) {
        super(level, x, y);
        this.getDescription = () => {
            return "STONE\nSome fragments of stone.";
        };
        this.tileX = 15;
        this.tileY = 0;
        this.stackable = true;
    }
}
exports.Stone = Stone;
Stone.itemName = "stones";


/***/ }),

/***/ "./src/item/tool/fishingRod.ts":
/*!*************************************!*\
  !*** ./src/item/tool/fishingRod.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FishingRod = void 0;
const item_1 = __webpack_require__(/*! ../item */ "./src/item/item.ts");
class FishingRod extends item_1.Item {
    constructor(level, x, y) {
        super(level, x, y);
        this.tileX = 31;
        this.tileY = 2;
        this.offsetY = -0.1;
        this.description = "useful for catching fish";
        this.name = FishingRod.itemName;
    }
}
exports.FishingRod = FishingRod;
FishingRod.itemName = "fishing rod";


/***/ }),

/***/ "./src/item/tool/hammer.ts":
/*!*********************************!*\
  !*** ./src/item/tool/hammer.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Hammer = void 0;
const sound_1 = __webpack_require__(/*! ../../sound/sound */ "./src/sound/sound.ts");
const usable_1 = __webpack_require__(/*! ../usable/usable */ "./src/item/usable/usable.ts");
const weapon_1 = __webpack_require__(/*! ../weapon/weapon */ "./src/item/weapon/weapon.ts");
const weaponFragments_1 = __webpack_require__(/*! ../usable/weaponFragments */ "./src/item/usable/weaponFragments.ts");
const random_1 = __webpack_require__(/*! ../../utility/random */ "./src/utility/random.ts");
class Hammer extends usable_1.Usable {
    constructor(level, x, y) {
        super(level, x, y);
        this.onUse = (player) => {
            player.health = Math.min(player.maxHealth, player.health + 1);
            if (this.level.game.rooms[player.levelID] === this.level.game.room)
                sound_1.Sound.heal();
            //this.level.items = this.level.items.filter((x) => x !== this); // removes itself from the level
        };
        this.useOnOther = (player, other) => {
            if (other instanceof weapon_1.Weapon && other.name !== "dagger") {
                other.disassemble();
            }
            else if (other.name === "dagger") {
                this.level.game.pushMessage(`You probably shouldn't disassemble your dagger...`);
            }
            else if (other.name === "hammer" && other !== this) {
                let hammer = other;
                hammer.disassemble(player);
                this.level.game.pushMessage(`I only needed one of those anyways...`);
            }
            else if (other.name === "geode") {
                let geode = other;
                geode.split(player.inventory);
                this.level.game.pushMessage(`You hit the geode with the hammer.`);
            }
            else if (other.name === "pickaxe") {
                let pickaxe = other;
                pickaxe.disassemble();
            }
            else if (other.name === "gold bar") {
                let goldBar = other;
                goldBar.smith(player);
            }
            else if (other.name === "gold") {
                let gold = other;
                gold.smelt(player);
            }
        };
        this.disassemble = (player) => {
            let inventoryX = this.x;
            let inventoryY = this.y;
            let numFragments = Math.ceil(random_1.Random.rand() * 5 + 5);
            player.inventory.removeItem(this);
            player.inventory.addItem(new weaponFragments_1.WeaponFragments(this.level, inventoryX, inventoryY, numFragments));
        };
        this.tileX = 21;
        this.tileY = 2;
        this.offsetY = -0.3;
        this.canUseOnOther = true;
        this.description = "useful for breaking weapons down into fragments";
        this.name = Hammer.itemName;
    }
}
exports.Hammer = Hammer;
Hammer.itemName = "hammer";


/***/ }),

/***/ "./src/item/tool/pickaxe.ts":
/*!**********************************!*\
  !*** ./src/item/tool/pickaxe.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Pickaxe = void 0;
const weapon_1 = __webpack_require__(/*! ../weapon/weapon */ "./src/item/weapon/weapon.ts");
class Pickaxe extends weapon_1.Weapon {
    constructor(level, x, y) {
        super(level, x, y);
        this.tileX = 30;
        this.tileY = 0;
        this.name = Pickaxe.itemName;
        this.description = "allows mining rocks without equipping";
        this.canMine = true;
    }
}
exports.Pickaxe = Pickaxe;
Pickaxe.itemName = "pickaxe";


/***/ }),

/***/ "./src/item/usable/apple.ts":
/*!**********************************!*\
  !*** ./src/item/usable/apple.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Apple = void 0;
const usable_1 = __webpack_require__(/*! ./usable */ "./src/item/usable/usable.ts");
const sound_1 = __webpack_require__(/*! ../../sound/sound */ "./src/sound/sound.ts");
class Apple extends usable_1.Usable {
    constructor(level, x, y) {
        super(level, x, y);
        this.onUse = (player) => {
            if (player.health < player.maxHealth) {
                player.health = Math.min(player.maxHealth, player.health + 0.5);
                sound_1.Sound.playEat();
                if (this.stackCount > 1) {
                    this.stackCount--;
                }
                else
                    player.inventory.removeItem(this);
                player.game.pushMessage("You eat the apple and feel better.");
            }
        };
        this.getDescription = () => {
            return "APPLE\nAppears nutritious.";
        };
        this.tileX = 6;
        this.tileY = 2;
        this.stackable = true;
    }
}
exports.Apple = Apple;
Apple.itemName = "apple";


/***/ }),

/***/ "./src/item/usable/bluePotion.ts":
/*!***************************************!*\
  !*** ./src/item/usable/bluePotion.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BluePotion = void 0;
const sound_1 = __webpack_require__(/*! ../../sound/sound */ "./src/sound/sound.ts");
const usable_1 = __webpack_require__(/*! ./usable */ "./src/item/usable/usable.ts");
class BluePotion extends usable_1.Usable {
    constructor(level, x, y) {
        super(level, x, y);
        this.onUse = (player) => {
            player.health = Math.min(player.maxHealth, player.health + 1);
            if (this.level.game.rooms[player.levelID] === this.level.game.room)
                sound_1.Sound.heal();
            player.inventory.removeItem(this);
            //this.level.items = this.level.items.filter((x) => x !== this); // removes itself from the level
        };
        this.getDescription = () => {
            return "HEALTH POTION\nRestores 1 heart";
        };
        this.tileX = 9;
        this.tileY = 0;
        this.offsetY = -0.3;
    }
}
exports.BluePotion = BluePotion;


/***/ }),

/***/ "./src/item/usable/fish.ts":
/*!*********************************!*\
  !*** ./src/item/usable/fish.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Fish = void 0;
const usable_1 = __webpack_require__(/*! ./usable */ "./src/item/usable/usable.ts");
const sound_1 = __webpack_require__(/*! ../../sound/sound */ "./src/sound/sound.ts");
class Fish extends usable_1.Usable {
    constructor(level, x, y) {
        super(level, x, y);
        this.onUse = (player) => {
            if (player.health < player.maxHealth) {
                player.health = Math.min(player.maxHealth, player.health + 0.5);
                sound_1.Sound.playEat();
                if (this.stackCount > 1) {
                    this.stackCount--;
                }
                else
                    player.inventory.removeItem(this);
                player.game.pushMessage("You eat the fish and feel better.");
            }
        };
        this.getDescription = () => {
            return "FISH\nLooks spiky.";
        };
        this.tileX = 5;
        this.tileY = 2;
        this.stackable = true;
    }
}
exports.Fish = Fish;
Fish.itemName = "fish";


/***/ }),

/***/ "./src/item/usable/greenPotion.ts":
/*!****************************************!*\
  !*** ./src/item/usable/greenPotion.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GreenPotion = void 0;
const sound_1 = __webpack_require__(/*! ../../sound/sound */ "./src/sound/sound.ts");
const usable_1 = __webpack_require__(/*! ./usable */ "./src/item/usable/usable.ts");
class GreenPotion extends usable_1.Usable {
    constructor(level, x, y) {
        super(level, x, y);
        this.onUse = (player) => {
            player.health = Math.min(player.maxHealth, player.health + 1);
            if (this.level.game.rooms[player.levelID] === this.level.game.room)
                sound_1.Sound.heal();
            player.inventory.removeItem(this);
            //this.level.items = this.level.items.filter((x) => x !== this); // removes itself from the level
        };
        this.getDescription = () => {
            return "GREEN POTION\nRestores 1 heart";
        };
        this.tileX = 7;
        this.tileY = 0;
        this.offsetY = -0.3;
    }
}
exports.GreenPotion = GreenPotion;


/***/ }),

/***/ "./src/item/usable/heart.ts":
/*!**********************************!*\
  !*** ./src/item/usable/heart.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Heart = void 0;
const sound_1 = __webpack_require__(/*! ../../sound/sound */ "./src/sound/sound.ts");
const usable_1 = __webpack_require__(/*! ./usable */ "./src/item/usable/usable.ts");
class Heart extends usable_1.Usable {
    constructor(level, x, y) {
        super(level, x, y);
        this.onUse = (player) => {
            if (player.health < player.maxHealth) {
                player.health = Math.min(player.maxHealth, player.health + 1);
                if (this.level.game.rooms[player.levelID] === this.level.game.room)
                    sound_1.Sound.heal();
                if (this.stackCount > 1) {
                    this.stackCount--;
                }
                else
                    player.inventory.removeItem(this);
                player.game.pushMessage("You drink the health potion.");
            }
        };
        this.tileX = 8;
        this.tileY = 0;
        this.offsetY = -0.3;
        this.name = Heart.itemName;
        this.stackable = true;
        this.description = "restores 1 health";
    }
}
exports.Heart = Heart;
Heart.itemName = "health potion";


/***/ }),

/***/ "./src/item/usable/hourglass.ts":
/*!**************************************!*\
  !*** ./src/item/usable/hourglass.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Hourglass = void 0;
const usable_1 = __webpack_require__(/*! ./usable */ "./src/item/usable/usable.ts");
class Hourglass extends usable_1.Usable {
    constructor(level, x, y) {
        super(level, x, y);
        this.onUse = (player) => {
            if (this.broken)
                return;
            player.stall();
            player.game.pushMessage("turn skipped");
            this.durability -= 1;
            if (this.durability <= 0) {
                this.broken = true;
            }
            //this.level.items = this.level.items.filter((x) => x !== this); // removes itself from the level
        };
        this.getDescription = () => {
            return "HOURGLASS\nSkips a turn";
        };
        this.tileX = 0;
        this.tileY = 2;
        this.offsetY = -0.3;
        this.durability = 30;
        this.durabilityMax = 30;
    }
}
exports.Hourglass = Hourglass;


/***/ }),

/***/ "./src/item/usable/shrooms.ts":
/*!************************************!*\
  !*** ./src/item/usable/shrooms.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Shrooms = void 0;
const usable_1 = __webpack_require__(/*! ./usable */ "./src/item/usable/usable.ts");
const sound_1 = __webpack_require__(/*! ../../sound/sound */ "./src/sound/sound.ts");
class Shrooms extends usable_1.Usable {
    constructor(level, x, y) {
        super(level, x, y);
        this.onUse = (player) => {
            if (player.health < player.maxHealth) {
                player.health = Math.min(player.maxHealth, player.health + 0.5);
                sound_1.Sound.playEat();
                if (this.stackCount > 1) {
                    this.stackCount--;
                }
                else
                    player.inventory.removeItem(this);
                player.game.pushMessage("You eat the mushrooms and feel better.");
            }
        };
        this.getDescription = () => {
            return "SHROOMS\nI don't think I should eat these...";
        };
        this.tileX = 6;
        this.tileY = 0;
        this.stackable = true;
    }
}
exports.Shrooms = Shrooms;
Shrooms.itemName = "mushrooms";


/***/ }),

/***/ "./src/item/usable/spellbookPage.ts":
/*!******************************************!*\
  !*** ./src/item/usable/spellbookPage.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SpellbookPage = void 0;
const sound_1 = __webpack_require__(/*! ../../sound/sound */ "./src/sound/sound.ts");
const usable_1 = __webpack_require__(/*! ./usable */ "./src/item/usable/usable.ts");
const equippable_1 = __webpack_require__(/*! ../equippable */ "./src/item/equippable.ts");
const random_1 = __webpack_require__(/*! ../../utility/random */ "./src/utility/random.ts");
class SpellbookPage extends usable_1.Usable {
    constructor(level, x, y, stackCount) {
        super(level, x, y);
        this.onUse = (player) => {
            player.health = Math.min(player.maxHealth, player.health + 1);
            if (this.level.game.rooms[player.levelID] === this.level.game.room)
                sound_1.Sound.heal();
            player.inventory.removeItem(this);
            //this.level.items = this.level.items.filter((x) => x !== this); // removes itself from the level
        };
        this.useOnOther = (player, other) => {
            if (other instanceof equippable_1.Equippable &&
                other.durabilityMax - other.durability >= 1 &&
                other.name === "spellbook") {
                let repairAmount = Math.min(other.durabilityMax - other.durability, this.stackCount);
                other.durability += repairAmount;
                this.stackCount -= repairAmount;
                other.broken = false;
                this.level.game.pushMessage(`You feel your ${other.name}'s power return as you add ${repairAmount} pages to it.`);
                if (this.stackCount <= 0)
                    player.inventory.removeItem(this);
            }
        };
        this.tileX = 25;
        this.tileY = 2;
        this.offsetY = -0.3;
        this.name = "spellbook pages";
        this.canUseOnOther = true;
        this.stackable = true;
        this.stackCount = stackCount || Math.ceil(random_1.Random.rand() * 3);
        this.description = "Can be used to restore power to a depleted spellbook";
    }
}
exports.SpellbookPage = SpellbookPage;
SpellbookPage.itemName = "weapon fragments";


/***/ }),

/***/ "./src/item/usable/usable.ts":
/*!***********************************!*\
  !*** ./src/item/usable/usable.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Usable = void 0;
const item_1 = __webpack_require__(/*! ../item */ "./src/item/item.ts");
class Usable extends item_1.Item {
    constructor(level, x, y) {
        super(level, x, y);
        this.onUse = (player) => { };
        this.useOnOther = (player, other) => { };
        this.canUseOnOther = false;
    }
}
exports.Usable = Usable;


/***/ }),

/***/ "./src/item/usable/weaponBlood.ts":
/*!****************************************!*\
  !*** ./src/item/usable/weaponBlood.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WeaponBlood = void 0;
const sound_1 = __webpack_require__(/*! ../../sound/sound */ "./src/sound/sound.ts");
const usable_1 = __webpack_require__(/*! ./usable */ "./src/item/usable/usable.ts");
const weapon_1 = __webpack_require__(/*! ../weapon/weapon */ "./src/item/weapon/weapon.ts");
class WeaponBlood extends usable_1.Usable {
    constructor(level, x, y) {
        super(level, x, y);
        this.onUse = (player) => {
            player.health = Math.min(player.maxHealth, player.health + 1);
            if (this.level.game.rooms[player.levelID] === this.level.game.room)
                sound_1.Sound.heal();
            //this.level.items = this.level.items.filter((x) => x !== this); // removes itself from the level
        };
        this.useOnOther = (player, other) => {
            if (other instanceof weapon_1.Weapon) {
                other.applyStatus({ blood: true, poison: false });
                player.inventory.removeItem(this);
                this.level.game.pushMessage(`You coat your ${other.name} in cursed blood.`);
            }
        };
        this.getDescription = () => {
            return "WEAPON BLOOD\nCan be applied to weapons to deal bleed damage";
        };
        this.tileX = 12;
        this.tileY = 4;
        this.offsetY = -0.3;
        this.canUseOnOther = true;
    }
}
exports.WeaponBlood = WeaponBlood;
WeaponBlood.itemName = "cursed blood";


/***/ }),

/***/ "./src/item/usable/weaponFragments.ts":
/*!********************************************!*\
  !*** ./src/item/usable/weaponFragments.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WeaponFragments = void 0;
const sound_1 = __webpack_require__(/*! ../../sound/sound */ "./src/sound/sound.ts");
const usable_1 = __webpack_require__(/*! ./usable */ "./src/item/usable/usable.ts");
const equippable_1 = __webpack_require__(/*! ../equippable */ "./src/item/equippable.ts");
const random_1 = __webpack_require__(/*! ../../utility/random */ "./src/utility/random.ts");
class WeaponFragments extends usable_1.Usable {
    constructor(level, x, y, stackCount) {
        super(level, x, y);
        this.onUse = (player) => {
            player.health = Math.min(player.maxHealth, player.health + 1);
            if (this.level.game.rooms[player.levelID] === this.level.game.room)
                sound_1.Sound.heal();
            player.inventory.removeItem(this);
            //this.level.items = this.level.items.filter((x) => x !== this); // removes itself from the level
        };
        this.useOnOther = (player, other) => {
            if (other instanceof equippable_1.Equippable &&
                other.durabilityMax - other.durability >= 1 &&
                other.name !== "spellbook") {
                let repairAmount = Math.min(other.durabilityMax - other.durability, this.stackCount);
                other.durability += repairAmount;
                this.stackCount -= repairAmount;
                other.broken = false;
                this.level.game.pushMessage(`You repair your ${other.name} with ${repairAmount} fragments.`);
                if (this.stackCount <= 0)
                    player.inventory.removeItem(this);
            }
            else if (other.name === "spellbook") {
                this.level.game.pushMessage("You'll need some book pages to replenish that.");
            }
        };
        this.tileX = 3;
        this.tileY = 0;
        this.offsetY = -0.3;
        this.name = "weapon fragments";
        this.canUseOnOther = true;
        this.stackable = true;
        this.stackCount = stackCount || Math.ceil(random_1.Random.rand() * 10) + 7;
        this.description = "Can be used to repair broken weapons";
    }
}
exports.WeaponFragments = WeaponFragments;
WeaponFragments.itemName = "weapon fragments";


/***/ }),

/***/ "./src/item/usable/weaponPoison.ts":
/*!*****************************************!*\
  !*** ./src/item/usable/weaponPoison.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WeaponPoison = void 0;
const sound_1 = __webpack_require__(/*! ../../sound/sound */ "./src/sound/sound.ts");
const usable_1 = __webpack_require__(/*! ./usable */ "./src/item/usable/usable.ts");
const weapon_1 = __webpack_require__(/*! ../weapon/weapon */ "./src/item/weapon/weapon.ts");
class WeaponPoison extends usable_1.Usable {
    constructor(level, x, y) {
        super(level, x, y);
        this.onUse = (player) => {
            player.health = Math.min(player.maxHealth, player.health + 1);
            if (this.level.game.rooms[player.levelID] === this.level.game.room)
                sound_1.Sound.heal();
            //this.level.items = this.level.items.filter((x) => x !== this); // removes itself from the level
        };
        this.useOnOther = (player, other) => {
            if (other instanceof weapon_1.Weapon) {
                other.applyStatus({ poison: true, blood: false });
                player.inventory.removeItem(this);
                this.level.game.pushMessage(`You apply the poison to your ${other.name}.`);
                console.log(`weapon poison used on ${other.name}`);
            }
        };
        this.getDescription = () => {
            return "WEAPON POISON\nCan be applied to weapons to deal poison damage";
        };
        this.tileX = 11;
        this.tileY = 4;
        this.offsetY = -0.3;
        this.canUseOnOther = true;
    }
}
exports.WeaponPoison = WeaponPoison;
WeaponPoison.itemName = "weapon poison";


/***/ }),

/***/ "./src/item/weapon/dagger.ts":
/*!***********************************!*\
  !*** ./src/item/weapon/dagger.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Dagger = void 0;
const weapon_1 = __webpack_require__(/*! ./weapon */ "./src/item/weapon/weapon.ts");
class Dagger extends weapon_1.Weapon {
    constructor(level, x, y) {
        super(level, x, y);
        this.weaponMove = (newX, newY) => {
            if (this.checkForPushables(newX, newY))
                return true;
            const hitSomething = this.executeAttack(newX, newY);
            return !hitSomething;
        };
        this.degrade = () => { };
        this.tileX = 22;
        this.tileY = 0;
        this.name = "dagger";
        this.description = "A basic but dependable weapon.";
    }
}
exports.Dagger = Dagger;
Dagger.itemName = "dagger";


/***/ }),

/***/ "./src/item/weapon/dualdagger.ts":
/*!***************************************!*\
  !*** ./src/item/weapon/dualdagger.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DualDagger = void 0;
const weapon_1 = __webpack_require__(/*! ./weapon */ "./src/item/weapon/weapon.ts");
const sound_1 = __webpack_require__(/*! ../../sound/sound */ "./src/sound/sound.ts");
const attackAnimation_1 = __webpack_require__(/*! ../../particle/attackAnimation */ "./src/particle/attackAnimation.ts");
class DualDagger extends weapon_1.Weapon {
    constructor(level, x, y) {
        super(level, x, y);
        this.hitSound = () => {
            sound_1.Sound.swing();
            sound_1.Sound.playShortSlice();
        };
        this.tickInInventory = () => {
            this.firstAttack = true;
        };
        this.weaponMove = (newX, newY) => {
            const entities = this.getEntitiesAt(newX, newY).filter((e) => !e.pushable);
            let flag = false;
            for (let e of entities) {
                this.attack(e, this.damage);
                this.statusEffect(e);
                flag = true;
            }
            if (flag) {
                this.hitSound();
                this.wielder.setHitXY(newX, newY);
                this.shakeScreen(newX, newY);
                if (this.firstAttack) {
                    this.game.rooms[this.wielder.levelID].particles.push(new attackAnimation_1.AttackAnimation(newX, newY, "dualdagger", this.wielder.direction));
                }
                else {
                    this.game.rooms[this.wielder.levelID].particles.push(new attackAnimation_1.AttackAnimation(newX, newY, "dualdagger2", this.wielder.direction));
                }
                this.game.rooms[this.wielder.levelID].entities = this.game.rooms[this.wielder.levelID].entities.filter((e) => !e.dead);
                if (!this.firstAttack) {
                    this.game.rooms[this.wielder.levelID].tick(this.wielder);
                }
                if (this.wielder === this.game.players[this.game.localPlayerID])
                    this.game.shakeScreen(10 * this.wielder.hitX, 10 * this.wielder.hitY);
                if (this.firstAttack) {
                    this.game.rooms[this.wielder.levelID].tickHitWarnings();
                    this.game.rooms[this.wielder.levelID].clearDeadStuff();
                    this.firstAttack = false;
                    this.wielder.beginSlowMotion();
                }
                this.degrade();
            }
            return !flag;
        };
        this.tileX = 23;
        this.tileY = 0;
        this.firstAttack = true;
        this.name = "Dual Daggers";
        this.useCost = 2;
        this.description =
            "After the first attack, enemies will not take their turn until you attack or move again.";
    }
}
exports.DualDagger = DualDagger;
DualDagger.itemName = "dual daggers";


/***/ }),

/***/ "./src/item/weapon/greataxe.ts":
/*!*************************************!*\
  !*** ./src/item/weapon/greataxe.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Greataxe = void 0;
const weapon_1 = __webpack_require__(/*! ./weapon */ "./src/item/weapon/weapon.ts");
const sound_1 = __webpack_require__(/*! ../../sound/sound */ "./src/sound/sound.ts");
const game_1 = __webpack_require__(/*! ../../game */ "./src/game.ts");
class Greataxe extends weapon_1.Weapon {
    constructor(level, x, y) {
        super(level, x, y);
        this.hitSound = () => {
            sound_1.Sound.swing();
            sound_1.Sound.playWarHammer();
        };
        this.adjustedDamage = () => {
            let hp = this.wielder?.health / this.wielder?.maxHealth;
            let damage = 1;
            if (hp <= 1)
                damage = 1;
            if (hp <= 0.75)
                damage = 2;
            if (hp <= 0.5)
                damage = 4;
            if (hp <= 0.25)
                damage = 8;
            return damage;
        };
        this.attack = (enemy) => {
            enemy.hurt(this.wielder, this.adjustedDamage());
            this.statusEffect(enemy);
        };
        this.shakeScreen = () => {
            this.wielder.beginSlowMotion();
            setTimeout(() => {
                this.wielder.endSlowMotion();
                //this.hitSound();
                switch (this.wielder.direction) {
                    case game_1.Direction.DOWN:
                        this.game.shakeScreen(0, -10 * this.adjustedDamage(), false);
                        break;
                    case game_1.Direction.UP:
                        this.game.shakeScreen(0, -10 * this.adjustedDamage(), false);
                        break;
                    case game_1.Direction.LEFT:
                        this.game.shakeScreen(-5, -10 * this.adjustedDamage(), false);
                        break;
                    case game_1.Direction.RIGHT:
                        this.game.shakeScreen(5, -10 * this.adjustedDamage(), false);
                        break;
                }
            }, this.hitDelay);
        };
        this.tileX = 24;
        this.tileY = 2;
        this.damage = 2;
        this.name = "greataxe";
        this.hitDelay = 225;
        this.offsetY = 0;
        this.iconOffset = 0.2;
        this.durability = 25;
        this.durabilityMax = 25;
        this.useCost = 5;
    }
}
exports.Greataxe = Greataxe;
Greataxe.itemName = "greataxe";


/***/ }),

/***/ "./src/item/weapon/scythe.ts":
/*!***********************************!*\
  !*** ./src/item/weapon/scythe.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Scythe = void 0;
const weapon_1 = __webpack_require__(/*! ./weapon */ "./src/item/weapon/weapon.ts");
const sound_1 = __webpack_require__(/*! ../../sound/sound */ "./src/sound/sound.ts");
const game_1 = __webpack_require__(/*! ../../game */ "./src/game.ts");
class Scythe extends weapon_1.Weapon {
    constructor(level, x, y) {
        super(level, x, y);
        this.hitSound = () => {
            sound_1.Sound.swing();
            //Sound.hit();
            sound_1.Sound.playSlice();
        };
        this.weaponMove = (newX, newY) => {
            let positions = [];
            switch (this.wielder.direction) {
                case game_1.Direction.DOWN:
                    positions = [
                        { x: newX - 1, y: newY },
                        { x: newX + 1, y: newY },
                        { x: newX - 1, y: newY - 1 },
                        { x: newX + 1, y: newY - 1 }, // rightEdge
                    ];
                    break;
                case game_1.Direction.UP:
                    positions = [
                        { x: newX + 1, y: newY },
                        { x: newX - 1, y: newY },
                        { x: newX + 1, y: newY + 1 },
                        { x: newX - 1, y: newY + 1 }, // rightEdge
                    ];
                    break;
                case game_1.Direction.LEFT:
                    positions = [
                        { x: newX, y: newY + 1 },
                        { x: newX, y: newY - 1 },
                        { x: newX + 1, y: newY + 1 },
                        { x: newX + 1, y: newY - 1 }, // rightEdge
                    ];
                    break;
                case game_1.Direction.RIGHT:
                    positions = [
                        { x: newX, y: newY - 1 },
                        { x: newX, y: newY + 1 },
                        { x: newX - 1, y: newY - 1 },
                        { x: newX - 1, y: newY + 1 }, // rightEdge
                    ];
                    break;
            }
            if (this.checkForPushables(newX, newY))
                return true;
            const hitSomething = this.executeAttack(newX, newY, true, 1, true, true, true, false);
            if (hitSomething) {
                if (positions.length > 0) {
                    for (const pos of positions) {
                        if (!this.game.rooms[this.wielder.levelID].roomArray[pos.x][pos.y].isSolid()) {
                            this.hitEntitiesAt(pos.x, pos.y, 1);
                        }
                    }
                }
                this.game.rooms[this.wielder.levelID].tick(this.wielder);
            }
            return !hitSomething;
        };
        this.shakeScreen = () => {
            //this.wielder.beginSlowMotion();
            setTimeout(() => {
                //this.wielder.endSlowMotion();
                switch (this.wielder.direction) {
                    case game_1.Direction.DOWN:
                        this.game.shakeScreen(0, -5, false);
                        break;
                    case game_1.Direction.UP:
                        this.game.shakeScreen(0, -5, false);
                        break;
                    case game_1.Direction.LEFT:
                        this.game.shakeScreen(-5, -5, false);
                        break;
                    case game_1.Direction.RIGHT:
                        this.game.shakeScreen(5, -5, false);
                        break;
                }
            }, this.hitDelay);
        };
        this.tileX = 23;
        this.tileY = 2;
        this.damage = 1;
        this.name = "scythe";
        this.hitDelay = 150;
        this.useCost = 2;
        this.offsetY = 0;
        this.iconOffset = 0.2;
        this.degradeable = false;
    }
}
exports.Scythe = Scythe;
Scythe.itemName = "scythe";


/***/ }),

/***/ "./src/item/weapon/scytheBlade.ts":
/*!****************************************!*\
  !*** ./src/item/weapon/scytheBlade.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ScytheBlade = void 0;
const usable_1 = __webpack_require__(/*! ../usable/usable */ "./src/item/usable/usable.ts");
const scythe_1 = __webpack_require__(/*! ./scythe */ "./src/item/weapon/scythe.ts");
const scytheHandle_1 = __webpack_require__(/*! ./scytheHandle */ "./src/item/weapon/scytheHandle.ts");
class ScytheBlade extends usable_1.Usable {
    constructor(level, x, y) {
        super(level, x, y);
        this.onDrop = () => {
            if (this.level.game.lastDroppedScythePiece === "blade") {
                this.level.game.lastDroppedScythePiece = null;
                this.level.items.push(new scytheHandle_1.ScytheHandle(this.level, this.x, this.y));
                this.level.items = this.level.items.filter((item) => item !== this);
            }
            else if (this.level.game.lastDroppedScythePiece === null) {
                this.level.game.lastDroppedScythePiece = "blade";
            }
        };
        this.useOnOther = (player, other) => {
            if (other instanceof scytheHandle_1.ScytheHandle) {
                player.inventory.removeItem(this);
                player.inventory.removeItem(other);
                player.game.pushMessage("You combine the scythe blade and handle.");
                const scythe = new scythe_1.Scythe(player.game.rooms[player.levelID], player.x, player.y);
                player.inventory.addItem(scythe);
            }
        };
        this.tileX = 30;
        this.tileY = 2;
        this.stackable = false;
        this.name = ScytheBlade.itemName;
        this.description = "The blade of a scythe. Find the handle to use it.";
        this.canUseOnOther = true;
    }
}
exports.ScytheBlade = ScytheBlade;
ScytheBlade.itemName = "scythe blade";


/***/ }),

/***/ "./src/item/weapon/scytheHandle.ts":
/*!*****************************************!*\
  !*** ./src/item/weapon/scytheHandle.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ScytheHandle = void 0;
const usable_1 = __webpack_require__(/*! ../usable/usable */ "./src/item/usable/usable.ts");
const scythe_1 = __webpack_require__(/*! ./scythe */ "./src/item/weapon/scythe.ts");
const scytheBlade_1 = __webpack_require__(/*! ./scytheBlade */ "./src/item/weapon/scytheBlade.ts");
class ScytheHandle extends usable_1.Usable {
    constructor(level, x, y) {
        super(level, x, y);
        this.onDrop = () => {
            if (this.level.game.lastDroppedScythePiece === "handle") {
                this.level.game.lastDroppedScythePiece = null;
                this.level.items.push(new scytheBlade_1.ScytheBlade(this.level, this.x, this.y));
                this.level.items = this.level.items.filter((item) => item !== this);
            }
            else if (this.level.game.lastDroppedScythePiece === null) {
                this.level.game.lastDroppedScythePiece = "handle";
            }
        };
        this.useOnOther = (player, other) => {
            if (other instanceof scytheBlade_1.ScytheBlade) {
                player.inventory.removeItem(this);
                player.inventory.removeItem(other);
                player.game.pushMessage("You combine the scythe blade and handle.");
                const scythe = new scythe_1.Scythe(player.game.rooms[player.levelID], player.x, player.y);
                player.inventory.addItem(scythe);
            }
        };
        this.tileX = 29;
        this.tileY = 2;
        this.stackable = false;
        this.name = ScytheHandle.itemName;
        this.description = "The handle of a scythe. Find the blade to use it.";
        this.canUseOnOther = true;
    }
}
exports.ScytheHandle = ScytheHandle;
ScytheHandle.itemName = "scythe handle";


/***/ }),

/***/ "./src/item/weapon/shotgun.ts":
/*!************************************!*\
  !*** ./src/item/weapon/shotgun.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Shotgun = void 0;
const weapon_1 = __webpack_require__(/*! ./weapon */ "./src/item/weapon/weapon.ts");
const genericParticle_1 = __webpack_require__(/*! ../../particle/genericParticle */ "./src/particle/genericParticle.ts");
class Shotgun extends weapon_1.Weapon {
    constructor(level, x, y) {
        super(level, x, y);
        this.weaponMove = (newX, newY) => {
            let newX2 = 2 * newX - this.wielder.x;
            let newY2 = 2 * newY - this.wielder.y;
            let newX3 = 3 * newX - 2 * this.wielder.x;
            let newY3 = 3 * newY - 2 * this.wielder.y;
            let range = 3;
            if (!this.game.rooms[this.wielder.levelID].tileInside(newX, newY) ||
                this.game.rooms[this.wielder.levelID].roomArray[newX][newY].isSolid())
                return true;
            else if (!this.game.rooms[this.wielder.levelID].tileInside(newX2, newY2) ||
                this.game.rooms[this.wielder.levelID].roomArray[newX2][newY2].isSolid())
                range = 1;
            else if (!this.game.rooms[this.wielder.levelID].tileInside(newX3, newY3) ||
                this.game.rooms[this.wielder.levelID].roomArray[newX3][newY3].isSolid())
                range = 2;
            let enemyHitCandidates = [];
            let firstPushable = 4;
            let firstNonPushable = 5;
            let firstNonDestroyable = 5;
            for (let e of this.game.rooms[this.wielder.levelID].entities) {
                if (e.pushable) {
                    if (e.pointIn(newX, newY))
                        return true;
                    if (e.pointIn(newX2, newY2) && range >= 2) {
                        enemyHitCandidates.push({ enemy: e, dist: 2 });
                        firstPushable = 2;
                    }
                    if (e.pointIn(newX3, newY3) && range >= 3) {
                        enemyHitCandidates.push({ enemy: e, dist: 3 });
                        firstPushable = Math.min(firstPushable, 3);
                    }
                }
                else if (e.destroyable) {
                    if (e.pointIn(newX, newY) && range >= 1) {
                        firstNonPushable = 1;
                        enemyHitCandidates.push({ enemy: e, dist: 1 });
                    }
                    if (e.pointIn(newX2, newY2) && range >= 2) {
                        firstNonPushable = Math.min(firstNonPushable, 2);
                        enemyHitCandidates.push({ enemy: e, dist: 2 });
                    }
                    if (e.pointIn(newX3, newY3) && range >= 3) {
                        firstNonPushable = Math.min(firstNonPushable, 3);
                        enemyHitCandidates.push({ enemy: e, dist: 3 });
                    }
                }
                else {
                    if (e.pointIn(newX, newY) && range >= 1) {
                        firstNonDestroyable = 1;
                    }
                    if (e.pointIn(newX2, newY2) && range >= 2) {
                        firstNonDestroyable = Math.min(firstNonDestroyable, 2);
                    }
                    if (e.pointIn(newX3, newY3) && range >= 3) {
                        firstNonDestroyable = Math.min(firstNonDestroyable, 3);
                    }
                }
            }
            let targetX = newX3;
            let targetY = newY3;
            if (firstNonDestroyable < firstNonPushable &&
                firstNonDestroyable < firstPushable) {
                return true;
            }
            if (firstNonPushable <= firstPushable) {
                for (const c of enemyHitCandidates) {
                    let e = c.enemy;
                    let d = c.dist;
                    if (d === 3)
                        e.hurt(this.wielder, 0.5);
                    else
                        e.hurt(this.wielder, 1);
                }
                this.hitSound();
                this.wielder.setHitXY(newX, newY);
                genericParticle_1.GenericParticle.shotgun(this.game.rooms[this.wielder.levelID], this.wielder.x + 0.5, this.wielder.y, targetX + 0.5, targetY, "black");
                genericParticle_1.GenericParticle.shotgun(this.game.rooms[this.wielder.levelID], this.wielder.x + 0.5, this.wielder.y, targetX + 0.5, targetY, "#ffddff");
                let gp = new genericParticle_1.GenericParticle(this.game.rooms[this.wielder.levelID], 0.5 * (newX + this.wielder.x) + 0.5, 0.5 * (newY + this.wielder.y), 0, 1, 0, 0, 0, "white", 0);
                gp.expirationTimer = 10;
                this.game.rooms[this.wielder.levelID].particles.push(gp);
                this.game.rooms[this.wielder.levelID].tick(this.wielder);
                this.shakeScreen(newX, newY);
                this.degrade();
                return false;
            }
            return true;
        };
        this.tileX = 26;
        this.tileY = 0;
        this.name = "shotgun";
    }
}
exports.Shotgun = Shotgun;
Shotgun.itemName = "shotgun";


/***/ }),

/***/ "./src/item/weapon/slingshot.ts":
/*!**************************************!*\
  !*** ./src/item/weapon/slingshot.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Slingshot = void 0;
const weapon_1 = __webpack_require__(/*! ./weapon */ "./src/item/weapon/weapon.ts");
const genericParticle_1 = __webpack_require__(/*! ../../particle/genericParticle */ "./src/particle/genericParticle.ts");
class Slingshot extends weapon_1.Weapon {
    constructor(level, x, y) {
        super(level, x, y);
        this.weaponMove = (newX, newY) => {
            let nextX = [newX];
            let nextY = [newY];
            //define arrays for coords beginning with function arguments
            let range = 1;
            let l = 0;
            for (let i = 0; i < 5; i++ //loop through range
            ) {
                if (newX === this.wielder.x) {
                    nextX.push(newX), nextY.push(nextY[l] + (newY - this.wielder.y));
                }
                if (newY === this.wielder.y) {
                    nextX.push(nextX[l] + (newX - this.wielder.x)), nextY.push(newY);
                }
                // push nex coordinates to array of possible moves
                l++;
            }
            if (!this.game.rooms[this.wielder.levelID].tileInside(newX, newY) ||
                this.game.rooms[this.wielder.levelID].roomArray[newX][newY].isSolid()) {
                //if current position is inside new position OR is solid
                return true;
            }
            let c = 1;
            for (let i = 0; i < 5; i++) {
                if (!this.game.rooms[this.wielder.levelID].tileInside(nextX[c], nextY[c]) ||
                    this.game.rooms[this.wielder.levelID].roomArray[nextX[c]][nextY[c]].isSolid()) {
                    range = c;
                    //exit the function if wall is detected
                }
                c++;
                //increase the range each loop until
            }
            //range = 15;
            let enemyHitCandidates = [];
            let firstPushable = range + 1;
            let firstNonPushable = range + 2;
            let firstNonDestroyable = range + 2;
            for (let e of this.game.rooms[this.wielder.levelID].entities) {
                //loop through enemies in this weapons wielders level
                if (e.pushable) {
                    let p = 2;
                    //case for pushables
                    if (e.pointIn(newX, newY))
                        return true;
                    //if pushable is in new position return true
                    for (let i = 0; i < 15; i++) {
                        if (e.pointIn(nextX[p - 1], nextY[p - 1]) && range >= p) {
                            //enemyHitCandidates.push({ enemy: e, dist: p });
                            firstPushable = Math.min(firstPushable, p);
                        }
                        p++; //run that shit back
                    }
                }
                else if (e.destroyable) {
                    //case for destroyables
                    if (e.pointIn(newX, newY) && range >= 1) {
                        firstNonPushable = 1;
                        enemyHitCandidates.push({ enemy: e, dist: 1 });
                    }
                    let d = 2;
                    for (let i = 0; i < 15; i++) {
                        if (e.pointIn(nextX[d - 1], nextY[d - 1]) && range >= d) {
                            firstNonPushable = Math.min(firstNonPushable, d);
                            enemyHitCandidates.push({ enemy: e, dist: d });
                        }
                        d++;
                    }
                }
                else {
                    if (e.pointIn(newX, newY) && range >= 1) {
                        firstNonDestroyable = 1;
                    }
                    let n = 2;
                    for (let i = 0; i < 15; i++) {
                        if (e.pointIn(nextX[n - 1], nextY[n - 1]) && range >= n) {
                            firstNonDestroyable = Math.min(firstNonDestroyable, n);
                        }
                        n++;
                        //if enemy is in new position and range is enough set first non destroyable to 3
                    }
                }
            }
            //enemyHitCandidates.splice(1, enemyHitCandidates.length - 1);
            let targetX = newX; //nextX[range];
            let targetY = newY; //nextY[range];
            if (firstNonDestroyable < firstNonPushable &&
                firstNonDestroyable < firstPushable
            //if a non destroyable comes before the first non pushable and before the first pushable
            ) {
                return true;
                //return true and exit the function
            }
            if (firstNonPushable <= firstPushable) {
                if (enemyHitCandidates.length > 0) {
                    const closestEnemy = enemyHitCandidates.reduce((minEnemy, currentEnemy) => {
                        if (currentEnemy.dist < minEnemy.dist) {
                            return currentEnemy;
                        }
                        else
                            return minEnemy;
                    });
                    closestEnemy.enemy.hurt(this.wielder, 1);
                }
                //finally bro
                //for the array c of enemyHitCandidates if the enemy distance is 3 only do .5 damage
                //if they're closer do the usual damage
                //hits all candidates in enemyHitCandidates
                this.hitSound();
                this.wielder.setHitXY(newX, newY);
                genericParticle_1.GenericParticle.shotgun(this.game.rooms[this.wielder.levelID], this.wielder.x + 0.5, this.wielder.y, targetX + 0.5, targetY, "black");
                genericParticle_1.GenericParticle.shotgun(this.game.rooms[this.wielder.levelID], this.wielder.x + 0.5, this.wielder.y, targetX + 0.5, targetY, "#ffddff");
                let gp = new genericParticle_1.GenericParticle(this.game.rooms[this.wielder.levelID], 0.5 * (newX + this.wielder.x) + 0.5, 0.5 * (newY + this.wielder.y), 0, 1, 0, 0, 0, "white", 0);
                gp.expirationTimer = 10;
                this.game.rooms[this.wielder.levelID].particles.push(gp);
                //this.game.levels[this.wielder.levelID].particles.push(new SlashParticle(newX, newY));
                //this.game.levels[this.wielder.levelID].particles.push(new SlashParticle(newX2, newY2));
                //this.game.levels[this.wielder.levelID].particles.push(new SlashParticle(newX3, newY3));
                this.game.rooms[this.wielder.levelID].tick(this.wielder);
                this.shakeScreen(newX * 10, newY * 10);
                return false;
            }
            return true;
        };
        this.tileX = 26;
        this.tileY = 0;
        this.name = "Slingshot";
    }
}
exports.Slingshot = Slingshot;
Slingshot.itemName = "slingshot";


/***/ }),

/***/ "./src/item/weapon/spear.ts":
/*!**********************************!*\
  !*** ./src/item/weapon/spear.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Spear = void 0;
const weapon_1 = __webpack_require__(/*! ./weapon */ "./src/item/weapon/weapon.ts");
class Spear extends weapon_1.Weapon {
    constructor(level, x, y) {
        super(level, x, y);
        this.weaponMove = (newX, newY) => {
            let newX2 = 2 * newX - this.wielder.x;
            let newY2 = 2 * newY - this.wielder.y;
            let hitEnemies = false;
            // Check if there are any pushables at first tile - these completely block the spear
            const pushables = this.getEntitiesAt(newX, newY).filter((e) => e.pushable);
            if (pushables.length > 0)
                return true;
            // Get entities at both tiles
            const entitiesAtFirstTile = this.getEntitiesAt(newX, newY);
            const entitiesAtSecondTile = this.getEntitiesAt(newX2, newY2);
            // Check if first tile has non-enemy entities that would block the spear
            const nonEnemiesAtFirstTile = entitiesAtFirstTile.filter((e) => !e.pushable && !e.isEnemy);
            if (nonEnemiesAtFirstTile.length > 0) {
                // Hit non-enemy entities at first tile and stop (blocked)
                for (const entity of nonEnemiesAtFirstTile) {
                    this.attack(entity);
                }
                this.hitSound();
                this.attackAnimation(newX, newY);
                this.game.rooms[this.wielder.levelID].tick(this.wielder);
                this.shakeScreen(newX, newY);
                this.degrade();
                return false;
            }
            // Hit all enemies at first tile (spear penetrates through)
            const enemiesAtFirstTile = entitiesAtFirstTile.filter((e) => !e.pushable && e.isEnemy);
            if (enemiesAtFirstTile.length > 0) {
                for (const enemy of enemiesAtFirstTile) {
                    this.attack(enemy);
                }
                hitEnemies = true;
            }
            // Hit all enemies at second tile (if tile is valid and not solid)
            if (this.game.rooms[this.wielder.levelID].roomArray[newX2] &&
                this.game.rooms[this.wielder.levelID].roomArray[newX2][newY2] &&
                !this.game.rooms[this.wielder.levelID].roomArray[newX2][newY2].isSolid()) {
                const enemiesAtSecondTile = entitiesAtSecondTile.filter((e) => !e.pushable && e.isEnemy);
                if (enemiesAtSecondTile.length > 0) {
                    for (const enemy of enemiesAtSecondTile) {
                        this.attack(enemy);
                    }
                    hitEnemies = true;
                }
            }
            if (hitEnemies) {
                this.hitSound();
                this.attackAnimation(newX2, newY2); // Show animation at the furthest point
                this.game.rooms[this.wielder.levelID].tick(this.wielder);
                this.shakeScreen(newX2, newY2);
                this.degrade();
            }
            return !hitEnemies;
        };
        this.tileX = 24;
        this.tileY = 0;
        this.name = "spear";
        this.description =
            "Hits enemies in front of you within a range of 2 tiles.";
        this.iconOffset = 0.1; //default 0
        this.offsetY = 0; //default -0.25
        this.useCost = 1;
        this.degradeable = false;
    }
}
exports.Spear = Spear;
Spear.itemName = "spear";


/***/ }),

/***/ "./src/item/weapon/spellbook.ts":
/*!**************************************!*\
  !*** ./src/item/weapon/spellbook.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Spellbook = void 0;
const weapon_1 = __webpack_require__(/*! ./weapon */ "./src/item/weapon/weapon.ts");
const sound_1 = __webpack_require__(/*! ../../sound/sound */ "./src/sound/sound.ts");
const playerFireball_1 = __webpack_require__(/*! ../../projectile/playerFireball */ "./src/projectile/playerFireball.ts");
const utils_1 = __webpack_require__(/*! ../../utility/utils */ "./src/utility/utils.ts");
const game_1 = __webpack_require__(/*! ../../game */ "./src/game.ts");
const spellbookPage_1 = __webpack_require__(/*! ../usable/spellbookPage */ "./src/item/usable/spellbookPage.ts");
class Spellbook extends weapon_1.Weapon {
    constructor(level, x, y) {
        super(level, x, y);
        this.getTargets = () => {
            this.targets = [];
            let entities = this.game.rooms[this.wielder.levelID].entities;
            this.targets = entities.filter((e) => !e.pushable &&
                utils_1.Utils.distance(this.wielder.x, this.wielder.y, e.x, e.y) <=
                    this.range &&
                e.destroyable);
            let enemies = this.targets.filter((e) => e.isEnemy === true);
            //console.log(enemies);
            if (enemies.length > 0)
                return enemies;
            else {
                //console.log(this.targets);
                return this.targets;
            }
        };
        this.disassemble = () => {
            if (this.equipped) {
                this.game.pushMessage("I should probably unequip this before I try to disassemble it...");
                return;
            }
            this.game.pushMessage(`You tear the remaining pages out of your spellbook.`);
            let inventory = this.wielder.inventory;
            let inventoryX = this.x;
            let inventoryY = this.y;
            let numFragments = Math.floor(this.durability);
            this.toggleEquip();
            //inventory.weapon = null;
            inventory.removeItem(this);
            inventory.addItem(new spellbookPage_1.SpellbookPage(this.level, inventoryX, inventoryY, numFragments));
        };
        this.weaponMove = (newX, newY) => {
            this.getTargets();
            let direction = this.wielder.direction;
            let flag = false;
            let targets = this.targets;
            const isTargetInDirection = (e) => {
                switch (direction) {
                    case game_1.Direction.UP:
                        return e.y <= newY;
                    case game_1.Direction.RIGHT:
                        return e.x >= newX;
                    case game_1.Direction.DOWN:
                        return e.y >= newY;
                    case game_1.Direction.LEFT:
                        return e.x <= newX;
                    default:
                        return false;
                }
            };
            if (targets.length > 0) {
                this.isTargeting = true;
            }
            else {
                this.isTargeting = false;
            }
            targets = targets.filter(isTargetInDirection);
            // Store only the targets that actually get hit
            const actuallyHitTargets = [];
            for (let e of targets) {
                if (!this.game.rooms[this.wielder.levelID].roomArray[e.x][e.y].isSolid()) {
                    e.hurt(this.wielder, 1);
                    this.game.rooms[this.wielder.levelID].projectiles.push(new playerFireball_1.PlayerFireball(this.wielder, e.x, e.y));
                    // Add to the list of actually hit targets
                    actuallyHitTargets.push(e);
                    flag = true;
                }
            }
            // Update this.targets to only contain targets that were actually hit
            this.targets = actuallyHitTargets;
            if (flag) {
                this.hitSound();
                this.wielder.setHitXY(newX, newY);
                this.game.rooms[this.wielder.levelID].tick(this.wielder);
                this.shakeScreen(newX, newY);
                sound_1.Sound.playMagic();
                //this.degrade();
                this.cooldown = this.cooldownMax;
                setTimeout(() => {
                    this.isTargeting = false;
                }, 100);
            }
            return !flag;
        };
        this.drawBeams = (playerDrawX, playerDrawY, delta) => {
            // Clear existing beam effects each frame
            this.game.rooms[this.wielder.levelID].beamEffects = [];
            if (this.isTargeting) {
                for (let target of this.targets) {
                    // Create a new beam effect from the player to the enemy
                    this.game.rooms[this.wielder.levelID].addBeamEffect(playerDrawX, playerDrawY, target.x - target.drawX, target.y - target.drawY, target);
                    // Retrieve the newly added beam effect
                    const beam = this.game.rooms[this.wielder.levelID].beamEffects[this.game.rooms[this.wielder.levelID].beamEffects.length - 1];
                    // Render the beam
                    beam.render(playerDrawX, playerDrawY, target.x - target.drawX, target.y - target.drawY, "cyan", 2, delta);
                }
            }
        };
        this.range = 4;
        this.tileX = 25;
        this.tileY = 0;
        this.canMine = true;
        this.name = Spellbook.itemName;
        this.isTargeting = false;
        this.durability = 10;
        this.durabilityMax = 10;
        this.description = "Hits multiple enemies within a range of 4 tiles.";
        this.degradeable = false;
        this.cooldownMax = 25;
    }
}
exports.Spellbook = Spellbook;
Spellbook.itemName = "spellbook";


/***/ }),

/***/ "./src/item/weapon/sword.ts":
/*!**********************************!*\
  !*** ./src/item/weapon/sword.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Sword = void 0;
const weapon_1 = __webpack_require__(/*! ./weapon */ "./src/item/weapon/weapon.ts");
const sound_1 = __webpack_require__(/*! ../../sound/sound */ "./src/sound/sound.ts");
const game_1 = __webpack_require__(/*! ../../game */ "./src/game.ts");
class Sword extends weapon_1.Weapon {
    constructor(level, x, y) {
        super(level, x, y);
        this.hitSound = () => {
            sound_1.Sound.hit();
            sound_1.Sound.playShortSlice();
        };
        this.weaponMove = (newX, newY) => {
            let leftCorner = { x: newX, y: newY };
            let rightCorner = { x: newX, y: newY };
            let positions = [leftCorner, rightCorner];
            switch (this.wielder.direction) {
                case game_1.Direction.DOWN:
                    leftCorner.x = newX - 1;
                    rightCorner.x = newX + 1;
                    break;
                case game_1.Direction.UP:
                    leftCorner.x = newX + 1;
                    rightCorner.x = newX - 1;
                    break;
                case game_1.Direction.LEFT:
                    leftCorner.y = newY + 1;
                    rightCorner.y = newY - 1;
                    break;
                case game_1.Direction.RIGHT:
                    leftCorner.y = newY - 1;
                    rightCorner.y = newY + 1;
                    break;
            }
            if (this.checkForPushables(newX, newY))
                return true;
            const hitSomething = this.executeAttack(newX, newY, true, 1, true, true, true, false);
            if (hitSomething) {
                for (const pos of positions) {
                    if (!this.game.rooms[this.wielder.levelID].roomArray[pos.x][pos.y].isSolid()) {
                        const damage = 1;
                        this.hitEntitiesAt(pos.x, pos.y, damage);
                    }
                }
                this.game.rooms[this.wielder.levelID].tick(this.wielder);
            }
            return !hitSomething;
        };
        this.shakeScreen = () => {
            //this.wielder.beginSlowMotion();
            setTimeout(() => {
                //this.wielder.endSlowMotion();
                switch (this.wielder.direction) {
                    case game_1.Direction.DOWN:
                        this.game.shakeScreen(0, -5, false);
                        break;
                    case game_1.Direction.UP:
                        this.game.shakeScreen(0, -5, false);
                        break;
                    case game_1.Direction.LEFT:
                        this.game.shakeScreen(-5, -5, false);
                        break;
                    case game_1.Direction.RIGHT:
                        this.game.shakeScreen(5, -5, false);
                        break;
                }
            }, this.hitDelay);
        };
        this.tileX = 28;
        this.tileY = 2;
        this.damage = 1;
        this.name = "sword";
        //this.hitDelay = 150;
        this.degradeable = false;
        this.useCost = 2;
        this.offsetY = 0;
        //this.iconOffset = 0.2;
    }
}
exports.Sword = Sword;
Sword.itemName = "sword";


/***/ }),

/***/ "./src/item/weapon/warhammer.ts":
/*!**************************************!*\
  !*** ./src/item/weapon/warhammer.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Warhammer = void 0;
const weapon_1 = __webpack_require__(/*! ./weapon */ "./src/item/weapon/weapon.ts");
const sound_1 = __webpack_require__(/*! ../../sound/sound */ "./src/sound/sound.ts");
const game_1 = __webpack_require__(/*! ../../game */ "./src/game.ts");
class Warhammer extends weapon_1.Weapon {
    constructor(level, x, y) {
        super(level, x, y);
        this.hitSound = () => {
            sound_1.Sound.swing();
            sound_1.Sound.playWarHammer();
        };
        this.weaponMove = (newX, newY) => {
            if (this.checkForPushables(newX, newY))
                return true;
            const hitSomething = this.executeAttack(newX, newY);
            if (hitSomething) {
                this.cooldown = this.cooldownMax;
            }
            return !hitSomething;
        };
        this.shakeScreen = () => {
            this.wielder.beginSlowMotion();
            setTimeout(() => {
                this.wielder.endSlowMotion();
                switch (this.wielder.direction) {
                    case game_1.Direction.DOWN:
                        this.game.shakeScreen(0, -30, false);
                        break;
                    case game_1.Direction.UP:
                        this.game.shakeScreen(0, -30, false);
                        break;
                    case game_1.Direction.LEFT:
                        this.game.shakeScreen(-5, -30, false);
                        break;
                    case game_1.Direction.RIGHT:
                        this.game.shakeScreen(5, -30, false);
                        break;
                }
            }, this.hitDelay);
        };
        this.tileX = 22;
        this.tileY = 2;
        this.damage = 2;
        this.name = "warhammer";
        this.hitDelay = 225;
        this.useCost = 2;
        //this.cooldownMax = 10;
        this.degradeable = false;
    }
}
exports.Warhammer = Warhammer;
Warhammer.itemName = "warhammer";


/***/ }),

/***/ "./src/item/weapon/weapon.ts":
/*!***********************************!*\
  !*** ./src/item/weapon/weapon.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Weapon = void 0;
const game_1 = __webpack_require__(/*! ../../game */ "./src/game.ts");
const equippable_1 = __webpack_require__(/*! ../equippable */ "./src/item/equippable.ts");
const sound_1 = __webpack_require__(/*! ../../sound/sound */ "./src/sound/sound.ts");
const gameConstants_1 = __webpack_require__(/*! ../../game/gameConstants */ "./src/game/gameConstants.ts");
const weaponFragments_1 = __webpack_require__(/*! ../usable/weaponFragments */ "./src/item/usable/weaponFragments.ts");
const attackAnimation_1 = __webpack_require__(/*! ../../particle/attackAnimation */ "./src/particle/attackAnimation.ts");
const game_2 = __webpack_require__(/*! ../../game */ "./src/game.ts");
class Weapon extends equippable_1.Equippable {
    constructor(level, x, y, status) {
        super(level, x, y);
        this.break = () => {
            this.durability = 0;
            this.wielder.inventory.weapon = null;
            this.toggleEquip();
            //this.wielder.inventory.removeItem(this);
            //this.wielder = null;
            this.game.pushMessage("Your weapon breaks");
            if (this.status.poison || this.status.blood) {
                this.clearStatus();
            }
            this.broken = true;
        };
        this.coEquippable = (other) => {
            if (other instanceof Weapon)
                return false;
            return true;
        };
        this.applyStatus = (status) => {
            this.status = status;
            if (this.status.blood) {
                //this.damage = Math.max(0.5, this.damage - 0.5);
            }
        };
        this.clearStatus = () => {
            const status = this.status.poison ? "poison" : "bleed";
            this.game.pushMessage(`Your ${this.name}'s ${status} effect dries up`);
            this.status = { poison: false, blood: false };
            this.statusApplicationCount = 0;
        };
        this.statusEffect = (entity) => {
            if (!entity.isEnemy)
                return;
            const enemy = entity;
            if (!enemy.status.poison.active && !enemy.status.bleed.active) {
                if (this.wielder.applyStatus(enemy, this.status) && enemy.health > 0) {
                    this.statusApplicationCount++;
                    const message = this.status.poison
                        ? `Your weapon poisons the ${enemy.name}`
                        : `Your cursed weapon draws blood from the ${enemy.name}`;
                    this.game.pushMessage(message);
                    //if (this.statusApplicationCount >= 10) this.clearStatus();
                }
            }
        };
        this.disassemble = () => {
            if (!this.degradeable) {
                this.game.pushMessage("You can't disassemble this item because it's not degradeable.");
                return;
            }
            if (this.equipped) {
                this.game.pushMessage("I should probably unequip this before I try to disassemble it...");
                return;
            }
            this.game.pushMessage(`You dissassemble your ${this.name} into fragments.`);
            let inventory = this.wielder.inventory;
            let inventoryX = this.x;
            let inventoryY = this.y;
            let numFragments = Math.floor(this.durability / 1.5);
            this.toggleEquip();
            //inventory.weapon = null;
            inventory.removeItem(this);
            inventory.addItem(new weaponFragments_1.WeaponFragments(this.level, inventoryX, inventoryY, numFragments));
        };
        this.dropFromInventory = () => {
            if (this.wielder.inventory.weapon === this)
                this.wielder.inventory.weapon = null;
            this.wielder = null;
            this.equipped = false;
        };
        this.weaponMove = (newX, newY) => {
            if (this.checkForPushables(newX, newY))
                return true;
            const hitSomething = this.executeAttack(newX, newY);
            return !hitSomething;
        };
        this.attack = (enemy, damage) => {
            enemy.hurt(this.wielder, damage || this.damage);
            this.statusEffect(enemy);
        };
        this.attackAnimation = (newX, newY) => {
            this.wielder.setHitXY(newX, newY);
            this.game.rooms[this.wielder.levelID].particles.push(new attackAnimation_1.AttackAnimation(newX, newY, this.name, this.wielder.direction));
        };
        this.shakeScreen = (eX, eY) => {
            if (this.wielder.game.rooms[this.wielder.levelID] === this.wielder.game.room)
                this.wielder.shakeScreen(this.wielder.x, this.wielder.y, eX, eY);
        };
        this.hitSound = () => {
            sound_1.Sound.swing();
            sound_1.Sound.hit();
        };
        this.drawStatus = (x, y) => {
            if (this.status.poison || this.status.blood) {
                let tileX = 3;
                if (this.status.poison) {
                    tileX = 4;
                }
                if (this.status.blood) {
                    tileX = 3;
                }
                game_1.Game.drawFX(tileX, 0, 1, 1, x - 1 / gameConstants_1.GameConstants.TILESIZE, y - 1 / gameConstants_1.GameConstants.TILESIZE, 1, 1);
            }
        };
        this.getDescription = () => {
            let broken = this.broken ? " (broken)" : "";
            let status = [];
            let durability = "";
            if (this.status.poison)
                status.push("Poison");
            if (this.status.blood)
                status.push(" Bleed");
            if (this.durability < this.durabilityMax)
                durability = ` Durability: ${this.durability}/${this.durabilityMax}`;
            return `${this.name}${broken}\n${status.join(", ")}\n${durability}\n${this.description}\ndamage: ${this.damage}`;
        };
        this.tick = () => {
            this.updateCooldown();
        };
        this.updateCooldown = () => {
            if (this.cooldown > 0) {
                this.cooldown--;
                if (this.cooldown > 0 && this.equipped) {
                    this.equipped = false;
                    const hasPreviousWeapon = this.wielder.inventory.items.some((item) => item === this.previousWeapon);
                    if (hasPreviousWeapon &&
                        this.previousWeapon !== null &&
                        this.previousWeapon.broken === false &&
                        this.previousWeapon.cooldown === 0) {
                        this.wielder.inventory.weapon = this.previousWeapon;
                        this.previousWeapon.equipped = true;
                    }
                    else {
                        this.wielder.inventory.weapon = null;
                    }
                }
            }
        };
        this.applyHitDelay = (hitSomething) => {
            if (hitSomething) {
                this.wielder.busyAnimating = true;
                setTimeout(() => {
                    this.wielder.busyAnimating = false;
                }, this.hitDelay || 0);
            }
        };
        if (level)
            this.game = level.game;
        this.canMine = false;
        this.range = 1;
        this.damage = 1;
        this.status = status || { poison: false, blood: false };
        this.durability = 50;
        this.durabilityMax = 50;
        this.statusApplicationCount = 0;
        this.equipTick = true;
        this.name = this.constructor.prototype.itemName;
        this.cooldown = 0;
        this.cooldownMax = 0;
    }
    // returns true if nothing was hit, false if the player should move
    getEntitiesAt(x, y) {
        return this.game.rooms[this.wielder.levelID].entities.filter((e) => e.destroyable && e.pointIn(x, y));
    }
    hitEntitiesAt(x, y, damage) {
        const entities = this.getEntitiesAt(x, y).filter((e) => !e.pushable);
        let hitSomething = false;
        for (const entity of entities) {
            this.attack(entity, damage);
            hitSomething = true;
        }
        return hitSomething;
    }
    checkForPushables(x, y) {
        const direction = this.wielder.direction;
        let behindX = x;
        let behindY = y;
        switch (direction) {
            case game_2.Direction.DOWN:
                behindY += 1;
                break;
            case game_2.Direction.UP:
                behindY -= 1;
                break;
            case game_2.Direction.LEFT:
                behindX -= 1;
                break;
            case game_2.Direction.RIGHT:
                behindX += 1;
                break;
        }
        const unpushables = this.getEntitiesAt(behindX, behindY).filter((e) => !e.pushable);
        const hasUnpushablesBehind = unpushables.length > 0;
        const behindTile = this.game.rooms[this.wielder.levelID].roomArray[behindX]?.[behindY];
        const isSolidBehind = !behindTile || behindTile.isSolid();
        const pushables = this.getEntitiesAt(x, y).filter((e) => e.pushable);
        const hasSpaceToPush = !isSolidBehind && !hasUnpushablesBehind;
        return pushables.length > 0 && hasSpaceToPush;
    }
    executeAttack(targetX, targetY, animated = true, damage = this.damage, shakeScreen = true, sound = true, mainAttack = true, shouldTick = true) {
        const hitSomething = this.hitEntitiesAt(targetX, targetY, damage);
        this.applyHitDelay(hitSomething);
        if (hitSomething) {
            if (sound)
                this.hitSound();
            this.wielder.setHitXY(targetX, targetY);
            if (animated)
                this.attackAnimation(targetX, targetY);
            if (shouldTick)
                this.game.rooms[this.wielder.levelID].tick(this.wielder);
            if (shakeScreen)
                this.shakeScreen(targetX, targetY);
            if (mainAttack)
                this.degrade();
        }
        return hitSomething;
    }
}
exports.Weapon = Weapon;
Weapon.itemName = "weapon";


/***/ }),

/***/ "./src/level/environment.ts":
/*!**********************************!*\
  !*** ./src/level/environment.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.environmentData = exports.enemyMinimumDepth = exports.Environment = exports.enemyClassToId = void 0;
const barrel_1 = __webpack_require__(/*! ../entity/object/barrel */ "./src/entity/object/barrel.ts");
const block_1 = __webpack_require__(/*! ../entity/object/block */ "./src/entity/object/block.ts");
const bush_1 = __webpack_require__(/*! ../entity/object/bush */ "./src/entity/object/bush.ts");
const chest_1 = __webpack_require__(/*! ../entity/object/chest */ "./src/entity/object/chest.ts");
const crate_1 = __webpack_require__(/*! ../entity/object/crate */ "./src/entity/object/crate.ts");
const mushrooms_1 = __webpack_require__(/*! ../entity/object/mushrooms */ "./src/entity/object/mushrooms.ts");
const pot_1 = __webpack_require__(/*! ../entity/object/pot */ "./src/entity/object/pot.ts");
const pottedPlant_1 = __webpack_require__(/*! ../entity/object/pottedPlant */ "./src/entity/object/pottedPlant.ts");
const pumpkin_1 = __webpack_require__(/*! ../entity/object/pumpkin */ "./src/entity/object/pumpkin.ts");
const sprout_1 = __webpack_require__(/*! ../entity/object/sprout */ "./src/entity/object/sprout.ts");
const tombStone_1 = __webpack_require__(/*! ../entity/object/tombStone */ "./src/entity/object/tombStone.ts");
const rockResource_1 = __webpack_require__(/*! ../entity/resource/rockResource */ "./src/entity/resource/rockResource.ts");
const coalResource_1 = __webpack_require__(/*! ../entity/resource/coalResource */ "./src/entity/resource/coalResource.ts");
const goldResource_1 = __webpack_require__(/*! ../entity/resource/goldResource */ "./src/entity/resource/goldResource.ts");
const emeraldResource_1 = __webpack_require__(/*! ../entity/resource/emeraldResource */ "./src/entity/resource/emeraldResource.ts");
const glowBugEnemy_1 = __webpack_require__(/*! ../entity/enemy/glowBugEnemy */ "./src/entity/enemy/glowBugEnemy.ts");
const tree_1 = __webpack_require__(/*! ../entity/object/tree */ "./src/entity/object/tree.ts");
const environmentTypes_1 = __webpack_require__(/*! ../constants/environmentTypes */ "./src/constants/environmentTypes.ts");
const decoBlock_1 = __webpack_require__(/*! ../entity/object/decoBlock */ "./src/entity/object/decoBlock.ts");
const furnace_1 = __webpack_require__(/*! ../entity/object/furnace */ "./src/entity/object/furnace.ts");
// Enemy imports
const crabEnemy_1 = __webpack_require__(/*! ../entity/enemy/crabEnemy */ "./src/entity/enemy/crabEnemy.ts");
const frogEnemy_1 = __webpack_require__(/*! ../entity/enemy/frogEnemy */ "./src/entity/enemy/frogEnemy.ts");
const zombieEnemy_1 = __webpack_require__(/*! ../entity/enemy/zombieEnemy */ "./src/entity/enemy/zombieEnemy.ts");
const skullEnemy_1 = __webpack_require__(/*! ../entity/enemy/skullEnemy */ "./src/entity/enemy/skullEnemy.ts");
const energyWizard_1 = __webpack_require__(/*! ../entity/enemy/energyWizard */ "./src/entity/enemy/energyWizard.ts");
const chargeEnemy_1 = __webpack_require__(/*! ../entity/enemy/chargeEnemy */ "./src/entity/enemy/chargeEnemy.ts");
const rookEnemy_1 = __webpack_require__(/*! ../entity/enemy/rookEnemy */ "./src/entity/enemy/rookEnemy.ts");
const bishopEnemy_1 = __webpack_require__(/*! ../entity/enemy/bishopEnemy */ "./src/entity/enemy/bishopEnemy.ts");
const armoredzombieEnemy_1 = __webpack_require__(/*! ../entity/enemy/armoredzombieEnemy */ "./src/entity/enemy/armoredzombieEnemy.ts");
const bigSkullEnemy_1 = __webpack_require__(/*! ../entity/enemy/bigSkullEnemy */ "./src/entity/enemy/bigSkullEnemy.ts");
const queenEnemy_1 = __webpack_require__(/*! ../entity/enemy/queenEnemy */ "./src/entity/enemy/queenEnemy.ts");
const knightEnemy_1 = __webpack_require__(/*! ../entity/enemy/knightEnemy */ "./src/entity/enemy/knightEnemy.ts");
const bigKnightEnemy_1 = __webpack_require__(/*! ../entity/enemy/bigKnightEnemy */ "./src/entity/enemy/bigKnightEnemy.ts");
const armoredSkullEnemy_1 = __webpack_require__(/*! ../entity/enemy/armoredSkullEnemy */ "./src/entity/enemy/armoredSkullEnemy.ts");
const fireWizard_1 = __webpack_require__(/*! ../entity/enemy/fireWizard */ "./src/entity/enemy/fireWizard.ts");
const mummyEnemy_1 = __webpack_require__(/*! ../entity/enemy/mummyEnemy */ "./src/entity/enemy/mummyEnemy.ts");
const spiderEnemy_1 = __webpack_require__(/*! ../entity/enemy/spiderEnemy */ "./src/entity/enemy/spiderEnemy.ts");
// Enemy ID mapping for integration with level progression system
exports.enemyClassToId = new Map([
    [crabEnemy_1.CrabEnemy, 1],
    [frogEnemy_1.FrogEnemy, 2],
    [zombieEnemy_1.ZombieEnemy, 3],
    [skullEnemy_1.SkullEnemy, 4],
    [energyWizard_1.EnergyWizardEnemy, 5],
    [chargeEnemy_1.ChargeEnemy, 6],
    [rookEnemy_1.RookEnemy, 7],
    [bishopEnemy_1.BishopEnemy, 8],
    [armoredzombieEnemy_1.ArmoredzombieEnemy, 9],
    [bigSkullEnemy_1.BigSkullEnemy, 10],
    [queenEnemy_1.QueenEnemy, 11],
    [knightEnemy_1.KnightEnemy, 12],
    [bigKnightEnemy_1.BigKnightEnemy, 13],
    [fireWizard_1.FireWizardEnemy, 14],
    [armoredSkullEnemy_1.ArmoredSkullEnemy, 15],
    [mummyEnemy_1.MummyEnemy, 16],
    [spiderEnemy_1.SpiderEnemy, 17],
]);
class Environment {
    constructor(type) {
        this.type = type;
        this.skin = this.type;
    }
}
exports.Environment = Environment;
// Import the enemy minimum depth from level.ts
var level_1 = __webpack_require__(/*! ./level */ "./src/level/level.ts");
Object.defineProperty(exports, "enemyMinimumDepth", ({ enumerable: true, get: function () { return level_1.enemyMinimumDepth; } }));
const environmentData = {
    [environmentTypes_1.EnvType.DUNGEON]: {
        props: [
            { class: crate_1.Crate, weight: 1 },
            { class: barrel_1.Barrel, weight: 1 },
            { class: tombStone_1.TombStone, weight: 0.01, additionalParams: [1] },
            { class: tombStone_1.TombStone, weight: 0.01, additionalParams: [0] },
            { class: pumpkin_1.Pumpkin, weight: 0.05 },
            { class: block_1.Block, weight: 1 },
            { class: pot_1.Pot, weight: 1 },
            { class: pottedPlant_1.PottedPlant, weight: 1 },
            { class: mushrooms_1.Mushrooms, weight: 0.1 },
            { class: bush_1.Bush, weight: 0.1 },
            { class: sprout_1.Sprout, weight: 0.025 },
            { class: chest_1.Chest, weight: 0.025 },
            { class: decoBlock_1.DecoBlock, weight: 0.05 },
            { class: furnace_1.Furnace, weight: 0.05 },
        ],
        enemies: [
            // Early game enemies (depth 0+)
            { class: crabEnemy_1.CrabEnemy, weight: 1.0, minDepth: 0 },
            { class: zombieEnemy_1.ZombieEnemy, weight: 1.2, minDepth: 0 },
            { class: skullEnemy_1.SkullEnemy, weight: 1.0, minDepth: 0 },
            { class: spiderEnemy_1.SpiderEnemy, weight: 1.0, minDepth: 0 },
            { class: mummyEnemy_1.MummyEnemy, weight: 1.0, minDepth: 0 },
            // Mid game enemies (depth 1+)
            { class: energyWizard_1.EnergyWizardEnemy, weight: 0.1, minDepth: 1 },
            { class: rookEnemy_1.RookEnemy, weight: 0.6, minDepth: 1 },
            { class: bishopEnemy_1.BishopEnemy, weight: 0.6, minDepth: 1 },
            { class: armoredzombieEnemy_1.ArmoredzombieEnemy, weight: 0.8, minDepth: 1 },
            { class: knightEnemy_1.KnightEnemy, weight: 0.7, minDepth: 1 },
            // Late game enemies (depth 2+)
            { class: chargeEnemy_1.ChargeEnemy, weight: 0.5, minDepth: 2 },
            {
                class: bigSkullEnemy_1.BigSkullEnemy,
                weight: 0.1,
                minDepth: 2,
                specialSpawnLogic: "clearFloor",
                size: { w: 2, h: 2 },
            },
            { class: queenEnemy_1.QueenEnemy, weight: 0.2, minDepth: 2 },
            {
                class: bigKnightEnemy_1.BigKnightEnemy,
                weight: 0.1,
                minDepth: 2,
                specialSpawnLogic: "clearFloor",
                size: { w: 2, h: 2 },
            },
            { class: fireWizard_1.FireWizardEnemy, weight: 0.1, minDepth: 2 },
            { class: armoredSkullEnemy_1.ArmoredSkullEnemy, weight: 0.5, minDepth: 2 },
        ],
    },
    [environmentTypes_1.EnvType.CAVE]: {
        props: [
            { class: coalResource_1.CoalResource, weight: 1 },
            { class: goldResource_1.GoldResource, weight: 0.1 },
            { class: emeraldResource_1.EmeraldResource, weight: 0.05 },
            { class: block_1.Block, weight: 0.2 },
            { class: rockResource_1.Rock, weight: 0.4 },
            { class: mushrooms_1.Mushrooms, weight: 0.3 },
            { class: pot_1.Pot, weight: 0.2 },
            { class: chest_1.Chest, weight: 0.1 },
        ],
        enemies: [
            // Cave-dwelling creatures
            { class: crabEnemy_1.CrabEnemy, weight: 1.5, minDepth: 0 },
            { class: spiderEnemy_1.SpiderEnemy, weight: 1.2, minDepth: 0 },
            { class: skullEnemy_1.SkullEnemy, weight: 0.8, minDepth: 0 },
            // Mid depth cave enemies
            { class: chargeEnemy_1.ChargeEnemy, weight: 1.0, minDepth: 2 },
            { class: armoredzombieEnemy_1.ArmoredzombieEnemy, weight: 0.6, minDepth: 1 },
            { class: energyWizard_1.EnergyWizardEnemy, weight: 0.5, minDepth: 1 },
            // Deep cave threats
            {
                class: bigSkullEnemy_1.BigSkullEnemy,
                weight: 0.15,
                minDepth: 2,
                specialSpawnLogic: "clearFloor",
                size: { w: 2, h: 2 },
            },
            { class: armoredSkullEnemy_1.ArmoredSkullEnemy, weight: 0.7, minDepth: 2 },
            //{ class: MummyEnemy, weight: 0.4, minDepth: 2 }, // Ancient cave mummies
        ],
    },
    [environmentTypes_1.EnvType.FOREST]: {
        props: [
            { class: tombStone_1.TombStone, weight: 0.035, additionalParams: [1] },
            { class: tombStone_1.TombStone, weight: 0.035, additionalParams: [0] },
            { class: pumpkin_1.Pumpkin, weight: 0.05 },
            { class: bush_1.Bush, weight: 2 },
            { class: sprout_1.Sprout, weight: 0.05 },
            { class: mushrooms_1.Mushrooms, weight: 0.2 },
            { class: rockResource_1.Rock, weight: 0.1 },
            { class: chest_1.Chest, weight: 0.05 },
            { class: glowBugEnemy_1.GlowBugEnemy, weight: 0.05 },
            { class: tree_1.Tree, weight: 0.1 },
        ],
        enemies: [
            // Nature creatures (higher weights)
            { class: glowBugEnemy_1.GlowBugEnemy, weight: 1.5, minDepth: 0 },
            { class: frogEnemy_1.FrogEnemy, weight: 0.25, minDepth: 0 },
            { class: spiderEnemy_1.SpiderEnemy, weight: 0.25, minDepth: 0 },
            // Less common forest enemies
            { class: crabEnemy_1.CrabEnemy, weight: 0.3, minDepth: 0 },
            { class: zombieEnemy_1.ZombieEnemy, weight: 0.2, minDepth: 0 },
            { class: skullEnemy_1.SkullEnemy, weight: 0.1, minDepth: 0 },
            // Rare magical forest creatures
            { class: energyWizard_1.EnergyWizardEnemy, weight: 0.4, minDepth: 1 },
            { class: chargeEnemy_1.ChargeEnemy, weight: 0.3, minDepth: 2 }, // Charging forest beasts
        ],
    },
    [environmentTypes_1.EnvType.SWAMP]: {
        props: [
            { class: barrel_1.Barrel, weight: 8 },
            { class: tombStone_1.TombStone, weight: 5, additionalParams: [1] },
            { class: tombStone_1.TombStone, weight: 2, additionalParams: [0] },
            { class: block_1.Block, weight: 5 },
            { class: mushrooms_1.Mushrooms, weight: 0.5 },
            { class: bush_1.Bush, weight: 0.25 },
            { class: pot_1.Pot, weight: 0.15 },
            { class: rockResource_1.Rock, weight: 0.05 },
            { class: chest_1.Chest, weight: 0.05 },
        ],
        enemies: [
            // Decay and poison themed enemies
            { class: zombieEnemy_1.ZombieEnemy, weight: 1.8, minDepth: 0 },
            { class: frogEnemy_1.FrogEnemy, weight: 1.5, minDepth: 1 },
            { class: mummyEnemy_1.MummyEnemy, weight: 1.0, minDepth: 2 },
            { class: armoredzombieEnemy_1.ArmoredzombieEnemy, weight: 1.2, minDepth: 1 },
            // Other swamp dwellers
            { class: crabEnemy_1.CrabEnemy, weight: 0.8, minDepth: 0 },
            { class: skullEnemy_1.SkullEnemy, weight: 1.0, minDepth: 0 },
            { class: spiderEnemy_1.SpiderEnemy, weight: 0.6, minDepth: 0 },
            // Powerful swamp creatures
            { class: armoredSkullEnemy_1.ArmoredSkullEnemy, weight: 0.8, minDepth: 2 },
            { class: energyWizard_1.EnergyWizardEnemy, weight: 0.3, minDepth: 1 }, // Swamp witches
        ],
    },
    [environmentTypes_1.EnvType.GLACIER]: {
        props: [
            { class: block_1.Block, weight: 20 },
            { class: crate_1.Crate, weight: 5 },
            { class: rockResource_1.Rock, weight: 0.6 },
            { class: chest_1.Chest, weight: 0.4 },
        ],
        enemies: [
            // Ice and cold themed enemies
            { class: crabEnemy_1.CrabEnemy, weight: 1.0, minDepth: 0 },
            { class: chargeEnemy_1.ChargeEnemy, weight: 1.2, minDepth: 2 },
            { class: knightEnemy_1.KnightEnemy, weight: 1.0, minDepth: 1 },
            {
                class: bigKnightEnemy_1.BigKnightEnemy,
                weight: 0.15,
                minDepth: 2,
                specialSpawnLogic: "clearFloor",
                size: { w: 2, h: 2 },
            },
            // Hardy creatures that survive cold
            { class: armoredzombieEnemy_1.ArmoredzombieEnemy, weight: 0.8, minDepth: 1 },
            { class: armoredSkullEnemy_1.ArmoredSkullEnemy, weight: 0.9, minDepth: 2 },
            { class: rookEnemy_1.RookEnemy, weight: 0.7, minDepth: 1 },
            { class: bishopEnemy_1.BishopEnemy, weight: 0.7, minDepth: 1 },
            // Rare glacier threats
            {
                class: bigSkullEnemy_1.BigSkullEnemy,
                weight: 0.1,
                minDepth: 2,
                specialSpawnLogic: "clearFloor",
                size: { w: 2, h: 2 },
            },
        ],
    },
    [environmentTypes_1.EnvType.CASTLE]: {
        props: [
            { class: crate_1.Crate, weight: 10 },
            { class: barrel_1.Barrel, weight: 8 },
            { class: tombStone_1.TombStone, weight: 4, additionalParams: [1] },
            { class: tombStone_1.TombStone, weight: 2, additionalParams: [0] },
            { class: block_1.Block, weight: 6 },
            { class: pottedPlant_1.PottedPlant, weight: 0.4 },
            { class: pot_1.Pot, weight: 0.3 },
            { class: chest_1.Chest, weight: 0.2 },
            { class: rockResource_1.Rock, weight: 0.1 },
        ],
        enemies: [
            // Royal guards and castle defenders
            { class: knightEnemy_1.KnightEnemy, weight: 2.0, minDepth: 1 },
            {
                class: bigKnightEnemy_1.BigKnightEnemy,
                weight: 0.2,
                minDepth: 2,
                specialSpawnLogic: "clearFloor",
                size: { w: 2, h: 2 },
            },
            { class: rookEnemy_1.RookEnemy, weight: 1.5, minDepth: 1 },
            { class: bishopEnemy_1.BishopEnemy, weight: 1.5, minDepth: 1 },
            { class: queenEnemy_1.QueenEnemy, weight: 0.5, minDepth: 2 },
            // Castle undead
            { class: armoredzombieEnemy_1.ArmoredzombieEnemy, weight: 1.0, minDepth: 1 },
            { class: armoredSkullEnemy_1.ArmoredSkullEnemy, weight: 1.0, minDepth: 2 },
            // Other castle inhabitants
            { class: energyWizard_1.EnergyWizardEnemy, weight: 0.1, minDepth: 1 },
            { class: fireWizard_1.FireWizardEnemy, weight: 0.1, minDepth: 2 },
            { class: chargeEnemy_1.ChargeEnemy, weight: 0.4, minDepth: 2 }, // War beasts
        ],
    },
};
exports.environmentData = environmentData;


/***/ }),

/***/ "./src/level/generationVisualizer.ts":
/*!*******************************************!*\
  !*** ./src/level/generationVisualizer.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GenerationVisualizer = void 0;
const game_1 = __webpack_require__(/*! ../game */ "./src/game.ts");
const gameConstants_1 = __webpack_require__(/*! ../game/gameConstants */ "./src/game/gameConstants.ts");
class GenerationVisualizer {
    constructor(game) {
        this.game = game;
        this.debugMode = document.cookie.includes("showgeneration=true");
        this.animationConfig = {
            partitionSplitDelay: this.debugMode ? 10 : 0,
            pathfindingDelay: this.debugMode ? 100 : 0,
            largeStepDelay: this.debugMode ? 100 : 0,
            animationConstant: 1,
            enabled: this.debugMode,
        };
        this.visualizationState = {
            currentStep: "initializing",
            progress: 0,
            partitions: [],
            centerX: 0,
            centerY: 0,
        };
    }
    /**
     * Updates the animation configuration
     */
    updateAnimationConfig(config) {
        this.animationConfig = { ...this.animationConfig, ...config };
    }
    /**
     * Sets the visualization state for rendering
     */
    setVisualizationState(partitions, centerX, centerY, step = "generating", progress = 0) {
        this.visualizationState = {
            currentStep: step,
            progress,
            partitions,
            centerX,
            centerY,
        };
    }
    /**
     * Draws the current generation state
     */
    draw(delta) {
        // Clear the canvas
        game_1.Game.ctx.fillStyle = "rgba(0, 0, 0, 1)";
        game_1.Game.ctx.fillRect(0, 0, gameConstants_1.GameConstants.WIDTH, gameConstants_1.GameConstants.HEIGHT);
        if (this.debugMode) {
            this.drawGenerationProgress(delta);
        }
        else {
            this.drawSimpleLoadingScreen();
        }
    }
    /**
     * Draws detailed generation progress for debug mode
     */
    drawGenerationProgress(delta) {
        if (this.visualizationState.partitions.length > 0) {
            // Draw all partitions
            this.visualizationState.partitions.forEach((partition) => {
                this.drawPartition(partition, delta, this.visualizationState.centerX, this.visualizationState.centerY);
            });
            // Draw progress information
            this.drawProgressInfo();
        }
    }
    /**
     * Draws a simple loading screen for normal mode
     */
    drawSimpleLoadingScreen() {
        this.game.drawTextScreen("generating level");
    }
    /**
     * Draws an individual partition
     */
    drawPartition(partition, delta, levelCenterX, levelCenterY) {
        // Draw partition rectangle
        game_1.Game.ctx.fillStyle = partition.fillStyle;
        game_1.Game.ctx.fillRect(Math.round(gameConstants_1.GameConstants.WIDTH / 2 + partition.x - levelCenterX), Math.round(gameConstants_1.GameConstants.HEIGHT / 2 + partition.y - levelCenterY), partition.w, partition.h);
        // Draw connections
        this.drawPartitionConnections(partition, levelCenterX, levelCenterY);
        // Draw partition info if in debug mode
        if (this.debugMode) {
            this.drawPartitionInfo(partition, levelCenterX, levelCenterY);
        }
    }
    /**
     * Draws connections for a partition
     */
    drawPartitionConnections(partition, levelCenterX, levelCenterY) {
        game_1.Game.ctx.fillStyle = "white";
        for (let connection of partition.connections) {
            game_1.Game.ctx.fillRect(Math.round(gameConstants_1.GameConstants.WIDTH / 2 + connection.x - levelCenterX), Math.round(gameConstants_1.GameConstants.HEIGHT / 2 + connection.y - levelCenterY), 1, 1);
        }
    }
    /**
     * Draws debug information for a partition
     */
    drawPartitionInfo(partition, levelCenterX, levelCenterY) {
        const x = Math.round(gameConstants_1.GameConstants.WIDTH / 2 + partition.x - levelCenterX);
        const y = Math.round(gameConstants_1.GameConstants.HEIGHT / 2 + partition.y - levelCenterY);
        game_1.Game.ctx.fillStyle = "yellow";
        game_1.Game.ctx.font = "8px Arial";
        game_1.Game.ctx.fillText(`${partition.type}`, x + 2, y + 10);
        game_1.Game.ctx.fillText(`D:${partition.distance}`, x + 2, y + 20);
    }
    /**
     * Draws progress information overlay
     */
    drawProgressInfo() {
        game_1.Game.ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
        game_1.Game.ctx.fillRect(10, 10, 200, 60);
        game_1.Game.ctx.fillStyle = "white";
        game_1.Game.ctx.font = "12px Arial";
        game_1.Game.ctx.fillText(`Step: ${this.visualizationState.currentStep}`, 20, 30);
        game_1.Game.ctx.fillText(`Partitions: ${this.visualizationState.partitions.length}`, 20, 45);
        game_1.Game.ctx.fillText(`Progress: ${Math.round(this.visualizationState.progress * 100)}%`, 20, 60);
    }
    /**
     * Creates an animation delay promise
     */
    async createAnimationDelay(delayType) {
        if (!this.animationConfig.enabled) {
            return Promise.resolve();
        }
        let delay = 0;
        switch (delayType) {
            case "partition":
                delay =
                    this.animationConfig.animationConstant *
                        this.animationConfig.partitionSplitDelay;
                break;
            case "pathfinding":
                delay =
                    this.animationConfig.animationConstant *
                        this.animationConfig.pathfindingDelay;
                break;
            case "large":
                delay =
                    this.animationConfig.animationConstant *
                        this.animationConfig.largeStepDelay;
                break;
        }
        return new Promise((resolve) => setTimeout(resolve, delay));
    }
    /**
     * Updates partition visual styles during generation
     */
    updatePartitionStyles(partitions) {
        // Sort partitions by area for consistent styling
        const sortedPartitions = [...partitions].sort((a, b) => a.area() - b.area());
        if (sortedPartitions.length === 0)
            return;
        const minArea = sortedPartitions[0].area();
        const maxArea = sortedPartitions[sortedPartitions.length - 1].area();
        // Apply area-based styling
        partitions.forEach((partition) => {
            if (partition.type === "START") {
                partition.fillStyle = "rgb(0, 255, 0)";
            }
            else if (partition.type === "BOSS") {
                partition.fillStyle = "rgb(255, 0, 0)";
            }
            else if (partition.type === "DOWNLADDER") {
                partition.fillStyle = "blue";
            }
            else if (partition.type === "ROPEHOLE") {
                partition.fillStyle = "purple";
            }
            else {
                // Default area-based styling
                const normalizedArea = maxArea > minArea
                    ? (partition.area() - minArea) / (maxArea - minArea)
                    : 0;
                const opacity = 0.3 + normalizedArea * 0.7;
                partition.fillStyle = `rgba(128, 128, 128, ${opacity})`;
            }
        });
    }
    /**
     * Visualizes partition layout in console (for debugging)
     */
    visualizePartitionsInConsole(partitions, mapWidth, mapHeight) {
        if (!this.debugMode)
            return;
        const grid = Array.from({ length: mapHeight }, () => Array(mapWidth).fill(" . "));
        const maxIndex = partitions.length - 1;
        const padLength = maxIndex.toString().length;
        partitions.forEach((partition, index) => {
            const paddedIndex = index.toString().padStart(padLength, " ");
            for (let x = partition.x; x < partition.x + partition.w; x++) {
                for (let y = partition.y; y < partition.y + partition.h; y++) {
                    if (x >= 0 && x < mapWidth && y >= 0 && y < mapHeight) {
                        grid[y][x] = ` ${paddedIndex} `;
                    }
                }
            }
        });
        console.log("Partition Layout:");
        console.log("   " + [...Array(mapWidth)].map((_, i) => i % 10).join("  ") + " X");
        grid.forEach((row, index) => {
            const paddedIndex = index.toString().padStart(2, " ");
            console.log(`${paddedIndex} ${row.join("")}`);
        });
        console.log("Y");
    }
    /**
     * Logs generation progress messages
     */
    logGenerationStep(step, details) {
        if (!this.debugMode)
            return;
        const message = details ? `${step}: ${details}` : step;
        console.log(`[GenerationVisualizer] ${message}`);
        if (this.game && this.game.pushMessage) {
            this.game.pushMessage(message);
        }
    }
    /**
     * Creates visual effects for specific generation events
     */
    createVisualEffect(effectType, partition) {
        if (!this.debugMode)
            return;
        switch (effectType) {
            case "partition_split":
                if (partition) {
                    // Temporarily highlight the partition
                    const originalStyle = partition.fillStyle;
                    partition.fillStyle = "yellow";
                    setTimeout(() => {
                        partition.fillStyle = originalStyle;
                    }, 200);
                }
                break;
            case "room_connected":
                if (partition) {
                    partition.fillStyle = "lightgreen";
                }
                break;
            case "boss_found":
                if (partition) {
                    partition.fillStyle = "rgb(255, 0, 0)";
                }
                this.logGenerationStep("Boss room found!");
                break;
            case "generation_complete":
                this.logGenerationStep("Generation complete!");
                break;
        }
    }
    /**
     * Updates the current generation progress
     */
    updateProgress(step, progress) {
        this.visualizationState.currentStep = step;
        this.visualizationState.progress = Math.max(0, Math.min(1, progress));
        this.logGenerationStep(step, `${Math.round(progress * 100)}%`);
    }
    /**
     * Resets the visualizer state
     */
    reset() {
        this.visualizationState = {
            currentStep: "initializing",
            progress: 0,
            partitions: [],
            centerX: 0,
            centerY: 0,
        };
    }
    /**
     * Gets the current animation configuration
     */
    getAnimationConfig() {
        return { ...this.animationConfig };
    }
    /**
     * Gets the current visualization state
     */
    getVisualizationState() {
        return { ...this.visualizationState };
    }
}
exports.GenerationVisualizer = GenerationVisualizer;


/***/ }),

/***/ "./src/level/level.ts":
/*!****************************!*\
  !*** ./src/level/level.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Level = exports.enemyMinimumDepth = void 0;
const room_1 = __webpack_require__(/*! ../room/room */ "./src/room/room.ts");
const environment_1 = __webpack_require__(/*! ./environment */ "./src/level/environment.ts");
const roomPopulator_1 = __webpack_require__(/*! ../room/roomPopulator */ "./src/room/roomPopulator.ts");
const downLadder_1 = __webpack_require__(/*! ../tile/downLadder */ "./src/tile/downLadder.ts");
const key_1 = __webpack_require__(/*! ../item/key */ "./src/item/key.ts");
const random_1 = __webpack_require__(/*! ../utility/random */ "./src/utility/random.ts");
exports.enemyMinimumDepth = {
    1: 0,
    2: 1,
    3: 0,
    4: 0,
    5: 1,
    6: 2,
    7: 1,
    8: 1,
    9: 1,
    10: 2,
    11: 2,
    12: 1,
    13: 2,
    14: 2,
    15: 2, // ArmoredSkullEnemy  16: 2, // ArmoredKnightEnemy
};
/*
interface enemySpawnPoolData {
  maxCount: number;
  minCount: number;
}

interface environmentData {
  name: string;
  preferredEnemies: Array<Enemy>;
  preferredEntities: Array<Entity>;
  entityBlacklist: Array<Entity>;
  enemySpawnPoolData: enemySpawnPoolData;
  roomData: roomData;
}

interface entitySpawnData {
  enemy: Enemy;
  spawnChance: number;
  maximumCount: number;
}
*/
class Level {
    constructor(game, depth, width, height, isMainPath = true, mapGroup, env) {
        this.isMainPath = true;
        this.initializeLevelArray = () => {
            // Create a 300x300 grid for depth 0
            this.levelArray = [];
            for (let x = 0; x < this.width; x++) {
                this.levelArray[x] = [];
                for (let y = 0; y < this.height; y++) {
                    this.levelArray[x][y] = null;
                }
            }
        };
        this.loadRoomsIntoLevelArray = () => {
            for (let room of this.rooms) {
                for (let x = room.roomX; x < room.roomX + room.width; x++) {
                    for (let y = room.roomY; y < room.roomY + room.height; y++) {
                        // Add bounds checking
                        if (x >= 0 && x < this.width && y >= 0 && y < this.height) {
                            // Ensure room array has valid tiles at these coordinates
                            if (room.roomArray[x] && room.roomArray[x][y]) {
                                this.levelArray[x][y] = room.roomArray[x][y];
                            }
                            else {
                                console.warn(`Room array missing tile at (${x}, ${y}) for room ${room.id}`);
                            }
                        }
                        else {
                            console.warn(`Room coordinates (${x}, ${y}) are outside level bounds (${this.width}, ${this.height})`);
                        }
                    }
                }
            }
        };
        this.game = game;
        this.depth = depth;
        this.width = width;
        this.height = height;
        this.rooms = [];
        this.isMainPath = isMainPath;
        this.initializeLevelArray();
        this.mapGroup = mapGroup;
        this.environment = new environment_1.Environment(env);
        this.populator = new roomPopulator_1.Populator(this);
        this.enemyParameters = this.getEnemyParameters();
        let mainPath = this.isMainPath ? "main" : "side";
    }
    getDownLadder(room) {
        if (!room || room.type !== room_1.RoomType.ROPEHOLE) {
            console.error("Room is not a rope hole");
            return null;
        }
        // Then check ROPEHOLE rooms
        //let room = this.rooms.find((room) => room.type === RoomType.ROPEHOLE);
        if (room) {
            for (let x = room.roomX; x < room.roomX + room.width; x++) {
                for (let y = room.roomY; y < room.roomY + room.height; y++) {
                    const tile = room.roomArray[x][y];
                    if (tile instanceof downLadder_1.DownLadder) {
                        return tile;
                    }
                }
            }
        }
        console.error("No down ladder found");
        return null;
    }
    distributeKeys() {
        console.log("Starting distributeKeys - searching entire level array for down ladders");
        // Search the entire level array for down ladders
        let downLadder = null;
        for (let room of this.rooms) {
            for (let x = room.roomX; x < room.roomX + room.width; x++) {
                for (let y = room.roomY; y < room.roomY + room.height; y++) {
                    const tile = room.roomArray[x][y];
                    if (tile instanceof downLadder_1.DownLadder) {
                        console.log(`Found down ladder at position (${x}, ${y})`);
                        downLadder = tile;
                        break;
                    }
                }
                if (downLadder)
                    break;
            }
        }
        if (!downLadder) {
            console.error("No down ladder found in level array");
            return;
        }
        console.log("Down ladder found, proceeding with key distribution");
        this.distributeKey(downLadder);
    }
    distributeKey(downLadder) {
        const rooms = this.rooms.filter((r) => r.type !== room_1.RoomType.START &&
            r.type !== room_1.RoomType.DOWNLADDER &&
            r.type !== room_1.RoomType.ROPEHOLE);
        const disableCoords = {
            disableX: downLadder.x,
            disableY: downLadder.y,
            disableRoom: downLadder.room,
        };
        console.log(`Found ${rooms.length} eligible rooms for key placement`);
        if (rooms.length === 0) {
            console.error("No eligible rooms found for key placement");
            return;
        }
        const randomRoom = rooms[Math.floor(random_1.Random.rand() * rooms.length)];
        console.log(`Selected room ${randomRoom.id} for key placement`);
        let emptyTiles = randomRoom.getEmptyTiles();
        if (disableCoords.disableRoom === randomRoom) {
            emptyTiles = emptyTiles.filter((t) => t.x !== disableCoords.disableX && t.y !== disableCoords.disableY);
        }
        console.log(`Room has ${emptyTiles.length} empty tiles`);
        if (emptyTiles.length === 0) {
            console.error(`No empty tiles found in room ${randomRoom.id} for key placement`);
            return;
        }
        const randomIndex = Math.floor(random_1.Random.rand() * emptyTiles.length);
        const randomTile = emptyTiles[randomIndex];
        console.log(`Placing key at tile position (${randomTile.x}, ${randomTile.y})`);
        const key = new key_1.Key(randomRoom, randomTile.x, randomTile.y);
        downLadder.lockable.setKey(key);
        randomRoom.items.push(key);
        console.log("key.doorID", key.doorID, "downLadder.keyID", downLadder.lockable.keyID);
        console.log("Key successfully distributed and linked to down ladder");
        //this.game.player.inventory.addItem(key);
    }
    setExitRoom() {
        if (this.isMainPath) {
            this.exitRoom = this.rooms.find((room) => room.type === room_1.RoomType.DOWNLADDER);
        }
        else {
            this.exitRoom = this.rooms.find((room) => room.type === room_1.RoomType.UPLADDER);
        }
    }
    setStartRoom() {
        if (this.isMainPath) {
            this.startRoom = this.rooms.find((room) => room.type === room_1.RoomType.START);
        }
        else {
            this.startRoom = this.rooms.find((room) => room.type === room_1.RoomType.ROPECAVE);
        }
    }
    setRooms(rooms) {
        this.rooms = rooms;
        this.setExitRoom();
        this.setStartRoom();
        rooms.forEach((room) => {
            room.id = this.rooms.indexOf(room);
        });
    }
    /**
     * Generates enemy parameters based on the current depth.
     * @param depth The current depth level.
     * @returns An object conforming to the EnemyParameters interface.
     */
    getEnemyParameters() {
        // This can now be simplified or deprecated since Populator handles everything
        return {
            enemyTables: {},
            maxDepthTable: this.depth,
            minDepths: exports.enemyMinimumDepth,
        };
    }
    setRoomSkins() {
        for (let room of this.rooms) {
            room.skin = this.environment.skin;
        }
    }
}
exports.Level = Level;


/***/ }),

/***/ "./src/level/levelConstants.ts":
/*!*************************************!*\
  !*** ./src/level/levelConstants.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LevelConstants = void 0;
class LevelConstants {
}
exports.LevelConstants = LevelConstants;
LevelConstants.SCREEN_W = 1;
LevelConstants.SCREEN_H = 1;
LevelConstants.COMPUTER_TURN_DELAY = 250; // milliseconds (was 300)
LevelConstants.TURN_TIME = 3000; // milliseconds
LevelConstants.LEVEL_TRANSITION_TIME = 300; // milliseconds
LevelConstants.LEVEL_TRANSITION_TIME_LADDER = 1000; // milliseconds
LevelConstants.ROOM_COUNT = 50;
LevelConstants.HEALTH_BAR_FADEIN = 100;
LevelConstants.HEALTH_BAR_FADEOUT = 350;
LevelConstants.HEALTH_BAR_TOTALTIME = 1000;
LevelConstants.SHADED_TILE_CUTOFF = 1;
LevelConstants.MIN_VISIBILITY = 0; // visibility level of places you've already seen
LevelConstants.LIGHTING_ANGLE_STEP = 2; // how many degrees between each ray, previously 5
LevelConstants.LIGHTING_MAX_DISTANCE = 7;
//static readonly LIGHT_RESOLUTION = 0.1; //1 is default
LevelConstants.LEVEL_TEXT_COLOR = "yellow";
LevelConstants.AMBIENT_LIGHT_COLOR = [12, 15, 12];
LevelConstants.TORCH_LIGHT_COLOR = [120, 35, 10];


/***/ }),

/***/ "./src/level/levelGenerator.ts":
/*!*************************************!*\
  !*** ./src/level/levelGenerator.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LevelGenerator = void 0;
const game_1 = __webpack_require__(/*! ../game */ "./src/game.ts");
const room_1 = __webpack_require__(/*! ../room/room */ "./src/room/room.ts");
const random_1 = __webpack_require__(/*! ../utility/random */ "./src/utility/random.ts");
const downLadder_1 = __webpack_require__(/*! ../tile/downLadder */ "./src/tile/downLadder.ts");
const levelParametersGenerator_1 = __webpack_require__(/*! ./levelParametersGenerator */ "./src/level/levelParametersGenerator.ts");
const level_1 = __webpack_require__(/*! ./level */ "./src/level/level.ts");
const gameConstants_1 = __webpack_require__(/*! ../game/gameConstants */ "./src/game/gameConstants.ts");
const environmentTypes_1 = __webpack_require__(/*! ../constants/environmentTypes */ "./src/constants/environmentTypes.ts");
const partitionGenerator_1 = __webpack_require__(/*! ./partitionGenerator */ "./src/level/partitionGenerator.ts");
const levelValidator_1 = __webpack_require__(/*! ./levelValidator */ "./src/level/levelValidator.ts");
const pngPartitionGenerator_1 = __webpack_require__(/*! ./pngPartitionGenerator */ "./src/level/pngPartitionGenerator.ts");
class LevelGenerator {
    constructor() {
        this.depthReached = 0;
        this.currentFloorFirstLevelID = 0;
        this.setOpenWallsForPartitions = (partitions, mapWidth, mapHeight) => {
            for (const partition of partitions) {
                // Reset all walls to closed by default
                partition.isTopOpen = false;
                partition.isRightOpen = false;
                partition.isBottomOpen = false;
                partition.isLeftOpen = false;
                // Check if partition touches map boundaries
                if (partition.x === 0) {
                    partition.isLeftOpen = true;
                }
                if (partition.y === 0) {
                    partition.isTopOpen = true;
                }
                if (partition.x + partition.w === mapWidth) {
                    partition.isRightOpen = true;
                }
                if (partition.y + partition.h === mapHeight) {
                    partition.isBottomOpen = true;
                }
            }
        };
        this.createLevel = (depth, isMainPath = true, mapGroup, envType) => {
            let newLevel = new level_1.Level(this.game, depth, 100, 100, isMainPath, mapGroup, envType);
            return newLevel;
        };
        this.getRooms = (partitions, depth, mapGroup, envType) => {
            let rooms = [];
            for (let i = 0; i < partitions.length; i++) {
                let partition = partitions[i];
                let room = new room_1.Room(this.game, partition.x - 1, partition.y - 1, partition.w + 2, partition.h + 2, partition.type, depth, mapGroup, this.game.levels[depth], random_1.Random.rand, envType);
                rooms.push(room);
            }
            let doors_added = [];
            partitions.forEach((partition, index) => {
                partition.connections.forEach((connection) => {
                    let door = rooms[index].addDoor(connection.x, connection.y);
                    let existingDoor = doors_added.find((existing) => existing.x === door.x && existing.y === door.y);
                    if (existingDoor) {
                        existingDoor.link(door);
                        door.link(existingDoor);
                    }
                    doors_added.push(door);
                });
            });
            return rooms;
        };
        this.setSeed = (seed) => {
            this.seed = seed;
        };
        this.generate = async (game, depth, isSidePath = false, callback, environment = environmentTypes_1.EnvType.DUNGEON) => {
            // Initialize components with game instance
            if (!this.partitionGenerator) {
                this.partitionGenerator = new partitionGenerator_1.PartitionGenerator(game);
            }
            if (!this.validator) {
                this.validator = new levelValidator_1.LevelValidator(game);
            }
            if (!this.visualizer) {
                this.visualizer = this.partitionGenerator.getVisualizer();
            }
            this.levelParams = levelParametersGenerator_1.LevelParameterGenerator.getParameters(depth);
            this.depthReached = depth;
            // Set the random state based on the seed and depth
            random_1.Random.setState(this.seed + depth);
            this.game = game;
            // Determine the map group
            let mapGroup = this.game.rooms.length > 0
                ? this.game.rooms[this.game.rooms.length - 1].mapGroup + 1
                : 0;
            // Generate partitions based on whether it's a side path or main path
            let partitions;
            const shouldUsePNG = gameConstants_1.GameConstants.USE_PNG_LEVELS && !isSidePath;
            const rollPNG = random_1.Random.rand() < 0.25;
            if (shouldUsePNG && rollPNG) {
                // Use PNG-based level generation for MAIN PATHS ONLY
                const pngUrl = await this.selectRandomLevelForDepth(depth);
                if (pngUrl) {
                    console.log(`Using PNG level generation from: ${pngUrl}`);
                    partitions = await this.pngPartitionGenerator.generatePartitionsFromPng(pngUrl, game, depth, isSidePath);
                }
                // Fallback to procedural generation if PNG generation fails or no PNG found
                if (!pngUrl || partitions.length === 0) {
                    if (!pngUrl) {
                        console.warn(`No PNG levels found for depth ${depth}, falling back to procedural generation`);
                    }
                    else {
                        console.warn("PNG generation failed, falling back to procedural generation");
                    }
                    partitions = await this.partitionGenerator.generateDungeonPartitions(game, this.levelParams.mapWidth, this.levelParams.mapHeight, depth, this.levelParams);
                }
            }
            else {
                // Use procedural generation for side paths OR when PNG is disabled
                if (isSidePath) {
                    partitions = await this.partitionGenerator.generateCavePartitions(50, 50);
                }
                else {
                    partitions = await this.partitionGenerator.generateDungeonPartitions(game, this.levelParams.mapWidth, this.levelParams.mapHeight, depth, this.levelParams);
                }
            }
            // Use validator instead of direct overlap checking
            const overlapValidation = this.validator.validateNoOverlaps(partitions);
            if (!overlapValidation.isValid) {
                console.warn(`Overlap validation failed: ${overlapValidation.errorMessage}`);
            }
            let envType = environment;
            // Check for overlaps
            // if (this.partitionGenerator.checkOverlaps(partitions)) { // This line is removed as per the new_code
            //   console.warn("There are overlapping partitions.");
            // }
            // Get the levels based on the partitions
            let newLevel = this.createLevel(depth, !isSidePath, mapGroup, envType);
            if (isSidePath) {
                // create Level object ONLY to prepare rooms, but
                // DO NOT push to game.levels
            }
            else {
                this.game.levels.push(newLevel);
            }
            let rooms = this.getRooms(partitions, depth, mapGroup, envType);
            newLevel.setRooms(rooms);
            newLevel.populator.populateRooms();
            newLevel.setRoomSkins();
            //newLevel.loadRoomsIntoLevelArray();
            // Only call linkExitToStart for main paths
            if (newLevel.exitRoom) {
                newLevel.exitRoom.linkExitToStart();
            }
            // Update the current floor first level ID if it's not a cave
            if (!isSidePath)
                this.currentFloorFirstLevelID = this.game.rooms.length;
            // Add the new levels to the game rooms
            this.game.rooms = rooms;
            // Generate the rope hole if it exists
            for (let room of rooms) {
                if (room.type === room_1.RoomType.ROPEHOLE) {
                    for (let x = room.roomX; x < room.roomX + room.width; x++) {
                        for (let y = room.roomY; y < room.roomY + room.height; y++) {
                            let tile = room.roomArray[x][y];
                            if (tile instanceof downLadder_1.DownLadder && tile.isSidePath) {
                                tile.generate();
                                callback(isSidePath
                                    ? rooms.find((r) => r.type === room_1.RoomType.ROPECAVE)
                                    : rooms.find((r) => r.type === room_1.RoomType.START));
                            }
                        }
                    }
                }
            }
            // Return the start room or the rope cave room
            callback(isSidePath
                ? rooms.find((r) => r.type === room_1.RoomType.ROPECAVE)
                : rooms.find((r) => r.type === room_1.RoomType.START));
        };
        this.generateFirstNFloors = async (game, numFloors) => {
            await this.generate(game, 0, false, () => { });
            for (let i = 0; i < numFloors; i++) {
                let foundRoom = this.game.rooms
                    .slice()
                    .reverse()
                    .find((room) => room.type === room_1.RoomType.DOWNLADDER);
                if (foundRoom) {
                    for (let x = foundRoom.roomX; x < foundRoom.roomX + foundRoom.width; x++) {
                        for (let y = foundRoom.roomY; y < foundRoom.roomY + foundRoom.height; y++) {
                            let tile = foundRoom.roomArray[x][y];
                            if (tile instanceof downLadder_1.DownLadder) {
                                tile.generate();
                                break;
                            }
                        }
                    }
                }
            }
        };
        this.draw = (delta) => {
            if (this.visualizer) {
                this.visualizer.draw(delta);
            }
            else {
                // Fallback if visualizer not initialized
                game_1.Game.ctx.fillStyle = "rgba(0, 0, 0, 1)";
                game_1.Game.ctx.fillRect(0, 0, gameConstants_1.GameConstants.WIDTH, gameConstants_1.GameConstants.HEIGHT);
                this.game.drawTextScreen("generating level");
            }
        };
        // Don't initialize partitionGenerator here yet since we need game instance
        this.validator = null;
        this.visualizer = null;
        this.pngPartitionGenerator = new pngPartitionGenerator_1.PngPartitionGenerator();
    }
    async selectRandomLevelForDepth(depth) {
        console.log(`Looking for PNG levels for depth ${depth}...`);
        // Try to find available variations for this depth
        const availableVariations = [];
        const maxVariations = 10; // Check up to 10 variations per depth
        for (let variation = 0; variation < maxVariations; variation++) {
            const filename = `${depth}_${variation}.png`;
            const fullPath = `res/levels/${filename}`;
            // Check if file exists by trying to load it
            if (await this.checkImageExists(fullPath)) {
                availableVariations.push(fullPath);
                console.log(`  ✓ Found variation: ${filename}`);
            }
        }
        if (availableVariations.length === 0) {
            console.log(`  ❌ No PNG levels found for depth ${depth}`);
            return null;
        }
        // Randomly select one of the available variations
        const selectedIndex = Math.floor(random_1.Random.rand() * availableVariations.length);
        const selectedPath = availableVariations[selectedIndex];
        console.log(`  🎲 Selected ${selectedPath} (${selectedIndex + 1}/${availableVariations.length} available)`);
        return selectedPath;
    }
    async checkImageExists(imagePath) {
        return new Promise((resolve) => {
            const img = new Image();
            img.onload = () => {
                resolve(true);
            };
            img.onerror = () => {
                resolve(false);
            };
            // Set a timeout to avoid hanging
            setTimeout(() => {
                resolve(false);
            }, 1000);
            img.src = imagePath;
        });
    }
}
exports.LevelGenerator = LevelGenerator;
LevelGenerator.ANIMATION_CONSTANT = 1;
const getPathParameters = (pathType, depth) => {
    const baseParams = levelParametersGenerator_1.LevelParameterGenerator.getParameters(depth);
    switch (pathType) {
        case partitionGenerator_1.PathType.MAIN_PATH:
            return {
                pathType: partitionGenerator_1.PathType.MAIN_PATH,
                mapWidth: baseParams.mapWidth,
                mapHeight: baseParams.mapHeight,
                roomCount: {
                    min: baseParams.minRoomCount,
                    max: baseParams.maxRoomCount,
                },
                splitProbabilities: [0.75, 1, 0.5],
                wallRemoveProbability: 0.5,
                maxRoomArea: baseParams.maxRoomArea,
                softMaxRoomArea: baseParams.softMaxRoomArea,
                connectionStyle: "linear",
                loopDoorCount: { min: 4, max: 8 },
            };
        case partitionGenerator_1.PathType.SIDE_PATH:
            return {
                pathType: partitionGenerator_1.PathType.SIDE_PATH,
                mapWidth: 50,
                mapHeight: 50,
                roomCount: { min: 5, max: 5 },
                splitProbabilities: [0.75, 1, 0.5],
                wallRemoveProbability: 0.5,
                maxRoomArea: 100,
                softMaxRoomArea: 80,
                connectionStyle: "branched",
                loopDoorCount: { min: 4, max: 8 },
            };
        case partitionGenerator_1.PathType.TUTORIAL:
            return {
                pathType: partitionGenerator_1.PathType.TUTORIAL,
                mapWidth: 7,
                mapHeight: 7,
                roomCount: { min: 1, max: 1 },
                splitProbabilities: [],
                wallRemoveProbability: 0,
                maxRoomArea: 49,
                softMaxRoomArea: 49,
                connectionStyle: "linear",
                loopDoorCount: { min: 0, max: 0 },
            };
        default:
            throw new Error(`Unknown path type: ${pathType}`);
    }
};


/***/ }),

/***/ "./src/level/levelImageGenerator.ts":
/*!******************************************!*\
  !*** ./src/level/levelImageGenerator.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LevelImageGenerator = void 0;
const game_1 = __webpack_require__(/*! ../game */ "./src/game.ts");
const utils_1 = __webpack_require__(/*! ../utility/utils */ "./src/utility/utils.ts");
const random_1 = __webpack_require__(/*! ../utility/random */ "./src/utility/random.ts");
class LevelImageGenerator {
    constructor(width = 100, height = 100) {
        this.rooms = [];
        this.settled = false;
        this.width = width;
        this.height = height;
        this.canvas = document.createElement("canvas");
        this.canvas.width = width;
        this.canvas.height = height;
        this.ctx = this.canvas.getContext("2d");
        // Disable image smoothing for pixel-perfect rendering
        this.ctx.imageSmoothingEnabled = false;
        this.ctx.webkitImageSmoothingEnabled = false;
        this.ctx.mozImageSmoothingEnabled = false;
        this.ctx.msImageSmoothingEnabled = false;
    }
    // Generate room size using normal distribution for rectangles
    generateRoomSize() {
        const minSize = 2;
        const maxSize = 25;
        // Use normal distribution for both width and height independently
        // This creates rectangles with varied proportions
        const width = Math.max(minSize, Math.min(maxSize, utils_1.Utils.randomNormalInt(minSize, maxSize, { median: 6 })));
        const height = Math.max(minSize, Math.min(maxSize, utils_1.Utils.randomNormalInt(minSize, maxSize, { median: 6 })));
        return { width, height };
    }
    // Calculate mass based on room size (larger rooms = more mass)
    calculateMass(width, height) {
        return width * height * 0.1;
    }
    // Generate rooms with physics properties
    generateRooms(numRooms, rand = random_1.Random.rand, startingPattern = "center") {
        this.rooms = [];
        this.settled = false;
        for (let i = 0; i < numRooms; i++) {
            const { width, height } = this.generateRoomSize();
            const mass = this.calculateMass(width, height);
            let x, y;
            // Different starting patterns
            switch (startingPattern) {
                case "split":
                    if (i < numRooms / 2) {
                        // Top right
                        x = this.width * 0.6 + rand() * this.width * 0.3;
                        y = this.height * 0.1 + rand() * this.height * 0.3;
                    }
                    else {
                        // Bottom left
                        x = this.width * 0.1 + rand() * this.width * 0.3;
                        y = this.height * 0.6 + rand() * this.height * 0.3;
                    }
                    break;
                case "corners":
                    const corner = Math.floor(rand() * 4);
                    switch (corner) {
                        case 0: // Top left
                            x = this.width * 0.1 + rand() * this.width * 0.2;
                            y = this.height * 0.1 + rand() * this.height * 0.2;
                            break;
                        case 1: // Top right
                            x = this.width * 0.7 + rand() * this.width * 0.2;
                            y = this.height * 0.1 + rand() * this.height * 0.2;
                            break;
                        case 2: // Bottom left
                            x = this.width * 0.1 + rand() * this.width * 0.2;
                            y = this.height * 0.7 + rand() * this.height * 0.2;
                            break;
                        case 3: // Bottom right
                            x = this.width * 0.7 + rand() * this.width * 0.2;
                            y = this.height * 0.7 + rand() * this.height * 0.2;
                            break;
                    }
                    break;
                default: // center
                    x = this.width * 0.3 + rand() * this.width * 0.4;
                    y = this.height * 0.3 + rand() * this.height * 0.4;
            }
            this.rooms.push({
                x,
                y,
                width,
                height,
                vx: 0,
                vy: 0,
                mass,
                id: i,
            });
        }
    }
    // Check if two rooms collide (including 1-pixel border requirement)
    roomsCollide(room1, room2) {
        return !(room1.x + room1.width + 1 <= room2.x ||
            room2.x + room2.width + 1 <= room1.x ||
            room1.y + room1.height + 1 <= room2.y ||
            room2.y + room2.height + 1 <= room1.y);
    }
    // Check if two rooms should be snapped together (very close)
    shouldSnap(room1, room2) {
        const SNAP_DISTANCE = 3; // If closer than this, snap together
        // Check horizontal snapping
        const horizontalGap = Math.min(Math.abs(room1.x + room1.width + 1 - room2.x), Math.abs(room2.x + room2.width + 1 - room1.x));
        // Check vertical snapping
        const verticalGap = Math.min(Math.abs(room1.y + room1.height + 1 - room2.y), Math.abs(room2.y + room2.height + 1 - room1.y));
        const overlapsHorizontally = !(room1.x + room1.width < room2.x || room2.x + room2.width < room1.x);
        const overlapsVertically = !(room1.y + room1.height < room2.y || room2.y + room2.height < room1.y);
        return ((horizontalGap < SNAP_DISTANCE && overlapsVertically) ||
            (verticalGap < SNAP_DISTANCE && overlapsHorizontally));
    }
    // Snap two rooms together with proper 1-pixel border
    snapRooms(room1, room2) {
        const overlapsHorizontally = !(room1.x + room1.width < room2.x || room2.x + room2.width < room1.x);
        const overlapsVertically = !(room1.y + room1.height < room2.y || room2.y + room2.height < room1.y);
        if (overlapsHorizontally) {
            // Snap vertically
            if (room1.y < room2.y) {
                // room1 above room2
                const targetY = room1.y + room1.height + 1;
                room2.y = targetY;
                room2.vy = 0;
                room1.vy = 0;
            }
            else {
                // room2 above room1
                const targetY = room2.y + room2.height + 1;
                room1.y = targetY;
                room1.vy = 0;
                room2.vy = 0;
            }
        }
        else if (overlapsVertically) {
            // Snap horizontally
            if (room1.x < room2.x) {
                // room1 left of room2
                const targetX = room1.x + room1.width + 1;
                room2.x = targetX;
                room2.vx = 0;
                room1.vx = 0;
            }
            else {
                // room2 left of room1
                const targetX = room2.x + room2.width + 1;
                room1.x = targetX;
                room1.vx = 0;
                room2.vx = 0;
            }
        }
    }
    // Apply collision response between two rooms
    resolveCollision(room1, room2) {
        // Calculate overlap
        const overlapX = Math.min(room1.x + room1.width + 1 - room2.x, room2.x + room2.width + 1 - room1.x);
        const overlapY = Math.min(room1.y + room1.height + 1 - room2.y, room2.y + room2.height + 1 - room1.y);
        // Resolve collision by moving along the axis with minimum overlap
        if (overlapX < overlapY) {
            // Horizontal separation
            const direction = room1.x < room2.x ? -1 : 1;
            const totalMass = room1.mass + room2.mass;
            const separation = overlapX / 2;
            room1.x += direction * separation * (room2.mass / totalMass);
            room2.x -= direction * separation * (room1.mass / totalMass);
            // Add some velocity for natural movement
            room1.vx += direction * 0.1 * (room2.mass / totalMass);
            room2.vx -= direction * 0.1 * (room1.mass / totalMass);
        }
        else {
            // Vertical separation
            const direction = room1.y < room2.y ? -1 : 1;
            const totalMass = room1.mass + room2.mass;
            const separation = overlapY / 2;
            room1.y += direction * separation * (room2.mass / totalMass);
            room2.y -= direction * separation * (room1.mass / totalMass);
            // Add some velocity for natural movement
            room1.vy += direction * 0.1 * (room2.mass / totalMass);
            room2.vy -= direction * 0.1 * (room1.mass / totalMass);
        }
    }
    // Run physics simulation
    simulatePhysics(iterations = 1000) {
        const damping = 0.95;
        const minVelocity = 0.01;
        for (let iter = 0; iter < iterations; iter++) {
            let hasMovement = false;
            // Apply forces and resolve collisions
            for (let i = 0; i < this.rooms.length; i++) {
                for (let j = i + 1; j < this.rooms.length; j++) {
                    if (this.roomsCollide(this.rooms[i], this.rooms[j])) {
                        this.resolveCollision(this.rooms[i], this.rooms[j]);
                        hasMovement = true;
                    }
                }
            }
            // Apply snapping every iteration - rooms that are close enough stick together
            for (let i = 0; i < this.rooms.length; i++) {
                for (let j = i + 1; j < this.rooms.length; j++) {
                    if (this.shouldSnap(this.rooms[i], this.rooms[j])) {
                        this.snapRooms(this.rooms[i], this.rooms[j]);
                    }
                }
            }
            // Update positions and apply damping
            for (const room of this.rooms) {
                room.x += room.vx;
                room.y += room.vy;
                room.vx *= damping;
                room.vy *= damping;
                // Keep rooms within bounds
                room.x = Math.max(1, Math.min(this.width - room.width - 1, room.x));
                room.y = Math.max(1, Math.min(this.height - room.height - 1, room.y));
                if (Math.abs(room.vx) > minVelocity ||
                    Math.abs(room.vy) > minVelocity) {
                    hasMovement = true;
                }
            }
            // Check if system has settled
            if (!hasMovement) {
                console.log(`Physics settled after ${iter} iterations`);
                break;
            }
        }
        // Final pass: ensure all positions are integers for pixel-perfect rendering
        for (const room of this.rooms) {
            room.x = Math.round(room.x);
            room.y = Math.round(room.y);
        }
        this.settled = true;
    }
    // Generate PNG image data
    generatePNG() {
        // Clear canvas with transparent background
        this.ctx.clearRect(0, 0, this.width, this.height);
        // Ensure pixel-perfect rendering
        this.ctx.imageSmoothingEnabled = false;
        // Draw white rectangles for rooms
        this.ctx.fillStyle = "white";
        for (const room of this.rooms) {
            this.ctx.fillRect(Math.floor(room.x), Math.floor(room.y), room.width, room.height);
        }
        return this.canvas;
    }
    // Save PNG to organized directory structure
    savePNG(filename) {
        const canvas = this.generatePNG();
        const timestamp = new Date().toISOString().replace(/[:.]/g, "-");
        const finalFilename = filename || `level_${timestamp}.png`;
        // Create organized download
        const link = document.createElement("a");
        link.download = `generated_levels/${finalFilename}`;
        link.href = canvas.toDataURL("image/png");
        // Add to page temporarily and click
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        // Also log the data URL for manual saving if needed
        console.log(`Generated level PNG (${this.width}x${this.height}):`, link.href);
        console.log(`Suggested save path: generated_levels/${finalFilename}`);
    }
    // Draw the level using Game.ctx for debugging/visualization
    draw(offsetX = 0, offsetY = 0, scale = 2) {
        if (!game_1.Game.ctx)
            return;
        game_1.Game.ctx.save();
        // Disable smoothing for pixel-perfect rendering
        game_1.Game.ctx.imageSmoothingEnabled = false;
        game_1.Game.ctx.webkitImageSmoothingEnabled = false;
        game_1.Game.ctx.mozImageSmoothingEnabled = false;
        game_1.Game.ctx.msImageSmoothingEnabled = false;
        // Clear area
        game_1.Game.ctx.fillStyle = "rgba(0, 0, 0, 0.8)";
        game_1.Game.ctx.fillRect(offsetX, offsetY, this.width * scale, this.height * scale);
        // Draw grid for reference
        game_1.Game.ctx.strokeStyle = "rgba(100, 100, 100, 0.3)";
        game_1.Game.ctx.lineWidth = 1;
        for (let x = 0; x <= this.width; x += 10) {
            game_1.Game.ctx.beginPath();
            game_1.Game.ctx.moveTo(offsetX + x * scale, offsetY);
            game_1.Game.ctx.lineTo(offsetX + x * scale, offsetY + this.height * scale);
            game_1.Game.ctx.stroke();
        }
        for (let y = 0; y <= this.height; y += 10) {
            game_1.Game.ctx.beginPath();
            game_1.Game.ctx.moveTo(offsetX, offsetY + y * scale);
            game_1.Game.ctx.lineTo(offsetX + this.width * scale, offsetY + y * scale);
            game_1.Game.ctx.stroke();
        }
        // Draw rooms with different colors to show rectangles better
        for (const room of this.rooms) {
            // Room fill - use different colors for different aspect ratios
            const aspectRatio = room.width / room.height;
            let hue;
            if (aspectRatio > 1.5) {
                // Wide rectangle - blue tones
                hue = 200 + ((room.id * 30) % 60);
            }
            else if (aspectRatio < 0.67) {
                // Tall rectangle - red tones
                hue = 0 + ((room.id * 30) % 60);
            }
            else {
                // Square-ish - green tones
                hue = 100 + ((room.id * 30) % 60);
            }
            game_1.Game.ctx.fillStyle = `hsl(${hue}, 70%, 60%)`;
            game_1.Game.ctx.fillRect(offsetX + Math.floor(room.x) * scale, offsetY + Math.floor(room.y) * scale, room.width * scale, room.height * scale);
            // Room border
            game_1.Game.ctx.strokeStyle = "white";
            game_1.Game.ctx.lineWidth = 1;
            game_1.Game.ctx.strokeRect(offsetX + Math.floor(room.x) * scale, offsetY + Math.floor(room.y) * scale, room.width * scale, room.height * scale);
            // Room ID and dimensions text
            if (scale >= 2) {
                game_1.Game.ctx.fillStyle = "white";
                game_1.Game.ctx.font = "10px monospace";
                game_1.Game.ctx.textAlign = "center";
                game_1.Game.ctx.fillText(`${room.id}`, offsetX + (room.x + room.width / 2) * scale, offsetY + (room.y + room.height / 2) * scale - 2);
                // Show dimensions for rectangles
                if (scale >= 3) {
                    game_1.Game.ctx.font = "8px monospace";
                    game_1.Game.ctx.fillText(`${room.width}×${room.height}`, offsetX + (room.x + room.width / 2) * scale, offsetY + (room.y + room.height / 2) * scale + 8);
                }
            }
        }
        game_1.Game.ctx.restore();
    }
    // Generate a complete random level
    static generateRandomLevel(width = 80, height = 60, numRooms = 15, rand = random_1.Random.rand, pattern = "center") {
        const generator = new LevelImageGenerator(width, height);
        generator.generateRooms(numRooms, rand, pattern);
        generator.simulatePhysics();
        return generator;
    }
    // Get room data for external use
    getRooms() {
        return [...this.rooms];
    }
    // Check if rooms are accessible (basic connectivity check)
    areRoomsAccessible() {
        if (this.rooms.length === 0)
            return true;
        if (this.rooms.length === 1)
            return true;
        // Simple flood fill to check connectivity
        const visited = new Set();
        const queue = [0]; // Start with first room
        visited.add(0);
        while (queue.length > 0) {
            const currentId = queue.shift();
            const currentRoom = this.rooms[currentId];
            // Check adjacent rooms (exactly 1 pixel apart = touching with 1px border)
            for (let i = 0; i < this.rooms.length; i++) {
                if (visited.has(i))
                    continue;
                const otherRoom = this.rooms[i];
                // Check if rooms are exactly adjacent (1 pixel gap)
                const horizontallyAdjacent = Math.abs(currentRoom.x + currentRoom.width + 1 - otherRoom.x) < 1 ||
                    Math.abs(otherRoom.x + otherRoom.width + 1 - currentRoom.x) < 1;
                const verticallyAdjacent = Math.abs(currentRoom.y + currentRoom.height + 1 - otherRoom.y) < 1 ||
                    Math.abs(otherRoom.y + otherRoom.height + 1 - currentRoom.y) < 1;
                const overlapsHorizontally = !(currentRoom.x + currentRoom.width < otherRoom.x ||
                    otherRoom.x + otherRoom.width < currentRoom.x);
                const overlapsVertically = !(currentRoom.y + currentRoom.height < otherRoom.y ||
                    otherRoom.y + otherRoom.height < currentRoom.y);
                if ((horizontallyAdjacent && overlapsVertically) ||
                    (verticallyAdjacent && overlapsHorizontally)) {
                    visited.add(i);
                    queue.push(i);
                }
            }
        }
        return visited.size === this.rooms.length;
    }
}
exports.LevelImageGenerator = LevelImageGenerator;


/***/ }),

/***/ "./src/level/levelParametersGenerator.ts":
/*!***********************************************!*\
  !*** ./src/level/levelParametersGenerator.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LevelParameterGenerator = exports.enemyClasses = void 0;
const crabEnemy_1 = __webpack_require__(/*! ../entity/enemy/crabEnemy */ "./src/entity/enemy/crabEnemy.ts");
const frogEnemy_1 = __webpack_require__(/*! ../entity/enemy/frogEnemy */ "./src/entity/enemy/frogEnemy.ts");
const zombieEnemy_1 = __webpack_require__(/*! ../entity/enemy/zombieEnemy */ "./src/entity/enemy/zombieEnemy.ts");
const skullEnemy_1 = __webpack_require__(/*! ../entity/enemy/skullEnemy */ "./src/entity/enemy/skullEnemy.ts");
const energyWizard_1 = __webpack_require__(/*! ../entity/enemy/energyWizard */ "./src/entity/enemy/energyWizard.ts");
const chargeEnemy_1 = __webpack_require__(/*! ../entity/enemy/chargeEnemy */ "./src/entity/enemy/chargeEnemy.ts");
const bishopEnemy_1 = __webpack_require__(/*! ../entity/enemy/bishopEnemy */ "./src/entity/enemy/bishopEnemy.ts");
const armoredzombieEnemy_1 = __webpack_require__(/*! ../entity/enemy/armoredzombieEnemy */ "./src/entity/enemy/armoredzombieEnemy.ts");
const bigSkullEnemy_1 = __webpack_require__(/*! ../entity/enemy/bigSkullEnemy */ "./src/entity/enemy/bigSkullEnemy.ts");
const queenEnemy_1 = __webpack_require__(/*! ../entity/enemy/queenEnemy */ "./src/entity/enemy/queenEnemy.ts");
const knightEnemy_1 = __webpack_require__(/*! ../entity/enemy/knightEnemy */ "./src/entity/enemy/knightEnemy.ts");
const bigKnightEnemy_1 = __webpack_require__(/*! ../entity/enemy/bigKnightEnemy */ "./src/entity/enemy/bigKnightEnemy.ts");
const fireWizard_1 = __webpack_require__(/*! ../entity/enemy/fireWizard */ "./src/entity/enemy/fireWizard.ts");
const rookEnemy_1 = __webpack_require__(/*! ../entity/enemy/rookEnemy */ "./src/entity/enemy/rookEnemy.ts");
const armoredSkullEnemy_1 = __webpack_require__(/*! ../entity/enemy/armoredSkullEnemy */ "./src/entity/enemy/armoredSkullEnemy.ts");
const mummyEnemy_1 = __webpack_require__(/*! ../entity/enemy/mummyEnemy */ "./src/entity/enemy/mummyEnemy.ts");
const spiderEnemy_1 = __webpack_require__(/*! ../entity/enemy/spiderEnemy */ "./src/entity/enemy/spiderEnemy.ts");
exports.enemyClasses = {
    1: crabEnemy_1.CrabEnemy,
    2: frogEnemy_1.FrogEnemy,
    3: zombieEnemy_1.ZombieEnemy,
    4: skullEnemy_1.SkullEnemy,
    5: energyWizard_1.EnergyWizardEnemy,
    6: chargeEnemy_1.ChargeEnemy,
    7: rookEnemy_1.RookEnemy,
    8: bishopEnemy_1.BishopEnemy,
    9: armoredzombieEnemy_1.ArmoredzombieEnemy,
    10: bigSkullEnemy_1.BigSkullEnemy,
    11: queenEnemy_1.QueenEnemy,
    12: knightEnemy_1.KnightEnemy,
    13: bigKnightEnemy_1.BigKnightEnemy,
    14: fireWizard_1.FireWizardEnemy,
    15: armoredSkullEnemy_1.ArmoredSkullEnemy,
    16: mummyEnemy_1.MummyEnemy,
    17: spiderEnemy_1.SpiderEnemy,
};
class LevelParameterGenerator {
    /**
     * Generates level parameters based on the current depth.
     * @param depth The current depth level.
     * @returns An object conforming to the LevelParameters interface.
     */
    static getParameters(depth) {
        return {
            minRoomCount: depth > 0 ? 0 : 0,
            maxRoomCount: depth > 0 ? 12 : 6,
            maxRoomArea: depth > 0 ? 120 + 10 * depth : 40,
            mapWidth: 25 + 5 * depth,
            mapHeight: 25 + 5 * depth,
            splitProbabilities: [0.75, 1.0, 0.25],
            wallRemoveProbability: depth > 0 ? 0.1 : 1,
            numLoopDoorsRange: [4, 8],
            numberOfRooms: depth > 0 ? 5 : 3,
            softMaxRoomArea: depth > 0 ? 0.5 * (120 + 10 * depth) : 40,
        };
    }
}
exports.LevelParameterGenerator = LevelParameterGenerator;


/***/ }),

/***/ "./src/level/levelValidator.ts":
/*!*************************************!*\
  !*** ./src/level/levelValidator.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LevelValidator = exports.ValidationErrorType = void 0;
const room_1 = __webpack_require__(/*! ../room/room */ "./src/room/room.ts");
var ValidationErrorType;
(function (ValidationErrorType) {
    ValidationErrorType["INSUFFICIENT_ROOMS"] = "INSUFFICIENT_ROOMS";
    ValidationErrorType["BOSS_ROOM_MISSING"] = "BOSS_ROOM_MISSING";
    ValidationErrorType["BOSS_TOO_CLOSE"] = "BOSS_TOO_CLOSE";
    ValidationErrorType["OVERLAPPING_PARTITIONS"] = "OVERLAPPING_PARTITIONS";
    ValidationErrorType["EMPTY_PARTITIONS"] = "EMPTY_PARTITIONS";
    ValidationErrorType["STAIR_ROOM_MISSING"] = "STAIR_ROOM_MISSING";
    ValidationErrorType["INSUFFICIENT_CAVE_ROOMS"] = "INSUFFICIENT_CAVE_ROOMS";
})(ValidationErrorType = exports.ValidationErrorType || (exports.ValidationErrorType = {}));
class LevelValidator {
    constructor(game, enableDebugMessages = false) {
        this.game = game;
        this.enableDebugMessages =
            enableDebugMessages || document.cookie.includes("showgeneration=true");
    }
    /**
     * Validates dungeon partitions against the provided parameters
     */
    validateDungeonPartitions(partitions, params) {
        // Check for empty partitions
        const emptyCheck = this.validateNotEmpty(partitions);
        if (!emptyCheck.isValid)
            return emptyCheck;
        // Check minimum room count
        const roomCountCheck = this.validateMinimumRoomCount(partitions, params.minRoomCount);
        if (!roomCountCheck.isValid)
            return roomCountCheck;
        // Check boss room existence
        const bossExistenceCheck = this.validateBossRoomExists(partitions);
        if (!bossExistenceCheck.isValid)
            return bossExistenceCheck;
        // Check boss room distance
        const bossDistanceCheck = this.validateBossRoomDistance(partitions, 3);
        if (!bossDistanceCheck.isValid)
            return bossDistanceCheck;
        // Check for overlapping partitions
        const overlapCheck = this.validateNoOverlaps(partitions);
        if (!overlapCheck.isValid)
            return overlapCheck;
        // Check for stair room (required for dungeon completion)
        const stairCheck = this.validateStairRoomExists(partitions);
        if (!stairCheck.isValid)
            return stairCheck;
        return { isValid: true };
    }
    /**
     * Validates cave partitions
     */
    validateCavePartitions(partitions, requiredRoomCount) {
        // Check for empty partitions
        const emptyCheck = this.validateNotEmpty(partitions);
        if (!emptyCheck.isValid)
            return emptyCheck;
        // Check minimum room count for caves
        const roomCountCheck = this.validateMinimumRoomCount(partitions, requiredRoomCount);
        if (!roomCountCheck.isValid) {
            return {
                isValid: false,
                errorMessage: `Cave needs at least ${requiredRoomCount} rooms, got ${partitions.length}`,
                errorType: ValidationErrorType.INSUFFICIENT_CAVE_ROOMS,
            };
        }
        // Check for overlapping partitions
        const overlapCheck = this.validateNoOverlaps(partitions);
        if (!overlapCheck.isValid)
            return overlapCheck;
        // Validate that we have a rope cave starting room
        const ropeCaveCheck = this.validateRopeCaveExists(partitions);
        if (!ropeCaveCheck.isValid)
            return ropeCaveCheck;
        return { isValid: true };
    }
    /**
     * Validates tutorial partitions
     */
    validateTutorialPartitions(partitions) {
        // Check for empty partitions
        const emptyCheck = this.validateNotEmpty(partitions);
        if (!emptyCheck.isValid)
            return emptyCheck;
        // Tutorial should have exactly 1 room
        if (partitions.length !== 1) {
            return {
                isValid: false,
                errorMessage: `Tutorial should have exactly 1 room, got ${partitions.length}`,
                errorType: ValidationErrorType.INSUFFICIENT_ROOMS,
            };
        }
        // Check that the room is marked as tutorial
        const tutorialRoom = partitions[0];
        if (tutorialRoom.type !== room_1.RoomType.TUTORIAL) {
            return {
                isValid: false,
                errorMessage: "Tutorial room is not marked with TUTORIAL type",
                errorType: ValidationErrorType.INSUFFICIENT_ROOMS,
            };
        }
        return { isValid: true };
    }
    /**
     * Validates that partitions array is not empty
     */
    validateNotEmpty(partitions) {
        if (!partitions || partitions.length === 0) {
            const errorMessage = "No partitions generated";
            this.logValidationError(errorMessage);
            return {
                isValid: false,
                errorMessage,
                errorType: ValidationErrorType.EMPTY_PARTITIONS,
            };
        }
        return { isValid: true };
    }
    /**
     * Validates minimum room count requirement
     */
    validateMinimumRoomCount(partitions, minRoomCount) {
        if (partitions.length < minRoomCount) {
            const errorMessage = `Not enough rooms: need ${minRoomCount}, got ${partitions.length}`;
            this.logValidationError(errorMessage);
            return {
                isValid: false,
                errorMessage,
                errorType: ValidationErrorType.INSUFFICIENT_ROOMS,
            };
        }
        return { isValid: true };
    }
    /**
     * Validates that a boss room exists
     */
    validateBossRoomExists(partitions) {
        const hasBossRoom = partitions.some((p) => p.type === room_1.RoomType.BOSS);
        if (!hasBossRoom) {
            const errorMessage = "Boss room unreachable or missing";
            this.logValidationError(errorMessage);
            return {
                isValid: false,
                errorMessage,
                errorType: ValidationErrorType.BOSS_ROOM_MISSING,
            };
        }
        return { isValid: true };
    }
    /**
     * Validates that boss room is at minimum distance from spawn
     */
    validateBossRoomDistance(partitions, minDistance) {
        const bossRoom = partitions.find((p) => p.type === room_1.RoomType.BOSS);
        if (!bossRoom) {
            return this.validateBossRoomExists(partitions); // This will return the appropriate error
        }
        if (bossRoom.distance < minDistance) {
            const errorMessage = `Boss room too close to spawn: distance ${bossRoom.distance}, minimum ${minDistance}`;
            this.logValidationError(errorMessage);
            return {
                isValid: false,
                errorMessage,
                errorType: ValidationErrorType.BOSS_TOO_CLOSE,
            };
        }
        return { isValid: true };
    }
    /**
     * Validates that partitions don't overlap
     */
    validateNoOverlaps(partitions) {
        for (let i = 0; i < partitions.length; i++) {
            for (let j = i + 1; j < partitions.length; j++) {
                const a = partitions[i];
                const b = partitions[j];
                if (a.x < b.x + b.w &&
                    a.x + a.w > b.x &&
                    a.y < b.y + b.h &&
                    a.y + a.h > b.y) {
                    const errorMessage = `Overlapping partitions detected: partition ${i} overlaps with partition ${j}`;
                    this.logValidationError(errorMessage);
                    return {
                        isValid: false,
                        errorMessage,
                        errorType: ValidationErrorType.OVERLAPPING_PARTITIONS,
                    };
                }
            }
        }
        return { isValid: true };
    }
    /**
     * Validates that a stair room exists for dungeon completion
     */
    validateStairRoomExists(partitions) {
        const hasStairRoom = partitions.some((p) => p.type === room_1.RoomType.DOWNLADDER);
        if (!hasStairRoom) {
            const errorMessage = "Stair room missing - dungeon cannot be completed";
            this.logValidationError(errorMessage);
            return {
                isValid: false,
                errorMessage,
                errorType: ValidationErrorType.STAIR_ROOM_MISSING,
            };
        }
        return { isValid: true };
    }
    /**
     * Validates that a rope cave starting room exists
     */
    validateRopeCaveExists(partitions) {
        const hasRopeCave = partitions.some((p) => p.type === room_1.RoomType.ROPECAVE);
        if (!hasRopeCave) {
            const errorMessage = "Rope cave starting room missing";
            this.logValidationError(errorMessage);
            return {
                isValid: false,
                errorMessage,
                errorType: ValidationErrorType.INSUFFICIENT_CAVE_ROOMS,
            };
        }
        return { isValid: true };
    }
    /**
     * Validates room connectivity by checking that all rooms have connections
     */
    validateConnectivity(partitions) {
        const unconnectedRooms = partitions.filter((partition) => partition.connections.length === 0);
        if (unconnectedRooms.length > 0) {
            const errorMessage = `Found ${unconnectedRooms.length} unconnected rooms`;
            this.logValidationError(errorMessage);
            return {
                isValid: false,
                errorMessage,
                errorType: ValidationErrorType.INSUFFICIENT_ROOMS,
            };
        }
        return { isValid: true };
    }
    /**
     * Validates that required room types are present
     */
    validateRequiredRoomTypes(partitions, requiredTypes) {
        const presentTypes = new Set(partitions.map((p) => p.type));
        const missingTypes = requiredTypes.filter((type) => !presentTypes.has(type));
        if (missingTypes.length > 0) {
            const errorMessage = `Missing required room types: ${missingTypes.join(", ")}`;
            this.logValidationError(errorMessage);
            return {
                isValid: false,
                errorMessage,
                errorType: ValidationErrorType.INSUFFICIENT_ROOMS,
            };
        }
        return { isValid: true };
    }
    /**
     * Comprehensive validation for partition quality
     */
    validatePartitionQuality(partitions) {
        // Check for degenerate partitions (too small)
        const minSize = 4;
        const tooSmallPartitions = partitions.filter((p) => p.w < minSize || p.h < minSize);
        if (tooSmallPartitions.length > 0) {
            const errorMessage = `Found ${tooSmallPartitions.length} partitions smaller than minimum size ${minSize}`;
            this.logValidationError(errorMessage);
            return {
                isValid: false,
                errorMessage,
                errorType: ValidationErrorType.INSUFFICIENT_ROOMS,
            };
        }
        // Check for partitions with negative dimensions
        const invalidPartitions = partitions.filter((p) => p.w <= 0 || p.h <= 0 || p.x < 0 || p.y < 0);
        if (invalidPartitions.length > 0) {
            const errorMessage = `Found ${invalidPartitions.length} partitions with invalid dimensions`;
            this.logValidationError(errorMessage);
            return {
                isValid: false,
                errorMessage,
                errorType: ValidationErrorType.INSUFFICIENT_ROOMS,
            };
        }
        return { isValid: true };
    }
    /**
     * Logs validation errors if debug messages are enabled
     */
    logValidationError(message) {
        if (this.enableDebugMessages) {
            console.warn(`[LevelValidator] ${message}`);
            if (this.game && this.game.pushMessage) {
                this.game.pushMessage(message);
            }
        }
    }
    /**
     * Validates and provides detailed reporting for debugging
     */
    validateWithDetailedReport(partitions, params, type = "dungeon") {
        const details = [];
        details.push(`Validating ${type} with ${partitions.length} partitions`);
        if (type === "dungeon") {
            details.push(`Required minimum rooms: ${params.minRoomCount}`);
            details.push(`Required maximum rooms: ${params.maxRoomCount}`);
        }
        const result = type === "dungeon"
            ? this.validateDungeonPartitions(partitions, params)
            : type === "cave"
                ? this.validateCavePartitions(partitions, 8)
                : this.validateTutorialPartitions(partitions);
        if (!result.isValid) {
            details.push(`Validation failed: ${result.errorMessage}`);
        }
        else {
            details.push("Validation passed");
        }
        return {
            ...result,
            details,
        };
    }
}
exports.LevelValidator = LevelValidator;


/***/ }),

/***/ "./src/level/partitionGenerator.ts":
/*!*****************************************!*\
  !*** ./src/level/partitionGenerator.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PartitionGenerator = exports.PartialLevel = exports.Partition = exports.PartitionConnection = exports.PathType = void 0;
const game_1 = __webpack_require__(/*! ../game */ "./src/game.ts");
const room_1 = __webpack_require__(/*! ../room/room */ "./src/room/room.ts");
const random_1 = __webpack_require__(/*! ../utility/random */ "./src/utility/random.ts");
const levelValidator_1 = __webpack_require__(/*! ./levelValidator */ "./src/level/levelValidator.ts");
const generationVisualizer_1 = __webpack_require__(/*! ./generationVisualizer */ "./src/level/generationVisualizer.ts");
var PathType;
(function (PathType) {
    PathType[PathType["MAIN_PATH"] = 0] = "MAIN_PATH";
    PathType[PathType["SIDE_PATH"] = 1] = "SIDE_PATH";
    PathType[PathType["TUTORIAL"] = 2] = "TUTORIAL";
})(PathType = exports.PathType || (exports.PathType = {}));
class PartitionConnection {
    constructor(x, y, other) {
        this.x = x;
        this.y = y;
        this.other = other;
    }
}
exports.PartitionConnection = PartitionConnection;
class Partition {
    constructor(x, y, w, h, fillStyle) {
        this.split = async () => {
            // Remove the setTimeout - animation is now handled by visualizer
            // The visualizer will handle the delay through createAnimationDelay('partition')
            // Reset open walls when a partition is split
            this.isTopOpen = true;
            this.isRightOpen = true;
            this.isBottomOpen = true;
            this.isLeftOpen = true;
            // This function generates a random number around the center (0.5) within a certain width (0.6).
            let rand_mid = () => {
                let center = 0.5;
                let width = 0.6;
                return (random_1.Random.rand() - 0.5) * width + center;
            };
            let MIN_SIZE = 4;
            if (this.w > this.h) {
                let w1 = Math.floor(rand_mid() * this.w);
                let w2 = this.w - w1 - 1;
                if (w1 < MIN_SIZE || w2 < MIN_SIZE)
                    return [this];
                return [
                    new Partition(this.x, this.y, w1, this.h, this.fillStyle),
                    new Partition(this.x + w1 + 1, this.y, w2, this.h, this.fillStyle),
                ];
            }
            else {
                let h1 = Math.floor(rand_mid() * this.h);
                let h2 = this.h - h1 - 1;
                if (h1 < MIN_SIZE || h2 < MIN_SIZE)
                    return [this];
                return [
                    new Partition(this.x, this.y, this.w, h1, this.fillStyle),
                    new Partition(this.x, this.y + h1 + 1, this.w, h2, this.fillStyle),
                ];
            }
        };
        this.point_in = (x, y) => {
            return (x >= this.x && x < this.x + this.w && y >= this.y && y < this.y + this.h);
        };
        this.point_next_to = (x, y) => {
            return ((x >= this.x - 1 &&
                x < this.x + this.w + 1 &&
                y >= this.y &&
                y < this.y + this.h) ||
                (x >= this.x &&
                    x < this.x + this.w &&
                    y >= this.y - 1 &&
                    y < this.y + this.h + 1));
        };
        this.area = () => {
            return this.w * this.h;
        };
        this.overlaps = (other) => {
            return (other.x < this.x + this.w + 1 &&
                other.x + other.w > this.x - 1 &&
                other.y < this.y + this.h + 1 &&
                other.y + other.h > this.y - 1);
        };
        this.setOpenWall = (connection) => {
            if (connection.y === this.y - 1 &&
                connection.x >= this.x &&
                connection.x < this.x + this.w) {
                this.isTopOpen = false;
            }
            if (connection.y === this.y + this.h &&
                connection.x >= this.x &&
                connection.x < this.x + this.w) {
                this.isBottomOpen = false;
            }
            if (connection.x === this.x + this.w &&
                connection.y >= this.y &&
                connection.y < this.y + this.h) {
                this.isRightOpen = false;
            }
            if (connection.x === this.x - 1 &&
                connection.y >= this.y &&
                connection.y < this.y + this.h) {
                this.isLeftOpen = false;
            }
        };
        this.get_branch_point = () => {
            let points = [];
            for (let x = this.x; x < this.x + this.w; x++) {
                points.push({ x: x, y: this.y - 1 });
                points.push({ x: x, y: this.y + this.h });
            }
            for (let y = this.y; y < this.y + this.h; y++) {
                points.push({ x: this.x - 1, y: y });
                points.push({ x: this.x + this.w, y: y });
            }
            points = points.filter((p) => !this.connections.some((c) => Math.abs(c.x - p.x) + Math.abs(c.y - p.y) <= 1));
            points.sort(() => 0.5 - random_1.Random.rand());
            return points[0];
        };
        this.x = x;
        this.y = y;
        this.w = w;
        this.h = h;
        this.fillStyle = fillStyle;
        this.type = room_1.RoomType.DUNGEON;
        this.connections = [];
        this.distance = 1000;
        this.isTopOpen = true;
        this.isRightOpen = true;
        this.isBottomOpen = true;
        this.isLeftOpen = true;
        this.pathIndex = 0;
    }
}
exports.Partition = Partition;
class PartialLevel {
    constructor() {
        this.partitions = [];
    }
}
exports.PartialLevel = PartialLevel;
class PartitionGenerator {
    constructor(game) {
        this.validator = new levelValidator_1.LevelValidator(game);
        this.visualizer = new generationVisualizer_1.GenerationVisualizer(game);
    }
    async generateDungeonPartitions(game, mapWidth, mapHeight, depth, params) {
        const partialLevel = new PartialLevel();
        let validationResult;
        let attempts = 0;
        this.visualizer.updateProgress("Starting dungeon generation", 0);
        do {
            attempts++;
            this.visualizer.updateProgress(`Generating candidate ${attempts}`, attempts * 0.1);
            await this.generateDungeonCandidate(game, partialLevel, mapWidth, mapHeight, depth, params);
            validationResult = this.validator.validateDungeonPartitions(partialLevel.partitions, params);
            // Update visualization state
            this.visualizer.setVisualizationState(partialLevel.partitions, mapWidth / 2, mapHeight / 2, "validating", 0.8);
            // If validation fails, the loop will continue and regenerate
        } while (!validationResult.isValid);
        this.visualizer.updateProgress("Finalizing generation", 0.9);
        await this.visualizer.createAnimationDelay("large");
        this.visualizer.createVisualEffect("generation_complete");
        this.visualizer.updateProgress("Generation complete", 1.0);
        console.log("finished generation");
        return partialLevel.partitions;
    }
    async generateCavePartitions(mapWidth, mapHeight) {
        const partialLevel = new PartialLevel();
        const numberOfRooms = 8;
        let validationResult;
        let attempts = 0;
        this.visualizer.updateProgress("Starting cave generation", 0);
        do {
            attempts++;
            this.visualizer.updateProgress(`Generating cave candidate ${attempts}`, attempts * 0.1);
            await this.generateCaveCandidate(partialLevel, mapWidth, mapHeight, numberOfRooms);
            validationResult = this.validator.validateCavePartitions(partialLevel.partitions, numberOfRooms);
            // Update visualization state
            this.visualizer.setVisualizationState(partialLevel.partitions, mapWidth / 2, mapHeight / 2, "validating cave", 0.8);
            // If validation fails, the loop will continue and regenerate
        } while (!validationResult.isValid);
        this.visualizer.updateProgress("Cave generation complete", 1.0);
        return partialLevel.partitions;
    }
    generateTutorialPartitions(height = 7, width = 7) {
        const partitions = [new Partition(0, 0, height, width, "white")];
        partitions[0].type = room_1.RoomType.TUTORIAL;
        // Validate tutorial partitions
        const validationResult = this.validator.validateTutorialPartitions(partitions);
        if (!validationResult.isValid) {
            throw new Error(`Tutorial validation failed: ${validationResult.errorMessage}`);
        }
        return partitions;
    }
    async generateDungeonCandidate(game, partialLevel, map_w, map_h, depth, params) {
        const { minRoomCount, maxRoomCount, maxRoomArea, splitProbabilities, wallRemoveProbability, softMaxRoomArea, } = params;
        partialLevel.partitions = [new Partition(0, 0, map_w, map_h, "white")];
        this.visualizer.updateProgress("Splitting partitions", 0.1);
        this.visualizer.setVisualizationState(partialLevel.partitions, map_w / 2, map_h / 2, "splitting");
        // Use splitProbabilities for splitting
        while (partialLevel.partitions.length < params.maxRoomCount) {
            for (let i = 0; i < splitProbabilities.length; i++) {
                partialLevel.partitions = await this.splitPartitions(partialLevel.partitions, splitProbabilities[i]);
                // Update visualization after each split
                this.visualizer.setVisualizationState(partialLevel.partitions, map_w / 2, map_h / 2, "splitting", 0.1 + (i / splitProbabilities.length) * 0.2);
            }
        }
        for (let i = 0; i < 100; i++) {
            partialLevel.partitions.forEach(async (partition) => {
                let roomArea = random_1.Random.rand() > 0.95 ? softMaxRoomArea : maxRoomArea;
                if (partition.area() > roomArea) {
                    partialLevel.partitions = partialLevel.partitions.filter((p) => p !== partition);
                    partialLevel.partitions = partialLevel.partitions.concat(await this.splitPartition(partition, 0.5));
                }
            });
        }
        this.visualizer.updateProgress("Removing wall rooms", 0.4);
        partialLevel.partitions = this.removeWallRooms(partialLevel.partitions, map_w, map_h, wallRemoveProbability);
        await this.visualizer.createAnimationDelay("large");
        if (partialLevel.partitions.length === 0) {
            partialLevel.partitions = [];
            return;
        }
        this.visualizer.updateProgress("Assigning room types", 0.5);
        // Sort and assign room types
        partialLevel.partitions.sort((a, b) => a.area() - b.area());
        this.visualizer.updatePartitionStyles(partialLevel.partitions);
        if (partialLevel.partitions.length === 0) {
            partialLevel.partitions = [];
            return;
        }
        let spawn = partialLevel.partitions[0];
        if (!spawn) {
            partialLevel.partitions = [];
            return;
        }
        spawn.type = room_1.RoomType.START;
        spawn.fillStyle = "rgb(0, 255, 0)";
        if (partialLevel.partitions.length > 1) {
            partialLevel.partitions[partialLevel.partitions.length - 1].type =
                room_1.RoomType.BOSS;
            partialLevel.partitions[partialLevel.partitions.length - 1].fillStyle =
                "red";
        }
        this.visualizer.updateProgress("Connecting partitions", 0.6);
        await this.connectPartitions(partialLevel, spawn);
        this.visualizer.updateProgress("Adding loop connections", 0.7);
        if (partialLevel.partitions.length > 0) {
            await this.addLoopConnections(partialLevel);
        }
        this.visualizer.updateProgress("Adding stair room", 0.8);
        if (partialLevel.partitions.length > 0) {
            await this.addStairRoom(partialLevel, game);
        }
        this.visualizer.updateProgress("Calculating distances", 0.9);
        if (partialLevel.partitions.length > 0) {
            await this.calculateDistances(partialLevel, spawn);
            await this.addSpecialRooms(partialLevel);
        }
    }
    async generateCaveCandidate(partialLevel, map_w, map_h, num_rooms) {
        const CAVE_OFFSET = 100;
        partialLevel.partitions = [
            new Partition(CAVE_OFFSET, CAVE_OFFSET, map_w, map_h, "white"),
        ];
        for (let i = 0; i < 9; i++) {
            partialLevel.partitions = await this.splitPartitions(partialLevel.partitions, 0.75);
        }
        partialLevel.partitions.sort((a, b) => a.area() - b.area());
        if (partialLevel.partitions.length === 0) {
            throw new Error("No partitions generated.");
        }
        let spawn = partialLevel.partitions[0];
        spawn.type = room_1.RoomType.ROPECAVE;
        for (let i = 1; i < partialLevel.partitions.length; i++) {
            partialLevel.partitions[i].type = room_1.RoomType.CAVE;
        }
        await this.connectCavePartitions(partialLevel, spawn, num_rooms);
        await this.addCaveLoops(partialLevel);
        await this.calculateDistances(partialLevel, spawn);
    }
    async splitPartitions(partitions, prob) {
        for (let partition of partitions) {
            if (random_1.Random.rand() < prob) {
                this.visualizer.createVisualEffect("partition_split", partition);
                partitions = partitions.filter((p) => p !== partition);
                partitions = partitions.concat(await partition.split());
            }
        }
        return partitions;
    }
    async splitPartition(partition, prob) {
        if (random_1.Random.rand() < prob) {
            return await partition.split();
        }
        else {
            return [partition];
        }
    }
    getWallRooms(partitions, mapWidth, mapHeight) {
        return partitions.filter((partition) => {
            const isPathClear = (direction) => {
                switch (direction) {
                    case "left":
                        for (let y = partition.y; y < partition.y + partition.h; y++) {
                            let blocked = partitions.some((other) => {
                                if (other === partition)
                                    return false;
                                return (other.y <= y &&
                                    y < other.y + other.h &&
                                    other.x + other.w > 0 &&
                                    other.x + other.w <= partition.x);
                            });
                            if (!blocked)
                                return true;
                        }
                        return false;
                    case "right":
                        for (let y = partition.y; y < partition.y + partition.h; y++) {
                            let blocked = partitions.some((other) => {
                                if (other === partition)
                                    return false;
                                return (other.y <= y &&
                                    y < other.y + other.h &&
                                    other.x < mapWidth &&
                                    other.x >= partition.x + partition.w);
                            });
                            if (!blocked)
                                return true;
                        }
                        return false;
                    case "top":
                        for (let x = partition.x; x < partition.x + partition.w; x++) {
                            let blocked = partitions.some((other) => {
                                if (other === partition)
                                    return false;
                                return (other.x <= x &&
                                    x < other.x + other.w &&
                                    other.y + other.h > 0 &&
                                    other.y + other.h <= partition.y);
                            });
                            if (!blocked)
                                return true;
                        }
                        return false;
                    case "bottom":
                        for (let x = partition.x; x < partition.x + partition.w; x++) {
                            let blocked = partitions.some((other) => {
                                if (other === partition)
                                    return false;
                                return (other.x <= x &&
                                    x < other.x + other.w &&
                                    other.y < mapHeight &&
                                    other.y >= partition.y + partition.h);
                            });
                            if (!blocked)
                                return true;
                        }
                        return false;
                    default:
                        return false;
                }
            };
            const openPaths = [
                isPathClear("left"),
                isPathClear("right"),
                isPathClear("top"),
                isPathClear("bottom"),
            ].filter(Boolean).length;
            return openPaths === 1;
        });
    }
    removeWallRooms(partitions, w, h, prob = 1.0) {
        const wallRooms = this.getWallRooms(partitions, w, h);
        for (const wallRoom of wallRooms) {
            if (random_1.Random.rand() < prob) {
                partitions = partitions.filter((p) => p !== wallRoom);
            }
        }
        return partitions;
    }
    async connectPartitions(partialLevel, spawn) {
        let connected = [spawn];
        let frontier = [spawn];
        let found_boss = false;
        while (frontier.length > 0 && !found_boss) {
            let room = frontier[0];
            if (room !== spawn) {
                this.visualizer.createVisualEffect("room_connected", room);
            }
            frontier.splice(0, 1);
            let doors_found = 0;
            const num_doors = Math.floor(random_1.Random.rand() * 2 + 1);
            let tries = 0;
            const max_tries = 1000;
            while (doors_found < num_doors && tries < max_tries) {
                let point = room.get_branch_point();
                for (const p of partialLevel.partitions) {
                    if (p !== room &&
                        connected.indexOf(p) === -1 &&
                        p.point_next_to(point.x, point.y)) {
                        room.connections.push(new PartitionConnection(point.x, point.y, p));
                        p.connections.push(new PartitionConnection(point.x, point.y, room));
                        room.setOpenWall(new PartitionConnection(point.x, point.y, p));
                        p.setOpenWall(new PartitionConnection(point.x, point.y, room));
                        frontier.push(p);
                        connected.push(p);
                        doors_found++;
                        if (p.type === room_1.RoomType.BOSS) {
                            found_boss = true;
                            this.visualizer.createVisualEffect("boss_found", p);
                        }
                        break;
                    }
                }
                tries++;
            }
            await this.visualizer.createAnimationDelay("pathfinding");
        }
        // Remove unconnected rooms
        for (const partition of partialLevel.partitions) {
            if (partition.connections.length === 0) {
                partialLevel.partitions = partialLevel.partitions.filter((p) => p !== partition);
            }
        }
    }
    async connectCavePartitions(partialLevel, spawn, num_rooms) {
        let connected = [spawn];
        let frontier = [spawn];
        while (frontier.length > 0 && connected.length < num_rooms) {
            let room = frontier[0];
            frontier.splice(0, 1);
            let doors_found = 0;
            const num_doors = Math.floor(random_1.Random.rand() * 2 + 1);
            let tries = 0;
            const max_tries = 1000;
            while (doors_found < num_doors &&
                tries < max_tries &&
                connected.length < num_rooms) {
                let point = room.get_branch_point();
                if (!point)
                    break;
                for (const p of partialLevel.partitions) {
                    if (p !== room &&
                        connected.indexOf(p) === -1 &&
                        p.point_next_to(point.x, point.y)) {
                        room.connections.push(new PartitionConnection(point.x, point.y, p));
                        p.connections.push(new PartitionConnection(point.x, point.y, room));
                        frontier.push(p);
                        connected.push(p);
                        doors_found++;
                        break;
                    }
                }
                tries++;
            }
        }
        // Remove unconnected rooms
        partialLevel.partitions = partialLevel.partitions.filter((partition) => partition.connections.length > 0);
        if (partialLevel.partitions.length === 0) {
            throw new Error("No valid rooms after filtering.");
        }
    }
    async addLoopConnections(partialLevel) {
        // Check if we have any partitions to work with
        if (partialLevel.partitions.length === 0) {
            return;
        }
        let num_loop_doors = Math.floor(random_1.Random.rand() * 4 + 4);
        for (let i = 0; i < num_loop_doors; i++) {
            // Double-check array length in case partitions were removed during iteration
            if (partialLevel.partitions.length === 0) {
                break;
            }
            let roomIndex = Math.floor(random_1.Random.rand() * partialLevel.partitions.length);
            let room = partialLevel.partitions[roomIndex];
            // Safety check to ensure room exists
            if (!room) {
                continue;
            }
            let found_door = false;
            let tries = 0;
            const max_tries = 10;
            let not_already_connected = partialLevel.partitions.filter((p) => p && !room.connections.some((c) => c.other === p));
            while (!found_door && tries < max_tries) {
                let point = room.get_branch_point();
                if (!point) {
                    break; // Skip if no valid branch point found
                }
                for (const p of not_already_connected) {
                    if (p && p !== room && p.point_next_to(point.x, point.y)) {
                        room.connections.push(new PartitionConnection(point.x, point.y, p));
                        p.connections.push(new PartitionConnection(point.x, point.y, room));
                        room.setOpenWall(new PartitionConnection(point.x, point.y, p));
                        p.setOpenWall(new PartitionConnection(point.x, point.y, room));
                        found_door = true;
                        break;
                    }
                }
                tries++;
            }
        }
    }
    async addCaveLoops(partialLevel) {
        // Check if we have any partitions to work with
        if (partialLevel.partitions.length === 0) {
            return;
        }
        let num_loop_doors = Math.floor(random_1.Random.rand() * 4 + 4);
        for (let i = 0; i < num_loop_doors; i++) {
            // Double-check array length in case partitions were removed during iteration
            if (partialLevel.partitions.length === 0) {
                break;
            }
            let roomIndex = Math.floor(random_1.Random.rand() * partialLevel.partitions.length);
            let room = partialLevel.partitions[roomIndex];
            // Safety check to ensure room exists
            if (!room) {
                continue;
            }
            let found_door = false;
            let tries = 0;
            const max_tries = 100;
            let not_already_connected = partialLevel.partitions.filter((p) => p && !room.connections.some((c) => c.other === p));
            while (!found_door && tries < max_tries) {
                let point = room.get_branch_point();
                if (!point) {
                    break; // Skip if no valid branch point found
                }
                for (const p of not_already_connected) {
                    if (p && p !== room && p.point_next_to(point.x, point.y)) {
                        room.connections.push(new PartitionConnection(point.x, point.y, p));
                        p.connections.push(new PartitionConnection(point.x, point.y, room));
                        found_door = true;
                        break;
                    }
                }
                tries++;
            }
        }
    }
    async addStairRoom(partialLevel, game) {
        if (!partialLevel.partitions.some((p) => p.type === room_1.RoomType.BOSS)) {
            partialLevel.partitions = [];
            return;
        }
        let boss = partialLevel.partitions.find((p) => p.type === room_1.RoomType.BOSS);
        let found_stair = false;
        const max_stair_tries = 5;
        const stairRoomWidth = 5;
        const stairRoomHeight = 5;
        for (let stair_tries = 0; stair_tries < max_stair_tries; stair_tries++) {
            let stair = new Partition(game_1.Game.rand(boss.x - 1, boss.x + boss.w - 2, random_1.Random.rand), boss.y - stairRoomHeight - 1, stairRoomWidth, stairRoomHeight, "white");
            stair.type = room_1.RoomType.DOWNLADDER;
            stair.fillStyle = "blue";
            if (!partialLevel.partitions.some((p) => p.overlaps(stair))) {
                found_stair = true;
                partialLevel.partitions.push(stair);
                stair.connections.push(new PartitionConnection(stair.x + 1, stair.y + stairRoomHeight, boss));
                boss.connections.push(new PartitionConnection(stair.x + 1, stair.y + stairRoomHeight, stair));
                stair.setOpenWall(new PartitionConnection(stair.x + 1, stair.y + stairRoomHeight, boss));
                boss.setOpenWall(new PartitionConnection(stair.x + 1, stair.y + stairRoomHeight, stair));
                break;
            }
        }
        if (!found_stair) {
            console.log("No stair found");
            partialLevel.partitions = [];
        }
    }
    async calculateDistances(partialLevel, spawn) {
        let frontier = [spawn];
        let seen = [];
        spawn.distance = 0;
        while (frontier.length > 0) {
            let room = frontier[0];
            frontier.splice(0, 1);
            seen.push(room);
            for (let c of room.connections) {
                let other = c.other;
                other.distance = Math.min(other.distance, room.distance + 1);
                if (seen.indexOf(other) === -1)
                    frontier.push(other);
            }
        }
    }
    async addSpecialRooms(partialLevel) {
        let added_rope_hole = false;
        for (const p of partialLevel.partitions) {
            if (p.type === room_1.RoomType.DUNGEON) {
                if (p.distance > 4 && p.area() <= 30 && random_1.Random.rand() < 0) {
                    p.type = room_1.RoomType.TREASURE;
                } /*else if (!added_rope_hole) {
                  p.type = RoomType.ROPEHOLE;
                  added_rope_hole = true;
                }*/
            }
        }
        await this.visualizer.createAnimationDelay("large");
    }
    // Add method to get visualizer (for external access)
    getVisualizer() {
        return this.visualizer;
    }
}
exports.PartitionGenerator = PartitionGenerator;


/***/ }),

/***/ "./src/level/pngPartitionGenerator.ts":
/*!********************************************!*\
  !*** ./src/level/pngPartitionGenerator.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PngPartitionGenerator = void 0;
const partitionGenerator_1 = __webpack_require__(/*! ./partitionGenerator */ "./src/level/partitionGenerator.ts");
const room_1 = __webpack_require__(/*! ../room/room */ "./src/room/room.ts");
const random_1 = __webpack_require__(/*! ../utility/random */ "./src/utility/random.ts");
const game_1 = __webpack_require__(/*! ../game */ "./src/game.ts");
// Color-to-RoomType mapping for level designers
const COLOR_TO_ROOM_TYPE = {
    // Core room types
    "rgb(0, 255, 0)": room_1.RoomType.START,
    "rgb(255, 0, 0)": room_1.RoomType.BOSS,
    "rgb(0, 0, 255)": room_1.RoomType.DOWNLADDER,
    "rgb(0, 255, 255)": room_1.RoomType.UPLADDER,
    // Special rooms
    "rgb(255, 255, 0)": room_1.RoomType.TREASURE,
    "rgb(255, 0, 255)": room_1.RoomType.SHOP,
    "rgb(128, 0, 128)": room_1.RoomType.FOUNTAIN,
    "rgb(139, 69, 19)": room_1.RoomType.COFFIN,
    "rgb(255, 165, 0)": room_1.RoomType.KEYROOM,
    // Puzzle and special mechanics
    "rgb(64, 64, 64)": room_1.RoomType.PUZZLE,
    "rgb(0, 0, 0)": room_1.RoomType.CHESSBOARD,
    "rgb(192, 192, 192)": room_1.RoomType.MAZE,
    "rgb(255, 192, 203)": room_1.RoomType.SPAWNER,
    // Environment types
    "rgb(34, 139, 34)": room_1.RoomType.GRASS,
    "rgb(101, 67, 33)": room_1.RoomType.CAVE,
    "rgb(85, 107, 47)": room_1.RoomType.GRAVEYARD,
    "rgb(46, 125, 50)": room_1.RoomType.FOREST,
    // Corridors and connections
    "rgb(160, 160, 160)": room_1.RoomType.CORRIDOR,
    "rgb(255, 87, 34)": room_1.RoomType.SPIKECORRIDOR,
    // Cave system
    "rgb(121, 85, 72)": room_1.RoomType.BIGCAVE,
    "rgb(78, 52, 46)": room_1.RoomType.ROPECAVE,
    "rgb(156, 102, 68)": room_1.RoomType.ROPEHOLE,
    "rgb(141, 110, 99)": room_1.RoomType.ROPEUP,
    // Tutorial and misc
    "rgb(173, 216, 230)": room_1.RoomType.TUTORIAL,
    "rgb(250, 250, 250)": room_1.RoomType.BIGDUNGEON,
    // Default fallback
    "rgb(255, 255, 255)": room_1.RoomType.DUNGEON, // White - Standard dungeon room
};
class PngPartitionGenerator {
    async generatePartitionsFromPng(imageUrl, game, depth, isSidePath = false) {
        console.log("=== PNG PARTITION GENERATION START ===");
        console.log(`Processing image: ${imageUrl}`);
        console.log(`Game depth: ${depth}`);
        console.log(`Is side path: ${isSidePath}`);
        try {
            console.log("Step 1: Loading image data...");
            const imageData = await this.loadImageData(imageUrl);
            console.log(`✓ Image loaded: ${imageData.width}x${imageData.height} pixels`);
            console.log("Step 2: Finding rectangles...");
            const rectangles = this.findRectangles(imageData);
            console.log(`✓ Found ${rectangles.length} rectangles:`, rectangles);
            console.log("Step 3: Creating partitions from rectangles...");
            const rawPartitions = this.createPartitionsFromRectangles(rectangles, isSidePath);
            console.log(`✓ Created ${rawPartitions.length} raw partitions`);
            if (rawPartitions.length === 0) {
                console.error("❌ No partitions created from image!");
                return [];
            }
            console.log("Step 4: Processing partitions for gameplay...");
            const partialLevel = new partitionGenerator_1.PartialLevel();
            partialLevel.partitions = rawPartitions;
            await this.processPartitionsForGameplay(partialLevel, game, isSidePath);
            console.log(`✓ Final processed partitions: ${partialLevel.partitions.length}`);
            console.log("=== PNG PARTITION GENERATION COMPLETE ===");
            return partialLevel.partitions;
        }
        catch (error) {
            console.error("❌ Error in PNG partition generation:", error);
            console.error("Stack trace:", error.stack);
            return [];
        }
    }
    loadImageData(imageUrl) {
        console.log(`  Loading image from: ${imageUrl}`);
        return new Promise((resolve, reject) => {
            const image = new Image();
            image.crossOrigin = "Anonymous";
            image.onload = () => {
                console.log(`  ✓ Image loaded successfully: ${image.width}x${image.height}`);
                try {
                    const canvas = document.createElement("canvas");
                    canvas.width = image.width;
                    canvas.height = image.height;
                    const ctx = canvas.getContext("2d");
                    if (!ctx) {
                        throw new Error("Could not get canvas context");
                    }
                    ctx.drawImage(image, 0, 0);
                    const imageData = ctx.getImageData(0, 0, image.width, image.height);
                    console.log(`  ✓ Image data extracted: ${imageData.data.length} bytes`);
                    resolve(imageData);
                }
                catch (error) {
                    console.error("  ❌ Error processing image:", error);
                    reject(error);
                }
            };
            image.onerror = (err) => {
                console.error(`  ❌ Failed to load image: ${err}`);
                reject(new Error(`Failed to load image at ${imageUrl}: ${err}`));
            };
            image.src = imageUrl;
            console.log("  Image loading initiated...");
        });
    }
    findRectangles(imageData) {
        console.log("  Finding rectangles in image...");
        const { width, height, data } = imageData;
        const visited = new Array(width * height).fill(false);
        const rectangles = [];
        console.log(`  Scanning ${width}x${height} pixels (${data.length} bytes)`);
        let transparentPixels = 0;
        let processedPixels = 0;
        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                const index = y * width + x;
                if (visited[index]) {
                    continue;
                }
                const pixelIndex = index * 4;
                const alpha = data[pixelIndex + 3];
                if (alpha === 0) {
                    transparentPixels++;
                    continue;
                }
                processedPixels++;
                const r = data[pixelIndex];
                const g = data[pixelIndex + 1];
                const b = data[pixelIndex + 2];
                const color = `rgb(${r}, ${g}, ${b})`;
                console.log(`  Processing pixel at (${x}, ${y}): color ${color}, alpha ${alpha}`);
                let rectW = 1;
                while (x + rectW < width &&
                    !visited[y * width + (x + rectW)] &&
                    this.isSameColor(data, pixelIndex, (y * width + x + rectW) * 4)) {
                    rectW++;
                }
                let rectH = 1;
                while (y + rectH < height) {
                    let isRowSolid = true;
                    for (let i = 0; i < rectW; i++) {
                        if (visited[(y + rectH) * width + (x + i)] ||
                            !this.isSameColor(data, pixelIndex, ((y + rectH) * width + x + i) * 4)) {
                            isRowSolid = false;
                            break;
                        }
                    }
                    if (isRowSolid) {
                        rectH++;
                    }
                    else {
                        break;
                    }
                }
                // Mark all pixels in this rectangle as visited
                for (let j = 0; j < rectH; j++) {
                    for (let i = 0; i < rectW; i++) {
                        visited[(y + j) * width + (x + i)] = true;
                    }
                }
                const rectangle = { x, y, w: rectW, h: rectH, color };
                rectangles.push(rectangle);
                console.log(`  ✓ Found rectangle: ${rectW}x${rectH} at (${x}, ${y}) with color ${color}`);
            }
        }
        console.log(`  ✓ Rectangle finding complete:`);
        console.log(`    - Transparent pixels: ${transparentPixels}`);
        console.log(`    - Processed pixels: ${processedPixels}`);
        console.log(`    - Total rectangles found: ${rectangles.length}`);
        return rectangles;
    }
    isSameColor(data, index1, index2) {
        const same = data[index1] === data[index2] &&
            data[index1 + 1] === data[index2 + 1] &&
            data[index1 + 2] === data[index2 + 2] &&
            data[index1 + 3] === data[index2 + 3];
        return same;
    }
    createPartitionsFromRectangles(rectangles, isSidePath) {
        console.log("  Creating partitions from rectangles...");
        console.log(`  Side path mode: ${isSidePath}`);
        if (rectangles.length === 0) {
            console.warn("  ⚠️  No rectangles to create partitions from!");
            return [];
        }
        const partitions = rectangles.map((rect, index) => {
            console.log(`  Processing rectangle ${index + 1}/${rectangles.length}:`);
            console.log(`    Position: (${rect.x}, ${rect.y})`);
            console.log(`    Size: ${rect.w}x${rect.h}`);
            console.log(`    Color: ${rect.color}`);
            const partition = new partitionGenerator_1.Partition(rect.x, rect.y, rect.w, rect.h, rect.color);
            if (isSidePath) {
                // For side paths, use cave-appropriate color mappings
                const caveRoomType = this.getCaveRoomTypeFromColor(rect.color);
                partition.type = caveRoomType;
                console.log(`    ✓ Cave room type assigned: ${caveRoomType}`);
            }
            else {
                // For main paths, use the existing color mapping
                const roomType = COLOR_TO_ROOM_TYPE[rect.color];
                if (roomType) {
                    partition.type = roomType;
                    console.log(`    ✓ Main path room type assigned: ${roomType}`);
                }
                else {
                    partition.type = room_1.RoomType.DUNGEON;
                    console.log(`    ⚠️  Unknown color, defaulted to: ${room_1.RoomType.DUNGEON}`);
                }
            }
            console.log(`    ✓ Partition created with area: ${partition.area()}`);
            return partition;
        });
        console.log(`  ✓ Created ${partitions.length} partitions`);
        return partitions;
    }
    getCaveRoomTypeFromColor(color) {
        // Cave-specific color mappings
        switch (color) {
            case "rgb(0, 255, 0)": // Green - Cave spawn point
                return room_1.RoomType.ROPECAVE;
            case "rgb(0, 255, 255)": // Cyan - Up ladder (exit to main path)
                return room_1.RoomType.UPLADDER;
            case "rgb(255, 255, 0)": // Yellow - Treasure room
                return room_1.RoomType.TREASURE;
            case "rgb(255, 0, 255)": // Magenta - Shop
                return room_1.RoomType.SHOP;
            default:
                return room_1.RoomType.CAVE; // Default cave room
        }
    }
    async processPartitionsForGameplay(partialLevel, game, isSidePath) {
        console.log("  === GAMEPLAY PROCESSING START ===");
        console.log(`  Side path mode: ${isSidePath}`);
        if (partialLevel.partitions.length === 0) {
            console.error("  ❌ No partitions to process!");
            return;
        }
        console.log(`  Processing ${partialLevel.partitions.length} partitions for gameplay`);
        if (isSidePath) {
            await this.processCavePartitions(partialLevel, game);
        }
        else {
            await this.processMainPathPartitions(partialLevel, game);
        }
        console.log("  === GAMEPLAY PROCESSING COMPLETE ===");
    }
    async processCavePartitions(partialLevel, game) {
        console.log("  Processing as CAVE system...");
        // Log all room types found
        const roomTypeCounts = {};
        partialLevel.partitions.forEach((p) => {
            roomTypeCounts[p.type] = (roomTypeCounts[p.type] || 0) + 1;
        });
        console.log("  Cave room type distribution:", roomTypeCounts);
        // Find or assign ROPECAVE room
        let spawn = partialLevel.partitions.find((p) => p.type === room_1.RoomType.ROPECAVE);
        if (!spawn && partialLevel.partitions.length > 0) {
            console.log("  No ROPECAVE room specified, assigning to smallest room...");
            partialLevel.partitions.sort((a, b) => a.area() - b.area());
            spawn = partialLevel.partitions[0];
            spawn.type = room_1.RoomType.ROPECAVE;
            spawn.fillStyle = "rgb(0, 255, 0)";
            console.log(`  ✓ Assigned ROPECAVE to room at (${spawn.x}, ${spawn.y})`);
        }
        // Make sure all other rooms are CAVE type (unless they're special rooms like TREASURE)
        partialLevel.partitions.forEach((p) => {
            if (p !== spawn && p.type === room_1.RoomType.DUNGEON) {
                p.type = room_1.RoomType.CAVE;
                console.log(`  Converted DUNGEON to CAVE at (${p.x}, ${p.y})`);
            }
        });
        console.log("  Updating visual styles...");
        this.updatePartitionVisualStyles(partialLevel.partitions);
        // CRITICAL: Move ROPECAVE room to index 0 for proper spawning
        if (spawn) {
            const startIndex = partialLevel.partitions.indexOf(spawn);
            if (startIndex > 0) {
                console.log(`  Moving ROPECAVE room from index ${startIndex} to index 0`);
                partialLevel.partitions.splice(startIndex, 1);
                partialLevel.partitions.unshift(spawn);
                console.log(`  ✓ ROPECAVE room is now at index 0`);
            }
            else {
                console.log(`  ✓ ROPECAVE room already at index 0`);
            }
        }
        // Connect partitions using cave logic
        if (spawn) {
            console.log("  Connecting cave partitions...");
            await this.connectCavePartitions(partialLevel, spawn);
            console.log(`  ✓ Cave connection complete. Remaining partitions: ${partialLevel.partitions.length}`);
        }
        // Add cave loops
        if (partialLevel.partitions.length > 0) {
            console.log("  Adding cave loop connections...");
            await this.addLoopConnections(partialLevel);
        }
        // Calculate distances (no stair room for caves)
        if (partialLevel.partitions.length > 0 && spawn) {
            console.log("  Calculating cave distances...");
            await this.calculateDistances(partialLevel, spawn);
            await this.addSpecialRooms(partialLevel);
        }
    }
    async processMainPathPartitions(partialLevel, game) {
        console.log("  Processing as MAIN PATH...");
        // Log all room types found
        const roomTypeCounts = {};
        partialLevel.partitions.forEach((p) => {
            roomTypeCounts[p.type] = (roomTypeCounts[p.type] || 0) + 1;
        });
        console.log("  Room type distribution:", roomTypeCounts);
        // Find START and BOSS rooms from color assignments
        let spawn = partialLevel.partitions.find((p) => p.type === room_1.RoomType.START);
        let boss = partialLevel.partitions.find((p) => p.type === room_1.RoomType.BOSS);
        console.log(`  Found START room: ${spawn ? "YES" : "NO"}`);
        console.log(`  Found BOSS room: ${boss ? "YES" : "NO"}`);
        // If no START room was specified by color, assign the smallest room
        if (!spawn && partialLevel.partitions.length > 0) {
            console.log("  No START room specified, finding smallest room...");
            partialLevel.partitions.sort((a, b) => a.area() - b.area());
            spawn = partialLevel.partitions[0];
            spawn.type = room_1.RoomType.START;
            spawn.fillStyle = "rgb(0, 255, 0)";
            console.log(`  ✓ Assigned START to smallest room at (${spawn.x}, ${spawn.y}) with area ${spawn.area()}`);
        }
        // If no BOSS room was specified by color, assign the largest room
        if (!boss && partialLevel.partitions.length > 1) {
            console.log("  No BOSS room specified, finding largest room...");
            partialLevel.partitions.sort((a, b) => a.area() - b.area());
            boss = partialLevel.partitions[partialLevel.partitions.length - 1];
            if (boss.type === room_1.RoomType.DUNGEON) {
                boss.type = room_1.RoomType.BOSS;
                boss.fillStyle = "red";
                console.log(`  ✓ Assigned BOSS to largest room at (${boss.x}, ${boss.y}) with area ${boss.area()}`);
            }
            else {
                console.log(`  ⚠️  Largest room is already ${boss.type}, not assigning BOSS`);
                boss = null;
            }
        }
        console.log("  Updating visual styles...");
        this.updatePartitionVisualStyles(partialLevel.partitions);
        // CRITICAL: Move START room to index 0 for proper spawning
        if (spawn) {
            const startIndex = partialLevel.partitions.indexOf(spawn);
            if (startIndex > 0) {
                console.log(`  Moving START room from index ${startIndex} to index 0`);
                // Remove START room from current position
                partialLevel.partitions.splice(startIndex, 1);
                // Insert at beginning
                partialLevel.partitions.unshift(spawn);
                console.log(`  ✓ START room is now at index 0`);
            }
            else {
                console.log(`  ✓ START room already at index 0`);
            }
        }
        // Connect partitions
        if (spawn) {
            console.log("  Connecting partitions...");
            await this.connectPartitions(partialLevel, spawn);
            console.log(`  ✓ Connection phase complete. Remaining partitions: ${partialLevel.partitions.length}`);
        }
        else {
            console.error("  ❌ No spawn room found, cannot connect partitions!");
        }
        // Add loop connections
        if (partialLevel.partitions.length > 0) {
            console.log("  Adding loop connections...");
            await this.addLoopConnections(partialLevel);
            console.log("  ✓ Loop connections added");
        }
        // Add stair room
        const hasStairRoom = partialLevel.partitions.some((p) => p.type === room_1.RoomType.DOWNLADDER);
        console.log(`  Existing stair room: ${hasStairRoom ? "YES" : "NO"}`);
        if (!hasStairRoom && partialLevel.partitions.length > 0) {
            console.log("  Adding automatic stair room...");
            await this.addStairRoom(partialLevel, game);
            console.log(`  ✓ Stair room processing complete. Final partitions: ${partialLevel.partitions.length}`);
        }
        // Calculate distances
        if (partialLevel.partitions.length > 0 && spawn) {
            console.log("  Calculating distances...");
            await this.calculateDistances(partialLevel, spawn);
            console.log("  Adding special rooms...");
            await this.addSpecialRooms(partialLevel);
            console.log("  ✓ Distance calculation complete");
            // Log final distances
            partialLevel.partitions.forEach((p) => {
                console.log(`    ${p.type} at (${p.x}, ${p.y}): distance ${p.distance}`);
            });
        }
    }
    updatePartitionVisualStyles(partitions) {
        console.log("    Updating visual styles...");
        for (const partition of partitions) {
            const oldStyle = partition.fillStyle;
            switch (partition.type) {
                case room_1.RoomType.START:
                    partition.fillStyle = "rgb(0, 255, 0)";
                    break;
                case room_1.RoomType.BOSS:
                    partition.fillStyle = "red";
                    break;
                case room_1.RoomType.DOWNLADDER:
                case room_1.RoomType.UPLADDER:
                    partition.fillStyle = "blue";
                    break;
                case room_1.RoomType.TREASURE:
                    partition.fillStyle = "rgb(255, 215, 0)";
                    break;
                case room_1.RoomType.SHOP:
                    partition.fillStyle = "rgb(255, 0, 255)";
                    break;
                case room_1.RoomType.FOUNTAIN:
                    partition.fillStyle = "rgb(128, 0, 128)";
                    break;
                case room_1.RoomType.CAVE:
                case room_1.RoomType.BIGCAVE:
                    partition.fillStyle = "rgb(101, 67, 33)";
                    break;
                default:
                    partition.fillStyle = "white";
                    break;
            }
            if (oldStyle !== partition.fillStyle) {
                console.log(`      Updated ${partition.type} style: ${oldStyle} -> ${partition.fillStyle}`);
            }
        }
    }
    async connectPartitions(partialLevel, spawn) {
        console.log("    === PNG CONNECTION WITH DEAD ENDS ===");
        let connected = [spawn];
        let frontier = [spawn];
        let connectionsMade = 0;
        while (frontier.length > 0) {
            let room = frontier[0];
            frontier.splice(0, 1);
            console.log(`    Processing ${room.type} at (${room.x}, ${room.y})`);
            // Find all unconnected rooms that are adjacent to this room
            const adjacentRooms = partialLevel.partitions.filter((p) => {
                return (p !== room &&
                    connected.indexOf(p) === -1 &&
                    this.arePartitionsAdjacent(room, p));
            });
            console.log(`      Found ${adjacentRooms.length} adjacent unconnected rooms`);
            // AGGRESSIVE: Connect to ALL adjacent rooms, not just 1-2
            for (let i = 0; i < adjacentRooms.length; i++) {
                const target = adjacentRooms[i];
                const adjacencyInfo = this.arePartitionsAdjacent(room, target);
                if (adjacencyInfo) {
                    const connectionPoint = adjacencyInfo.connectionPoint;
                    console.log(`      ✓ Connecting to ${target.type} at (${connectionPoint.x}, ${connectionPoint.y})`);
                    // Create bidirectional connections
                    room.connections.push(new partitionGenerator_1.PartitionConnection(connectionPoint.x, connectionPoint.y, target));
                    target.connections.push(new partitionGenerator_1.PartitionConnection(connectionPoint.x, connectionPoint.y, room));
                    // Set wall openings
                    room.setOpenWall(new partitionGenerator_1.PartitionConnection(connectionPoint.x, connectionPoint.y, target));
                    target.setOpenWall(new partitionGenerator_1.PartitionConnection(connectionPoint.x, connectionPoint.y, room));
                    frontier.push(target);
                    connected.push(target);
                    connectionsMade++;
                }
            }
            console.log(`      Room completed with ${room.connections.length} total connections`);
        }
        console.log(`    ✓ Connected ${connected.length}/${partialLevel.partitions.length} rooms`);
        // PRESERVE UNCONNECTED ROOMS: Don't remove them, just log them
        const unconnected = partialLevel.partitions.filter((p) => p.connections.length === 0);
        if (unconnected.length > 0) {
            console.log(`    📍 Found ${unconnected.length} isolated rooms (keeping as dead ends):`);
            unconnected.forEach((partition) => {
                console.log(`      - ${partition.type} at (${partition.x}, ${partition.y})`);
                // Make them accessible by connecting to the nearest connected room
                this.connectIsolatedRoom(partition, partialLevel.partitions.filter((p) => p.connections.length > 0));
            });
        }
        console.log(`    Final result: ${partialLevel.partitions.length} total rooms preserved`);
    }
    connectIsolatedRoom(isolatedRoom, connectedRooms) {
        // Find the closest connected room and create a connection
        let closestRoom = null;
        let closestDistance = Infinity;
        for (const room of connectedRooms) {
            const distance = Math.abs(isolatedRoom.x - room.x) + Math.abs(isolatedRoom.y - room.y);
            if (distance < closestDistance) {
                closestDistance = distance;
                closestRoom = room;
            }
        }
        if (closestRoom) {
            // Create a connection point between the rooms
            const connectionX = Math.floor((isolatedRoom.x + closestRoom.x) / 2);
            const connectionY = Math.floor((isolatedRoom.y + closestRoom.y) / 2);
            console.log(`      ✓ Linking isolated ${isolatedRoom.type} to ${closestRoom.type} via (${connectionX}, ${connectionY})`);
            isolatedRoom.connections.push(new partitionGenerator_1.PartitionConnection(connectionX, connectionY, closestRoom));
            closestRoom.connections.push(new partitionGenerator_1.PartitionConnection(connectionX, connectionY, isolatedRoom));
        }
    }
    async connectCavePartitions(partialLevel, spawn) {
        console.log("    Connecting cave partitions...");
        let connected = [spawn];
        let frontier = [spawn];
        const maxRooms = partialLevel.partitions.length; // Connect all available rooms
        while (frontier.length > 0 && connected.length < maxRooms) {
            let room = frontier[0];
            frontier.splice(0, 1);
            console.log(`    Processing cave room ${room.type} at (${room.x}, ${room.y})`);
            // Find adjacent unconnected rooms
            const adjacentRooms = partialLevel.partitions.filter((p) => {
                return (p !== room &&
                    connected.indexOf(p) === -1 &&
                    this.arePartitionsAdjacent(room, p));
            });
            const maxConnections = Math.min(adjacentRooms.length, Math.floor(random_1.Random.rand() * 2 + 1));
            for (let i = 0; i < maxConnections && connected.length < maxRooms; i++) {
                const target = adjacentRooms[i];
                const adjacencyInfo = this.arePartitionsAdjacent(room, target);
                if (adjacencyInfo) {
                    const connectionPoint = adjacencyInfo.connectionPoint;
                    room.connections.push(new partitionGenerator_1.PartitionConnection(connectionPoint.x, connectionPoint.y, target));
                    target.connections.push(new partitionGenerator_1.PartitionConnection(connectionPoint.x, connectionPoint.y, room));
                    frontier.push(target);
                    connected.push(target);
                    console.log(`    ✓ Cave connection: ${room.type} <-> ${target.type}`);
                }
            }
        }
        // Remove unconnected rooms
        partialLevel.partitions = partialLevel.partitions.filter((p) => p.connections.length > 0);
        console.log(`    ✓ Cave connection complete: ${connected.length} rooms connected`);
    }
    /**
     * Check if two partitions are adjacent and return connection info
     */
    arePartitionsAdjacent(p1, p2) {
        // Check if they're horizontally adjacent (side by side)
        if (p1.y < p2.y + p2.h && p2.y < p1.y + p1.h) {
            // p1 is to the left of p2
            if (p1.x + p1.w === p2.x || p1.x + p1.w === p2.x - 1) {
                const overlapStart = Math.max(p1.y, p2.y);
                const overlapEnd = Math.min(p1.y + p1.h, p2.y + p2.h);
                const connectionY = Math.floor(overlapStart + (overlapEnd - overlapStart) / 2);
                return {
                    direction: "horizontal",
                    connectionPoint: { x: p1.x + p1.w, y: connectionY },
                };
            }
            // p2 is to the left of p1
            if (p2.x + p2.w === p1.x || p2.x + p2.w === p1.x - 1) {
                const overlapStart = Math.max(p1.y, p2.y);
                const overlapEnd = Math.min(p1.y + p1.h, p2.y + p2.h);
                const connectionY = Math.floor(overlapStart + (overlapEnd - overlapStart) / 2);
                return {
                    direction: "horizontal",
                    connectionPoint: { x: p2.x + p2.w, y: connectionY },
                };
            }
        }
        // Check if they're vertically adjacent (top/bottom)
        if (p1.x < p2.x + p2.w && p2.x < p1.x + p1.w) {
            // p1 is above p2
            if (p1.y + p1.h === p2.y || p1.y + p1.h === p2.y - 1) {
                const overlapStart = Math.max(p1.x, p2.x);
                const overlapEnd = Math.min(p1.x + p1.w, p2.x + p2.w);
                const connectionX = Math.floor(overlapStart + (overlapEnd - overlapStart) / 2);
                return {
                    direction: "vertical",
                    connectionPoint: { x: connectionX, y: p1.y + p1.h },
                };
            }
            // p2 is above p1
            if (p2.y + p2.h === p1.y || p2.y + p2.h === p1.y - 1) {
                const overlapStart = Math.max(p1.x, p2.x);
                const overlapEnd = Math.min(p1.x + p1.w, p2.x + p2.w);
                const connectionX = Math.floor(overlapStart + (overlapEnd - overlapStart) / 2);
                return {
                    direction: "vertical",
                    connectionPoint: { x: connectionX, y: p2.y + p2.h },
                };
            }
        }
        return null;
    }
    /**
     * Enhanced loop connections that work better with PNG layouts
     */
    async addLoopConnections(partialLevel) {
        console.log("    Adding PNG-optimized loop connections...");
        if (partialLevel.partitions.length === 0) {
            return;
        }
        // Build adjacency map
        const adjacencyMap = new Map();
        partialLevel.partitions.forEach((p1) => {
            const adjacent = partialLevel.partitions.filter((p2) => {
                return p2 !== p1 && this.arePartitionsAdjacent(p1, p2);
            });
            adjacencyMap.set(p1, adjacent);
        });
        let loopsAdded = 0;
        const maxLoops = Math.min(4, Math.floor(partialLevel.partitions.length / 2));
        console.log(`    Attempting up to ${maxLoops} loop connections`);
        for (let i = 0; i < maxLoops; i++) {
            // Pick a random room
            const roomIndex = Math.floor(random_1.Random.rand() * partialLevel.partitions.length);
            const room = partialLevel.partitions[roomIndex];
            // Find adjacent rooms that aren't already connected
            const adjacentRooms = adjacencyMap.get(room) || [];
            const unconnectedAdjacent = adjacentRooms.filter((p) => !room.connections.some((c) => c.other === p));
            if (unconnectedAdjacent.length > 0) {
                const target = unconnectedAdjacent[Math.floor(random_1.Random.rand() * unconnectedAdjacent.length)];
                const adjacencyInfo = this.arePartitionsAdjacent(room, target);
                if (adjacencyInfo) {
                    const connectionPoint = adjacencyInfo.connectionPoint;
                    room.connections.push(new partitionGenerator_1.PartitionConnection(connectionPoint.x, connectionPoint.y, target));
                    target.connections.push(new partitionGenerator_1.PartitionConnection(connectionPoint.x, connectionPoint.y, room));
                    room.setOpenWall(new partitionGenerator_1.PartitionConnection(connectionPoint.x, connectionPoint.y, target));
                    target.setOpenWall(new partitionGenerator_1.PartitionConnection(connectionPoint.x, connectionPoint.y, room));
                    loopsAdded++;
                    console.log(`    ✓ Loop ${loopsAdded}: ${room.type} <-> ${target.type}`);
                }
            }
        }
        console.log(`    ✓ Added ${loopsAdded} loop connections`);
    }
    async addStairRoom(partialLevel, game) {
        console.log("    Adding stair room...");
        const hasBoss = partialLevel.partitions.some((p) => p.type === room_1.RoomType.BOSS);
        const hasStairs = partialLevel.partitions.some((p) => p.type === room_1.RoomType.DOWNLADDER);
        console.log(`    Has boss room: ${hasBoss}`);
        console.log(`    Has existing stairs: ${hasStairs}`);
        if (!hasBoss || hasStairs) {
            console.log("    Skipping stair room addition");
            return;
        }
        let boss = partialLevel.partitions.find((p) => p.type === room_1.RoomType.BOSS);
        console.log(`    Boss room at (${boss.x}, ${boss.y})`);
        let found_stair = false;
        const max_stair_tries = 5;
        const stairRoomWidth = 5;
        const stairRoomHeight = 5;
        for (let stair_tries = 0; stair_tries < max_stair_tries; stair_tries++) {
            const stairX = game_1.Game.rand(boss.x - 1, boss.x + boss.w - 2, random_1.Random.rand);
            const stairY = boss.y - stairRoomHeight - 1;
            console.log(`    Stair attempt ${stair_tries + 1}: trying position (${stairX}, ${stairY})`);
            let stair = new partitionGenerator_1.Partition(stairX, stairY, stairRoomWidth, stairRoomHeight, "white");
            stair.type = room_1.RoomType.DOWNLADDER;
            stair.fillStyle = "blue";
            const overlaps = partialLevel.partitions.some((p) => p.overlaps(stair));
            console.log(`    Overlap check: ${overlaps ? "OVERLAPS" : "CLEAR"}`);
            if (!overlaps) {
                found_stair = true;
                partialLevel.partitions.push(stair);
                const connectionX = stair.x + 1;
                const connectionY = stair.y + stairRoomHeight;
                stair.connections.push(new partitionGenerator_1.PartitionConnection(connectionX, connectionY, boss));
                boss.connections.push(new partitionGenerator_1.PartitionConnection(connectionX, connectionY, stair));
                stair.setOpenWall(new partitionGenerator_1.PartitionConnection(connectionX, connectionY, boss));
                boss.setOpenWall(new partitionGenerator_1.PartitionConnection(connectionX, connectionY, stair));
                console.log(`    ✓ Stair room added at (${stairX}, ${stairY}) connected to boss`);
                break;
            }
        }
        if (!found_stair) {
            console.log("    ❌ Could not place stair room after all attempts");
        }
    }
    async calculateDistances(partialLevel, spawn) {
        console.log("    Calculating distances from spawn...");
        let frontier = [spawn];
        let seen = [];
        spawn.distance = 0;
        let processedRooms = 0;
        while (frontier.length > 0) {
            let room = frontier[0];
            frontier.splice(0, 1);
            seen.push(room);
            processedRooms++;
            console.log(`    Processing room ${processedRooms}: ${room.type} at distance ${room.distance}`);
            for (let c of room.connections) {
                let other = c.other;
                const newDistance = room.distance + 1;
                if (newDistance < other.distance) {
                    other.distance = newDistance;
                    console.log(`    Updated ${other.type} distance to ${newDistance}`);
                }
                if (seen.indexOf(other) === -1) {
                    frontier.push(other);
                }
            }
        }
        console.log(`    ✓ Distance calculation complete for ${processedRooms} rooms`);
    }
    async addSpecialRooms(partialLevel) {
        console.log("    Adding special rooms...");
        let specialRoomsAdded = 0;
        for (const p of partialLevel.partitions) {
            if (p.type === room_1.RoomType.DUNGEON) {
                if (p.distance > 4 && p.area() <= 30 && random_1.Random.rand() < 0.1) {
                    p.type = room_1.RoomType.TREASURE;
                    specialRoomsAdded++;
                    console.log(`    ✓ Converted DUNGEON to TREASURE at (${p.x}, ${p.y}), distance ${p.distance}`);
                }
            }
        }
        console.log(`    ✓ Added ${specialRoomsAdded} special rooms`);
    }
    // Utility method to get color mapping documentation
    static getColorGuide() {
        const guide = Object.entries(COLOR_TO_ROOM_TYPE)
            .map(([color, type]) => `${color} -> ${type}`)
            .join("\n");
        return `PNG Level Designer Color Guide:\n${guide}`;
    }
}
exports.PngPartitionGenerator = PngPartitionGenerator;


/***/ }),

/***/ "./src/lighting/lightSource.ts":
/*!*************************************!*\
  !*** ./src/lighting/lightSource.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LightSource = void 0;
class LightSource {
    constructor(x, y, r, c = [180, 60, 5], b = 1) {
        this.b = 1;
        this.dead = false;
        this.updatePosition = (x, y) => {
            this.x = x;
            this.y = y;
        };
        this.shouldUpdate = () => {
            return true;
            this.hasChanged =
                this.x !== this.oldX ||
                    this.y !== this.oldY ||
                    this.r !== this.oldR ||
                    this.c !== this.oldC ||
                    this.b !== this.oldB ||
                    this.hasChanged;
            return this.hasChanged;
        };
        this.x = x;
        this.y = y;
        this.r = r;
        this.c = c;
        this.b = b;
        this.oldX = x;
        this.oldY = y;
        this.oldR = r;
        this.oldC = c;
        this.oldB = b;
        this.hasChanged = true;
    }
}
exports.LightSource = LightSource;


/***/ }),

/***/ "./src/lighting/lighting.ts":
/*!**********************************!*\
  !*** ./src/lighting/lighting.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Lighting = void 0;
const lightSource_1 = __webpack_require__(/*! ./lightSource */ "./src/lighting/lightSource.ts");
class Lighting {
}
exports.Lighting = Lighting;
Lighting.momentaryLight = (room, x, y, radius, color, duration, brightness, delay) => {
    const lightSource = Lighting.newLightSource(x, y, color, radius, brightness);
    setTimeout(() => {
        room.updateLightSources(lightSource);
        setTimeout(() => {
            room.updateLightSources(lightSource, true);
        }, duration);
    }, delay);
};
Lighting.newLightSource = (x, y, color, radius, brightness) => {
    return new lightSource_1.LightSource(x, y, radius, color, brightness);
};
Lighting.addLightSource = (room, lightSource) => {
    room.lightSources.push(lightSource);
};
Lighting.removeLightSource = (room, lightSource) => {
    room.lightSources = room.lightSources.filter((ls) => ls !== lightSource);
};


/***/ }),

/***/ "./src/particle/attackAnimation.ts":
/*!*****************************************!*\
  !*** ./src/particle/attackAnimation.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AttackAnimation = void 0;
const game_1 = __webpack_require__(/*! ../game */ "./src/game.ts");
const particle_1 = __webpack_require__(/*! ./particle */ "./src/particle/particle.ts");
class AttackAnimation extends particle_1.Particle {
    constructor(x, y, type, direction) {
        super();
        this.drawTopLayer = (delta) => {
            // if (this.frame <= this.frames / 2)
            this.drawAnimation(delta);
        };
        this.drawAnimation = (delta) => {
            if (this.dead)
                return;
            if (this.frame >= 0) {
                game_1.Game.drawFX(this.tileX + 2 * Math.round(Math.max(0, this.frame) / 2), this.tileY + this.tileYOffset, 2, 2, this.x - 0.5 + this.xOffset, this.y - 0.5 + this.yOffset, 2, 2);
            }
            this.frame += this.animationSpeed * delta;
            if (this.frame > this.frames)
                this.dead = true;
        };
        this.x = x;
        this.y = y - 0.25;
        this.dead = false;
        this.frame = 0;
        this.type = type;
        this.xOffset = 0;
        this.yOffset = 0;
        this.tileX = 12;
        this.animationSpeed = 1;
        switch (type) {
            case "dagger":
                this.frames = 8;
                this.tileY = 24;
                this.yOffset = 0;
                this.xOffset = 0;
                switch (direction) {
                    case game_1.Direction.DOWN:
                        this.yOffset -= 0.75;
                        break;
                    case game_1.Direction.UP:
                        this.yOffset += 0.5;
                        break;
                    case game_1.Direction.LEFT:
                        this.xOffset += 0.8;
                        this.yOffset += 0.25;
                        break;
                    case game_1.Direction.RIGHT:
                        this.xOffset -= 0.8;
                        this.yOffset -= 0.25;
                        break;
                }
                break;
            case "warhammer":
                this.frames = 8;
                this.tileX = 12;
                this.tileY = 32;
                this.yOffset = -0.75;
                this.xOffset = -0;
                this.frame = -5;
                this.animationSpeed = 2;
                switch (direction) {
                    case game_1.Direction.DOWN:
                        this.yOffset -= 0.25;
                        this.xOffset += 0.125;
                        break;
                    case game_1.Direction.UP:
                        this.yOffset += 1;
                        this.xOffset += 0.25;
                        break;
                    case game_1.Direction.LEFT:
                        this.xOffset += 0.75;
                        this.yOffset += 0.5;
                        break;
                    case game_1.Direction.RIGHT:
                        this.xOffset -= 0.75;
                        this.yOffset += 0.5;
                        break;
                }
                break;
            case "dualdagger":
                this.frames = 8;
                this.tileY = 40;
                this.yOffset = 0;
                this.xOffset = 0;
                switch (direction) {
                    case game_1.Direction.DOWN:
                        this.yOffset -= 1;
                        break;
                    case game_1.Direction.UP:
                        this.yOffset += 0.5;
                        break;
                    case game_1.Direction.LEFT:
                        this.xOffset += 0.8;
                        this.yOffset -= 0.25;
                        break;
                    case game_1.Direction.RIGHT:
                        this.xOffset -= 0.8;
                        this.yOffset -= 0.25;
                        break;
                }
                break;
            case "dualdagger2":
                this.frames = 8;
                this.tileY = 48;
                this.yOffset = 0;
                this.xOffset = 0;
                //this.animationSpeed = 1;
                switch (direction) {
                    case game_1.Direction.DOWN:
                        this.yOffset -= 1;
                        break;
                    case game_1.Direction.UP:
                        this.yOffset += 0.5;
                        break;
                    case game_1.Direction.LEFT:
                        this.xOffset += 0.8;
                        this.yOffset -= 0.25;
                        break;
                    case game_1.Direction.RIGHT:
                        this.xOffset -= 0.8;
                        this.yOffset -= 0.25;
                        break;
                }
                break;
            case "spear":
                this.frames = 5;
                this.tileY = 32;
                this.tileX = 22;
                this.animationSpeed = 0.5;
                switch (direction) {
                    case game_1.Direction.DOWN:
                        this.yOffset -= 0.75;
                        this.xOffset += 0.125;
                        break;
                    case game_1.Direction.UP:
                        //needs to draw behind player but its fine for now
                        this.yOffset += 1;
                        this.xOffset -= 0.125;
                        break;
                    case game_1.Direction.LEFT:
                        this.xOffset += 1;
                        this.yOffset += 0.25;
                        break;
                    case game_1.Direction.RIGHT:
                        this.xOffset -= 1;
                        this.yOffset += 0.25;
                        break;
                }
                break;
            case "scythe":
                this.frames = 6;
                this.tileY = 40;
                this.tileX = 0;
                this.animationSpeed = 0.75;
                switch (direction) {
                    case game_1.Direction.DOWN:
                        this.yOffset -= 0.75;
                        this.xOffset += 0;
                        break;
                    case game_1.Direction.UP:
                        this.yOffset += 0.75;
                        this.xOffset -= 0;
                        break;
                    case game_1.Direction.LEFT:
                        this.xOffset += 0.75;
                        this.yOffset += 0;
                        break;
                    case game_1.Direction.RIGHT:
                        this.xOffset -= 0.75;
                        this.yOffset -= 0;
                        break;
                }
                break;
            case "sword":
                this.frames = 6;
                this.tileY = 48;
                this.tileX = 0;
                this.animationSpeed = 0.75;
                switch (direction) {
                    case game_1.Direction.DOWN:
                        this.yOffset -= 0.95;
                        this.xOffset += 0;
                        break;
                    case game_1.Direction.UP:
                        this.yOffset += 0.95;
                        this.xOffset -= 0;
                        break;
                    case game_1.Direction.LEFT:
                        this.xOffset += 0.95;
                        this.yOffset += 0;
                        break;
                    case game_1.Direction.RIGHT:
                        this.xOffset -= 0.95;
                        this.yOffset -= 0;
                        break;
                }
                break;
        }
        switch (direction) {
            case game_1.Direction.DOWN:
                this.tileYOffset = 0;
                break;
            case game_1.Direction.UP:
                this.tileYOffset = 2;
                break;
            case game_1.Direction.LEFT:
                this.tileYOffset = 4;
                break;
            case game_1.Direction.RIGHT:
                this.tileYOffset = 6;
                break;
        }
    }
}
exports.AttackAnimation = AttackAnimation;


/***/ }),

/***/ "./src/particle/damageNumber.ts":
/*!**************************************!*\
  !*** ./src/particle/damageNumber.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DamageNumber = void 0;
const game_1 = __webpack_require__(/*! ../game */ "./src/game.ts");
const gameConstants_1 = __webpack_require__(/*! ../game/gameConstants */ "./src/game/gameConstants.ts");
const random_1 = __webpack_require__(/*! ../utility/random */ "./src/utility/random.ts");
const particle_1 = __webpack_require__(/*! ./particle */ "./src/particle/particle.ts");
class DamageNumber extends particle_1.Particle {
    constructor(room, x, y, damage, color, outlineColor) {
        super();
        this.alpha = 1;
        this.frame = 0;
        this.xoffset = 0;
        this.getXoffset = () => {
            if (this.room.particles.length > 0) {
                let damageNumbers = this.room.particles.filter((p) => p instanceof DamageNumber);
                if (damageNumbers.length % 3 === 0)
                    return 0.5;
                if (damageNumbers.length % 3 === 1)
                    return 0;
                if (damageNumbers.length % 3 === 2)
                    return 0.25;
            }
        };
        this.drawTopLayer = (delta) => {
            game_1.Game.ctx.save();
            if (this.dead) {
                game_1.Game.ctx.restore();
                return;
            }
            if (this.frame > 15)
                this.alpha -= 0.025 * delta;
            this.y -= 0.03 * delta;
            this.frame += delta;
            let width = game_1.Game.measureText(this.damage.toString()).width;
            if (this.alpha <= 0.002) {
                this.alpha = 0;
                this.dead = true;
            }
            game_1.Game.ctx.globalAlpha = this.alpha;
            game_1.Game.fillTextOutline(this.damage.toString(), (this.x + 0.4 + this.xoffset) * gameConstants_1.GameConstants.TILESIZE - width / 2, (this.y - 0.6) * gameConstants_1.GameConstants.TILESIZE, this.outlineColor, this.color);
            game_1.Game.ctx.globalAlpha = 1;
            game_1.Game.ctx.restore();
        };
        this.room = room;
        this.damage = damage;
        this.x = x;
        this.y = y;
        if (color)
            this.color = color;
        else
            this.color = "red";
        if (outlineColor)
            this.outlineColor = outlineColor;
        else
            this.outlineColor = gameConstants_1.GameConstants.OUTLINE;
        this.xoffset = random_1.Random.rand() * 0.2;
    }
}
exports.DamageNumber = DamageNumber;


/***/ }),

/***/ "./src/particle/genericParticle.ts":
/*!*****************************************!*\
  !*** ./src/particle/genericParticle.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GenericParticle = void 0;
const particle_1 = __webpack_require__(/*! ./particle */ "./src/particle/particle.ts");
const game_1 = __webpack_require__(/*! ../game */ "./src/game.ts");
const gameConstants_1 = __webpack_require__(/*! ../game/gameConstants */ "./src/game/gameConstants.ts");
const random_1 = __webpack_require__(/*! ../utility/random */ "./src/utility/random.ts");
class GenericParticle extends particle_1.Particle {
    constructor(level, x, y, z, s, dx, dy, dz, color, delay, expirationTimer, targetX, targetY, targetZ) {
        super();
        this.render = () => {
            let scale = gameConstants_1.GameConstants.TILESIZE;
            let scaledS = this.s * this.alpha; // using alpha for scaling, not alpha
            let halfS = 0.5 * scaledS;
            let oldFillStyle = game_1.Game.ctx.fillStyle;
            game_1.Game.ctx.fillStyle = this.color;
            game_1.Game.ctx.imageSmoothingEnabled = false;
            game_1.Game.ctx.beginPath();
            game_1.Game.ctx.arc(Math.round(this.x * scale), Math.round((this.y - this.z) * scale), Math.round(halfS * scale), 0, 2 * Math.PI, false);
            game_1.Game.ctx.fill();
            game_1.Game.ctx.fillStyle = oldFillStyle;
        };
        this.draw = (delta) => {
            if (this.targetX)
                this.x += 0.1 * (this.targetX - this.x);
            else
                this.x += this.dx;
            if (this.targetY)
                this.y += 0.1 * (this.targetY - this.y);
            else
                this.y += this.dy;
            if (this.targetZ)
                this.z += 0.1 * (this.targetZ - this.z);
            else
                this.z += this.dz;
            this.dx *= 0.97;
            this.dy *= 0.97;
            if (this.z <= 0) {
                this.z = 0;
                this.dz *= -0.8;
            }
            // apply gravity
            this.dz -= 0.01;
            if (this.alpha < 0.2)
                this.alpha -= 0.007;
            else
                this.alpha -= 0.02;
            if (this.alpha <= 0.1)
                this.dead = true;
            this.expirationTimer--;
            if (this.expirationTimer <= 0)
                this.dead = true;
            if (this.dead)
                return;
            this.drawableY = this.y;
            this.render();
        };
        this.level = level;
        this.x = x;
        this.y = y;
        this.z = z;
        this.s = s;
        this.dx = dx;
        this.dy = dy;
        this.dz = dz;
        this.color = color;
        this.alpha = 1.0;
        if (delay !== undefined)
            this.delay = delay;
        this.targetX = targetX;
        this.targetY = targetY;
        this.targetZ = targetZ;
        this.expirationTimer = 1000000;
        if (expirationTimer !== undefined)
            this.expirationTimer = expirationTimer;
    }
}
exports.GenericParticle = GenericParticle;
GenericParticle.shotgun = (level, cx, cy, tx, ty, color) => {
    for (let i = 0; i < 4; i++) {
        level.particles.push(new GenericParticle(level, cx, cy, 0, random_1.Random.rand() * 0.5 + 0.3, 0, 0, 0, color, 0, 10000000, tx + random_1.Random.rand() - 0.5, ty + random_1.Random.rand() - 0.5, 0));
    }
};
GenericParticle.spawnCluster = (level, cx, cy, color) => {
    for (let i = 0; i < 4; i++) {
        level.particles.push(new GenericParticle(level, cx + random_1.Random.rand() * 0.05 - 0.025, cy + random_1.Random.rand() * 0.05 - 0.025, random_1.Random.rand() * 0.5, 0.0625 * (i + 8), 0.025 * (random_1.Random.rand() * 2 - 1), 0.025 * (random_1.Random.rand() * 2 - 1), 0.2 * (random_1.Random.rand() - 1), color, 0));
    }
};


/***/ }),

/***/ "./src/particle/imageParticle.ts":
/*!***************************************!*\
  !*** ./src/particle/imageParticle.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ImageParticle = void 0;
const particle_1 = __webpack_require__(/*! ./particle */ "./src/particle/particle.ts");
const game_1 = __webpack_require__(/*! ../game */ "./src/game.ts");
const gameConstants_1 = __webpack_require__(/*! ../game/gameConstants */ "./src/game/gameConstants.ts");
const random_1 = __webpack_require__(/*! ../utility/random */ "./src/utility/random.ts");
class ImageParticle extends particle_1.Particle {
    constructor(room, x, y, z, s, dx, dy, dz, tileX, tileY, size, delay, expirationTimer, targetX, targetY, targetZ) {
        super();
        this.render = () => {
            let scale = gameConstants_1.GameConstants.TILESIZE;
            let yOffset = this.z * scale;
            let frame = this.s > 0.5 ? 1 : 0; // Placeholder frames for large and small particles
            game_1.Game.ctx.imageSmoothingEnabled = false;
            let adjustedTileX = this.tileX + this.size;
            game_1.Game.drawFX(adjustedTileX, this.tileY, 1, 1, this.x - this.alpha / 2, this.y - this.z - this.alpha / 2, 1, 1, this.shadeColor(), this.shadeAmount());
        };
        this.draw = (delta) => {
            game_1.Game.ctx.imageSmoothingEnabled = false;
            if (this.targetX)
                this.x += 0.2 * (this.targetX - this.x) * delta;
            else
                this.x += this.dx * delta;
            if (this.targetY)
                this.y += 0.2 * (this.targetY - this.y) * delta;
            else
                this.y += this.dy * delta;
            if (this.targetZ)
                this.z += 0.2 * (this.targetZ - this.z) * delta;
            else
                this.z += this.dz * delta;
            this.dx *= Math.pow(0.97, delta);
            this.dy *= Math.pow(0.97, delta);
            if (this.z <= 0) {
                this.z = 0;
                this.dz *= -0.8;
            }
            this.dz -= 0.01 * delta;
            this.expirationTimer -= delta;
            if (this.expirationTimer <= 0)
                this.dead = true;
            if (this.dead)
                return;
            this.drawableY = this.y;
            this.render();
        };
        this.room = room;
        this.x = x;
        this.y = y;
        this.z = z; // Use provided height
        this.s = s;
        this.dx = dx;
        this.dy = dy;
        this.dz = dz;
        this.tileX = tileX;
        this.tileY = tileY;
        this.size = size;
        this.alpha = 1.0;
        if (delay !== undefined)
            this.delay = delay;
        this.targetX = targetX;
        this.targetY = targetY;
        this.targetZ = targetZ;
        this.expirationTimer = 100; // Increased life duration
        if (expirationTimer !== undefined)
            this.expirationTimer = expirationTimer;
    }
}
exports.ImageParticle = ImageParticle;
ImageParticle.shotgun = (room, cx, cy, tx, ty, tileX, tileY) => {
    for (let i = 0; i < 4; i++) {
        room.particles.push(new ImageParticle(room, cx, cy, 0, random_1.Random.rand() * 0.5 + 0.3, 0, 0, 0, tileX, tileY, 0));
    }
};
ImageParticle.spawnCluster = (level, cx, cy, tileX, tileY) => {
    for (let i = Math.floor(random_1.Random.rand() * 3); i < 5; i++) {
        level.particles.push(new ImageParticle(level, cx + random_1.Random.rand() * 0.05 - 0.025, // x
        cy + random_1.Random.rand() * 0.05 - 0.025, // y
        random_1.Random.rand() * 0.5, // z
        0.0625 * (i + 8), // s
        0.025 * (random_1.Random.rand() * 2 - 1), //dx
        0.025 * (random_1.Random.rand() * 2 - 1), //dy
        0.2 * (random_1.Random.rand() - 1), //dz
        tileX, tileY, [2, 1, 0, 1, 2, 2, 2][i]));
    }
};


/***/ }),

/***/ "./src/particle/particle.ts":
/*!**********************************!*\
  !*** ./src/particle/particle.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Particle = void 0;
const drawable_1 = __webpack_require__(/*! ../drawable/drawable */ "./src/drawable/drawable.ts");
class Particle extends drawable_1.Drawable {
    constructor() {
        super(...arguments);
        this.drawTopLayer = (delta) => { };
        this.shadeAmount = () => {
            const x = Math.floor(this.x);
            const y = Math.floor(this.y);
            if (!this.room.softVis[x])
                return 0.9;
            const shade = this.room.softVis[x][y];
            return shade ?? 0.9;
        };
        this.shadeColor = () => {
            return this.room.shadeColor;
        };
    }
}
exports.Particle = Particle;


/***/ }),

/***/ "./src/particle/wizardTeleportParticle.ts":
/*!************************************************!*\
  !*** ./src/particle/wizardTeleportParticle.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WizardTeleportParticle = void 0;
const particle_1 = __webpack_require__(/*! ./particle */ "./src/particle/particle.ts");
const game_1 = __webpack_require__(/*! ../game */ "./src/game.ts");
class WizardTeleportParticle extends particle_1.Particle {
    constructor(x, y) {
        super();
        this.draw = (delta) => {
            if (this.dead)
                return;
            game_1.Game.drawFX(Math.floor(this.frame), 3, 1, 1, this.x, this.y - this.z, 1, 1);
            this.z += this.dz * delta;
            this.dz *= 0.9;
            this.frame += 0.3 * delta;
            if (this.frame > 6)
                this.dead = true;
        };
        this.x = x;
        this.y = y;
        this.dead = false;
        this.frame = 0;
        this.z = 0;
        this.dz = 0.1;
    }
}
exports.WizardTeleportParticle = WizardTeleportParticle;


/***/ }),

/***/ "./src/player/player.ts":
/*!******************************!*\
  !*** ./src/player/player.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Player = exports.PlayerDirection = void 0;
const input_1 = __webpack_require__(/*! ../game/input */ "./src/game/input.ts");
const gameConstants_1 = __webpack_require__(/*! ../game/gameConstants */ "./src/game/gameConstants.ts");
const game_1 = __webpack_require__(/*! ../game */ "./src/game.ts");
const door_1 = __webpack_require__(/*! ../tile/door */ "./src/tile/door.ts");
const trapdoor_1 = __webpack_require__(/*! ../tile/trapdoor */ "./src/tile/trapdoor.ts");
const inventory_1 = __webpack_require__(/*! ../inventory/inventory */ "./src/inventory/inventory.ts");
const sound_1 = __webpack_require__(/*! ../sound/sound */ "./src/sound/sound.ts");
const levelConstants_1 = __webpack_require__(/*! ../level/levelConstants */ "./src/level/levelConstants.ts");
const map_1 = __webpack_require__(/*! ../gui/map */ "./src/gui/map.ts");
const healthbar_1 = __webpack_require__(/*! ../drawable/healthbar */ "./src/drawable/healthbar.ts");
const drawable_1 = __webpack_require__(/*! ../drawable/drawable */ "./src/drawable/drawable.ts");
const item_1 = __webpack_require__(/*! ../item/item */ "./src/item/item.ts");
const enemy_1 = __webpack_require__(/*! ../entity/enemy/enemy */ "./src/entity/enemy/enemy.ts");
const mouseCursor_1 = __webpack_require__(/*! ../gui/mouseCursor */ "./src/gui/mouseCursor.ts");
const menu_1 = __webpack_require__(/*! ../gui/menu */ "./src/gui/menu.ts");
const bestiary_1 = __webpack_require__(/*! ../game/bestiary */ "./src/game/bestiary.ts");
const playerInputHandler_1 = __webpack_require__(/*! ./playerInputHandler */ "./src/player/playerInputHandler.ts");
const playerActionProcessor_1 = __webpack_require__(/*! ./playerActionProcessor */ "./src/player/playerActionProcessor.ts");
const playerMovement_1 = __webpack_require__(/*! ./playerMovement */ "./src/player/playerMovement.ts");
const playerRenderer_1 = __webpack_require__(/*! ./playerRenderer */ "./src/player/playerRenderer.ts");
const upLadder_1 = __webpack_require__(/*! ../tile/upLadder */ "./src/tile/upLadder.ts");
const downLadder_1 = __webpack_require__(/*! ../tile/downLadder */ "./src/tile/downLadder.ts");
const IdGenerator_1 = __webpack_require__(/*! ../globalStateManager/IdGenerator */ "./src/globalStateManager/IdGenerator.ts");
var PlayerDirection;
(function (PlayerDirection) {
    PlayerDirection[PlayerDirection["DOWN"] = 0] = "DOWN";
    PlayerDirection[PlayerDirection["UP"] = 1] = "UP";
    PlayerDirection[PlayerDirection["RIGHT"] = 2] = "RIGHT";
    PlayerDirection[PlayerDirection["LEFT"] = 3] = "LEFT";
})(PlayerDirection = exports.PlayerDirection || (exports.PlayerDirection = {}));
var DrawDirection;
(function (DrawDirection) {
    DrawDirection[DrawDirection["X"] = 0] = "X";
    DrawDirection[DrawDirection["Y"] = 1] = "Y";
})(DrawDirection || (DrawDirection = {}));
class Player extends drawable_1.Drawable {
    constructor(game, x, y, isLocalPlayer) {
        super();
        this.drawMoveQueue = [];
        this.seenEnemies = new Set();
        this.bestiary = null;
        this.setHitXY = (newX, newY, distance = 0.5) => {
            this.renderer.hitX = distance * (this.x - newX);
            this.renderer.hitY = distance * (this.y - newY);
        };
        this.applyStatus = (enemy, status) => {
            if (enemy instanceof enemy_1.Enemy) {
                if (status.poison) {
                    enemy.poison();
                    return true;
                }
                if (status.blood) {
                    enemy.bleed();
                    return true;
                }
            }
        };
        this.isMouseOnPlayerTile = () => {
            return this.mouseToTile().x === this.x && this.mouseToTile().y === this.y;
        };
        this.isMouseAboveFloor = (offsetY = 0) => {
            const mouseTile = this.mouseToTile(offsetY);
            // Handle undefined coordinates
            if (mouseTile.x === undefined || mouseTile.y === undefined) {
                return false;
            }
            const mouseX = mouseTile.x;
            const mouseY = mouseTile.y;
            if (this.game.levelState === game_1.LevelState.LEVEL_GENERATION ||
                !this.game.started ||
                !this.game.room ||
                !this.game.room.roomArray ||
                !Array.isArray(this.game.room.roomArray[mouseX]) ||
                this.game.room.roomArray[mouseX][mouseY] === undefined)
                return false;
            return !(!this.game.room?.tileInside(mouseX, mouseY) ||
                (this.game.room?.tileInside(mouseX, mouseY) &&
                    this.game.room?.roomArray[mouseX][mouseY].isSolid() &&
                    !(this.game.room?.roomArray[mouseX][mouseY] instanceof door_1.Door)));
        };
        this.mouseInLine = () => {
            const mouseTile = this.mouseToTile();
            // Handle undefined coordinates
            if (mouseTile.x === undefined || mouseTile.y === undefined) {
                return false;
            }
            return mouseTile.x === this.x || mouseTile.y === this.y;
        };
        this.canMoveWithMouse = () => {
            if (this.inventory.isOpen) {
                return null;
            }
            const isFloorNormal = this.isMouseAboveFloor();
            const isFloorOffset = this.isMouseAboveFloor(8);
            if (!isFloorNormal && !isFloorOffset) {
                return null;
            }
            const mouseTile = this.mouseToTile();
            const offsetMouseTile = this.mouseToTile(8);
            if (mouseTile.x === undefined ||
                mouseTile.y === undefined ||
                offsetMouseTile.x === undefined ||
                offsetMouseTile.y === undefined) {
                return null;
            }
            if (!this.game.room.roomArray ||
                !this.game.room.roomArray[mouseTile.x] ||
                !this.game.room.roomArray[mouseTile.x][mouseTile.y]) {
                return null;
            }
            let targetY = mouseTile.y;
            const hasEntityAtOffset = this.checkTileForEntity(offsetMouseTile);
            if (isFloorOffset && hasEntityAtOffset) {
                targetY = offsetMouseTile.y;
            }
            const sameX = mouseTile.x === this.x;
            const sameY = targetY === this.y;
            if (sameX && sameY) {
                return null;
            }
            if (sameX) {
                const nextY = targetY < this.y ? this.y - 1 : this.y + 1;
                if (!this.game.room.roomArray[this.x] ||
                    !this.game.room.roomArray[this.x][nextY]) {
                    return null;
                }
                return targetY < this.y
                    ? { direction: game_1.Direction.UP, x: this.x, y: nextY }
                    : { direction: game_1.Direction.DOWN, x: this.x, y: nextY };
            }
            if (sameY) {
                const nextX = mouseTile.x < this.x ? this.x - 1 : this.x + 1;
                if (!this.game.room.roomArray[nextX] ||
                    !this.game.room.roomArray[nextX][this.y]) {
                    return null;
                }
                return mouseTile.x < this.x
                    ? { direction: game_1.Direction.LEFT, x: nextX, y: this.y }
                    : { direction: game_1.Direction.RIGHT, x: nextX, y: this.y };
            }
            return null;
        };
        this.stall = () => {
            if (!this.game.started || !this.game.room || !this.renderer)
                return;
            if (this.game.levelState === game_1.LevelState.IN_LEVEL) {
                this.game?.room?.tick(this);
                this.shakeScreen(this.x - 0.5, this.y, this.x + 0.5, this.y, 5);
                this.game.pushMessage("Equipping an item takes a turn.");
            }
        };
        this.moveWithMouse = () => {
            this.inputHandler.setMostRecentMoveInput("mouse");
            if (!gameConstants_1.GameConstants.MOVE_WITH_MOUSE)
                return;
            const moveData = this.canMoveWithMouse();
            if (moveData !== null) {
                this.actionProcessor.process({
                    type: "MouseMove",
                    direction: moveData.direction,
                    targetX: moveData.x,
                    targetY: moveData.y,
                });
            }
        };
        this.mouseToTile = (offsetY = 0) => {
            // Handle undefined mouse coordinates
            if (input_1.Input.mouseX === undefined || input_1.Input.mouseY === undefined) {
                return { x: undefined, y: undefined };
            }
            // Get screen center coordinates
            const screenCenterX = gameConstants_1.GameConstants.WIDTH / 2;
            const screenCenterY = gameConstants_1.GameConstants.HEIGHT / 2;
            // Convert pixel offset to tile offset
            const tileOffsetX = Math.floor((input_1.Input.mouseX - screenCenterX + gameConstants_1.GameConstants.TILESIZE / 2) /
                gameConstants_1.GameConstants.TILESIZE);
            const tileOffsetY = Math.floor((input_1.Input.mouseY + offsetY - screenCenterY + gameConstants_1.GameConstants.TILESIZE / 2) /
                gameConstants_1.GameConstants.TILESIZE);
            return {
                x: this.x + tileOffsetX,
                y: this.y + tileOffsetY,
            };
        };
        this.tileToMouse = (tileX, tileY) => {
            // Get screen center coordinates
            const screenCenterX = gameConstants_1.GameConstants.WIDTH / 2;
            const screenCenterY = gameConstants_1.GameConstants.HEIGHT / 2;
            // Calculate the offset from the center position
            const tileOffsetX = tileX - this.x;
            const tileOffsetY = tileY - this.y;
            // Convert tile offset to pixel coordinates
            const pixelX = screenCenterX + tileOffsetX * gameConstants_1.GameConstants.TILESIZE;
            const pixelY = screenCenterY + tileOffsetY * gameConstants_1.GameConstants.TILESIZE;
            return {
                x: pixelX,
                y: pixelY,
            };
        };
        this.setTileCursorPosition = () => {
            const offsetX = Math.floor(gameConstants_1.GameConstants.WIDTH / 2) / gameConstants_1.GameConstants.TILESIZE;
            const offsetY = Math.floor(gameConstants_1.GameConstants.HEIGHT / 2) / gameConstants_1.GameConstants.TILESIZE;
            const mousePosition = this.mouseToTile();
            // Calculate cursor position relative to center
            let cursorX = mousePosition.x - this.x + offsetX - 0.5;
            let cursorY = mousePosition.y - this.y + offsetY - 0.5;
            // Clamp cursor to be no further than 1 tile from center
            // Center is at (offsetX, offsetY)
            const centerX = offsetX;
            const centerY = offsetY;
            // Calculate distance from center (before the 0.5 offset)
            const distanceX = Math.abs(cursorX + 0.5 - centerX);
            const distanceY = Math.abs(cursorY + 0.5 - centerY);
            // Clamp if needed
            if (distanceX > 1) {
                // Preserve direction but limit distance
                const direction = cursorX > centerX ? 1 : -1;
                cursorX = centerX + direction - 0.5; // -0.5 to account for the offset
            }
            if (distanceY > 1) {
                // Preserve direction but limit distance
                const direction = cursorY > centerY ? 1 : -1;
                cursorY = centerY + direction - 0.5; // -0.5 to account for the offset
            }
            this.tileCursor = {
                x: cursorX,
                y: cursorY,
            };
        };
        this.enemyInRange = (eX, eY, range) => {
            // Use nullish coalescing operator for cleaner default value
            const r = range ?? 1;
            // Same tile - not in range
            if (eX === this.x && eY === this.y)
                return false;
            // Diagonal - not in range
            if (eX !== this.x && eY !== this.y)
                return false;
            // Check horizontal range
            if (eY === this.y) {
                return Math.abs(eX - this.x) <= r;
            }
            // Check vertical range
            if (eX === this.x) {
                return Math.abs(eY - this.y) <= r;
            }
            return false;
        };
        this.getDirectionFromCoords = (inputX, inputY) => {
            // Same position - no direction
            if (inputX === this.x && inputY === this.y)
                return "";
            // Diagonal - no direction
            if (inputX !== this.x && inputY !== this.y)
                return "";
            // Check horizontal
            if (inputY === this.y) {
                return inputX > this.x ? "right" : "left";
            }
            // Check vertical
            if (inputX === this.x) {
                return inputY > this.y ? "down" : "up";
            }
            return "arrow";
        };
        this.setCursorIcon = () => {
            // Early return cases
            if (this.inventory.isDragging) {
                mouseCursor_1.MouseCursor.getInstance().setIcon("grab");
                return;
            }
            const cursor = mouseCursor_1.MouseCursor.getInstance();
            const mousePos = cursor.getPosition();
            const mouseTile = this.mouseToTile();
            // Check cursor states in order of priority
            const cursorState = this.getCursorState(mousePos, mouseTile);
            cursor.setIcon(cursorState);
        };
        this.getCursorState = (mousePos, mouseTile) => {
            // 1. Check UI interactions
            if (this.isMouseInUI(mousePos)) {
                return "hand";
            }
            if (this.isEntityAttackable(mouseTile)) {
                return "sword";
            }
            // 2. Check game world interactions
            if (this.isMouseAboveFloor() && this.mouseInLine()) {
                // 2a. Check for attackable entities
                // 2b. Check for movement target
                if (this.enemyInRange(mouseTile.x, mouseTile.y, 1)) {
                    return this.getDirectionFromCoords(mouseTile.x, mouseTile.y);
                }
                // 2c. Default floor interaction
                return "hand";
            }
            // 3. Default cursor state
            return "arrow";
        };
        this.isMouseInUI = (mousePos) => {
            const { x, y } = mousePos;
            return (this.inventory.isPointInInventoryButton(x, y) ||
                this.isInventoryItemInteraction(x, y));
        };
        this.isInventoryItemInteraction = (x, y) => {
            const hasSelectedItem = this.inventory.itemAtSelectedSlot() instanceof item_1.Item;
            return ((this.inventory.isPointInQuickbarBounds(x, y).inBounds &&
                hasSelectedItem) ||
                (this.inventory.isOpen &&
                    this.inventory.isPointInInventoryBounds(x, y).inBounds &&
                    hasSelectedItem));
        };
        this.isEntityAttackable = (mouseTile) => {
            // Check current tile
            const currentTileCheck = this.checkTileForEntity(mouseTile);
            if (currentTileCheck)
                return true;
            // Check tile above with 0.5 tile offset
            const belowTileCheck = this.checkTileForEntity({
                x: mouseTile.x,
                y: this.mouseToTile(gameConstants_1.GameConstants.TILESIZE / 2).y,
            });
            return belowTileCheck;
        };
        this.checkTileForEntity = (tile) => {
            const range = this.inventory.weapon?.range ?? 1;
            return this.game.room.entities.some((entity) => {
                return (entity.x === tile.x &&
                    entity.y === tile.y &&
                    this.enemyInRange(entity.x, entity.y, range));
            });
        };
        this.restart = () => {
            this.dead = false;
            this.game.newGame();
        };
        this.hit = () => {
            return 1;
        };
        this.tryCollide = (other, newX, newY) => {
            if (newX >= other.x + other.w || newX + this.w <= other.x)
                return false;
            if (newY >= other.y + other.h || newY + this.h <= other.y)
                return false;
            return true;
        };
        this.tryMove = (x, y) => {
            if (this.busyAnimating ||
                this.game.levelState === game_1.LevelState.TRANSITIONING ||
                this.game.levelState === game_1.LevelState.TRANSITIONING_LADDER)
                return;
            // TODO don't move if hit by enemy
            this.game.levels[this.depth].rooms[this.levelID].catchUp();
            //this.game.room.catchUp();
            if (!this.game.room) {
                console.warn("oi bruv, game.room isn't even there!");
                return;
            }
            if (this.dead)
                return;
            //for (let i = 0; i < 2; i++) //no idea why we would loop this...
            if (this.inventory.hasWeapon() &&
                !this.inventory.getWeapon().weaponMove(x, y)) {
                //for (let h of this.game.levels[this.levelID].hitwarnings) {
                //if (newMove instanceof HitWarning)
                return;
                //}
            }
            else if (!this.inventory.hasWeapon()) {
                this.game.pushMessage("No weapon equipped.");
            }
            for (let e of this.game.levels[this.depth].rooms[this.levelID].entities) {
                e.lastX = e.x;
                e.lastY = e.y;
                //console.log(`e.lastX, e.lastY: ${e.lastX}, ${e.lastY}`);
                if (this.tryCollide(e, x, y)) {
                    if (e.pushable) {
                        // pushing a crate or barrel
                        let dx = x - this.x;
                        let dy = y - this.y;
                        let nextX = x + dx;
                        let nextY = y + dy;
                        let foundEnd = false; // end of the train of whatever we're pushing
                        let enemyEnd = false; // end of the train is a solid enemy (i.e. potted plant)
                        let pushedEnemies = [];
                        while (true) {
                            foundEnd = true;
                            for (const f of this.game.levels[this.depth].rooms[this.levelID]
                                .entities) {
                                f.lastX = f.x;
                                f.lastY = f.y;
                                if (f.pointIn(nextX, nextY)) {
                                    if (!f.chainPushable) {
                                        enemyEnd = true;
                                        foundEnd = true;
                                        break;
                                    }
                                    foundEnd = false;
                                    pushedEnemies.push(f);
                                    break;
                                }
                            }
                            if (foundEnd)
                                break;
                            nextX += dx * pushedEnemies[pushedEnemies.length - 1].w;
                            nextY += dy * pushedEnemies[pushedEnemies.length - 1].h;
                        }
                        /* if no enemies and there is a wall, no move
                        otherwise, push everything, killing last enemy if there is a wall */
                        // here, (nextX, nextY) is the position immediately after the end of the train
                        if (pushedEnemies.length === 0 &&
                            (this.game.levels[this.depth].rooms[this.levelID].roomArray[nextX][nextY].canCrushEnemy() ||
                                enemyEnd)) {
                            if (e.destroyable) {
                                //fallback if no weapon equipped
                                e.hurt(this, e.health, "none");
                                if (this.game.levels[this.depth].rooms[this.levelID] ===
                                    this.game.room)
                                    sound_1.Sound.hit();
                                this.shakeScreen(this.x, this.y, e.x, e.y);
                                this.hitShake(this.x, this.y, e.x, e.y);
                                this.game.levels[this.depth].rooms[this.levelID].tick(this);
                                return;
                            }
                        }
                        else {
                            if (this.game.levels[this.depth].rooms[this.levelID] ===
                                this.game.room)
                                sound_1.Sound.push();
                            // here pushedEnemies may still be []
                            for (const f of pushedEnemies) {
                                f.lastX = f.x;
                                f.lastY = f.y;
                                f.x += dx;
                                f.y += dy;
                                f.drawX = dx;
                                f.drawY = dy;
                                f.skipNextTurns = 1; // skip next turn, so they don't move while we're pushing them
                            }
                            if (this.game.levels[this.depth].rooms[this.levelID].roomArray[nextX][nextY].canCrushEnemy() ||
                                enemyEnd) {
                                const pushedEnemy = pushedEnemies[pushedEnemies.length - 1];
                                pushedEnemy.crush();
                                if (pushedEnemy.isEnemy) {
                                    sound_1.Sound.playSquish();
                                }
                                if (this.game.levels[this.depth].rooms[this.levelID] ===
                                    this.game.room)
                                    sound_1.Sound.hit();
                            }
                            e.x += dx;
                            e.y += dy;
                            e.drawX = dx;
                            e.drawY = dy;
                            this.move(x, y);
                            this.moveDistance++;
                            this.game.levels[this.depth].rooms[this.levelID].tick(this);
                            return;
                        }
                    }
                    else {
                        // if we're trying to hit an enemy, check if it's destroyable
                        if (!e.dead) {
                            if (e.interactable)
                                e.interact(this);
                            //this.actionTab.actionState = ActionState.ATTACK;
                            //sets the action tab state to Attack
                            return;
                        }
                    }
                }
            }
            let other = this.game.levels[this.depth].rooms[this.levelID]?.roomArray?.[x]?.[y];
            if (!other) {
                console.warn("oi bruv, tile to check for collision isn't even there!");
                return;
            }
            if (!this.game.levels[this.depth].rooms[this.levelID]) {
                console.warn("oi bruv, room to check for collision isn't even there!");
                return;
            }
            if (!this.game.levels[this.depth].rooms[this.levelID].roomArray) {
                console.warn("oi bruv, level to check for collision isn't even there!");
                return;
            }
            if (!other.isSolid()) {
                if (other instanceof upLadder_1.UpLadder || other instanceof downLadder_1.DownLadder) {
                    const locked = other.isLocked();
                    if (locked) {
                        this.shakeScreen(this.x, this.y, x, y);
                        if (other.lockable.canUnlock(this)) {
                            other.lockable.unlock(this);
                        }
                        else {
                            sound_1.Sound.playLocked();
                        }
                        other.addLightSource();
                        this.game.room.updateLighting();
                        return;
                    }
                }
                this.move(x, y);
                other.onCollide(this);
                if (!(other instanceof door_1.Door ||
                    other instanceof trapdoor_1.Trapdoor ||
                    other instanceof upLadder_1.UpLadder ||
                    other instanceof downLadder_1.DownLadder))
                    this.game.levels[this.depth].rooms[this.levelID].tick(this);
            }
            else {
                if (other instanceof door_1.Door) {
                    this.shakeScreen(this.x, this.y, x, y);
                    if (other.canUnlock(this)) {
                        other.unlock(this);
                    }
                    else {
                        sound_1.Sound.playLocked();
                    }
                }
            }
        };
        this.updateLastPosition = (x, y) => {
            this.lastX = x;
            this.lastY = y;
        };
        this.hurt = (damage, enemy) => {
            // Play hurt sound if in current room
            if (this.game.levels[this.depth].rooms[this.levelID] === this.game.room) {
                sound_1.Sound.hurt();
                sound_1.Sound.playGrunt();
            }
            // Handle armor damage
            if (this.inventory.getArmor() && this.inventory.getArmor().health > 0) {
                this.inventory.getArmor().hurt(damage);
                this.renderer.hurtShield();
                this.hurtShield = true;
            }
            // Update player state
            this.lastHitBy = enemy;
            this.healthBar.hurt();
            this.renderer.flash();
            this.enemyHurtMessage(damage, enemy);
            // Apply damage if no shield
            if (!this.hurtShield) {
                this.health -= damage;
            }
            this.hurtShield = false;
            this.renderer.hurt();
            // Check for death
            if (this.health <= 0 && !gameConstants_1.GameConstants.DEVELOPER_MODE) {
                this.dead = true;
            }
        };
        this.enemyHurtMessage = (damage, enemy) => {
            this.game.pushMessage(`The ${enemy} hits you for ${damage} damage.`);
        };
        this.beginSlowMotion = () => {
            this.renderer.beginSlowMotion();
        };
        this.endSlowMotion = () => {
            this.renderer.endSlowMotion();
        };
        this.move = (x, y) => {
            this.updateLastPosition(this.x, this.y);
            //this.actionTab.setState(ActionState.MOVE);
            if (this.game.levels[this.depth].rooms[this.levelID] === this.game.room)
                sound_1.Sound.playerStoneFootstep(this.game.room.envType);
            if (this.openVendingMachine)
                this.openVendingMachine.close();
            this.renderer.setNewDrawXY(x, y);
            this.drawMoveQueue.push({
                drawX: x - this.x,
                drawY: y - this.y,
            });
            /*
            if (this.drawX > 1) this.drawX = 1;
            if (this.drawY > 1) this.drawY = 1;
            if (this.drawX < -1) this.drawX = -1;
            if (this.drawY < -1) this.drawY = -1;
            */
            this.x = x;
            this.y = y;
            for (let i of this.game.levels[this.depth].rooms[this.levelID].items) {
                if (i.x === x && i.y === y) {
                    i.onPickup(this);
                }
            }
            let diffX = x - this.lastX;
            let diffY = y - this.lastY;
            if (diffX === 0 && diffY === 0)
                return;
            //this.game.rooms[this.levelID].updateLighting();
            let roomsOnScreen = 0;
            for (let room of this.game.level.rooms) {
                room.roomOnScreen(this);
                //console.log("On Screen? " + room.onScreen + " levelID: " + room.id);
                if (room.onScreen)
                    roomsOnScreen++;
            }
            //console.log("Rooms On Screen Currently: " + roomsOnScreen);
        };
        this.moveNoSmooth = (x, y) => {
            // doesn't touch smoothing
            this.x = x;
            this.y = y;
        };
        this.moveSnap = (x, y) => {
            // no smoothing
            this.x = Math.round(x);
            this.y = Math.round(y);
            this.renderer.snapDrawStuff();
        };
        this.update = () => { };
        this.finishTick = () => {
            this.turnCount += 1;
            this.inventory.tick();
            this.renderer.disableFlash();
            let totalHealthDiff = this.health - this.lastTickHealth;
            this.lastTickHealth = this.health; // update last tick health
            if (totalHealthDiff < 0) {
                this.renderer.flash();
            }
            this.moveDistance = 0;
            //this.actionTab.actionState = ActionState.READY;
            //Sets the action tab state to Wait (during enemy turn)
        };
        this.draw = (delta) => {
            this.renderer.draw(delta);
        };
        this.heal = (amount) => {
            this.health += amount;
            if (this.health > this.maxHealth)
                this.health = this.maxHealth;
        };
        this.hitShake = (playerX, playerY, otherX, otherY) => {
            const range = gameConstants_1.GameConstants.TILESIZE;
            const hitX = Math.min(Math.max(0.5 * (playerX - otherX), -range), range);
            const hitY = Math.min(Math.max(0.5 * (playerY - otherY), -range), range);
            this.renderer.setHitXY(hitX, hitY);
        };
        this.shakeScreen = (playerX, playerY, otherX, otherY, shakeStrength = 10) => {
            const range = gameConstants_1.GameConstants.TILESIZE;
            const shakeX = Math.min(Math.max(0.5 * (playerX - otherX), -range), range);
            const shakeY = Math.min(Math.max(0.5 * (playerY - otherY), -range), range);
            this.renderer.setHitXY(shakeX, shakeY);
            this.game.shakeScreen(-shakeX * 1 * shakeStrength, -shakeY * 1 * shakeStrength);
        };
        this.updateSlowMotion = () => {
            this.renderer.updateSlowMotion();
        };
        this.drawGUI = (delta) => {
            this.renderer.drawGUI(delta);
        };
        this.globalId = IdGenerator_1.IdGenerator.generate("P");
        this.game = game;
        this.levelID = 0;
        this.x = x;
        this.y = y;
        this.w = 1;
        this.h = 1;
        this.moveDistance = 0;
        this.direction = game_1.Direction.UP;
        this.lastDirection = game_1.Direction.UP;
        this.lastX = 0;
        this.lastY = 0;
        this.isLocalPlayer = isLocalPlayer;
        this.depth = 0;
        this.menu = new menu_1.Menu(this);
        this.busyAnimating = false;
        this.mapToggled = true;
        this.health = 2;
        this.maxHealth = 2;
        this.healthBar = new healthbar_1.HealthBar();
        this.dead = false;
        this.lastTickHealth = this.health;
        this.inventory = new inventory_1.Inventory(game, this);
        this.defaultSightRadius = 3;
        this.sightRadius = levelConstants_1.LevelConstants.LIGHTING_MAX_DISTANCE; //this.defaultSightRadius;
        this.map = new map_1.Map(this.game, this);
        this.turnCount = 0;
        this.triedMove = false;
        this.tutorialRoom = false;
        this.tileCursor = { x: 0, y: 0 };
        this.moveRange = 1;
        this.lightEquipped = false;
        this.lightColor = levelConstants_1.LevelConstants.AMBIENT_LIGHT_COLOR;
        this.hurtShield = false;
        this.lightBrightness = 0.3;
        this.moveQueue = [];
        this.justMoved = DrawDirection.Y;
        this.inputHandler = new playerInputHandler_1.PlayerInputHandler(this);
        this.actionProcessor = new playerActionProcessor_1.PlayerActionProcessor(this);
        this.movement = new playerMovement_1.PlayerMovement(this);
        this.renderer = new playerRenderer_1.PlayerRenderer(this);
        this.bestiary = new bestiary_1.Bestiary(this.game, this);
        this.cooldownRemaining = 0;
    }
    get hitX() {
        return this.renderer?.drawX ?? 0;
    }
    get hitY() {
        return this.renderer?.drawY ?? 0;
    }
    get drawX() {
        return this.renderer?.drawX ?? 0;
    }
    get drawY() {
        return this.renderer?.drawY ?? 0;
    }
}
exports.Player = Player;
Player.minSightRadius = 2; //hard minimum sight radius that ignores depth


/***/ }),

/***/ "./src/player/playerActionProcessor.ts":
/*!*********************************************!*\
  !*** ./src/player/playerActionProcessor.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PlayerActionProcessor = void 0;
class PlayerActionProcessor {
    constructor(player) {
        this.player = player;
    }
    process(action) {
        switch (action.type) {
            case "Move":
                this.player.movement.move(action.direction, action.targetX, action.targetY);
                break;
            case "MouseMove":
                this.player.movement.moveMouse(action.direction, action.targetX, action.targetY);
                break;
            case "OpenInventory":
                this.player.inventory.open();
                break;
            case "CloseInventory":
                this.player.inventory.close();
                break;
            case "Restart":
                this.player.restart();
                break;
            case "Attack":
                // TODO: Route to PlayerCombat module once it's ready
                console.warn("Attack action received but not yet implemented.");
                break;
            case "Interact":
                this.player.tryMove(action.target.x, action.target.y); // will replace with cleaner interaction API later
                break;
        }
    }
}
exports.PlayerActionProcessor = PlayerActionProcessor;


/***/ }),

/***/ "./src/player/playerInputHandler.ts":
/*!******************************************!*\
  !*** ./src/player/playerInputHandler.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PlayerInputHandler = void 0;
const input_1 = __webpack_require__(/*! ../game/input */ "./src/game/input.ts");
const game_1 = __webpack_require__(/*! ../game */ "./src/game.ts");
const mouseCursor_1 = __webpack_require__(/*! ../gui/mouseCursor */ "./src/gui/mouseCursor.ts");
const vendingMachine_1 = __webpack_require__(/*! ../entity/object/vendingMachine */ "./src/entity/object/vendingMachine.ts");
const gameConstants_1 = __webpack_require__(/*! ../game/gameConstants */ "./src/game/gameConstants.ts");
const muteButton_1 = __webpack_require__(/*! ../gui/muteButton */ "./src/gui/muteButton.ts");
const sound_1 = __webpack_require__(/*! ../sound/sound */ "./src/sound/sound.ts");
class PlayerInputHandler {
    constructor(player) {
        this.mouseHoldInitialDirection = null;
        this.handleNumKey = (num) => {
            if (this.player.menu.open)
                return;
            this.setMostRecentInput("keyboard");
            if (num <= 5) {
                this.player.inventory.selX = Math.max(0, Math.min(num - 1, this.player.inventory.cols - 1));
                this.player.inventory.selY = 0;
                this.player.inventory.itemUse();
            }
            else {
                if (gameConstants_1.GameConstants.DEVELOPER_MODE) {
                    switch (num) {
                        case 6:
                            gameConstants_1.GameConstants.SET_SHADE_LAYER_COMPOSITE_OPERATION(true);
                            break;
                        case 7:
                            gameConstants_1.GameConstants.SET_SHADE_LAYER_COMPOSITE_OPERATION(false);
                            break;
                    }
                }
            }
        };
        this.ignoreDirectionInput = () => {
            return (this.player.inventory.isOpen ||
                this.player.dead ||
                this.player.game.levelState !== game_1.LevelState.IN_LEVEL ||
                this.player.menu.open ||
                (this.player.inventory.isPointInQuickbarBounds(input_1.Input.mouseX, input_1.Input.mouseY)
                    .inBounds &&
                    this.player.game.isMobile));
        };
        this.setMostRecentInput = (input) => {
            this.mostRecentInput = input;
        };
        this.setMostRecentMoveInput = (input) => {
            this.mostRecentMoveInput = input;
        };
        this.mouseAngle = () => {
            const mousePosition = mouseCursor_1.MouseCursor.getInstance().getPosition();
            const playerPixelPosition = {
                x: gameConstants_1.GameConstants.WIDTH / 2,
                y: gameConstants_1.GameConstants.HEIGHT / 2,
            };
            const dx = mousePosition.x - playerPixelPosition.x;
            const dy = mousePosition.y - playerPixelPosition.y;
            return Math.atan2(dy, dx);
        };
        this.faceMouse = () => {
            if (!gameConstants_1.GameConstants.MOVE_WITH_MOUSE ||
                this.mostRecentMoveInput === "keyboard" ||
                gameConstants_1.GameConstants.isMobile)
                return;
            const angle = this.mouseAngle();
            // Convert angle to direction
            // atan2 returns angle in radians (-π to π)
            // Divide the circle into 4 sectors for the 4 directions
            if (angle >= -Math.PI / 4 && angle < Math.PI / 4) {
                this.player.direction = game_1.Direction.RIGHT;
            }
            else if (angle >= Math.PI / 4 && angle < (3 * Math.PI) / 4) {
                this.player.direction = game_1.Direction.DOWN;
            }
            else if (angle >= (-3 * Math.PI) / 4 && angle < -Math.PI / 4) {
                this.player.direction = game_1.Direction.UP;
            }
            else {
                this.player.direction = game_1.Direction.LEFT;
            }
        };
        this.player = player;
        this.mostRecentInput = "keyboard";
        this.mostRecentMoveInput = "keyboard";
        this.moveStartTime = 0;
        if (player.isLocalPlayer) {
            this.setupListeners();
        }
    }
    setupListeners() {
        input_1.Input.leftSwipeListener = () => this.handleInput(input_1.InputEnum.LEFT);
        input_1.Input.rightSwipeListener = () => this.handleInput(input_1.InputEnum.RIGHT);
        input_1.Input.upSwipeListener = () => this.handleInput(input_1.InputEnum.UP);
        input_1.Input.downSwipeListener = () => this.handleInput(input_1.InputEnum.DOWN);
        input_1.Input.commaListener = () => this.handleInput(input_1.InputEnum.COMMA);
        input_1.Input.periodListener = () => this.handleInput(input_1.InputEnum.PERIOD);
        input_1.Input.tapListener = () => this.handleTap();
        input_1.Input.mouseMoveListener = () => this.handleInput(input_1.InputEnum.MOUSE_MOVE);
        input_1.Input.mouseRightClickListeners.push(() => this.handleInput(input_1.InputEnum.RIGHT_CLICK));
        input_1.Input.mouseDownListeners.push((x, y, button) => this.handleMouseDown(x, y, button));
        input_1.Input.numKeyListener = (num) => this.handleInput(input_1.InputEnum.NUMBER_1 + num - 1);
        input_1.Input.equalsListener = () => this.handleInput(input_1.InputEnum.EQUALS);
        input_1.Input.minusListener = () => this.handleInput(input_1.InputEnum.MINUS);
        input_1.Input.escapeListener = () => this.handleInput(input_1.InputEnum.ESCAPE);
        input_1.Input.fListener = () => this.handleInput(input_1.InputEnum.F);
    }
    handleInput(input) {
        if (this.player.busyAnimating || this.player.game.cameraAnimation.active)
            return;
        // Block input during level transitions, except for mouse movement
        if ((this.player.game.levelState === game_1.LevelState.TRANSITIONING ||
            this.player.game.levelState === game_1.LevelState.TRANSITIONING_LADDER) &&
            input !== input_1.InputEnum.MOUSE_MOVE) {
            return;
        }
        if (this.player.menu.open) {
            this.player.menu.inputHandler(input);
            return;
        }
        if (!this.player.game.started && input !== input_1.InputEnum.MOUSE_MOVE) {
            this.player.game.startedFadeOut = true;
            return;
        }
        switch (input) {
            case input_1.InputEnum.I:
                this.player.inventory.toggleOpen();
                break;
            case input_1.InputEnum.Q:
                this.player.inventory.drop();
                break;
            case input_1.InputEnum.F:
                //this.player.game.newGame();
                //this.player.stall();
                break;
            case input_1.InputEnum.LEFT:
                if (!this.ignoreDirectionInput())
                    this.player.actionProcessor.process({
                        type: "Move",
                        direction: game_1.Direction.LEFT,
                        targetX: this.player.x - 1,
                        targetY: this.player.y,
                    });
                break;
            case input_1.InputEnum.RIGHT:
                if (!this.ignoreDirectionInput())
                    this.player.actionProcessor.process({
                        type: "Move",
                        direction: game_1.Direction.RIGHT,
                        targetX: this.player.x + 1,
                        targetY: this.player.y,
                    });
                break;
            case input_1.InputEnum.UP:
                if (!this.ignoreDirectionInput())
                    this.player.actionProcessor.process({
                        type: "Move",
                        direction: game_1.Direction.UP,
                        targetX: this.player.x,
                        targetY: this.player.y - 1,
                    });
                break;
            case input_1.InputEnum.DOWN:
                if (!this.ignoreDirectionInput())
                    this.player.actionProcessor.process({
                        type: "Move",
                        direction: game_1.Direction.DOWN,
                        targetX: this.player.x,
                        targetY: this.player.y + 1,
                    });
                break;
            case input_1.InputEnum.SPACE:
                const player = this.player;
                this.setMostRecentInput("keyboard");
                if (player.game.chatOpen)
                    return;
                if (player.dead) {
                    player.restart();
                    return;
                }
                if (this.player.openVendingMachine &&
                    this.player.openVendingMachine.open) {
                    this.player.openVendingMachine.space();
                    break;
                }
                if (player.inventory.isOpen ||
                    player.game.levelState === game_1.LevelState.IN_LEVEL) {
                    this.setMostRecentInput("keyboard");
                    player.inventory.itemUse();
                }
                break;
            case input_1.InputEnum.COMMA:
                this.setMostRecentInput("keyboard");
                this.player.inventory.left();
                break;
            case input_1.InputEnum.PERIOD:
                this.setMostRecentInput("keyboard");
                this.player.inventory.right();
                break;
            case input_1.InputEnum.LEFT_CLICK:
                this.handleMouseLeftClick();
                break;
            case input_1.InputEnum.RIGHT_CLICK:
                this.handleMouseRightClick();
                break;
            case input_1.InputEnum.MOUSE_MOVE:
                //when mouse moves
                this.setMostRecentInput("mouse");
                this.player.inventory.mouseMove();
                // Check if mouse hold should be cancelled
                if (input_1.Input.mouseDown && input_1.Input.mouseDownHandled) {
                    let shouldCancelHold = false;
                    // Check distance from initial position
                    const dx = input_1.Input.mouseX - input_1.Input.lastMouseDownX;
                    const dy = input_1.Input.mouseY - input_1.Input.lastMouseDownY;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    const maxHoldDistance = gameConstants_1.GameConstants.TILESIZE * 1.5; // 1.5 tiles
                    if (distance > maxHoldDistance) {
                        shouldCancelHold = true;
                    }
                    // Check if player direction changed from initial
                    if (this.mouseHoldInitialDirection !== null &&
                        this.player.direction !== this.mouseHoldInitialDirection) {
                        shouldCancelHold = true;
                    }
                    if (shouldCancelHold) {
                        input_1.Input.mouseDownHandled = false;
                        input_1.Input.lastMouseDownTime = 0;
                        this.mouseHoldInitialDirection = null;
                    }
                }
                if (!this.ignoreDirectionInput() || gameConstants_1.GameConstants.isMobile) {
                    this.faceMouse();
                    this.player.setTileCursorPosition();
                }
                break;
            case input_1.InputEnum.NUMBER_1:
            case input_1.InputEnum.NUMBER_2:
            case input_1.InputEnum.NUMBER_3:
            case input_1.InputEnum.NUMBER_4:
            case input_1.InputEnum.NUMBER_5:
            case input_1.InputEnum.NUMBER_6:
            case input_1.InputEnum.NUMBER_7:
            case input_1.InputEnum.NUMBER_8:
            case input_1.InputEnum.NUMBER_9:
                this.setMostRecentInput("keyboard");
                this.handleNumKey(input - 13);
                break;
            case input_1.InputEnum.EQUALS:
                this.player.game.increaseScale();
                break;
            case input_1.InputEnum.MINUS:
                this.player.game.decreaseScale();
                break;
            case input_1.InputEnum.ESCAPE:
                this.player.inventory.close();
                break;
        }
    }
    handleMouseRightClick() {
        this.setMostRecentInput("mouse");
        const { x, y } = mouseCursor_1.MouseCursor.getInstance().getPosition();
        const bounds = this.player.inventory.isPointInInventoryBounds(x, y);
        if (bounds.inBounds) {
            this.player.inventory.drop();
        }
    }
    handleMouseDown(x, y, button) {
        if (button !== 0)
            return; // Only handle left mouse button
        const player = this.player;
        if (player.game.levelState !== game_1.LevelState.IN_LEVEL) {
            input_1.Input.mouseDownHandled = false;
            return;
        }
        this.setMostRecentInput("mouse");
        // Handle dead player restart
        if (player.dead) {
            player.restart();
            input_1.Input.mouseDownHandled = true;
            return;
        }
        // Handle game not started
        if (!player.game.started) {
            player.game.startedFadeOut = true;
            input_1.Input.mouseDownHandled = true;
            return;
        }
        // Store mouse down info for repeat
        input_1.Input.lastMouseDownTime = Date.now();
        input_1.Input.lastMouseDownX = x;
        input_1.Input.lastMouseDownY = y;
        const inventory = player.inventory;
        // Handle inventory toggle when clicking outside or on inventory button
        const clickedOutsideInventory = (inventory.isOpen &&
            !inventory.isPointInInventoryBounds(x, y).inBounds) ||
            inventory.isPointInInventoryButton(x, y);
        if (clickedOutsideInventory) {
            inventory.toggleOpen();
            input_1.Input.mouseDownHandled = true;
            return;
        }
        // Handle menu
        if (this.player.menu.open) {
            this.player.menu.mouseInputHandler(x, y);
            input_1.Input.mouseDownHandled = true;
            return;
        }
        // Check if click is on menu button
        if (this.isPointInMenuButtonBounds(x, y)) {
            this.handleMenuButtonClick();
            input_1.Input.mouseDownHandled = true;
            return;
        }
        // Handle vending machine
        if (player.openVendingMachine) {
            if (vendingMachine_1.VendingMachine.isPointInVendingMachineBounds(x, y, player.openVendingMachine)) {
                player.openVendingMachine.space();
            }
            else {
                player.openVendingMachine.close();
            }
            input_1.Input.mouseDownHandled = true;
            return;
        }
        // Check if this is a UI interaction
        const isUIInteraction = inventory.isPointInInventoryButton(x, y) ||
            inventory.isPointInQuickbarBounds(x, y).inBounds ||
            inventory.isOpen ||
            this.isPointInMenuButtonBounds(x, y);
        if (!isUIInteraction) {
            // Handle movement
            if (!player.busyAnimating && !player.game.cameraAnimation.active) {
                // Store the initial direction when starting mouse hold for movement
                this.mouseHoldInitialDirection = this.player.direction;
                player.moveWithMouse();
                input_1.Input.mouseDownHandled = true;
            }
            else {
                input_1.Input.mouseDownHandled = false;
            }
        }
        else {
            input_1.Input.mouseDownHandled = false;
        }
    }
    handleMouseLeftClick() {
        const player = this.player;
        const cursor = mouseCursor_1.MouseCursor.getInstance();
        const { x, y } = cursor.getPosition();
        if (player.game.levelState !== game_1.LevelState.IN_LEVEL) {
            return;
        }
        this.setMostRecentInput("mouse");
        if (player.dead) {
            player.restart();
            return;
        }
        const inventory = player.inventory;
        const clickedOutsideInventory = (inventory.isOpen &&
            !inventory.isPointInInventoryBounds(x, y).inBounds) ||
            inventory.isPointInInventoryButton(x, y);
        if (clickedOutsideInventory) {
            inventory.toggleOpen();
        }
        if (this.player.menu.open) {
            this.player.menu.mouseInputHandler(x, y);
            return;
        }
        else {
        }
        // Check if click is on menu button
        if (this.isPointInMenuButtonBounds(x, y)) {
            this.handleMenuButtonClick();
            return;
        }
        if (player.openVendingMachine) {
            if (vendingMachine_1.VendingMachine.isPointInVendingMachineBounds(x, y, player.openVendingMachine)) {
                player.openVendingMachine.space();
            }
            else {
                player.openVendingMachine.close();
                this.setMostRecentInput("mouse");
                const { x, y } = mouseCursor_1.MouseCursor.getInstance().getPosition();
                const bounds = this.player.inventory.isPointInInventoryBounds(x, y);
            }
            return;
        }
        const notInInventoryUI = !inventory.isPointInInventoryButton(x, y) &&
            !inventory.isPointInQuickbarBounds(x, y).inBounds &&
            !inventory.isOpen;
        // Only handle movement if it wasn't already handled on mousedown
        if (notInInventoryUI && !input_1.Input.mouseDownHandled) {
            player.moveWithMouse();
        }
    }
    handleTap() {
        // If the interaction was already handled by mouseDown, don't process it again
        if (input_1.Input.mouseDownHandled) {
            return;
        }
        if (this.player.dead) {
            this.player.restart();
            return;
        }
        else if (!this.player.game.started) {
            this.player.game.startedFadeOut = true;
            return;
        }
        if (this.player.menu.open) {
            this.player.menu.mouseInputHandler(input_1.Input.mouseX, input_1.Input.mouseY);
            return;
        }
        const x = input_1.Input.mouseX;
        const y = input_1.Input.mouseY;
        // Check if tap is on menu button
        if (this.isPointInMenuButtonBounds(x, y)) {
            this.handleMenuButtonClick();
            return;
        }
        const isInInventory = this.player.inventory.isPointInInventoryBounds(x, y).inBounds;
        const isInQuickbar = this.player.inventory.isPointInQuickbarBounds(x, y).inBounds;
        if (this.player.openVendingMachine && this.player.openVendingMachine.open) {
            const isInVMUI = vendingMachine_1.VendingMachine.isPointInVendingMachineBounds(input_1.Input.mouseX, input_1.Input.mouseY, this.player.openVendingMachine);
            if (isInVMUI) {
                this.player.openVendingMachine.space();
                return;
            }
            else if (!isInVMUI) {
                this.player.openVendingMachine.close();
                this.setMostRecentInput("mouse");
                const { x, y } = mouseCursor_1.MouseCursor.getInstance().getPosition();
                const bounds = this.player.inventory.isPointInInventoryBounds(x, y);
            }
            return;
        }
        if (!this.player.inventory.isOpen &&
            this.player.inventory.isPointInInventoryButton(x, y)) {
            this.player.inventory.open();
        }
        else if (this.player.inventory.isOpen) {
            if (isInInventory) {
                this.handleInput(input_1.InputEnum.LEFT_CLICK);
            }
            else {
                this.player.inventory.close();
            }
        }
        else if (isInQuickbar) {
            this.handleInput(input_1.InputEnum.LEFT_CLICK);
        }
    }
    handleKeyboardKey(key) {
        switch (key.toUpperCase()) {
            case "A":
            case "ARROWLEFT":
                this.handleInput(input_1.InputEnum.LEFT);
                break;
            case "D":
            case "ARROWRIGHT":
                this.handleInput(input_1.InputEnum.RIGHT);
                break;
            case "W":
            case "ARROWUP":
                this.handleInput(input_1.InputEnum.UP);
                break;
            case "S":
            case "ARROWDOWN":
                this.handleInput(input_1.InputEnum.DOWN);
                break;
            case " ":
                this.handleInput(input_1.InputEnum.SPACE);
                break;
            case "I":
                this.handleInput(input_1.InputEnum.I);
                break;
            case "Q":
                this.handleInput(input_1.InputEnum.Q);
                break;
            // Possibly add number keys for inventory here too
            default:
                // Unknown key; ignore or log if needed
                break;
        }
    }
    // Dummy methods for mute button functionality
    isPointInMuteButtonBounds(x, y) {
        const tile = gameConstants_1.GameConstants.TILESIZE;
        //mute button is at the top left of the screen right below the fps counter and is 1 tile wide and tall
        return x >= 0 && x <= tile && y >= 0 && y <= tile * 1.5;
    }
    handleMuteButtonClick() {
        muteButton_1.MuteButton.toggleMute();
        this.player.game.pushMessage(sound_1.Sound.audioMuted ? "Audio muted" : "Audio unmuted");
    }
    isPointInMenuButtonBounds(x, y) {
        const tile = gameConstants_1.GameConstants.TILESIZE;
        //menu button is at the top left of the screen right below the fps counter and is 1 tile wide and tall
        return x >= 0 && x <= tile * 1.5 && y >= 0 && y <= tile;
    }
    handleMenuButtonClick() {
        this.player.menu.toggleOpen();
    }
}
exports.PlayerInputHandler = PlayerInputHandler;


/***/ }),

/***/ "./src/player/playerMovement.ts":
/*!**************************************!*\
  !*** ./src/player/playerMovement.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PlayerMovement = void 0;
const game_1 = __webpack_require__(/*! ../game */ "./src/game.ts");
const gameConstants_1 = __webpack_require__(/*! ../game/gameConstants */ "./src/game/gameConstants.ts");
const room_1 = __webpack_require__(/*! ../room/room */ "./src/room/room.ts");
class PlayerMovement {
    constructor(player) {
        this.moveQueue = [];
        this.isProcessingQueue = false;
        this.animationFrameId = null;
        this.moveRange = 1;
        this.lastMoveTime = 0;
        this.lastChangeDirectionTime = 0;
        this.adjustedCooldown = 0;
        //unused
        this.moveRangeCheck = (x, y) => {
            const dx = Math.abs(this.player.x - x);
            const dy = Math.abs(this.player.y - y);
            return (dx <= this.moveRange &&
                dy <= this.moveRange &&
                (dx === 0 || dy === 0) &&
                dx + dy !== 0);
        };
        this.queueHandler = () => {
            if (!this.isProcessingQueue)
                return;
            const now = Date.now();
            const cooldown = gameConstants_1.GameConstants.MOVEMENT_COOLDOWN;
            if (now - this.lastMoveTime >= cooldown) {
                if (this.moveQueue.length > 0) {
                    const nextMove = this.moveQueue.shift();
                    this.handleMoveLoop(nextMove);
                    this.lastMoveTime = now;
                }
                else {
                    this.stopQueueProcessing();
                }
            }
            this.animationFrameId = requestAnimationFrame(this.queueHandler);
        };
        this.player = player;
    }
    move(direction, targetX, targetY) {
        if (!(direction in game_1.Direction) || !this.player)
            return;
        const coords = this.getTargetCoords(direction, targetX, targetY);
        if (!coords)
            return;
        const { x, y } = coords;
        if (this.canMove()) {
            const now = Date.now();
            this.lastMoveTime = now;
            this.lastChangeDirectionTime = now;
            this.player.inputHandler.setMostRecentMoveInput("keyboard");
            this.player.lastDirection = this.player.direction;
            this.player.direction = direction;
            this.player.tryMove(x, y);
        }
        else {
            this.queueMove(x, y, direction);
        }
    }
    moveMouse(direction, targetX, targetY) {
        if (!(direction in game_1.Direction) || !this.player || gameConstants_1.GameConstants.isMobile)
            return;
        const coords = this.getTargetCoords(direction, targetX, targetY);
        if (!coords)
            return;
        const { x, y } = coords;
        if (x === undefined || y === undefined)
            return;
        if (this.canMove()) {
            const now = Date.now();
            this.lastMoveTime = now;
            this.player.inputHandler.setMostRecentMoveInput("mouse");
            this.player.direction = direction;
            this.player.tryMove(x, y);
        }
        else {
            this.queueMove(x, y, direction);
        }
    }
    getTargetCoords(direction, x, y) {
        if (x !== undefined && y !== undefined && x !== null && y !== null) {
            return { x, y };
        }
        switch (direction) {
            case game_1.Direction.LEFT:
                return { x: this.player.x - 1, y: this.player.y };
            case game_1.Direction.RIGHT:
                return { x: this.player.x + 1, y: this.player.y };
            case game_1.Direction.UP:
                return { x: this.player.x, y: this.player.y - 1 };
            case game_1.Direction.DOWN:
                return { x: this.player.x, y: this.player.y + 1 };
            default:
                return null;
        }
    }
    inventoryClosedRecently() {
        const timeSinceDragEnd = Date.now() - this.player.inventory.dragEndTime;
        const timeSinceClose = Date.now() - this.player.inventory.closeTime;
        return timeSinceDragEnd < 10 || timeSinceClose < 10;
    }
    canMove() {
        if (this.inventoryClosedRecently())
            return false;
        // Only block movement during computer turn if slow inputs setting is enabled
        if (gameConstants_1.GameConstants.SLOW_INPUTS_NEAR_ENEMIES &&
            this.player.game.room.turn === room_1.TurnState.computerTurn &&
            this.player.game.room.hasEnemyInRadius(this.player.x, this.player.y)) {
            return false;
        }
        const now = Date.now();
        let cooldown = gameConstants_1.GameConstants.MOVEMENT_COOLDOWN;
        // Apply slower cooldown when enemies are nearby and setting is enabled
        if (gameConstants_1.GameConstants.SLOW_INPUTS_NEAR_ENEMIES &&
            this.player.game.room.hasEnemyInRadius(this.player.x, this.player.y)) {
            cooldown *= 2; // Double the cooldown when enemies are nearby
        }
        if (now - this.lastMoveTime >= cooldown) {
            return true;
        }
        return false;
    }
    canQueue() {
        if (this.inventoryClosedRecently())
            return false;
        const now = Date.now();
        let cooldown = gameConstants_1.GameConstants.MOVEMENT_QUEUE_COOLDOWN;
        // Apply slower queue cooldown when enemies are nearby and setting is enabled
        if (gameConstants_1.GameConstants.SLOW_INPUTS_NEAR_ENEMIES &&
            this.player.game.room.hasEnemyInRadius(this.player.x, this.player.y)) {
            cooldown *= 2; // Double the queue cooldown when enemies are nearby
        }
        if (now - this.lastMoveTime >= cooldown) {
            return true;
        }
        return false;
    }
    queueMove(x, y, direction) {
        if (!this.canQueue())
            return;
        if (x === undefined || y === undefined || this.moveQueue.length > 0)
            return;
        this.moveQueue.push({ x, y, direction });
        this.startQueueProcessing();
    }
    handleMoveLoop({ x, y, direction, }) {
        if (this.player.inputHandler.mostRecentMoveInput === "mouse") {
            this.moveMouse(direction, x, y);
        }
        else {
            this.move(direction, x, y);
        }
    }
    startQueueProcessing() {
        if (!this.isProcessingQueue) {
            this.isProcessingQueue = true;
            this.animationFrameId = requestAnimationFrame(() => this.queueHandler());
        }
    }
    stopQueueProcessing() {
        this.isProcessingQueue = false;
        if (this.animationFrameId !== null) {
            cancelAnimationFrame(this.animationFrameId);
            this.animationFrameId = null;
        }
    }
}
exports.PlayerMovement = PlayerMovement;


/***/ }),

/***/ "./src/player/playerRenderer.ts":
/*!**************************************!*\
  !*** ./src/player/playerRenderer.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PlayerRenderer = void 0;
const game_1 = __webpack_require__(/*! ../game */ "./src/game.ts");
const gameConstants_1 = __webpack_require__(/*! ../game/gameConstants */ "./src/game/gameConstants.ts");
const hitWarning_1 = __webpack_require__(/*! ../drawable/hitWarning */ "./src/drawable/hitWarning.ts");
const levelConstants_1 = __webpack_require__(/*! ../level/levelConstants */ "./src/level/levelConstants.ts");
const postProcess_1 = __webpack_require__(/*! ../gui/postProcess */ "./src/gui/postProcess.ts");
const stats_1 = __webpack_require__(/*! ../game/stats */ "./src/game/stats.ts");
const utils_1 = __webpack_require__(/*! ../utility/utils */ "./src/utility/utils.ts");
const spellbook_1 = __webpack_require__(/*! ../item/weapon/spellbook */ "./src/item/weapon/spellbook.ts");
const hoverText_1 = __webpack_require__(/*! ../gui/hoverText */ "./src/gui/hoverText.ts");
class PlayerRenderer {
    constructor(player) {
        this.hurt = () => {
            this.hurting = true;
            this.hurtAlpha = 0.25;
        };
        this.hurtShield = () => {
            this.hurtingShield = true;
        };
        this.flash = () => {
            this.flashing = true;
        };
        this.disableFlash = () => {
            this.flashing = false;
        };
        this.beginSlowMotion = () => {
            this.slowMotionEnabled = true;
        };
        this.endSlowMotion = () => {
            this.slowMotionEnabled = false;
        };
        this.setNewDrawXY = (x, y) => {
            this.drawX += x - this.player.x;
            this.drawY += y - this.player.y;
        };
        this.enableSlowMotion = () => {
            if (this.motionSpeed < 1 && !this.slowMotionEnabled) {
                this.motionSpeed *= 1.08;
                if (this.motionSpeed >= 1)
                    this.motionSpeed = 1;
            }
            if (this.slowMotionEnabled && this.motionSpeed > 0.25) {
                this.motionSpeed *= 0.95;
                if (this.motionSpeed < 0.25)
                    this.motionSpeed = 0.25;
            }
        };
        this.updateSlowMotion = () => {
            if (this.slowMotionTickDuration > 0)
                this.slowMotionTickDuration -= 1;
            if (this.slowMotionTickDuration === 0)
                this.slowMotionEnabled = false;
        };
        /**
         * Draws the player sprite to the canvas.
         * Added `ctx.save()` at the beginning and `ctx.restore()` at the end
         * to ensure canvas state is preserved.
         */
        this.drawPlayerSprite = (delta) => {
            const player = this.player;
            game_1.Game.ctx.save(); // Save the current canvas state
            if (this.drawSmear()) {
                game_1.Game.drawMob(this.setSmearFrame().x, this.setSmearFrame().y, 1, 2, player.x - this.drawX - this.hitX, player.y - 1.45 - this.drawY - this.jumpY - this.hitY, 1, 2, this.shadeColor());
            }
            else if (this.player.inputHandler.mostRecentMoveInput === "mouse" &&
                this.mouseDiagonal() &&
                !gameConstants_1.GameConstants.isMobile) {
                const angle = (this.player.inputHandler.mouseAngle() * 180) / Math.PI;
                let diagonalTile = { x: 1, y: 18 };
                if (angle > -150 && angle <= -120)
                    diagonalTile = { x: 3, y: 18 };
                if (angle > -60 && angle <= -30)
                    diagonalTile = { x: 4, y: 18 };
                if (angle > 30 && angle <= 60)
                    diagonalTile = { x: 2, y: 18 };
                if (angle > 120 && angle <= 150)
                    diagonalTile = { x: 1, y: 18 };
                game_1.Game.drawMob(diagonalTile.x, diagonalTile.y, 1, 2, player.x - this.drawX - this.hitX, player.y - 1.45 - this.drawY - this.jumpY - this.hitY, 1, 2, this.shadeColor());
            }
            else {
                this.frame += 0.1 * delta;
                if (this.frame >= 4)
                    this.frame = 0;
                game_1.Game.drawMob(1 + Math.floor(this.frame), 8 + player.direction * 2, 1, 2, player.x - this.drawX - this.hitX, player.y - 1.45 - this.drawY - this.jumpY - this.hitY, 1, 2, this.shadeColor());
            }
            if (player.inventory.getArmor() && player.inventory.getArmor().health > 0) {
                // TODO draw armor
            }
            game_1.Game.ctx.restore(); // Restore the canvas state
        };
        this.mouseDiagonal = () => {
            const angle = (this.player.inputHandler.mouseAngle() * 180) / Math.PI;
            if (angle > 30 && angle < 60)
                return true;
            if (angle > 120 && angle < 150)
                return true;
            if (angle > -150 && angle < -120)
                return true;
            if (angle > -60 && angle < -30)
                return true;
            return false;
        };
        this.drawSmear = () => {
            if (this.player.direction === this.player.lastDirection)
                return false;
            let t = 100;
            const lastDir = this.player.lastDirection;
            const dir = this.player.direction;
            if ((dir === game_1.Direction.UP && lastDir === game_1.Direction.DOWN) ||
                (dir === game_1.Direction.DOWN && lastDir === game_1.Direction.UP) ||
                (dir === game_1.Direction.LEFT && lastDir === game_1.Direction.RIGHT) ||
                (dir === game_1.Direction.RIGHT && lastDir === game_1.Direction.LEFT))
                t = 150;
            const timeSince = Date.now() - this.player.movement.lastChangeDirectionTime;
            if (timeSince <= t)
                return true;
            else
                return false;
        };
        this.setSmearFrame = () => {
            let tile = { x: 1, y: 18 };
            const timeSince = Date.now() - this.player.movement.lastChangeDirectionTime;
            const t = 50;
            if ((this.player.direction === game_1.Direction.UP &&
                this.player.lastDirection === game_1.Direction.LEFT) ||
                (this.player.direction === game_1.Direction.LEFT &&
                    this.player.lastDirection === game_1.Direction.UP)) {
                tile.x = 3;
                return tile;
            }
            if ((this.player.direction === game_1.Direction.UP &&
                this.player.lastDirection === game_1.Direction.RIGHT) ||
                (this.player.direction === game_1.Direction.RIGHT &&
                    this.player.lastDirection === game_1.Direction.UP)) {
                tile.x = 4;
                return tile;
            }
            if ((this.player.direction === game_1.Direction.DOWN &&
                this.player.lastDirection === game_1.Direction.RIGHT) ||
                (this.player.direction === game_1.Direction.RIGHT &&
                    this.player.lastDirection === game_1.Direction.DOWN)) {
                tile.x = 2;
                return tile;
            }
            if ((this.player.direction === game_1.Direction.DOWN &&
                this.player.lastDirection === game_1.Direction.LEFT) ||
                (this.player.direction === game_1.Direction.LEFT &&
                    this.player.lastDirection === game_1.Direction.DOWN)) {
                tile.x = 1;
                return tile;
            }
            if (this.player.direction === game_1.Direction.DOWN &&
                this.player.lastDirection === game_1.Direction.UP) {
                if (timeSince < t)
                    tile.x = 3;
                if (timeSince >= t && timeSince < t * 2) {
                    tile.x = 1;
                    tile.y = 14;
                }
                if (timeSince >= t * 2 && timeSince < t * 3)
                    tile.x = 1;
                return tile;
            }
            if (this.player.direction === game_1.Direction.LEFT &&
                this.player.lastDirection === game_1.Direction.RIGHT) {
                if (timeSince < t)
                    tile.x = 2;
                if (timeSince >= t && timeSince < t * 2) {
                    tile.x = 1;
                    tile.y = 8;
                }
                if (timeSince >= t * 2 && timeSince < t * 3)
                    tile.x = 1;
                return tile;
            }
            if (this.player.direction === game_1.Direction.UP &&
                this.player.lastDirection === game_1.Direction.DOWN) {
                if (timeSince < t)
                    tile.x = 2;
                if (timeSince >= t && timeSince < t * 2) {
                    tile.x = 1;
                    tile.y = 12;
                }
                if (timeSince >= t * 2 && timeSince < t * 3)
                    tile.x = 4;
                return tile;
            }
            if (this.player.direction === game_1.Direction.RIGHT &&
                this.player.lastDirection === game_1.Direction.LEFT) {
                if (timeSince < t)
                    tile.x = 1;
                if (timeSince >= t && timeSince < t * 2) {
                    tile.x = 1;
                    tile.y = 8;
                }
                if (timeSince >= t * 2 && timeSince < t * 3)
                    tile.x = 2;
                return tile;
            }
        };
        this.draw = (delta) => {
            const player = this.player;
            game_1.Game.ctx.save();
            this.updateDrawXY(delta);
            player.drawableY = player.y;
            this.flashingFrame += (delta * 12) / gameConstants_1.GameConstants.FPS;
            if (!player.dead) {
                game_1.Game.drawMob(0, 0, 1, 1, player.x - this.drawX, player.y - this.drawY, 1, 1);
                //this.drawTileCursor(delta);
                if (!this.flashing || Math.floor(this.flashingFrame) % 2 === 0) {
                    this.drawPlayerSprite(delta);
                }
            }
            this.drawSpellBeam(delta);
            game_1.Game.ctx.restore();
        };
        this.drawSpellBeam = (delta) => {
            game_1.Game.ctx.save();
            if (this.player.inventory.getWeapon() instanceof spellbook_1.Spellbook) {
                const spellbook = this.player.inventory.getWeapon();
                spellbook.drawBeams(this.player.x - this.drawX, this.player.y - this.drawY, delta);
            }
            game_1.Game.ctx.restore();
        };
        this.shadeColor = () => {
            const player = this.player;
            if (!gameConstants_1.GameConstants.CUSTOM_SHADER_COLOR_ENABLED) {
                return "black";
            }
            else {
                return utils_1.Utils.rgbToHex(player.game.levels[player.depth].rooms[player.levelID].col[player.x][player.y][0], player.game.levels[player.depth].rooms[player.levelID].col[player.x][player.y][1], player.game.levels[player.depth].rooms[player.levelID].col[player.x][player.y][2]);
            }
        };
        this.drawTopLayer = (delta) => {
            game_1.Game.ctx.save(); // Save the current canvas state
            this.player.healthBar.draw(delta, this.player.health, this.player.maxHealth, this.player.x - this.drawX, this.player.y - this.drawY, !this.flashing || Math.floor(this.flashingFrame) % 2 === 0);
            game_1.Game.ctx.restore(); // Restore the canvas state
        };
        this.updateDrawXY = (delta) => {
            if (!this.doneMoving()) {
                this.drawX *= 0.85 ** delta;
                this.drawY *= 0.85 ** delta;
                this.drawX = Math.abs(this.drawX) < 0.01 ? 0 : this.drawX;
                this.drawY = Math.abs(this.drawY) < 0.01 ? 0 : this.drawY;
            }
            if (this.doneHitting()) {
                this.jump(delta);
            }
            if (!this.doneHitting()) {
                this.updateHitXY(delta);
            }
            this.enableSlowMotion();
            gameConstants_1.GameConstants.ANIMATION_SPEED = this.motionSpeed;
        };
        this.updateHitXY = (delta) => {
            const hitX = this.hitX - this.hitX * 0.3;
            const hitY = this.hitY - this.hitY * 0.3;
            this.hitX = Math.min(Math.max(hitX, -1), 1);
            this.hitY = Math.min(Math.max(hitY, -1), 1);
            if (Math.abs(hitX) < 0.01)
                this.hitX = 0;
            if (Math.abs(hitY) < 0.01)
                this.hitY = 0;
        };
        this.doneMoving = () => {
            let EPSILON = 0.01;
            return Math.abs(this.drawX) < EPSILON && Math.abs(this.drawY) < EPSILON;
        };
        this.doneHitting = () => {
            let EPSILON = 0.01;
            return Math.abs(this.hitX) < EPSILON && Math.abs(this.hitY) < EPSILON;
        };
        this.snapDrawStuff = () => {
            this.drawX = 0;
            this.drawY = 0;
            this.hitX = 0;
            this.hitY = 0;
            this.jumpY = 0;
        };
        this.setHitXY = (x, y) => {
            this.hitX = x;
            this.hitY = y;
        };
        this.drawGUI = (delta, transitioning = false) => {
            game_1.Game.ctx.save();
            if (!this.player.dead) {
                //if (this.player.menu.open) this.player.menu.draw();
                if (this.player.bestiary)
                    this.player.bestiary.draw(delta);
                if (this.guiHeartFrame > 0)
                    this.guiHeartFrame += delta;
                if (this.guiHeartFrame > 5) {
                    this.guiHeartFrame = 0;
                }
                const armor = this.player.inventory.getArmor();
                // Get the quickbar's left edge position
                const quickbarStartX = this.player.inventory.getQuickbarStartX() + (armor ? -34 : -24);
                // Convert to tile coordinates
                let heartStartX = quickbarStartX / gameConstants_1.GameConstants.TILESIZE;
                // Ensure hearts don't go off the left edge of the screen
                if (heartStartX < 0.25) {
                    heartStartX = 0.25;
                }
                for (let i = 0; i < this.player.maxHealth; i++) {
                    let shake = 0;
                    let shakeY = 0;
                    if (this.player.health <= 1) {
                        shake =
                            Math.round(Math.sin(Date.now() / 25 / (i + 1)) + i / 2) /
                                2 /
                                gameConstants_1.GameConstants.TILESIZE;
                        shakeY =
                            Math.round(Math.sin(Date.now() / 25 / (i + 2)) + i / 2) /
                                2 /
                                gameConstants_1.GameConstants.TILESIZE;
                    }
                    let frame = this.guiHeartFrame > 0 ? 1 : 0;
                    let offsetY = gameConstants_1.GameConstants.WIDTH > 175 ? 0 : -1.25;
                    if (i >= Math.floor(this.player.health)) {
                        if (i == Math.floor(this.player.health) &&
                            (this.player.health * 2) % 2 == 1) {
                            // draw half heart
                            game_1.Game.drawFX(4, 2, 0.75, 0.75, heartStartX + i / 1.5 + shake, gameConstants_1.GameConstants.HEIGHT / gameConstants_1.GameConstants.TILESIZE -
                                1 +
                                shakeY +
                                offsetY, 0.75, 0.75);
                        }
                        else {
                            game_1.Game.drawFX(3, 2, 0.75, 0.75, heartStartX + i / 1.5 + shake, gameConstants_1.GameConstants.HEIGHT / gameConstants_1.GameConstants.TILESIZE -
                                1 +
                                shakeY +
                                offsetY, 0.75, 0.75);
                        }
                    }
                    else {
                        game_1.Game.drawFX(frame, 2, 0.75, 0.75, heartStartX + i / 1.5 + shake, gameConstants_1.GameConstants.HEIGHT / gameConstants_1.GameConstants.TILESIZE -
                            1 +
                            shakeY +
                            offsetY, 0.75, 0.75);
                    }
                }
                //this.drawCooldownBar();
                if (armor)
                    armor.drawGUI(delta, this.player.maxHealth, quickbarStartX);
                if (!transitioning)
                    this.player.inventory.draw(delta);
                hoverText_1.HoverText.draw(delta, this.player.x, this.player.y, this.player.game.levels[this.player.depth].rooms[this.player.levelID], this.player);
            }
            else {
                game_1.Game.ctx.fillStyle = levelConstants_1.LevelConstants.LEVEL_TEXT_COLOR;
                const enemies = stats_1.statsTracker.getStats().enemies;
                // Count the occurrences of each enemy
                const enemyCounts = enemies.reduce((acc, enemy) => {
                    acc[enemy] = (acc[enemy] || 0) + 1;
                    return acc;
                }, {});
                // Create individual lines
                const lines = [];
                // Line 1: Game Over or slain by
                if (this.player.lastHitBy !== "enemy") {
                    lines.push(`You were slain by ${this.player.lastHitBy}.`);
                }
                else {
                    lines.push("Game Over");
                }
                lines.push(`Depth reached: ${this.player.game.levels[this.player.depth].rooms[this.player.levelID].depth}`);
                // Line 2: Enemies killed
                lines.push(`${Object.values(enemyCounts).reduce((a, b) => a + b, 0)} enemies killed in total:`);
                // Subsequent lines: Each enemy count
                Object.entries(enemyCounts).forEach(([enemy, count]) => {
                    lines.push(`${enemy} x${count}`);
                });
                // Line after enemy counts: Restart instruction
                let restartButton = "Press space or click to restart";
                if (gameConstants_1.GameConstants.isMobile)
                    restartButton = "Tap to restart";
                // Calculate total height based on number of lines
                const lineHeight = game_1.Game.letter_height + 2; // Adjust spacing as needed
                const totalHeight = lines.length * lineHeight + lineHeight; // Additional space for restart button
                // Starting Y position to center the text block
                let startY = gameConstants_1.GameConstants.HEIGHT / 2 - totalHeight / 2;
                // Draw each line centered horizontally
                lines.forEach((line, index) => {
                    const textWidth = game_1.Game.measureText(line).width;
                    const spacing = index === 0 || index === 1 || index === lines.length - 1
                        ? lineHeight * 1.5
                        : lineHeight;
                    game_1.Game.fillText(line, gameConstants_1.GameConstants.WIDTH / 2 - textWidth / 2, startY);
                    startY += spacing;
                });
                // Draw the restart button
                const restartTextWidth = game_1.Game.measureText(restartButton).width;
                game_1.Game.fillText(restartButton, gameConstants_1.GameConstants.WIDTH / 2 - restartTextWidth / 2, startY);
            }
            postProcess_1.PostProcessor.draw(delta);
            if (this.hurting)
                this.drawHurt(delta);
            if (this.player.mapToggled === true)
                this.player.map.draw(delta);
            this.drawTileCursor(delta);
            this.player.setCursorIcon();
            //this.drawInventoryButton(delta);
            if (this.player.menu.open)
                this.player.menu.draw();
            game_1.Game.ctx.restore();
        };
        this.drawCooldownBar = () => {
            game_1.Game.ctx.save();
            if (this.player.cooldownRemaining > 0) {
                this.player.cooldownRemaining =
                    1 -
                        (Date.now() - this.player.movement.lastMoveTime) /
                            this.player.movement.adjustedCooldown;
            }
            else
                this.player.cooldownRemaining = 0;
            const tile = gameConstants_1.GameConstants.TILESIZE;
            game_1.Game.drawFX(12 +
                Math.max(0, Math.min(14, Math.floor(17 * this.player.cooldownRemaining))), 2, 1, 1, 0.45, gameConstants_1.GameConstants.HEIGHT / tile - 2.125, 1, 1);
            game_1.Game.ctx.restore();
        };
        this.drawHurt = (delta) => {
            game_1.Game.ctx.save(); // Save the current canvas state
            game_1.Game.ctx.globalAlpha = this.hurtAlpha;
            this.hurtAlpha -= (this.hurtAlpha / 10) * delta;
            if (this.hurtAlpha <= 0.01) {
                this.hurtAlpha = 0;
                this.hurting = false;
                this.hurtingShield = false;
            }
            game_1.Game.ctx.globalCompositeOperation = "source-over";
            game_1.Game.ctx.fillStyle = "#cc3333"; // bright but not fully saturated red
            if (this.hurtingShield) {
                game_1.Game.ctx.fillStyle = "#639bff"; // bright but not fully saturated blue
            }
            game_1.Game.ctx.fillRect(0, 0, gameConstants_1.GameConstants.WIDTH, gameConstants_1.GameConstants.HEIGHT);
            game_1.Game.ctx.restore(); // Restore the canvas state
        };
        this.drawLowHealth = (delta) => {
            game_1.Game.ctx.save();
            //unused
            if (this.player.health <= 1 && !this.player.dead) {
                // Calculate pulsating alpha for the vignette effect
                const lowHealthAlpha = 0.5; //Math.sin(this.lowHealthFrame / 10) * 0.5 + 0.5;
                game_1.Game.ctx.globalAlpha = lowHealthAlpha;
                this.lowHealthFrame += delta;
                const gradientBottom = game_1.Game.ctx.createLinearGradient(0, gameConstants_1.GameConstants.HEIGHT, 0, (gameConstants_1.GameConstants.HEIGHT * 2) / 3);
                // Define gradient color stops
                [gradientBottom].forEach((gradient) => {
                    gradient.addColorStop(0, "#cc3333"); // Solid red at edges
                    gradient.addColorStop(1, "rgba(0, 0, 0, 0)"); // Transparent toward center
                });
                // Draw the gradients
                game_1.Game.ctx.globalCompositeOperation = "source-over";
                game_1.Game.ctx.fillStyle = gradientBottom;
                game_1.Game.ctx.fillRect(0, 0, gameConstants_1.GameConstants.WIDTH, gameConstants_1.GameConstants.HEIGHT);
                // Reset composite operation and alpha
                game_1.Game.ctx.globalCompositeOperation = "source-over";
                game_1.Game.ctx.globalAlpha = 1.0;
            }
            else {
                this.lowHealthFrame = 0;
            }
            game_1.Game.ctx.restore();
        };
        this.heartbeat = () => {
            this.guiHeartFrame = 1;
        };
        /**
         * Draws the tile cursor to the canvas.
         * Added `ctx.save()` at the beginning and `ctx.restore()` at the end
         * to ensure canvas state is preserved.
         */
        this.drawTileCursor = (delta) => {
            if (this.player.inventory.isOpen ||
                this.player.inputHandler.mostRecentMoveInput === "keyboard" ||
                gameConstants_1.GameConstants.isMobile)
                return;
            game_1.Game.ctx.save(); // Save the current canvas state
            if (!this.player.mouseInLine() ||
                !this.player.isMouseAboveFloor() ||
                this.player.isMouseOnPlayerTile())
                return;
            let tileX = 24; //inRange ? 22 : 24;
            let tileY = 5;
            game_1.Game.drawFX(tileX + Math.floor(hitWarning_1.HitWarning.frame), tileY, 1, 1, this.player.tileCursor.x + this.player.drawX, this.player.tileCursor.y + this.player.drawY, 1, 1);
            game_1.Game.ctx.restore(); // Restore the canvas state
        };
        this.jump = (delta) => {
            let j = Math.max(Math.abs(this.drawX), Math.abs(this.drawY));
            this.jumpY = Math.abs(Math.sin(j * Math.PI) * this.jumpHeight);
            if (Math.abs(this.jumpY) < 0.01)
                this.jumpY = 0;
            if (this.jumpY > this.jumpHeight)
                this.jumpY = this.jumpHeight;
        };
        this.player = player;
        this.jumpY = 0;
        this.flashingFrame = 0;
        this.guiHeartFrame = 0;
        this.motionSpeed = 1;
        this.hitX = 0;
        this.hitY = 0;
        this.drawX = 0;
        this.drawY = 0;
        this.hurtAlpha = 0.25;
        this.jumpHeight = 0.25;
        this.hurting = false;
        this.hurtingShield = false;
        this.slowMotionEnabled = false;
        this.slowMotionTickDuration = 0;
        this.flashing = false;
        this.lowHealthFrame = 0;
        this.frame = 0;
    }
}
exports.PlayerRenderer = PlayerRenderer;


/***/ }),

/***/ "./src/projectile/beamEffect.ts":
/*!**************************************!*\
  !*** ./src/projectile/beamEffect.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BeamEffect = void 0;
const game_1 = __webpack_require__(/*! ../game */ "./src/game.ts");
const gameConstants_1 = __webpack_require__(/*! ../game/gameConstants */ "./src/game/gameConstants.ts");
const projectile_1 = __webpack_require__(/*! ./projectile */ "./src/projectile/projectile.ts");
const random_1 = __webpack_require__(/*! ../utility/random */ "./src/utility/random.ts");
class BeamEffect extends projectile_1.Projectile {
    constructor(x1, y1, x2, y2, parent) {
        super(parent, x1, y1);
        this.active = true;
        this.time = 0;
        this.alpha = 1;
        this.gravity = BeamEffect.GRAVITY;
        this.motionInfluence = BeamEffect.MOTION_INFLUENCE;
        this.turbulence = BeamEffect.TURBULENCE;
        this.velocityDecay = BeamEffect.VELOCITY_DECAY;
        this.angleChange = BeamEffect.ANGLE_CHANGE;
        this.maxVelocity = BeamEffect.MAX_VELOCITY;
        this.damping = BeamEffect.DAMPING;
        this.springStiffness = BeamEffect.SPRING_STIFFNESS;
        this.springDamping = BeamEffect.SPRING_DAMPING;
        this.iterations = BeamEffect.ITERATIONS;
        this.segments = BeamEffect.SEGMENTS;
        this.tick = () => {
            if (this.parent.dead) {
                this.destroy();
            }
        };
        this.draw = (delta) => {
            this.drawableY = this.y - 0.01;
            this.render(this.targetX, this.targetY, this.x, this.y, this.color, 2, delta, this.compositeOperation);
        };
        const startX = x1 * gameConstants_1.GameConstants.TILESIZE + 0.5 * gameConstants_1.GameConstants.TILESIZE;
        const startY = y1 * gameConstants_1.GameConstants.TILESIZE + 0.5 * gameConstants_1.GameConstants.TILESIZE;
        const endX = x2 * gameConstants_1.GameConstants.TILESIZE + 0.5 * gameConstants_1.GameConstants.TILESIZE;
        const endY = y2 * gameConstants_1.GameConstants.TILESIZE + 0.5 * gameConstants_1.GameConstants.TILESIZE;
        this.x = x1;
        this.y = y1;
        this.targetX = x2;
        this.targetY = y2;
        this.points = this.initializePoints(startX, startY, endX, endY);
        this.prevStartX = startX;
        this.prevStartY = startY;
        this.prevEndX = endX;
        this.prevEndY = endY;
        this.color = "cyan";
        this.compositeOperation = "source-over";
    }
    /**
     * Sets the physics properties for the beam effect.
     *
     * @param {number} [gravity] - The gravitational force applied to the beam. Default: 2
     * @param {number} [motionInfluence] - The influence of motion on the beam. Default: 1
     * @param {number} [turbulence] - The turbulence applied to the beam. Default: 0.5
     * @param {number} [velocityDecay] - The rate at which velocity decays. Default: 0.1
     * @param {number} [angleChange] - The change in angle of the beam. Default: 0.01
     * @param {number} [maxVelocity] - The maximum velocity of the beam.
     * @param {number} [damping] - The damping factor for the beam's motion.
     * @param {number} [springStiffness] - The stiffness of the spring effect.
     * @param {number} [springDamping] - The damping of the spring effect.
     * @param {number} [iterations] - The number of iterations for the physics simulation.
     * @param {number} [segments] - The number of segments for the beam.
     */
    setPhysics(gravity, motionInfluence, turbulence, velocityDecay, angleChange, maxVelocity, damping, springStiffness, springDamping, iterations, segments) {
        this.gravity = gravity ?? BeamEffect.GRAVITY;
        this.motionInfluence = motionInfluence ?? BeamEffect.MOTION_INFLUENCE;
        this.turbulence = turbulence ?? BeamEffect.TURBULENCE;
        this.velocityDecay = velocityDecay ?? BeamEffect.VELOCITY_DECAY;
        this.angleChange = angleChange ?? BeamEffect.ANGLE_CHANGE;
        this.maxVelocity = maxVelocity ?? BeamEffect.MAX_VELOCITY;
        this.damping = damping ?? BeamEffect.DAMPING;
        this.springStiffness = springStiffness ?? BeamEffect.SPRING_STIFFNESS;
        this.springDamping = springDamping ?? BeamEffect.SPRING_DAMPING;
        this.iterations = iterations ?? BeamEffect.ITERATIONS;
        this.segments = segments ?? BeamEffect.SEGMENTS;
    }
    setTarget(x, y, x2, y2) {
        this.x = x;
        this.y = y;
        this.targetX = x2;
        this.targetY = y2;
    }
    render(x1, y1, x2, y2, color = this.color, lineWidth = 2, delta = 1 / 60, compositeOperation = this.compositeOperation) {
        const startX = this.x * gameConstants_1.GameConstants.TILESIZE + 0.5 * gameConstants_1.GameConstants.TILESIZE;
        const startY = this.y * gameConstants_1.GameConstants.TILESIZE + 0.5 * gameConstants_1.GameConstants.TILESIZE;
        const endX = this.targetX * gameConstants_1.GameConstants.TILESIZE + 0.5 * gameConstants_1.GameConstants.TILESIZE;
        const endY = this.targetY * gameConstants_1.GameConstants.TILESIZE + 0.5 * gameConstants_1.GameConstants.TILESIZE;
        const startForceX = (startX - this.prevStartX) * this.motionInfluence * delta;
        const startForceY = (startY - this.prevStartY) * this.motionInfluence * delta;
        const endForceX = (endX - this.prevEndX) * this.motionInfluence * delta;
        const endForceY = (endY - this.prevEndY) * this.motionInfluence * delta;
        for (let i = 1; i < 4; i++) {
            const influence = 1 - i / 4;
            this.points[i].x += startForceX * influence;
            this.points[i].y += startForceY * influence;
        }
        for (let i = this.points.length - 4; i < this.points.length - 1; i++) {
            const influence = 1 - (this.points.length - i) / 4;
            this.points[i].x += endForceX * influence;
            this.points[i].y += endForceY * influence;
        }
        this.simulateRope(startX, startY, endX, endY, delta);
        const ctx = game_1.Game.ctx;
        ctx.save();
        game_1.Game.ctx.globalCompositeOperation =
            compositeOperation;
        for (let i = 0; i < this.points.length - 1; i++) {
            const p1 = this.points[i];
            const p2 = this.points[i + 1];
            const dx = p2.x - p1.x;
            const dy = p2.y - p1.y;
            const steps = Math.max(Math.abs(dx), Math.abs(dy));
            const xIncrement = dx / steps;
            const yIncrement = dy / steps;
            let x = p1.x;
            let y = p1.y;
            for (let step = 0; step <= steps; step++) {
                for (let w = 0; w < lineWidth; w++) {
                    for (let h = 0; h < lineWidth; h++) {
                        ctx.fillStyle = color;
                        ctx.fillRect(Math.round(x + w), Math.round(y + h), 1, 1);
                    }
                }
                x += xIncrement;
                y += yIncrement;
            }
        }
        ctx.restore();
        this.prevStartX = startX;
        this.prevStartY = startY;
        this.prevEndX = endX;
        this.prevEndY = endY;
    }
    initializePoints(startX, startY, endX, endY) {
        const points = [];
        for (let i = 0; i < this.segments; i++) {
            const t = i / (this.segments - 1);
            points.push({
                x: startX + (endX - startX) * t,
                y: startY + (endY - startY) * t,
                oldX: startX + (endX - startX) * t,
                oldY: startY + (endY - startY) * t,
                velocityX: 0,
                velocityY: 0,
                angle: random_1.Random.rand() * Math.PI * 2,
            });
        }
        return points;
    }
    applyTurbulence(point, index) {
        point.angle += Math.sin(this.time * 0.1 + index * 0.5) * this.angleChange;
        const turbulenceX = Math.cos(point.angle) * this.turbulence;
        const turbulenceY = Math.sin(point.angle) * this.turbulence;
        point.velocityX += turbulenceX;
        point.velocityY += turbulenceY;
        point.velocityX = Math.min(Math.max(point.velocityX, -this.maxVelocity), this.maxVelocity);
        point.velocityY = Math.min(Math.max(point.velocityY, -this.maxVelocity), this.maxVelocity);
    }
    simulateRope(startX, startY, endX, endY, delta) {
        const iterationsThisFrame = Math.ceil(this.iterations * delta);
        for (let iteration = 0; iteration < iterationsThisFrame; iteration++) {
            for (let i = 1; i < this.points.length - 1; i++) {
                const point = this.points[i];
                const prevPoint = this.points[i - 1];
                const nextPoint = this.points[i + 1];
                const springForceXPrev = (prevPoint.x - point.x) * this.springStiffness;
                const springForceYPrev = (prevPoint.y - point.y) * this.springStiffness;
                const springForceXNext = (nextPoint.x - point.x) * this.springStiffness;
                const springForceYNext = (nextPoint.y - point.y) * this.springStiffness;
                this.applyTurbulence(point, i);
                point.velocityX =
                    (point.velocityX + springForceXPrev + springForceXNext) *
                        this.damping;
                point.velocityY =
                    (point.velocityY + springForceYPrev + springForceYNext) *
                        this.damping;
                const relativeVXPrev = prevPoint.velocityX - point.velocityX;
                const relativeVYPrev = prevPoint.velocityY - point.velocityY;
                const relativeVXNext = nextPoint.velocityX - point.velocityX;
                const relativeVYNext = nextPoint.velocityY - point.velocityY;
                point.velocityX +=
                    (relativeVXPrev + relativeVXNext) * this.springDamping;
                point.velocityY +=
                    (relativeVYPrev + relativeVYNext) * this.springDamping;
                point.oldX = point.x;
                point.oldY = point.y;
                point.x += point.velocityX;
                point.y += point.velocityY + this.gravity;
            }
            const segmentLength = Math.sqrt(Math.pow(endX - startX, 2) + Math.pow(endY - startY, 2)) /
                (this.segments - 1);
            for (let constraintIteration = 0; constraintIteration < 2; constraintIteration++) {
                for (let i = 0; i < this.points.length - 1; i++) {
                    const p1 = this.points[i];
                    const p2 = this.points[i + 1];
                    const dx = p2.x - p1.x;
                    const dy = p2.y - p1.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    const difference = segmentLength - distance;
                    const percent = difference / distance / 2;
                    const offsetX = dx * percent;
                    const offsetY = dy * percent;
                    if (i > 0) {
                        p1.x -= offsetX * 1.5;
                        p1.y -= offsetY * 1.5;
                    }
                    if (i < this.points.length - 2) {
                        p2.x += offsetX * 1.5;
                        p2.y += offsetY * 1.5;
                    }
                }
            }
        }
        this.points[0].x = startX;
        this.points[0].y = startY;
        this.points[0].oldX = startX;
        this.points[0].oldY = startY;
        this.points[this.points.length - 1].x = endX;
        this.points[this.points.length - 1].y = endY;
        this.points[this.points.length - 1].oldX = endX;
        this.points[this.points.length - 1].oldY = endY;
    }
    static renderBeam(x1, y1, x2, y2, color = "cyan", lineWidth = 2, alpha = 1) {
        const ctx = game_1.Game.ctx;
        ctx.globalAlpha = alpha;
        const startX = x1 * gameConstants_1.GameConstants.TILESIZE + 0.5 * gameConstants_1.GameConstants.TILESIZE;
        const startY = y1 * gameConstants_1.GameConstants.TILESIZE + 0.5 * gameConstants_1.GameConstants.TILESIZE;
        const endX = x2 * gameConstants_1.GameConstants.TILESIZE + 0.5 * gameConstants_1.GameConstants.TILESIZE;
        const endY = y2 * gameConstants_1.GameConstants.TILESIZE + 0.5 * gameConstants_1.GameConstants.TILESIZE;
        ctx.save();
        ctx.beginPath();
        ctx.moveTo(startX, startY);
        ctx.lineTo(endX, endY);
        ctx.lineWidth = lineWidth;
        ctx.strokeStyle = color;
        ctx.stroke();
        ctx.restore();
    }
    destroy() {
        this.active = false;
        this.points = [];
        this.dead = true;
    }
    isActive() {
        return this.active;
    }
}
exports.BeamEffect = BeamEffect;
// Number of points that make up the beam (higher = smoother but more expensive)
// Range: 10-100, recommended: 30
BeamEffect.SEGMENTS = 30;
// Downward force applied to each point (0 = no gravity)
// Range: 0-10, recommended: 2
BeamEffect.GRAVITY = 2;
// Physics simulation steps per frame (higher = more accurate but more expensive)
// Range: 1-10, recommended: 1
BeamEffect.ITERATIONS = 5;
// How much the beam reacts to movement of start/end points
// Range: 0-5, recommended: 1
BeamEffect.MOTION_INFLUENCE = 1;
// Amount of random movement applied to points (0 = straight beam)
// Range: 0-1, recommended: 0.5
BeamEffect.TURBULENCE = 0.5;
// How quickly velocity decreases over time
// Range: 0-1, recommended: 0.5
BeamEffect.VELOCITY_DECAY = 0.1;
// How quickly the turbulence angle changes
// Range: 0-2, recommended: 0.9
BeamEffect.ANGLE_CHANGE = 0.01; // for turbulence specifically
// Maximum speed any point can move per frame
// Range: 10-1000, recommended: 100
BeamEffect.MAX_VELOCITY = 100;
// General movement resistance (1 = no damping, 0 = full stop)
// Range: 0.9-0.999, recommended: 0.8
BeamEffect.DAMPING = 0.8;
// How strongly points pull toward their neighbors
// Range: 0.01-1, recommended: 0.01
BeamEffect.SPRING_STIFFNESS = 0.01;
// How quickly spring oscillations settle
// Range: 0.001-0.1, recommended: 0.1
BeamEffect.SPRING_DAMPING = 0.1;


/***/ }),

/***/ "./src/projectile/enemyShield.ts":
/*!***************************************!*\
  !*** ./src/projectile/enemyShield.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EnemyShield = void 0;
const projectile_1 = __webpack_require__(/*! ./projectile */ "./src/projectile/projectile.ts");
const game_1 = __webpack_require__(/*! ../game */ "./src/game.ts");
const lighting_1 = __webpack_require__(/*! ../lighting/lighting */ "./src/lighting/lighting.ts");
const beamEffect_1 = __webpack_require__(/*! ./beamEffect */ "./src/projectile/beamEffect.ts");
class EnemyShield extends projectile_1.Projectile {
    constructor(parent, x, y, health = 1) {
        super(parent, x, y);
        this.remove = () => {
            this.parent.shielded = false;
            this.parent.removeLightSource(this.lightSource);
            this.parent.room.projectiles = this.parent.room.projectiles.filter((projectile) => projectile !== this);
            let beam = this.parent.room.projectiles.find((projectile) => projectile instanceof beamEffect_1.BeamEffect && projectile.parent === this.parent);
            if (beam) {
                beam.dead = true;
            }
            this.parent.shadeColor = "black";
            this.lightSource = null;
            this.parent.shield = null;
        };
        this.updateLightSourcePos = () => {
            if (this.lightSource === null)
                return;
            let index = this.parent.room.lightSources.indexOf(this.lightSource);
            this.parent.room.lightSources[index].x = this.parent.x + 0.5;
            this.parent.room.lightSources[index].y = this.parent.y + 0.5;
            this.parent.room.updateLighting();
        };
        this.hurt = (damage) => {
            const damageOverShield = Math.max(0, damage - this.health);
            this.health -= damage;
            /*
            GenericParticle.spawnCluster(
              this.parent.room,
              this.parent.x + 0.5,
              this.parent.y + 0.5,
              "#fbf236",
            );
            */
            if (this.health <= 0) {
                this.remove();
            }
            return damageOverShield;
        };
        this.tick = () => {
            if (this.parent.dead) {
                this.remove();
            }
            if (this.dead) {
                this.parent.room.projectiles = this.parent.room.projectiles.filter((projectile) => projectile !== this);
            }
        };
        this.draw = (delta) => {
            if (this.dead)
                return;
            game_1.Game.ctx.save();
            game_1.Game.ctx.globalAlpha = 1;
            this.frame += 0.1 * delta;
            if (this.frame >= 4)
                this.frame = 0;
            this.drawableY = this.parent.drawableY - 0.05;
            game_1.Game.ctx.globalCompositeOperation = "difference";
            if (this.parent.shielded) {
                game_1.Game.drawFX(18 + Math.floor(this.frame), 9, 1, 1, this.parent.x - this.parent.drawX, this.parent.y - this.parent.drawY, 1, 1);
            }
            game_1.Game.ctx.restore();
        };
        this.parent = parent;
        this.frame = 0;
        this.health = health;
        this.parent.shielded = true;
        this.lightSource = lighting_1.Lighting.newLightSource(this.x + 0.5, this.y + 0.5, [20, 0, 40], 3.5, 20);
        this.parent.addLightSource(this.lightSource);
        this.parent.room.projectiles.push(this);
        this.parent.room.updateLighting();
    }
}
exports.EnemyShield = EnemyShield;


/***/ }),

/***/ "./src/projectile/enemySpawnAnimation.ts":
/*!***********************************************!*\
  !*** ./src/projectile/enemySpawnAnimation.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EnemySpawnAnimation = void 0;
const projectile_1 = __webpack_require__(/*! ./projectile */ "./src/projectile/projectile.ts");
const game_1 = __webpack_require__(/*! ../game */ "./src/game.ts");
const sound_1 = __webpack_require__(/*! ../sound/sound */ "./src/sound/sound.ts");
const hitWarning_1 = __webpack_require__(/*! ../drawable/hitWarning */ "./src/drawable/hitWarning.ts");
const lightSource_1 = __webpack_require__(/*! ../lighting/lightSource */ "./src/lighting/lightSource.ts");
class EnemySpawnAnimation extends projectile_1.Projectile {
    constructor(room, enemy, x, y) {
        super(enemy, x, y);
        this.ANIM_COUNT = 3;
        this.tick = () => {
            if (this.room === this.room.game.room)
                sound_1.Sound.enemySpawn();
            let hitPlayer = false;
            for (const i in this.room.game.players) {
                if (this.room.game.players[i].x === this.x &&
                    this.room.game.players[i].y === this.y) {
                    this.room.game.players[i].hurt(0.5, "reaper");
                    hitPlayer = true;
                }
            }
            if (!hitPlayer) {
                this.dead = true;
                this.enemy.skipNextTurns = 1;
                this.room.entities.push(this.enemy);
                this.enemy.createHitParticles();
                this.lightSource.dead = true;
            }
            else {
                this.room.hitwarnings.push(new hitWarning_1.HitWarning(this.room.game, this.x, this.y, this.x, this.y));
            }
        };
        this.drawTopLayer = (delta) => {
            if (this.dead)
                return;
            this.frame += 0.25 * delta;
            if (this.frame >= 8)
                this.frame = 0;
            for (let i = 0; i < this.ANIM_COUNT; i++) {
                let offsetX = 0;
                game_1.Game.drawFX(Math.floor(this.frame), 27, 1, 1, this.x + Math.round(offsetX) / 16.0, this.y - 0.5, 1, 1);
            }
        };
        this.room = room;
        this.enemy = enemy;
        this.frame = 0;
        this.hasBloom = true;
        this.bloomColor = "#00BFFF";
        this.bloomOffsetY = -0.5;
        this.lightSource = new lightSource_1.LightSource(this.x + 0.5, this.y + 0.5, 1, [0, 50, 150], 1);
        this.room.lightSources.push(this.lightSource);
        this.room.updateLighting();
    }
}
exports.EnemySpawnAnimation = EnemySpawnAnimation;


/***/ }),

/***/ "./src/projectile/explosion.ts":
/*!*************************************!*\
  !*** ./src/projectile/explosion.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Explosion = void 0;
const projectile_1 = __webpack_require__(/*! ./projectile */ "./src/projectile/projectile.ts");
const game_1 = __webpack_require__(/*! ../game */ "./src/game.ts");
const lighting_1 = __webpack_require__(/*! ../lighting/lighting */ "./src/lighting/lighting.ts");
const utils_1 = __webpack_require__(/*! ../utility/utils */ "./src/utility/utils.ts");
const bomb_1 = __webpack_require__(/*! ../entity/object/bomb */ "./src/entity/object/bomb.ts");
class Explosion extends projectile_1.Projectile {
    constructor(entity, x, y, playerHitBy) {
        super(entity, x, y);
        this.drawTopLayer = (delta) => {
            if (this.dead)
                return;
            if (this.offsetFrame < 0)
                this.offsetFrame += 10 * delta;
            if (this.offsetFrame >= 0) {
                this.frame += 0.25 * delta;
            }
            if (this.frame > 17)
                this.dead = true;
            game_1.Game.drawFX(Math.floor(this.frame), 6, 1, 2, this.x, this.y - 1, 1, 2);
        };
        this.state = 0;
        this.frame = 6;
        this.parent = entity;
        this.offsetFrame =
            -utils_1.Utils.distance(this.parent.x, this.parent.y, this.x, this.y) * 100;
        this.delay = 0;
        lighting_1.Lighting.momentaryLight(this.parent.room, this.x + 0.5, this.y + 0.5, 0.5, [255, 100, 0], 350, 20, Math.abs(this.offsetFrame));
        const distance = utils_1.Utils.distance(this.parent.x, this.parent.y, this.x, this.y);
        let damage = distance === 0 ? 1 : Math.max(0.5, Math.floor((1 / distance) * 4) / 2);
        for (let entity of this.parent.room.entities) {
            if (entity.x === this.x &&
                entity.y === this.y &&
                entity !== this.parent) {
                if (entity instanceof bomb_1.Bomb) {
                    entity.fuseLength = 1;
                }
                entity.hurt(playerHitBy, damage);
            }
            if (playerHitBy.x === this.x && playerHitBy.y === this.y) {
                playerHitBy.hurt(damage, "bomb");
            }
        }
    }
}
exports.Explosion = Explosion;


/***/ }),

/***/ "./src/projectile/playerFireball.ts":
/*!******************************************!*\
  !*** ./src/projectile/playerFireball.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PlayerFireball = void 0;
const projectile_1 = __webpack_require__(/*! ./projectile */ "./src/projectile/projectile.ts");
const game_1 = __webpack_require__(/*! ../game */ "./src/game.ts");
const lighting_1 = __webpack_require__(/*! ../lighting/lighting */ "./src/lighting/lighting.ts");
const utils_1 = __webpack_require__(/*! ../utility/utils */ "./src/utility/utils.ts");
class PlayerFireball extends projectile_1.Projectile {
    constructor(parent, x, y) {
        super(parent, x, y);
        this.drawTopLayer = (delta) => {
            if (this.dead)
                return;
            if (this.offsetFrame < 0)
                this.offsetFrame += 10 * delta;
            if (this.offsetFrame >= 0) {
                this.frame += 0.25 * delta;
            }
            if (this.frame > 17)
                this.dead = true;
            game_1.Game.drawFX(Math.floor(this.frame), 6, 1, 2, this.x, this.y - 1, 1, 2);
        };
        this.state = 0;
        this.frame = 6;
        this.offsetFrame =
            -utils_1.Utils.distance(this.parent.x, this.parent.y, this.x, this.y) * 50;
        this.delay = 0;
        lighting_1.Lighting.momentaryLight(this.parent.game.rooms[this.parent.levelID], this.x + 0.5, this.y + 0.5, 0.5, [255, 100, 0], 250, 10, 1);
    }
}
exports.PlayerFireball = PlayerFireball;


/***/ }),

/***/ "./src/projectile/projectile.ts":
/*!**************************************!*\
  !*** ./src/projectile/projectile.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Projectile = void 0;
const drawable_1 = __webpack_require__(/*! ../drawable/drawable */ "./src/drawable/drawable.ts");
const IdGenerator_1 = __webpack_require__(/*! ../globalStateManager/IdGenerator */ "./src/globalStateManager/IdGenerator.ts");
class Projectile extends drawable_1.Drawable {
    constructor(parent, x, y) {
        super();
        this.hitPlayer = (player) => { };
        this.hitEnemy = (enemy) => { };
        this.tick = () => { };
        this.draw = (delta) => { };
        this.drawTopLayer = (delta) => { };
        this.globalId = IdGenerator_1.IdGenerator.generate("PROJ");
        this.x = x;
        this.y = y;
        this.dead = false;
        this.parent = parent;
        this.drawableY = y;
        this.hasBloom = false;
        this.bloomColor = "#00BFFF";
        this.bloomOffsetY = 0;
    }
    get distanceToParent() {
        return Math.abs(this.x - this.parent.x) + Math.abs(this.y - this.parent.y);
    }
    setTarget(x, y, x2, y2) { }
}
exports.Projectile = Projectile;


/***/ }),

/***/ "./src/projectile/stunAnimation.ts":
/*!*****************************************!*\
  !*** ./src/projectile/stunAnimation.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StunAnimation = void 0;
const projectile_1 = __webpack_require__(/*! ./projectile */ "./src/projectile/projectile.ts");
const game_1 = __webpack_require__(/*! ../game */ "./src/game.ts");
class StunAnimation extends projectile_1.Projectile {
    constructor(parent, x, y) {
        super(parent, x, y);
        this.ticks = 0;
        this.remove = () => {
            this.parent.room.projectiles = this.parent.room.projectiles.filter((projectile) => projectile !== this);
        };
        this.tick = () => {
            if (this.ticks > 1 || this.parent.dead === true) {
                this.remove();
                this.parent.unconscious = false;
                this.parent.justHurt = false;
            }
            this.ticks++;
        };
        this.drawTopLayer = (delta) => {
            if (this.dead)
                return;
            game_1.Game.ctx.save();
            game_1.Game.ctx.globalCompositeOperation = "screen";
            game_1.Game.ctx.globalAlpha = 0.5;
            this.frame += 0.2 * delta;
            if (this.frame > 4)
                this.frame = 0;
            //this.drawableY = this.parent.drawableY + 0.05;
            //Game.ctx.globalCompositeOperation = "difference";
            //if (this.parent.shielded) {
            game_1.Game.drawFX(19 + Math.floor(this.frame), 0, 1, 1, this.parent.x - this.parent.drawX, this.parent.y - this.parent.drawY - 1.4, 1, 1);
            //}
            game_1.Game.ctx.restore();
        };
        this.frame = 0;
        this.parent.room.projectiles.push(this);
    }
}
exports.StunAnimation = StunAnimation;


/***/ }),

/***/ "./src/projectile/wizardFireball.ts":
/*!******************************************!*\
  !*** ./src/projectile/wizardFireball.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WizardFireball = void 0;
const projectile_1 = __webpack_require__(/*! ./projectile */ "./src/projectile/projectile.ts");
const game_1 = __webpack_require__(/*! ../game */ "./src/game.ts");
const hitWarning_1 = __webpack_require__(/*! ../drawable/hitWarning */ "./src/drawable/hitWarning.ts");
const lightSource_1 = __webpack_require__(/*! ../lighting/lightSource */ "./src/lighting/lightSource.ts");
const lighting_1 = __webpack_require__(/*! ../lighting/lighting */ "./src/lighting/lighting.ts");
const utils_1 = __webpack_require__(/*! ../utility/utils */ "./src/utility/utils.ts");
const random_1 = __webpack_require__(/*! ../utility/random */ "./src/utility/random.ts");
class WizardFireball extends projectile_1.Projectile {
    constructor(parent, x, y) {
        super(parent, x, y);
        this.setMarkerFrame = () => {
            // Calculate offsetX based on direction
            this.offsetX = Math.floor(((this.dir + 1) % 8) / 2);
        };
        this.tick = () => {
            if (this.parent.dead || this.state === 3) {
                this.parent.removeLightSource(this.lightSource);
                this.dead = true;
            }
            if (!this.dead && this.state === 0) {
                this.bloomAlpha = 1;
            }
            this.state++;
            if (!this.dead && this.state === 1) {
                this.bloomAlpha = 0.5;
                const lightSource = this.parent.room.lightSources.find((ls) => ls === this.lightSource);
                lightSource.b = 0.4;
                this.parent.room.hitwarnings.push(new hitWarning_1.HitWarning(this.parent.game, this.x, this.y, this.parent.x, this.parent.y, true));
            }
            if (!this.dead && this.state === 2) {
                this.bloomAlpha = 0;
                lighting_1.Lighting.momentaryLight(this.parent.room, this.x, this.y, 3, this.parent.projectileColor, 500, 5, 350);
                this.parent.removeLightSource(this.lightSource);
                this.frame = 0;
                this.delay = game_1.Game.rand(0, 10, random_1.Random.rand);
            }
        };
        this.hitPlayer = (player) => {
            if (!this.dead && this.state === 2) {
                player.hurt(1, this.parent.name);
            }
        };
        this.draw = (delta) => {
            if (this.dead)
                return;
            /*Game.drawFX(
              18 + this.offsetX, //+ Math.floor(HitWarning.frame),
              4,
              1,
              1,
              this.x,
              this.y,
              1,
              1
            );*/
            if (this.state >= 0) {
                if (this.state === 0) {
                    this.frame += 0.25 * delta;
                    if (this.frame >= 4)
                        this.frame = 0;
                    game_1.Game.drawFX(22 + Math.floor(this.frame), this.tileY, 1, 1, this.x, this.y, 1, 1);
                }
                else if (this.state === 1) {
                    this.frame += 0.25 * delta;
                    if (this.frame >= 4)
                        this.frame = 0;
                    game_1.Game.drawFX(18 + Math.floor(this.frame), this.tileY, 1, 1, this.x, this.y - 0.2, 1, 1);
                }
                else {
                    if (this.delay > 0) {
                        this.delay--;
                        return;
                    }
                    this.frame += 0.3 * delta;
                    if (this.frame > 17)
                        this.dead = true;
                    game_1.Game.drawFX(Math.floor(this.frame), 6, 1, 2, this.x, this.y - 1, 1, 2);
                }
            }
        };
        this.tileY = parent.name === "wizard bomber" ? 7 : 8;
        this.parent = parent;
        this.frame = 0;
        this.state = 0; // this.distanceToParent;
        this.lightSource = new lightSource_1.LightSource(this.x + 0.5, this.y + 0.5, 4, parent.projectileColor, 0.1);
        this.parent.addLightSource(this.lightSource);
        //this.parent.room.updateLighting();
        this.hasBloom = true;
        this.bloomColor = utils_1.Utils.rgbToHex(this.parent.projectileColor[0], this.parent.projectileColor[1], this.parent.projectileColor[2]);
        this.bloomAlpha = 0.5;
        this.softBloomAlpha = 0;
    }
}
exports.WizardFireball = WizardFireball;


/***/ }),

/***/ "./src/room/propClusterer.ts":
/*!***********************************!*\
  !*** ./src/room/propClusterer.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PropClusterer = void 0;
const random_1 = __webpack_require__(/*! ../utility/random */ "./src/utility/random.ts");
/**
 * Handles clustering logic for prop placement
 */
class PropClusterer {
    constructor(room, options = {}) {
        this.placedPositions = [];
        this.availableTiles = [];
        this.room = room;
        this.options = {
            falloffExponent: options.falloffExponent ?? 2,
            baseScore: options.baseScore ?? 0.1,
            maxInfluenceDistance: options.maxInfluenceDistance ?? 10,
            useSeedPosition: options.useSeedPosition ?? false,
            seedPosition: options.seedPosition ?? { x: 0, y: 0 },
        };
    }
    /**
     * Generates clustered positions for the specified number of props
     */
    generateClusteredPositions(numProps) {
        this.placedPositions = [];
        this.availableTiles = this.getAvailableTiles();
        if (this.availableTiles.length === 0) {
            return [];
        }
        // Initialize with seed position or random position
        if (this.options.useSeedPosition &&
            this.isValidPosition(this.options.seedPosition)) {
            this.placePosition(this.options.seedPosition);
        }
        else if (this.availableTiles.length > 0) {
            const randomIndex = Math.floor(random_1.Random.rand() * this.availableTiles.length);
            const randomPosition = this.availableTiles.splice(randomIndex, 1)[0];
            this.placedPositions.push(randomPosition);
        }
        // Generate remaining positions
        for (let i = 1; i < numProps && this.availableTiles.length > 0; i++) {
            const position = this.selectNextPosition();
            if (position) {
                this.placePosition(position);
            }
            else {
                break; // No valid positions left
            }
        }
        return [...this.placedPositions];
    }
    /**
     * Gets all available tiles in the room
     */
    getAvailableTiles() {
        const tiles = this.room.getEmptyTiles();
        return tiles.map((tile) => ({ x: tile.x, y: tile.y }));
    }
    /**
     * Checks if a position is valid and available
     */
    isValidPosition(position) {
        return this.availableTiles.some((tile) => tile.x === position.x && tile.y === position.y);
    }
    /**
     * Places a position and removes it from available tiles
     */
    placePosition(position) {
        this.placedPositions.push(position);
        this.availableTiles = this.availableTiles.filter((tile) => !(tile.x === position.x && tile.y === position.y));
    }
    /**
     * Selects the next position based on clustering algorithm
     */
    selectNextPosition() {
        if (this.availableTiles.length === 0) {
            return null;
        }
        // Score each available tile based on proximity to placed entities
        const scoredTiles = this.availableTiles.map((tile) => ({
            position: tile,
            score: this.calculateTileScore(tile),
        }));
        // Normalize scores to create probability weights
        const totalScore = scoredTiles.reduce((sum, tile) => sum + tile.score, 0);
        if (totalScore <= 0) {
            // Fallback to uniform distribution if all scores are 0
            const randomIndex = Math.floor(random_1.Random.rand() * this.availableTiles.length);
            return this.availableTiles.splice(randomIndex, 1)[0];
        }
        // Perform weighted random selection
        const randomValue = random_1.Random.rand() * totalScore;
        let cumulativeScore = 0;
        for (const tile of scoredTiles) {
            cumulativeScore += tile.score;
            if (cumulativeScore >= randomValue) {
                return tile.position;
            }
        }
        // Fallback to last tile
        return scoredTiles[scoredTiles.length - 1].position;
    }
    /**
     * Calculates the score for a tile based on its proximity to placed entities
     */
    calculateTileScore(tile) {
        let score = this.options.baseScore;
        for (const placed of this.placedPositions) {
            const distance = this.calculateDistance(tile, placed);
            if (distance <= this.options.maxInfluenceDistance) {
                // Use inverse power function for falloff
                const influence = 1 / Math.pow(distance, this.options.falloffExponent);
                score += influence;
            }
        }
        return score;
    }
    /**
     * Calculates Euclidean distance between two positions
     */
    calculateDistance(pos1, pos2) {
        const dx = pos1.x - pos2.x;
        const dy = pos1.y - pos2.y;
        return Math.sqrt(dx * dx + dy * dy);
    }
}
exports.PropClusterer = PropClusterer;


/***/ }),

/***/ "./src/room/room.ts":
/*!**************************!*\
  !*** ./src/room/room.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Room = exports.WallDirection = exports.TurnState = exports.RoomType = exports.EnemyTypeMap = exports.EnemyType = void 0;
// #region imports
const wall_1 = __webpack_require__(/*! ../tile/wall */ "./src/tile/wall.ts");
const levelConstants_1 = __webpack_require__(/*! ../level/levelConstants */ "./src/level/levelConstants.ts");
const floor_1 = __webpack_require__(/*! ../tile/floor */ "./src/tile/floor.ts");
const game_1 = __webpack_require__(/*! ../game */ "./src/game.ts");
const door_1 = __webpack_require__(/*! ../tile/door */ "./src/tile/door.ts");
const knightEnemy_1 = __webpack_require__(/*! ../entity/enemy/knightEnemy */ "./src/entity/enemy/knightEnemy.ts");
const entity_1 = __webpack_require__(/*! ../entity/entity */ "./src/entity/entity.ts");
const chest_1 = __webpack_require__(/*! ../entity/object/chest */ "./src/entity/object/chest.ts");
const spawnfloor_1 = __webpack_require__(/*! ../tile/spawnfloor */ "./src/tile/spawnfloor.ts");
const gameConstants_1 = __webpack_require__(/*! ../game/gameConstants */ "./src/game/gameConstants.ts");
const skullEnemy_1 = __webpack_require__(/*! ../entity/enemy/skullEnemy */ "./src/entity/enemy/skullEnemy.ts");
const barrel_1 = __webpack_require__(/*! ../entity/object/barrel */ "./src/entity/object/barrel.ts");
const crate_1 = __webpack_require__(/*! ../entity/object/crate */ "./src/entity/object/crate.ts");
const armor_1 = __webpack_require__(/*! ../item/armor */ "./src/item/armor.ts");
const particle_1 = __webpack_require__(/*! ../particle/particle */ "./src/particle/particle.ts");
const spiketrap_1 = __webpack_require__(/*! ../tile/spiketrap */ "./src/tile/spiketrap.ts");
const pottedPlant_1 = __webpack_require__(/*! ../entity/object/pottedPlant */ "./src/entity/object/pottedPlant.ts");
const hitWarning_1 = __webpack_require__(/*! ../drawable/hitWarning */ "./src/drawable/hitWarning.ts");
const upLadder_1 = __webpack_require__(/*! ../tile/upLadder */ "./src/tile/upLadder.ts");
const downLadder_1 = __webpack_require__(/*! ../tile/downLadder */ "./src/tile/downLadder.ts");
const coalResource_1 = __webpack_require__(/*! ../entity/resource/coalResource */ "./src/entity/resource/coalResource.ts");
const goldResource_1 = __webpack_require__(/*! ../entity/resource/goldResource */ "./src/entity/resource/goldResource.ts");
const emeraldResource_1 = __webpack_require__(/*! ../entity/resource/emeraldResource */ "./src/entity/resource/emeraldResource.ts");
const chasm_1 = __webpack_require__(/*! ../tile/chasm */ "./src/tile/chasm.ts");
const spawner_1 = __webpack_require__(/*! ../entity/enemy/spawner */ "./src/entity/enemy/spawner.ts");
const vendingMachine_1 = __webpack_require__(/*! ../entity/object/vendingMachine */ "./src/entity/object/vendingMachine.ts");
const wallTorch_1 = __webpack_require__(/*! ../tile/wallTorch */ "./src/tile/wallTorch.ts");
const chargeEnemy_1 = __webpack_require__(/*! ../entity/enemy/chargeEnemy */ "./src/entity/enemy/chargeEnemy.ts");
const heart_1 = __webpack_require__(/*! ../item/usable/heart */ "./src/item/usable/heart.ts");
const spear_1 = __webpack_require__(/*! ../item/weapon/spear */ "./src/item/weapon/spear.ts");
const player_1 = __webpack_require__(/*! ../player/player */ "./src/player/player.ts");
const crabEnemy_1 = __webpack_require__(/*! ../entity/enemy/crabEnemy */ "./src/entity/enemy/crabEnemy.ts");
const zombieEnemy_1 = __webpack_require__(/*! ../entity/enemy/zombieEnemy */ "./src/entity/enemy/zombieEnemy.ts");
const bigSkullEnemy_1 = __webpack_require__(/*! ../entity/enemy/bigSkullEnemy */ "./src/entity/enemy/bigSkullEnemy.ts");
const random_1 = __webpack_require__(/*! ../utility/random */ "./src/utility/random.ts");
const bishopEnemy_1 = __webpack_require__(/*! ../entity/enemy/bishopEnemy */ "./src/entity/enemy/bishopEnemy.ts");
const rockResource_1 = __webpack_require__(/*! ../entity/resource/rockResource */ "./src/entity/resource/rockResource.ts");
const armoredzombieEnemy_1 = __webpack_require__(/*! ../entity/enemy/armoredzombieEnemy */ "./src/entity/enemy/armoredzombieEnemy.ts");
const tombStone_1 = __webpack_require__(/*! ../entity/object/tombStone */ "./src/entity/object/tombStone.ts");
const queenEnemy_1 = __webpack_require__(/*! ../entity/enemy/queenEnemy */ "./src/entity/enemy/queenEnemy.ts");
const frogEnemy_1 = __webpack_require__(/*! ../entity/enemy/frogEnemy */ "./src/entity/enemy/frogEnemy.ts");
const bigKnightEnemy_1 = __webpack_require__(/*! ../entity/enemy/bigKnightEnemy */ "./src/entity/enemy/bigKnightEnemy.ts");
const enemy_1 = __webpack_require__(/*! ../entity/enemy/enemy */ "./src/entity/enemy/enemy.ts");
const fireWizard_1 = __webpack_require__(/*! ../entity/enemy/fireWizard */ "./src/entity/enemy/fireWizard.ts");
const energyWizard_1 = __webpack_require__(/*! ../entity/enemy/energyWizard */ "./src/entity/enemy/energyWizard.ts");
const reverb_1 = __webpack_require__(/*! ../sound/reverb */ "./src/sound/reverb.ts");
const astarclass_1 = __webpack_require__(/*! ../utility/astarclass */ "./src/utility/astarclass.ts");
const torch_1 = __webpack_require__(/*! ../item/light/torch */ "./src/item/light/torch.ts");
const rookEnemy_1 = __webpack_require__(/*! ../entity/enemy/rookEnemy */ "./src/entity/enemy/rookEnemy.ts");
const beamEffect_1 = __webpack_require__(/*! ../projectile/beamEffect */ "./src/projectile/beamEffect.ts");
const environmentTypes_1 = __webpack_require__(/*! ../constants/environmentTypes */ "./src/constants/environmentTypes.ts");
const occultistEnemy_1 = __webpack_require__(/*! ../entity/enemy/occultistEnemy */ "./src/entity/enemy/occultistEnemy.ts");
const decoration_1 = __webpack_require__(/*! ../tile/decorations/decoration */ "./src/tile/decorations/decoration.ts");
const bomb_1 = __webpack_require__(/*! ../entity/object/bomb */ "./src/entity/object/bomb.ts");
const sound_1 = __webpack_require__(/*! ../sound/sound */ "./src/sound/sound.ts");
const block_1 = __webpack_require__(/*! ../entity/object/block */ "./src/entity/object/block.ts");
const armoredSkullEnemy_1 = __webpack_require__(/*! ../entity/enemy/armoredSkullEnemy */ "./src/entity/enemy/armoredSkullEnemy.ts");
const mummyEnemy_1 = __webpack_require__(/*! ../entity/enemy/mummyEnemy */ "./src/entity/enemy/mummyEnemy.ts");
const spiderEnemy_1 = __webpack_require__(/*! ../entity/enemy/spiderEnemy */ "./src/entity/enemy/spiderEnemy.ts");
const roomBuilder_1 = __webpack_require__(/*! ./roomBuilder */ "./src/room/roomBuilder.ts");
const bigZombieEnemy_1 = __webpack_require__(/*! ../entity/enemy/bigZombieEnemy */ "./src/entity/enemy/bigZombieEnemy.ts");
const candle_1 = __webpack_require__(/*! ../item/light/candle */ "./src/item/light/candle.ts");
const glowBugEnemy_1 = __webpack_require__(/*! ../entity/enemy/glowBugEnemy */ "./src/entity/enemy/glowBugEnemy.ts");
const gameplaySettings_1 = __webpack_require__(/*! ../game/gameplaySettings */ "./src/game/gameplaySettings.ts");
const webglBlurRenderer_1 = __webpack_require__(/*! ../gui/webglBlurRenderer */ "./src/gui/webglBlurRenderer.ts");
const utils_1 = __webpack_require__(/*! ../utility/utils */ "./src/utility/utils.ts");
const tree_1 = __webpack_require__(/*! ../entity/object/tree */ "./src/entity/object/tree.ts");
const IdGenerator_1 = __webpack_require__(/*! ../globalStateManager/IdGenerator */ "./src/globalStateManager/IdGenerator.ts");
// #endregion
// #region Enums & Interfaces
/**
 * Enumeration of available enemy types.
 */
var EnemyType;
(function (EnemyType) {
    EnemyType["crab"] = "crab";
    EnemyType["frog"] = "frog";
    EnemyType["zombie"] = "zombie";
    EnemyType["skull"] = "skull";
    EnemyType["energyWizard"] = "energywizard";
    EnemyType["charge"] = "charge";
    EnemyType["rook"] = "rook";
    EnemyType["bishop"] = "bishop";
    EnemyType["armoredzombie"] = "armoredzombie";
    EnemyType["bigskull"] = "bigskull";
    EnemyType["queen"] = "queen";
    EnemyType["knight"] = "knight";
    EnemyType["bigknight"] = "bigknight";
    EnemyType["firewizard"] = "firewizard";
    EnemyType["spawner"] = "spawner";
    EnemyType["occultist"] = "occultist";
    EnemyType["bomb"] = "bomb";
    EnemyType["armoredskull"] = "armoredskull";
    EnemyType["mummy"] = "mummy";
    EnemyType["spider"] = "spider";
    EnemyType["bigzombie"] = "bigzombie";
    EnemyType["glowbug"] = "glowbug";
    EnemyType["tree"] = "tree";
    EnemyType["tombStone"] = "tombstone";
    // Add other enemy types here
})(EnemyType = exports.EnemyType || (exports.EnemyType = {}));
/**
 * Mapping of enemy types to their corresponding classes.
 */
exports.EnemyTypeMap = {
    [EnemyType.crab]: crabEnemy_1.CrabEnemy,
    [EnemyType.frog]: frogEnemy_1.FrogEnemy,
    [EnemyType.zombie]: zombieEnemy_1.ZombieEnemy,
    [EnemyType.skull]: skullEnemy_1.SkullEnemy,
    [EnemyType.energyWizard]: energyWizard_1.EnergyWizardEnemy,
    [EnemyType.charge]: chargeEnemy_1.ChargeEnemy,
    [EnemyType.rook]: rookEnemy_1.RookEnemy,
    [EnemyType.bishop]: bishopEnemy_1.BishopEnemy,
    [EnemyType.armoredzombie]: armoredzombieEnemy_1.ArmoredzombieEnemy,
    [EnemyType.bigskull]: bigSkullEnemy_1.BigSkullEnemy,
    [EnemyType.queen]: queenEnemy_1.QueenEnemy,
    [EnemyType.knight]: knightEnemy_1.KnightEnemy,
    [EnemyType.bigknight]: bigKnightEnemy_1.BigKnightEnemy,
    [EnemyType.firewizard]: fireWizard_1.FireWizardEnemy,
    [EnemyType.spawner]: spawner_1.Spawner,
    [EnemyType.occultist]: occultistEnemy_1.OccultistEnemy,
    [EnemyType.bomb]: bomb_1.Bomb,
    [EnemyType.armoredskull]: armoredSkullEnemy_1.ArmoredSkullEnemy,
    [EnemyType.mummy]: mummyEnemy_1.MummyEnemy,
    [EnemyType.spider]: spiderEnemy_1.SpiderEnemy,
    [EnemyType.bigzombie]: bigZombieEnemy_1.BigZombieEnemy,
    [EnemyType.glowbug]: glowBugEnemy_1.GlowBugEnemy,
    [EnemyType.tree]: tree_1.Tree,
    [EnemyType.tombStone]: tombStone_1.TombStone,
    // Add other enemy mappings here
};
var RoomType;
(function (RoomType) {
    RoomType["START"] = "START";
    RoomType["DUNGEON"] = "DUNGEON";
    RoomType["BOSS"] = "BOSS";
    RoomType["BIGDUNGEON"] = "BIGDUNGEON";
    RoomType["TREASURE"] = "TREASURE";
    RoomType["FOUNTAIN"] = "FOUNTAIN";
    RoomType["COFFIN"] = "COFFIN";
    RoomType["GRASS"] = "GRASS";
    RoomType["PUZZLE"] = "PUZZLE";
    RoomType["KEYROOM"] = "KEYROOM";
    RoomType["CHESSBOARD"] = "CHESSBOARD";
    RoomType["MAZE"] = "MAZE";
    RoomType["CORRIDOR"] = "CORRIDOR";
    RoomType["SPIKECORRIDOR"] = "SPIKECORRIDOR";
    RoomType["UPLADDER"] = "UPLADDER";
    RoomType["DOWNLADDER"] = "DOWNLADDER";
    RoomType["SHOP"] = "SHOP";
    RoomType["BIGCAVE"] = "BIGCAVE";
    RoomType["CAVE"] = "CAVE";
    RoomType["SPAWNER"] = "SPAWNER";
    RoomType["ROPEHOLE"] = "ROPEHOLE";
    RoomType["ROPECAVE"] = "ROPECAVE";
    RoomType["TUTORIAL"] = "TUTORIAL";
    RoomType["GRAVEYARD"] = "GRAVEYARD";
    RoomType["FOREST"] = "FOREST";
    RoomType["ROPEUP"] = "ROPEUP";
})(RoomType = exports.RoomType || (exports.RoomType = {}));
var TurnState;
(function (TurnState) {
    TurnState[TurnState["playerTurn"] = 0] = "playerTurn";
    TurnState[TurnState["computerTurn"] = 1] = "computerTurn";
})(TurnState = exports.TurnState || (exports.TurnState = {}));
var WallDirection;
(function (WallDirection) {
    WallDirection["NORTH"] = "North";
    WallDirection["EAST"] = "East";
    WallDirection["SOUTH"] = "South";
    WallDirection["WEST"] = "West";
    WallDirection["TOPLEFT"] = "TopLeft";
    WallDirection["TOPRIGHT"] = "TopRight";
    WallDirection["BOTTOMLEFT"] = "BottomLeft";
    WallDirection["BOTTOMRIGHT"] = "BottomRight";
})(WallDirection = exports.WallDirection || (exports.WallDirection = {}));
class Room {
    constructor(game, x, y, w, h, type, depth, mapGroup, level, rand = random_1.Random.rand, envType) {
        this.name = "";
        this.shadeColor = "#000000";
        this.wallInfo = new Map();
        this.tunnelDoor = null; // this is the door that connects the start room to the exit room
        this.blurOffsetX = 5;
        this.blurOffsetY = 5;
        this.lastDraw = 0;
        this.drawTimestamp = 0;
        this.drawInterval = 4;
        // Add a list to keep track of BeamEffect instances
        this.beamEffects = [];
        // Add this property to track created mask canvases
        this.maskCanvases = [];
        // Add blur cache property
        this.blurCache = {
            color6px: null,
            color12px: null,
            shade5px: null,
            bloom8px: null,
            isValid: false,
            lastLightingUpdate: 0,
        };
        // #region TILE ADDING METHODS
        this.removeWall = (x, y) => {
            if (this.roomArray[x][y] instanceof wall_1.Wall) {
                this.roomArray[x][y] = null;
            }
            //this.innerWalls = this.innerWalls.filter((w) => w.x !== x && w.y !== y);
            //this.outerWalls = this.outerWalls.filter((w) => w.x !== x && w.y !== y);
        };
        this.addDoor = (x, y, room = this, tunnelDoor = false) => {
            let d;
            let t = door_1.DoorType.DOOR;
            if (room.type === RoomType.BOSS)
                t = door_1.DoorType.GUARDEDDOOR;
            if (room.type === RoomType.KEYROOM)
                t = door_1.DoorType.LOCKEDDOOR;
            if (tunnelDoor)
                t = door_1.DoorType.TUNNELDOOR;
            if (x === room.roomX) {
                d = new door_1.Door(room, room.game, x, y, game_1.Direction.RIGHT, t);
                room.roomArray[x + 1][y] = new spawnfloor_1.SpawnFloor(room, x + 1, y);
            }
            else if (x === room.roomX + room.width - 1) {
                d = new door_1.Door(room, room.game, x, y, game_1.Direction.LEFT, t);
                room.roomArray[x - 1][y] = new spawnfloor_1.SpawnFloor(room, x - 1, y);
            }
            else if (y === room.roomY) {
                d = new door_1.Door(room, room.game, x, y, game_1.Direction.UP, t);
                room.roomArray[x][y + 1] = new spawnfloor_1.SpawnFloor(room, x, y + 1);
            }
            else if (y === room.roomY + room.height - 1) {
                d = new door_1.Door(room, room.game, x, y, game_1.Direction.DOWN, t);
                room.roomArray[x][y - 1] = new spawnfloor_1.SpawnFloor(room, x, y - 1);
            }
            if (tunnelDoor) {
                room.tunnelDoor = d;
            }
            room.doors.push(d);
            if (room.roomArray[d.x] == undefined) {
                //console.log("door not added");
            }
            room.roomArray[d.x][d.y] = d;
            return d;
        };
        //used for spawn commands, implement elsewhere later
        /**
         * Adds a new enemy to the room based on the provided enemy type string.
         *
         * @param enemyType - The string identifier for the enemy type.
         */
        this.addNewEnemy = (enemyType) => {
            const EnemyClass = exports.EnemyTypeMap[enemyType];
            if (!EnemyClass) {
                console.error(`Enemy type "${enemyType}" is not recognized.`);
                return;
            }
            const tiles = this.getEmptyTiles();
            if (!tiles || tiles.length === 0) {
                // console.log(`No tiles left to spawn enemies.`);
                return;
            }
            let position = this.getRandomEmptyPosition(tiles);
            if (!position) {
                return;
            }
            let { x, y } = position;
            if (enemyType === EnemyType.bigzombie) {
                position = this.getBigRandomEmptyPosition(tiles);
                if (!position) {
                    return;
                }
                ({ x, y } = position);
            }
            EnemyClass.add(this, this.game, x, y);
        };
        this.addNewSpawner = (enemyType) => {
            const EnemyClass = exports.EnemyTypeMap[enemyType];
            if (!EnemyClass) {
                //console.error(`Enemy type "${enemyType}" is not recognized.`);
                return;
            }
            const tiles = this.getEmptyTiles();
            if (!tiles || tiles.length === 0) {
                // console.log(`No tiles left to spawn enemies.`);
                return;
            }
            const { x, y } = this.getRandomEmptyPosition(tiles);
            spawner_1.Spawner.add(this, this.game, x, y);
        };
        // #endregion
        // #region ENTERING / EXITING ROOM METHODS
        this.linkExitToStart = () => {
            //if (this.type === RoomType.ROPEHOLE) return;
            if (this.addDoorWithOffset(this.level.startRoom.roomX +
                Math.floor(this.level.startRoom.width / 2) +
                1, this.level.startRoom.roomY, this.level.startRoom, true) &&
                this.addDoorWithOffset(this.roomX + Math.floor(this.width / 2) - 1, this.roomY, this, true)) {
                this.tunnelDoor.linkedDoor = this.level.startRoom.tunnelDoor;
                this.tunnelDoor.linkedDoor.linkedDoor = this.tunnelDoor;
            }
        };
        this.exitLevel = () => {
            //this.game.onResize(); // stupid hack to keep fps high
            game_1.Game.shade_canvases = {};
            game_1.Game.text_rendering_canvases = {};
            for (let door of this.doors) {
                if (door.linkedDoor.lightSource !== null &&
                    !door.linkedDoor.room.active &&
                    door.linkedDoor.room.entered) {
                    door.linkedDoor.lightSource.b = 0;
                    door.linkedDoor.lightSource.r = 0;
                    door.room.updateLighting();
                }
            }
            this.active = false;
            this.updateLighting();
            this.particles.splice(0, this.particles.length);
            this.disableFuseSounds();
        };
        this.disableFuseSounds = () => {
            for (const b of this.entities.filter((e) => e instanceof bomb_1.Bomb)) {
                //if (!bomb.soundPaused) {
                //bomb.soundPaused = true;
                const bomb = b;
                sound_1.Sound.stopSound(bomb.fuseSound);
                //}
            }
        };
        this.enableFuseSounds = () => {
            for (const b of this.entities.filter((e) => e instanceof bomb_1.Bomb)) {
                //if (!bomb.soundPaused) {
                //bomb.soundPaused = true;
                const bomb = b;
                if (bomb.lit) {
                    sound_1.Sound.playWithReverb(bomb.fuseSound);
                }
            }
        };
        this.onEnterRoom = (player) => {
            this.enableFuseSounds();
            for (let room of this.level.rooms) {
                room.roomOnScreen(player);
            }
            this.entered = true;
            this.clearDeadStuff();
            this.calculateWallInfo();
            this.resetDoorLightSources();
            this.particles = [];
            this.alertEnemiesOnEntry();
            this.message = this.name;
            player.map.saveMapData();
            this.setReverb();
            this.active = true;
            this.invalidateBlurCache(); // Invalidate cache when room becomes active
            this.updateLighting();
        };
        this.enterLevel = (player) => {
            this.game.updateLevel(this);
            let roomCenter = this.getRoomCenter();
            if (this.roomArray[roomCenter.x][roomCenter.y].isSolid()) {
                roomCenter = this.getRandomEmptyPosition(this.getEmptyTiles());
            }
            let x = roomCenter.x;
            let y = roomCenter.y;
            // Use different variable names to avoid shadowing
            for (let i = this.roomX; i < this.roomX + this.width; i++) {
                for (let j = this.roomY; j < this.roomY + this.height; j++) {
                    const tile = this.roomArray[i]?.[j];
                    if (tile instanceof downLadder_1.DownLadder) {
                        x = tile.x;
                        y = tile.y;
                    }
                }
            }
            player.moveSnap(x, y);
            this.onEnterRoom(player);
        };
        this.enterLevelThroughDoor = (player, door, side) => {
            // console.log(door.linkedDoor.x, door.linkedDoor.y, door.x, door.y);
            if (door.doorDir === door.linkedDoor.doorDir) {
                door.opened = true;
                player.moveSnap(door.x, door.y + 1);
                setTimeout(() => {
                    player.direction = game_1.Direction.DOWN;
                }, 150);
            }
            if (door instanceof door_1.Door && door.doorDir === game_1.Direction.UP) {
                //if top door
                door.opened = true;
                player.moveNoSmooth(door.x, door.y + 1);
            }
            else if (door instanceof door_1.Door && door.doorDir === game_1.Direction.DOWN) {
                //if bottom door
                player.moveNoSmooth(door.x, door.y - 1);
            }
            else if (door instanceof door_1.Door &&
                [game_1.Direction.RIGHT, game_1.Direction.LEFT].includes(door.doorDir)) {
                // if side door
                player.moveNoSmooth(door.x + side, door.y);
            }
            this.onEnterRoom(player);
        };
        this.alertEnemiesOnEntry = () => {
            for (const e of this.entities) {
                if (e instanceof enemy_1.Enemy)
                    e.lookForPlayer(false);
            }
        };
        // #endregion
        // #region LOGIC METHODS
        this.tick = (player) => {
            this.updateLighting();
            player.updateSlowMotion();
            this.lastEnemyCount = this.entities.filter((e) => e instanceof enemy_1.Enemy).length;
            for (const h of this.hitwarnings) {
                h.tick();
            }
            for (const p of this.projectiles) {
                p.tick();
            }
            this.clearDeadStuff();
            this.calculateWallInfo();
            this.entities = this.entities.filter((e) => !e.dead);
            for (let x = this.roomX; x < this.roomX + this.width; x++) {
                for (let y = this.roomY; y < this.roomY + this.height; y++) {
                    this.roomArray[x][y].tick();
                }
            }
            this.turn = TurnState.computerTurn;
            this.playerTurnTime = Date.now();
            this.playerTicked = player;
            this.updateLighting();
            player.map.saveMapData();
            this.clearDeadStuff();
        };
        this.computerTurn = () => {
            // take computer turn
            for (const e of this.entities) {
                e.tick();
            }
            this.entities = this.entities.filter((e) => !e.dead);
            for (const i of this.items) {
                i.tick();
            }
            for (const p in this.game.players) {
                for (const i of this.game.players[p].inventory.items) {
                    if (i)
                        i.tick();
                }
            }
            for (const h of this.hitwarnings) {
                if (!this.roomArray[h.x] ||
                    !this.roomArray[h.x][h.y] ||
                    this.roomArray[h.x][h.y].isSolid()) {
                    h.dead = true;
                }
                h.removeOverlapping();
            }
            for (const p of this.projectiles) {
                if (this.roomArray[p.x] &&
                    this.roomArray[p.x][p.y] &&
                    this.roomArray[p.x][p.y].isSolid())
                    p.dead = true;
                for (const i in this.game.players) {
                    if (this.level.rooms[this.game.players[i].levelID] === this &&
                        p.x === this.game.players[i].x &&
                        p.y === this.game.players[i].y) {
                        p.hitPlayer(this.game.players[i]);
                    }
                }
                for (const e of this.entities) {
                    if (p.x === e.x && p.y === e.y) {
                        p.hitEnemy(e);
                    }
                }
            }
            for (let x = this.roomX; x < this.roomX + this.width; x++) {
                for (let y = this.roomY; y < this.roomY + this.height; y++) {
                    this.roomArray[x][y].tickEnd();
                }
            }
            this.entities = this.entities.filter((e) => !e.dead); // enemies may be killed by spiketrap
            this.clearDeadStuff();
            this.playerTicked.finishTick();
            this.checkForNoEnemies();
            //console.log(this.entities.filter((e) => e instanceof Enemy).length);
            this.turn = TurnState.playerTurn;
        };
        this.update = () => {
            if (this.turn == TurnState.computerTurn) {
                if (Date.now() - this.playerTurnTime >=
                    levelConstants_1.LevelConstants.COMPUTER_TURN_DELAY) {
                    this.computerTurn();
                }
            }
        };
        this.clearDeadStuff = () => {
            this.deadEntities = this.deadEntities.filter((e) => !e.dead);
            this.entities = this.entities.filter((e) => !e.dead);
            this.projectiles = this.projectiles.filter((p) => !p.dead);
            this.lightSources = this.lightSources.filter((ls) => !ls.dead);
            this.hitwarnings = this.hitwarnings.filter((h) => !h.dead);
            this.particles = this.particles.filter((p) => !p.dead);
        };
        this.catchUp = () => {
            if (this.turn === TurnState.computerTurn)
                this.computerTurn(); // player skipped computer's turn, catch up
        };
        this.tickHitWarnings = () => {
            for (const h of this.hitwarnings) {
                if (h.parent && (h.parent.dead || h.parent.unconscious)) {
                    h.tick();
                }
            }
        };
        // #endregion
        // #region LIGHTING METHODS
        this.fadeLighting = (delta) => {
            for (let x = this.roomX; x < this.roomX + this.width; x++) {
                for (let y = this.roomY; y < this.roomY + this.height; y++) {
                    let visDiff = this.softVis[x][y] - this.vis[x][y];
                    let softVis = this.softVis[x][y];
                    let flag = false;
                    if (Math.abs(visDiff) > 0.01)
                        flag = true;
                    if (!flag)
                        continue;
                    visDiff *= 0.05 * delta;
                    softVis -= visDiff;
                    if (softVis < 0)
                        softVis = 0;
                    if (softVis > 1)
                        softVis = 1;
                    this.softVis[x][y] = softVis;
                    // if (this.softVis[x][y] < 0.01) this.softVis[x][y] = 0;
                }
            }
        };
        this.fadeRgb = (delta) => {
            for (let x = this.roomX; x < this.roomX + this.width; x++) {
                for (let y = this.roomY; y < this.roomY + this.height; y++) {
                    const [softR, softG, softB] = this.softCol[x][y];
                    const [targetR, targetG, targetB] = this.col[x][y];
                    // Calculate differences
                    let diffR = softR - targetR;
                    let diffG = softG - targetG;
                    let diffB = softB - targetB;
                    let flagR = false;
                    let flagG = false;
                    let flagB = false;
                    if (Math.abs(diffR) > 0.001)
                        flagR = true;
                    if (Math.abs(diffG) > 0.001)
                        flagG = true;
                    if (Math.abs(diffB) > 0.001)
                        flagB = true;
                    if (!flagR && !flagG && !flagB) {
                        continue;
                    }
                    // Apply smoothing similar to fadeLighting
                    if (flagR) {
                        diffR *= 0.05 * delta;
                        this.softCol[x][y][0] = this.clamp(Math.round(softR - diffR), 0, 255);
                    }
                    if (flagG) {
                        diffG *= 0.05 * delta;
                        this.softCol[x][y][1] = this.clamp(Math.round(softG - diffG), 0, 255);
                    }
                    if (flagB) {
                        diffB *= 0.05 * delta;
                        this.softCol[x][y][2] = this.clamp(Math.round(softB - diffB), 0, 255);
                    }
                }
            }
        };
        this.resetDoorLightSources = () => {
            this.doors.forEach((d) => {
                d.lightSource.r = 0;
                d.linkedDoor.lightSource.r = 0;
            });
        };
        this.tileValuesToLightSource = (x, y, room) => {
            if (!room.roomArray[x])
                return null;
            if (!room.roomArray[x][y])
                return null;
            const color = room.col[x][y];
            const brightness = (1 - room.vis[x][y]) / 4;
            const radius = 9;
            return { color, brightness, radius };
        };
        this.updateDoorLightSources = () => {
            //works from inactive rooms onto their connected rooms
            if (!this.active)
                return;
            const directionOffsets = {
                [game_1.Direction.UP]: { x: 0, y: -1 },
                [game_1.Direction.DOWN]: { x: 0, y: 1 },
                [game_1.Direction.LEFT]: { x: -1, y: 0 },
                [game_1.Direction.RIGHT]: { x: 1, y: 0 },
            };
            let linkedDoors = [];
            this.doors.forEach((d) => {
                if (d.linkedDoor && d.room.entered)
                    linkedDoors.push(d.linkedDoor);
            });
            this.doors.forEach((d) => {
                d.lightSource.b = 0.1;
            });
            for (const d of linkedDoors) {
                d.lightSource.c = this.tileValuesToLightSource(d.linkedDoor.x, d.linkedDoor.y, this).color;
                d.lightSource.b = this.tileValuesToLightSource(d.linkedDoor.x, d.linkedDoor.y, this).brightness;
                d.lightSource.r = levelConstants_1.LevelConstants.LIGHTING_MAX_DISTANCE;
            }
            let connectedRooms = new Set(this.doors
                .filter((d) => d && d.linkedDoor) // Ensure door and linkedDoor exist
                .map((d) => d.linkedDoor.room)
                .filter((r) => r));
            for (const r of Array.from(connectedRooms)) {
                if (r.entered)
                    r.updateLighting();
            }
        };
        this.updateLighting = () => {
            if (!this.onScreen)
                return;
            // Invalidate cache when lighting is updated
            this.invalidateBlurCache();
            // Start timing the initial setup
            //console.time("updateLighting: Initial Setup");
            this.updateDoorLightSources();
            let oldVis = [];
            let oldCol = [];
            for (let x = this.roomX; x < this.roomX + this.width; x++) {
                oldVis[x] = [];
                oldCol[x] = [];
                for (let y = this.roomY; y < this.roomY + this.height; y++) {
                    oldVis[x][y] = this.vis[x][y];
                    oldCol[x][y] = this.col[x][y];
                    this.vis[x][y] = 1;
                    this.col[x][y] = [1, 1, 1];
                    this.renderBuffer[x][y] = [];
                }
            }
            // End timing the initial setup
            //console.timeEnd("updateLighting: Initial Setup");
            // Start timing the processing of light sources
            //console.time("updateLighting: Process LightSources");
            for (const l of this.lightSources) {
                if (l.shouldUpdate()) {
                    for (let i = 0; i < 360; i += levelConstants_1.LevelConstants.LIGHTING_ANGLE_STEP) {
                        this.castTintAtAngle(i, l.x, l.y, l.r, l.c, l.b); // RGB color in sRGB
                    }
                }
            }
            let lightingAngleStep = levelConstants_1.LevelConstants.LIGHTING_ANGLE_STEP;
            for (const p in this.game.players) {
                let player = this.game.players[p];
                if (this === this.level.rooms[player.levelID]) {
                    //console.log(`i: ${player.angle}`);
                    for (let i = 0; i < 360; i += lightingAngleStep) {
                        let lightColor = levelConstants_1.LevelConstants.AMBIENT_LIGHT_COLOR;
                        let lightBrightness = 5;
                        if (player.lightEquipped) {
                            lightColor = player.lightColor;
                            lightBrightness = player.lightBrightness;
                        }
                        let offsetX = 0;
                        let offsetY = 0;
                        switch (player.direction) {
                            case game_1.Direction.UP:
                                offsetY = -0;
                                break;
                            case game_1.Direction.DOWN:
                                offsetY = 0;
                                break;
                            case game_1.Direction.LEFT:
                                offsetX = -0;
                                break;
                            case game_1.Direction.RIGHT:
                                offsetX = 0;
                        }
                        this.castTintAtAngle(i, player.x + 0.5 + offsetX, player.y + 0.5 + offsetY, 
                        /*
                        Math.min(
                          Math.max(
                            player.sightRadius - this.depth + 2,
                            Player.minSightRadius,
                          ),
                          10,
                        ),
                        */
                        levelConstants_1.LevelConstants.LIGHTING_MAX_DISTANCE, lightColor, // RGB color in sRGB
                        lightBrightness);
                    }
                }
            }
            // End timing the processing of player lighting
            //console.timeEnd("updateLighting: Process Players");
            // Start timing the blending of colors
            //console.time("updateLighting: Blend Colors Array");
            const roomX = this.roomX;
            const roomY = this.roomY;
            const width = this.width;
            const height = this.height;
            const renderBuffer = this.renderBuffer;
            for (let x = roomX; x < roomX + width; x++) {
                for (let y = roomY; y < roomY + height; y++) {
                    this.col[x][y] = this.blendColorsArray(renderBuffer[x][y]);
                }
            }
            // End timing the blending of colors
            //console.timeEnd("updateLighting: Blend Colors Array");
            // Start timing the conversion to luminance
            //console.time("updateLighting: Convert to Luminance");
            for (let x = roomX; x < roomX + width; x++) {
                for (let y = roomY; y < roomY + height; y++) {
                    this.vis[x][y] = this.rgbToLuminance(this.col[x][y]);
                }
            }
            // End timing the conversion to luminance
            //console.timeEnd("updateLighting: Convert to Luminance");
            this.updateDoorLightSources();
        };
        this.updateLightSources = (lightSource, remove) => {
            this.oldCol = [];
            this.oldVis = [];
            this.oldCol = this.col;
            this.oldVis = this.vis;
            if (lightSource) {
                for (let i = 0; i < 360; i += levelConstants_1.LevelConstants.LIGHTING_ANGLE_STEP) {
                    if (!remove) {
                        this.castTintAtAngle(i, lightSource.x, lightSource.y, lightSource.r, lightSource.c, lightSource.b); // RGB color in sRGB
                    }
                    else {
                        this.unCastTintAtAngle(i, lightSource.x, lightSource.y, lightSource.r, lightSource.c, lightSource.b);
                    }
                }
            }
            for (let x = this.roomX; x < this.roomX + this.width; x++) {
                for (let y = this.roomY; y < this.roomY + this.height; y++) {
                    this.col[x][y] = this.blendColorsArray(this.renderBuffer[x][y]);
                }
            }
            for (let x = this.roomX; x < this.roomX + this.width; x++) {
                for (let y = this.roomY; y < this.roomY + this.height; y++) {
                    this.vis[x][y] = this.rgbToLuminance(this.col[x][y]);
                }
            }
        };
        this.revertLightSources = () => {
            //console.log("reverting lighting");
            this.oldCol = [];
            this.oldVis = [];
            this.col = this.oldCol;
            this.vis = this.oldVis;
        };
        /**
         * Casts or uncategorizes a tint from a light source at a specific angle.
         *
         * @param angle - The angle in degrees at which to cast or uncast the tint.
         * @param px - The x-coordinate of the light source.
         * @param py - The y-coordinate of the light source.
         * @param radius - The radius of the light's influence.
         * @param color - The RGB color tuple representing the tint.
         * @param brightness - The brightness of the light source.
         * @param action - 'cast' to add tint, 'unCast' to remove tint.
         */
        this.processTintAtAngle = (angle, px, py, radius, color, brightness, action = "cast") => {
            const dx = Math.cos((angle * Math.PI) / 180);
            const dy = Math.sin((angle * Math.PI) / 180);
            // Convert input color from sRGB to linear RGB
            const linearColor = [
                this.sRGBToLinear(color[0]),
                this.sRGBToLinear(color[1]),
                this.sRGBToLinear(color[2]),
            ];
            for (let i = 0; i <= Math.min(levelConstants_1.LevelConstants.LIGHTING_MAX_DISTANCE, radius); i++) {
                const currentX = Math.floor(px + dx * i);
                const currentY = Math.floor(py + dy * i);
                if (!this.isPositionInRoom(currentX, currentY))
                    return; // Outside the room
                const tile = this.roomArray[currentX][currentY];
                if (tile.isOpaque())
                    return; // Stop processing through opaque tiles
                // Handle i=0 separately to ensure correct intensity
                let intensity;
                if (i === 0) {
                    intensity = brightness * 0.1;
                }
                else {
                    intensity = brightness / Math.E ** (i - 0.25);
                }
                if (intensity < 0.005)
                    intensity = 0;
                if (intensity <= 0)
                    continue;
                if (!this.renderBuffer[currentX]) {
                    this.renderBuffer[currentX] = [];
                }
                if (!this.renderBuffer[currentX][currentY]) {
                    this.renderBuffer[currentX][currentY] = [];
                }
                if (gameConstants_1.GameConstants.ENEMIES_BLOCK_LIGHT) {
                    //begin processing opaque entities
                    const entity = this.entities.find((e) => e.x === currentX && e.y === currentY && e.opaque);
                    if (entity) {
                        //intensity = intensity * (1 - entity.opacity);
                        // Set the intensity for this tile and then terminate to create shadow effect
                        const weightedLinearColor = [
                            linearColor[0],
                            linearColor[1],
                            linearColor[2],
                            intensity,
                        ];
                        if (action === "cast") {
                            this.renderBuffer[currentX][currentY].push(weightedLinearColor);
                        }
                        else if (action === "unCast") {
                            this.renderBuffer[currentX][currentY] = this.renderBuffer[currentX][currentY].filter((colorEntry) => !(Math.abs(colorEntry[0] - weightedLinearColor[0]) < 0.0001 &&
                                Math.abs(colorEntry[1] - weightedLinearColor[1]) < 0.0001 &&
                                Math.abs(colorEntry[2] - weightedLinearColor[2]) < 0.0001 &&
                                Math.abs(colorEntry[3] - weightedLinearColor[3]) < 0.0001));
                        }
                        return; // Terminate after processing the opaque entity
                    }
                }
                //end processing opaque entities
                // Process inner walls like entities - terminate after processing
                if (tile instanceof wall_1.Wall && tile.isOpaque() && tile.isInnerWall()) {
                    const weightedLinearColor = [
                        linearColor[0],
                        linearColor[1],
                        linearColor[2],
                        intensity,
                    ];
                    if (action === "cast") {
                        this.renderBuffer[currentX][currentY].push(weightedLinearColor);
                    }
                    else if (action === "unCast") {
                        this.renderBuffer[currentX][currentY] = this.renderBuffer[currentX][currentY].filter((colorEntry) => !(Math.abs(colorEntry[0] - weightedLinearColor[0]) < 0.0001 &&
                            Math.abs(colorEntry[1] - weightedLinearColor[1]) < 0.0001 &&
                            Math.abs(colorEntry[2] - weightedLinearColor[2]) < 0.0001 &&
                            Math.abs(colorEntry[3] - weightedLinearColor[3]) < 0.0001));
                    }
                    return; // Terminate after processing the opaque wall
                }
                const weightedLinearColor = [
                    linearColor[0],
                    linearColor[1],
                    linearColor[2],
                    intensity,
                ];
                if (action === "cast") {
                    this.renderBuffer[currentX][currentY].push(weightedLinearColor);
                }
                else if (action === "unCast") {
                    this.renderBuffer[currentX][currentY] = this.renderBuffer[currentX][currentY].filter((colorEntry) => !(Math.abs(colorEntry[0] - weightedLinearColor[0]) < 0.0001 &&
                        Math.abs(colorEntry[1] - weightedLinearColor[1]) < 0.0001 &&
                        Math.abs(colorEntry[2] - weightedLinearColor[2]) < 0.0001 &&
                        Math.abs(colorEntry[3] - weightedLinearColor[3]) < 0.0001));
                }
            }
        };
        /**
         * Casts a tint from a light source at a specific angle.
         *
         * @param angle - The angle in degrees at which to cast the tint.
         * @param px - The x-coordinate of the light source.
         * @param py - The y-coordinate of the light source.
         * @param radius - The radius of the light's influence.
         * @param color - The RGB color tuple representing the tint.
         * @param brightness - The brightness of the light source.
         */
        this.castTintAtAngle = (angle, px, py, radius, color, brightness) => {
            this.processTintAtAngle(angle, px, py, radius, color, brightness / 3, "cast");
        };
        /**
         * Uncasts a tint from a light source at a specific angle.
         *
         * @param angle - The angle in degrees at which to uncast the tint.
         * @param px - The x-coordinate of the light source.
         * @param py - The y-coordinate of the light source.
         * @param radius - The radius of the light's influence.
         * @param color - The RGB color tuple representing the tint.
         * @param brightness - The brightness of the light source.
         */
        this.unCastTintAtAngle = (angle, px, py, radius, color, brightness) => {
            this.processTintAtAngle(angle, px, py, radius, color, brightness / 3, // added this
            "unCast");
        };
        this.sRGBToLinear = (value) => {
            const normalized = value / 255;
            if (normalized <= 0.04045) {
                return normalized / 12.92;
            }
            else {
                return Math.pow((normalized + 0.055) / 1.055, 2.2);
            }
        };
        this.linearToSRGB = (value) => {
            if (value <= 0.0031308) {
                return Math.round(12.92 * value * 255);
            }
            else {
                return Math.round((1.055 * Math.pow(value, 1 / 2.2 /*gamma*/) - 0.055) * 255);
            }
        };
        this.clamp = (value, min = 0, max = 1) => {
            return Math.min(Math.max(value, min), max);
        };
        /**
         * Blends an array of RGB colors into a single color without excessive darkness or clipping to white.
         *
         * @param colors - An array of RGB tuples to blend.
         * @returns A single RGB tuple representing the blended color.
         */
        this.blendColorsArray = (colors) => {
            if (colors.length === 0)
                return [0, 0, 0];
            // Sum all color channels in linear RGB
            const sum = colors.reduce((accumulator, color) => [
                accumulator[0] + color[0] * color[3],
                accumulator[1] + color[1] * color[3],
                accumulator[2] + color[2] * color[3],
            ], [0, 0, 0]);
            // Apply scaling factor to manage overall brightness
            const scalingFactor = 0.45 * 2.5; // Adjust as needed
            const scaledSum = [
                sum[0] * scalingFactor,
                sum[1] * scalingFactor,
                sum[2] * scalingFactor,
            ];
            // Clamp each channel to [0, 1] to prevent overflow
            const clampedSum = [
                this.clamp(scaledSum[0], 0, 1),
                this.clamp(scaledSum[1], 0, 1),
                this.clamp(scaledSum[2], 0, 1),
            ];
            // Convert back to sRGB
            return [
                this.linearToSRGB(clampedSum[0]),
                this.linearToSRGB(clampedSum[1]),
                this.linearToSRGB(clampedSum[2]),
            ];
        };
        this.rgbToLuminance = (color) => {
            //map to 1-0 range
            return 1 - (0.299 * color[0] + 0.587 * color[1] + 0.114 * color[2]) / 255;
        };
        this.draw = (delta) => {
            if (!this.onScreen)
                return;
            if (this.active) {
                hitWarning_1.HitWarning.updateFrame(delta);
                this.drawInterval = 4;
            }
            else if (!this.active) {
                this.drawInterval = 8;
            }
            this.drawTimestamp += delta;
            if (this.drawTimestamp - this.lastDraw >= this.drawInterval) {
                this.fadeRgb(delta + this.drawInterval);
                this.fadeLighting(delta + this.drawInterval);
                this.lastDraw = this.drawTimestamp;
            }
        };
        // added a multiplier to the input rgb values to avoid clipping to white
        this.drawColorLayer = () => {
            if (!this.onScreen)
                return;
            game_1.Game.ctx.save();
            // Clear the offscreen color canvas
            this.colorOffscreenCtx.clearRect(0, 0, this.colorOffscreenCanvas.width, this.colorOffscreenCanvas.height);
            let lastFillStyle = "";
            const offsetX = this.blurOffsetX;
            const offsetY = this.blurOffsetY;
            // Draw all color rectangles without any filters
            for (let x = this.roomX; x < this.roomX + this.width; x++) {
                for (let y = this.roomY; y < this.roomY + this.height; y++) {
                    const [r, g, b] = this.softCol[x][y];
                    if (r === 0 && g === 0 && b === 0)
                        continue; // Skip if no color
                    const fillStyle = `rgba(${r}, ${g}, ${b}, 1)`;
                    if (fillStyle !== lastFillStyle) {
                        this.colorOffscreenCtx.fillStyle = fillStyle;
                        lastFillStyle = fillStyle;
                    }
                    this.colorOffscreenCtx.fillRect((x - this.roomX + offsetX) * gameConstants_1.GameConstants.TILESIZE, (y - this.roomY + offsetY) * gameConstants_1.GameConstants.TILESIZE, gameConstants_1.GameConstants.TILESIZE, gameConstants_1.GameConstants.TILESIZE);
                }
            }
            // Choose blur method based on setting
            if (gameConstants_1.GameConstants.USE_WEBGL_BLUR) {
                // Use WebGL blur with caching
                const blurRenderer = webglBlurRenderer_1.WebGLBlurRenderer.getInstance();
                // Check if we can use cached results
                if (this.shouldUseBlurCache() &&
                    this.blurCache.color6px &&
                    this.blurCache.color12px) {
                    // Use cached blurred results
                    game_1.Game.ctx.globalCompositeOperation = "soft-light";
                    game_1.Game.ctx.globalAlpha = 0.6;
                    game_1.Game.ctx.drawImage(this.blurCache.color6px, (this.roomX - offsetX) * gameConstants_1.GameConstants.TILESIZE, (this.roomY - offsetY) * gameConstants_1.GameConstants.TILESIZE);
                    game_1.Game.ctx.globalCompositeOperation = "lighten";
                    game_1.Game.ctx.globalAlpha = 0.05;
                    game_1.Game.ctx.drawImage(this.blurCache.color12px, (this.roomX - offsetX) * gameConstants_1.GameConstants.TILESIZE, (this.roomY - offsetY) * gameConstants_1.GameConstants.TILESIZE);
                }
                else {
                    // Generate new blur and cache if inactive
                    game_1.Game.ctx.globalCompositeOperation = "soft-light";
                    game_1.Game.ctx.globalAlpha = 0.6;
                    // Apply 6px blur using WebGL
                    const blurred6px = blurRenderer.applyBlur(this.colorOffscreenCanvas, 6);
                    game_1.Game.ctx.drawImage(blurred6px, (this.roomX - offsetX) * gameConstants_1.GameConstants.TILESIZE, (this.roomY - offsetY) * gameConstants_1.GameConstants.TILESIZE);
                    // Cache the result if room is inactive
                    if (!this.active) {
                        this.cacheBlurResult("color6px", blurred6px);
                    }
                    game_1.Game.ctx.globalCompositeOperation = "lighten";
                    game_1.Game.ctx.globalAlpha = 0.05;
                    // Apply 12px blur using WebGL
                    const blurred12px = blurRenderer.applyBlur(this.colorOffscreenCanvas, 12);
                    game_1.Game.ctx.drawImage(blurred12px, (this.roomX - offsetX) * gameConstants_1.GameConstants.TILESIZE, (this.roomY - offsetY) * gameConstants_1.GameConstants.TILESIZE);
                    // Cache the result if room is inactive
                    if (!this.active) {
                        this.cacheBlurResult("color12px", blurred12px);
                    }
                }
            }
            else {
                // Use Canvas2D blur (fallback) - matching original settings
                game_1.Game.ctx.globalCompositeOperation =
                    gameConstants_1.GameConstants.COLOR_LAYER_COMPOSITE_OPERATION;
                game_1.Game.ctx.globalAlpha = 0.6;
                if (gameConstants_1.GameConstants.ctxBlurEnabled) {
                    game_1.Game.ctx.filter = "blur(6px)";
                }
                game_1.Game.ctx.drawImage(this.colorOffscreenCanvas, (this.roomX - offsetX) * gameConstants_1.GameConstants.TILESIZE, (this.roomY - offsetY) * gameConstants_1.GameConstants.TILESIZE);
                // Draw slight haze
                game_1.Game.ctx.globalCompositeOperation = "lighten";
                game_1.Game.ctx.globalAlpha = 0.05;
                if (gameConstants_1.GameConstants.ctxBlurEnabled) {
                    game_1.Game.ctx.filter = "blur(12px)";
                }
                game_1.Game.ctx.drawImage(this.colorOffscreenCanvas, (this.roomX - offsetX) * gameConstants_1.GameConstants.TILESIZE, (this.roomY - offsetY) * gameConstants_1.GameConstants.TILESIZE);
                game_1.Game.ctx.filter = "none";
            }
            this.colorOffscreenCtx.clearRect(0, 0, this.colorOffscreenCanvas.width, this.colorOffscreenCanvas.height);
            game_1.Game.ctx.restore();
        };
        this.drawShadeLayer = () => {
            if (gameConstants_1.GameConstants.isIOS || !gameConstants_1.GameConstants.SHADE_ENABLED)
                return;
            if (!this.onScreen)
                return;
            game_1.Game.ctx.save();
            game_1.Game.ctx.globalCompositeOperation =
                gameConstants_1.GameConstants.SHADE_LAYER_COMPOSITE_OPERATION;
            // Clear the offscreen shade canvas
            this.shadeOffscreenCtx.clearRect(0, 0, this.shadeOffscreenCanvas.width, this.shadeOffscreenCanvas.height);
            const offsetX = this.blurOffsetX;
            const offsetY = this.blurOffsetY;
            let lastFillStyle = "";
            // Draw all shade rectangles without any filters
            for (let x = this.roomX - 2; x < this.roomX + this.width + 4; x++) {
                for (let y = this.roomY - 2; y < this.roomY + this.height + 4; y++) {
                    let alpha = this.softVis[x] && this.softVis[x][y] ? this.softVis[x][y] : 0;
                    if (this.roomArray[x] &&
                        this.roomArray[x][y] &&
                        this.roomArray[x][y] instanceof wallTorch_1.WallTorch)
                        continue;
                    let factor = !gameConstants_1.GameConstants.SMOOTH_LIGHTING ? 2 : 2;
                    let smoothFactor = !gameConstants_1.GameConstants.SMOOTH_LIGHTING ? 0 : 2;
                    let computedAlpha = alpha ** factor * smoothFactor;
                    let fillX = x;
                    let fillY = y;
                    let fillWidth = 1;
                    let fillHeight = 1;
                    if (this.roomArray[x] &&
                        this.roomArray[x][y] &&
                        this.roomArray[x][y] instanceof wall_1.Wall) {
                        const wall = this.roomArray[x][y];
                        if (!this.innerWalls.includes(wall)) {
                            switch (wall.direction) {
                                case game_1.Direction.UP:
                                    fillY = y - 0.5;
                                    fillHeight = 0.5;
                                    break;
                                case game_1.Direction.DOWN:
                                    fillY = y - 0.5;
                                    fillHeight = 1.5;
                                    break;
                                case game_1.Direction.LEFT:
                                    fillX = x + 0.5;
                                    fillWidth = 0.5;
                                    break;
                                case game_1.Direction.RIGHT:
                                    fillX = x + 0;
                                    fillWidth = 0.5;
                                    break;
                                case game_1.Direction.DOWN_LEFT:
                                    fillX = x + 0.5;
                                    fillY = y - 0.5;
                                    fillWidth = 0.5;
                                    fillHeight = 1.5;
                                    break;
                                case game_1.Direction.DOWN_RIGHT:
                                    fillX = x;
                                    fillY = y - 0.5;
                                    fillWidth = 0.5;
                                    fillHeight = 1.5;
                                    break;
                                case game_1.Direction.UP_LEFT:
                                    fillX = x + 0.5;
                                    fillY = y - 0.5;
                                    fillWidth = 0.5;
                                    fillHeight = 0.5;
                                    break;
                                case game_1.Direction.UP_RIGHT:
                                    fillX = x - 0.5;
                                    fillY = y - 0.5;
                                    fillWidth = 0.5;
                                    fillHeight = 0.5;
                                    break;
                            }
                        }
                    }
                    const fillStyle = `rgba(0, 0, 0, ${computedAlpha * 0.5})`;
                    if (fillStyle !== lastFillStyle) {
                        this.shadeOffscreenCtx.fillStyle = fillStyle;
                        lastFillStyle = fillStyle;
                    }
                    fillY += 1;
                    fillX += 1;
                    this.shadeOffscreenCtx.fillRect((fillX - this.roomX + offsetX) * gameConstants_1.GameConstants.TILESIZE, (fillY - this.roomY + offsetY) * gameConstants_1.GameConstants.TILESIZE, fillWidth * gameConstants_1.GameConstants.TILESIZE, fillHeight * gameConstants_1.GameConstants.TILESIZE);
                }
            }
            // Choose blur method based on setting
            if (gameConstants_1.GameConstants.USE_WEBGL_BLUR) {
                // Use WebGL blur with caching
                const blurRenderer = webglBlurRenderer_1.WebGLBlurRenderer.getInstance();
                // Check if we can use cached results
                if (this.shouldUseBlurCache() && this.blurCache.shade5px) {
                    // Use cached blurred result
                    game_1.Game.ctx.globalAlpha = 1;
                    game_1.Game.ctx.drawImage(this.blurCache.shade5px, (this.roomX - offsetX - 1) * gameConstants_1.GameConstants.TILESIZE, (this.roomY - offsetY - 1) * gameConstants_1.GameConstants.TILESIZE);
                }
                else {
                    // Generate new blur and cache if inactive
                    game_1.Game.ctx.globalAlpha = 1;
                    // Apply 5px blur using WebGL
                    const blurred5px = blurRenderer.applyBlur(this.shadeOffscreenCanvas, 5);
                    game_1.Game.ctx.drawImage(blurred5px, (this.roomX - offsetX - 1) * gameConstants_1.GameConstants.TILESIZE, (this.roomY - offsetY - 1) * gameConstants_1.GameConstants.TILESIZE);
                    // Cache the result if room is inactive
                    if (!this.active) {
                        this.cacheBlurResult("shade5px", blurred5px);
                    }
                }
            }
            else {
                // Use Canvas2D blur (fallback) - matching original settings
                game_1.Game.ctx.globalAlpha = 1;
                if (gameConstants_1.GameConstants.ctxBlurEnabled) {
                    game_1.Game.ctx.filter = "blur(5px)";
                }
                game_1.Game.ctx.drawImage(this.shadeOffscreenCanvas, (this.roomX - offsetX - 1) * gameConstants_1.GameConstants.TILESIZE, (this.roomY - offsetY - 1) * gameConstants_1.GameConstants.TILESIZE);
                game_1.Game.ctx.filter = "none";
            }
            game_1.Game.ctx.restore();
        };
        this.drawBloomLayer = (delta) => {
            if (gameConstants_1.GameConstants.isIOS || !this.onScreen)
                return;
            game_1.Game.ctx.save();
            // Clear the offscreen shade canvas
            this.bloomOffscreenCtx.clearRect(0, 0, this.bloomOffscreenCanvas.width, this.bloomOffscreenCanvas.height);
            const offsetX = this.blurOffsetX;
            const offsetY = this.blurOffsetY;
            let lastFillStyle = "";
            // Draw all bloom rectangles without any filters
            const allEntities = this.entities.concat(this.deadEntities);
            if (allEntities.length > 0)
                for (let e of this.entities) {
                    if (e.hasBloom) {
                        e.updateBloom(delta);
                        this.bloomOffscreenCtx.globalAlpha =
                            1 * (1 - this.softVis[e.x][e.y]) * e.softBloomAlpha;
                        this.bloomOffscreenCtx.fillStyle = e.bloomColor;
                        this.bloomOffscreenCtx.fillRect((e.x - e.drawX - this.roomX + offsetX + 0.5 - e.bloomSize / 2) *
                            gameConstants_1.GameConstants.TILESIZE, (e.y -
                            e.drawY -
                            this.roomY -
                            0.5 +
                            offsetY +
                            0.5 -
                            e.bloomSize / 2) *
                            gameConstants_1.GameConstants.TILESIZE +
                            e.bloomOffsetY, gameConstants_1.GameConstants.TILESIZE * e.bloomSize, gameConstants_1.GameConstants.TILESIZE * e.bloomSize);
                    }
                }
            for (let x = this.roomX; x < this.roomX + this.width; x++) {
                for (let y = this.roomY; y < this.roomY + this.height; y++) {
                    if (this.roomArray[x][y].hasBloom) {
                        this.roomArray[x][y].updateBloom(delta);
                        this.bloomOffscreenCtx.globalAlpha =
                            1 * (1 - this.softVis[x][y]) * this.roomArray[x][y].softBloomAlpha;
                        this.bloomOffscreenCtx.fillStyle = this.roomArray[x][y].bloomColor;
                        this.bloomOffscreenCtx.fillRect((x - this.roomX + offsetX) * gameConstants_1.GameConstants.TILESIZE, (y - this.roomY - 0.25 + offsetY) * gameConstants_1.GameConstants.TILESIZE, gameConstants_1.GameConstants.TILESIZE, gameConstants_1.GameConstants.TILESIZE * 0.75);
                    }
                }
            }
            if (this.projectiles.length > 0)
                for (let p of this.projectiles) {
                    if (p.hasBloom) {
                        p.updateBloom(delta);
                        this.bloomOffscreenCtx.globalAlpha =
                            1 * (1 - this.softVis[p.x][p.y]) * p.softBloomAlpha;
                        this.bloomOffscreenCtx.fillStyle = p.bloomColor;
                        this.bloomOffscreenCtx.fillRect((p.x - this.roomX + offsetX) * gameConstants_1.GameConstants.TILESIZE, (p.y - this.roomY + offsetY + p.bloomOffsetY) *
                            gameConstants_1.GameConstants.TILESIZE, gameConstants_1.GameConstants.TILESIZE, gameConstants_1.GameConstants.TILESIZE);
                    }
                }
            // Choose blur method based on setting
            if (gameConstants_1.GameConstants.USE_WEBGL_BLUR) {
                // Use WebGL blur with caching
                const blurRenderer = webglBlurRenderer_1.WebGLBlurRenderer.getInstance();
                // Check if we can use cached results
                if (this.shouldUseBlurCache() && this.blurCache.bloom8px) {
                    // Use cached blurred result
                    game_1.Game.ctx.globalCompositeOperation = "screen";
                    game_1.Game.ctx.globalAlpha = 1;
                    game_1.Game.ctx.drawImage(this.blurCache.bloom8px, (this.roomX - offsetX) * gameConstants_1.GameConstants.TILESIZE, (this.roomY - offsetY) * gameConstants_1.GameConstants.TILESIZE);
                }
                else {
                    // Generate new blur and cache if inactive
                    game_1.Game.ctx.globalCompositeOperation = "screen";
                    game_1.Game.ctx.globalAlpha = 1;
                    // Apply 8px blur using WebGL
                    const blurred8px = blurRenderer.applyBlur(this.bloomOffscreenCanvas, 8);
                    game_1.Game.ctx.drawImage(blurred8px, (this.roomX - offsetX) * gameConstants_1.GameConstants.TILESIZE, (this.roomY - offsetY) * gameConstants_1.GameConstants.TILESIZE);
                    // Cache the result if room is inactive
                    if (!this.active) {
                        this.cacheBlurResult("bloom8px", blurred8px);
                    }
                }
            }
            else {
                // Use Canvas2D blur (fallback) - matching original settings
                game_1.Game.ctx.globalCompositeOperation = "screen";
                game_1.Game.ctx.globalAlpha = 1;
                if (gameConstants_1.GameConstants.ctxBlurEnabled) {
                    game_1.Game.ctx.filter = "blur(8px)";
                }
                game_1.Game.ctx.drawImage(this.bloomOffscreenCanvas, (this.roomX - offsetX) * gameConstants_1.GameConstants.TILESIZE, (this.roomY - offsetY) * gameConstants_1.GameConstants.TILESIZE);
                game_1.Game.ctx.filter = "none";
            }
            this.bloomOffscreenCtx.fillStyle = "rgba(0, 0, 0, 1)";
            this.bloomOffscreenCtx.fillRect(0, 0, this.bloomOffscreenCanvas.width, this.bloomOffscreenCanvas.height);
            game_1.Game.ctx.restore();
        };
        this.drawEntities = (delta, skipLocalPlayer) => {
            if (!this.onScreen)
                return;
            game_1.Game.ctx.save();
            let tiles = [];
            for (let x = this.roomX; x < this.roomX + this.width; x++) {
                for (let y = this.roomY; y < this.roomY + this.height; y++) {
                    this.roomArray[x][y].drawUnderPlayer(delta);
                    tiles.push(this.roomArray[x][y]);
                }
            }
            let drawables = new Array();
            let entities = new Array();
            entities = entities.concat(this.entities, this.deadEntities);
            drawables = drawables.concat(tiles, this.decorations, entities, this.hitwarnings, this.projectiles, this.particles, this.items);
            for (const i in this.game.players) {
                if (this.game.rooms[this.game.players[i].levelID] === this) {
                    if (!(skipLocalPlayer &&
                        this.game.players[i] === this.game.players[this.game.localPlayerID]))
                        drawables.push(this.game.players[i]);
                }
            }
            drawables.sort((a, b) => {
                if (a instanceof floor_1.Floor || a instanceof spawnfloor_1.SpawnFloor) {
                    return -1;
                }
                else if (b instanceof floor_1.Floor || b instanceof spawnfloor_1.SpawnFloor) {
                    return 1;
                }
                else if (a instanceof decoration_1.Decoration) {
                    return -1;
                }
                else if (b instanceof decoration_1.Decoration) {
                    return 1;
                }
                if (Math.abs(a.drawableY - b.drawableY) < 0.1) {
                    if (a instanceof player_1.Player) {
                        return 1;
                    }
                    else if (b instanceof player_1.Player) {
                        return -1;
                    }
                    else if (a instanceof entity_1.Entity) {
                        return 1;
                    }
                    else if (b instanceof entity_1.Entity) {
                        return -1;
                    }
                    else if (a instanceof particle_1.Particle) {
                        return 1;
                    }
                    else if (b instanceof particle_1.Particle) {
                        return -1;
                    }
                    else
                        return 0;
                }
                else {
                    return a.drawableY - b.drawableY;
                }
            });
            for (const d of drawables) {
                d.draw(delta);
            }
            this.drawAbovePlayer(delta);
            for (const i of this.items) {
                i.drawTopLayer(delta);
            }
            game_1.Game.ctx.restore();
        };
        this.drawAbovePlayer = (delta) => {
            for (let x = this.roomX; x < this.roomX + this.width; x++) {
                for (let y = this.roomY; y < this.roomY + this.height; y++) {
                    //if (this.softVis[x][y] < 1) this.roomArray[x][y].drawAbovePlayer(delta);
                }
            }
        };
        this.drawShade = (delta) => {
            if (!this.onScreen)
                return;
            game_1.Game.ctx.save();
            let bestSightRadius = 0;
            for (const p in this.game.players) {
                game_1.Game.ctx.globalCompositeOperation = "source-over"; // "soft-light";
                game_1.Game.ctx.globalAlpha = 1;
                if (this.level.rooms[this.game.players[p].levelID] === this &&
                    this.game.players[p].defaultSightRadius > bestSightRadius) {
                    bestSightRadius = this.game.players[p].defaultSightRadius;
                }
            }
            let shadingAlpha = Math.max(0, Math.min(0.8, 2 / bestSightRadius));
            if (gameConstants_1.GameConstants.ALPHA_ENABLED) {
                game_1.Game.ctx.globalAlpha = 0.25; //this.shadeOpacity();
                //Game.ctx.resetTransform();
                //Game.ctx.fillStyle = "#4a5d23"; // hex dark misty green
                game_1.Game.ctx.fillStyle = this.shadeColor;
                game_1.Game.ctx.fillRect(this.roomX * gameConstants_1.GameConstants.TILESIZE, (this.roomY - 1) * gameConstants_1.GameConstants.TILESIZE, this.width * gameConstants_1.GameConstants.TILESIZE, (this.height + 1) * gameConstants_1.GameConstants.TILESIZE);
                game_1.Game.ctx.globalAlpha = 1;
                game_1.Game.ctx.globalCompositeOperation = "source-over";
            }
            game_1.Game.ctx.restore();
        };
        this.shadeOpacity = () => {
            if (this.active) {
                return 0.25;
            }
            else {
                return 0.25;
            }
        };
        this.drawOverShade = (delta) => {
            game_1.Game.ctx.save();
            for (const e of this.entities) {
                e.drawTopLayer(delta); // health bars
            }
            for (const p of this.projectiles) {
                p.drawTopLayer(delta);
            }
            //Game.ctx.globalCompositeOperation = "overlay";
            for (const h of this.hitwarnings) {
                h.drawTopLayer(delta);
            }
            //Game.ctx.globalCompositeOperation = "source-over";
            for (const s of this.particles) {
                s.drawTopLayer(delta);
            }
            // draw over dithered shading
            for (let x = this.roomX; x < this.roomX + this.width; x++) {
                for (let y = this.roomY; y < this.roomY + this.height; y++) {
                    this.roomArray[x][y].drawAboveShading(delta);
                }
            }
            game_1.Game.ctx.restore();
        };
        // for stuff rendered on top of the player
        this.drawTopLayer = (delta) => {
            game_1.Game.ctx.save();
            // gui stuff
            // room name
            let old = game_1.Game.ctx.font;
            game_1.Game.ctx.font = gameConstants_1.GameConstants.SCRIPT_FONT_SIZE + "px Script";
            game_1.Game.ctx.fillStyle = levelConstants_1.LevelConstants.LEVEL_TEXT_COLOR;
            game_1.Game.fillText(this.message, gameConstants_1.GameConstants.WIDTH / 2 - game_1.Game.measureText(this.name).width / 2, 5);
            game_1.Game.ctx.font = old;
            game_1.Game.ctx.restore();
        };
        // src/room.ts
        this.createWallMask = () => {
            const maskCanvas = document.createElement("canvas");
            this.maskCanvases.push(maskCanvas); // <-- Track the canvas
            maskCanvas.width = this.width * gameConstants_1.GameConstants.TILESIZE;
            maskCanvas.height = this.height * gameConstants_1.GameConstants.TILESIZE;
            const ctx = maskCanvas.getContext("2d");
            if (!ctx) {
                throw new Error("Failed to create mask canvas context.");
            }
            // Fill the canvas with opaque color
            ctx.fillStyle = "rgba(255, 255, 255, 1)";
            ctx.fillRect(this.roomX * gameConstants_1.GameConstants.TILESIZE, this.roomY * gameConstants_1.GameConstants.TILESIZE, maskCanvas.width, maskCanvas.height);
            // Make wall areas transparent
            /*
            for (let x = this.roomX - 1; x < this.roomX + 1 + this.width; x++) {
              for (let y = this.roomY - 1; y < this.roomY + 1 + this.height; y++) {
                const tile = this.getTile(x, y);
                if (tile instanceof Wall) {
                  let offsetY = 0;
                  if (tile.direction === Direction.DOWN) offsetY = 1;
                  ctx.clearRect(
                    (x - this.roomX) * GameConstants.TILESIZE,
                    (y - 1 - this.roomY) * GameConstants.TILESIZE,
                    GameConstants.TILESIZE,
                    GameConstants.TILESIZE,
                  );
                }
              }
            }
              */
            return maskCanvas;
        };
        /**
         * Finds and returns the darkest and lightest tiles in the room based on their visibility.
         * Loops through the roomArray, sums all the vis values, sorts them, and identifies the extremes.
         *
         * @returns An object containing the darkest and lightest tiles with their coordinates and vis values.
         */
        this.getExtremeLuminance = () => {
            const visValues = [];
            // Loop through each tile in the room
            for (let x = this.roomX; x < this.roomX + this.width; x++) {
                for (let y = this.roomY; y < this.roomY + this.height; y++) {
                    if (this.vis[x] && this.vis[x][y] !== undefined) {
                        visValues.push({ x, y, vis: this.vis[x][y] });
                    }
                }
            }
            if (visValues.length === 0) {
                return { darkest: null, lightest: null };
            }
            // Sort the vis values in ascending order
            visValues.sort((a, b) => a.vis - b.vis);
            return {
                darkest: visValues[visValues.length - 1],
                lightest: visValues[0],
            };
        };
        /**
         * Finds and returns the darkest and lightest tiles adjacent to a given point.
         * It checks the tiles above, below, to the left, and to the right of the specified point.
         *
         * @param px - The x-coordinate of the reference point.
         * @param py - The y-coordinate of the reference point.
         * @returns An object containing the darkest and lightest adjacent tiles with their coordinates and vis values,
         *          or null if no valid adjacent tiles are found.
         */
        this.getExtremeLuminanceFromPoint = (px, py) => {
            const adjacentPositions = [
                { x: px, y: py - 1 },
                { x: px, y: py + 1 },
                { x: px - 1, y: py },
                { x: px + 1, y: py }, // Right
            ];
            const visValues = [];
            adjacentPositions.forEach((pos) => {
                const { x, y } = pos;
                if (this.vis[x] && this.vis[x][y] !== undefined) {
                    if (this.roomArray[x] && this.roomArray[x][y]) {
                        if (this.roomArray[x][y] instanceof floor_1.Floor) {
                            visValues.push({ x, y, vis: this.vis[x][y] });
                        }
                    }
                }
            });
            if (visValues.length === 0) {
                return { darkest: null, lightest: null };
            }
            // Sort the vis values in ascending order
            visValues.sort((a, b) => a.vis - b.vis);
            return {
                darkest: visValues[visValues.length - 1],
                lightest: visValues[0],
            };
        };
        this.getAverageLuminance = () => {
            let total = 0;
            let count = 0;
            for (let x = this.roomX - 2; x <= this.roomX + 2; x++) {
                if (this.roomArray[x] && this.roomArray[x][this.roomY]) {
                    for (let y = this.roomY - 2; y <= this.roomY + 2; y++) {
                        if (this.vis[x][y]) {
                            total += this.vis[x][y];
                            count++;
                        }
                    }
                }
            }
            return total / count;
        };
        this.tileInside = (tileX, tileY) => {
            return this.pointInside(tileX, tileY, this.roomX, this.roomY, this.width, this.height);
        };
        this.getEmptyTiles = () => {
            let returnVal = [];
            for (let x = this.roomX + 1; x < this.roomX + this.width - 1; x++) {
                for (let y = this.roomY + 1; y < this.roomY + this.height - 1; y++) {
                    if (!this.roomArray[x][y].isSolid() &&
                        !(this.roomArray[x][y] instanceof spiketrap_1.SpikeTrap) &&
                        !(this.roomArray[x][y] instanceof spawnfloor_1.SpawnFloor) &&
                        !(this.roomArray[x][y] instanceof upLadder_1.UpLadder) &&
                        !(this.roomArray[x][y] instanceof downLadder_1.DownLadder)) {
                        returnVal.push(this.roomArray[x][y]);
                    }
                }
            }
            for (const e of this.entities) {
                returnVal = returnVal.filter((t) => !e.pointIn(t.x, t.y));
            }
            return returnVal;
        };
        this.getTile = (x, y) => {
            if (this.roomArray[x])
                return this.roomArray[x][y];
            else
                return undefined;
        };
        this.getBossDoor = () => {
            for (const door of this.doors) {
                if (door.linkedDoor.room.type === RoomType.DOWNLADDER)
                    return { x: door.x, y: door.y, doorDir: door.doorDir };
            }
            return null;
        };
        this.hasNoEnemies = () => {
            let enemies = this.entities.filter((e) => e instanceof enemy_1.Enemy);
            const cleared = enemies.length === 0 && this.lastEnemyCount > 0;
            return cleared;
        };
        this.roomCleared = () => {
            const enemies = this.entities.filter((e) => e instanceof enemy_1.Enemy);
            return enemies.length === 0;
        };
        this.hasHitwarning = (x, y) => {
            /*
            for (const e of this.entities) {
              if (e instanceof Enemy && e.x === x && e.y === y) danger += 1;
            }
            */
            for (const h of this.hitwarnings) {
                if (h.x === x && h.y === y && !h.dead)
                    return true;
            }
            return false;
        };
        this.hasEnemy = (x, y) => {
            for (const e of this.entities) {
                if (e instanceof enemy_1.Enemy && e.x === x && e.y === y)
                    return true;
            }
            return false;
        };
        /**
         * Checks if a tile at the given coordinates is empty (not solid and no entities).
         * This is a comprehensive check that combines tile solidity and entity presence.
         *
         * @param x - The x-coordinate to check
         * @param y - The y-coordinate to check
         * @returns True if the tile is empty (walkable and no entities), false otherwise
         */
        this.isTileEmpty = (x, y) => {
            // First check if the position exists in the room array
            if (!this.roomArray[x] || !this.roomArray[x][y]) {
                return false;
            }
            const tile = this.roomArray[x][y];
            // Check if the tile is solid
            if (tile.isSolid()) {
                return false;
            }
            // Check for specific tile types that should be considered non-empty
            if (tile instanceof spiketrap_1.SpikeTrap ||
                tile instanceof spawnfloor_1.SpawnFloor ||
                tile instanceof upLadder_1.UpLadder ||
                tile instanceof downLadder_1.DownLadder) {
                return false;
            }
            // Check if there are any entities at this position
            for (const entity of this.entities) {
                if (entity.pointIn(x, y)) {
                    return false;
                }
            }
            return true;
        };
        this.hasEnemyInRadius = (x, y) => {
            const radius = 2;
            const radiusSquared = radius * radius; // Calculate once
            for (let dx = -radius; dx <= radius; dx++) {
                for (let dy = -radius; dy <= radius; dy++) {
                    // Check if point is within radius (circular check)
                    if (dx * dx + dy * dy <= radiusSquared) {
                        const checkX = x + dx;
                        const checkY = y + dy;
                        // Add bounds checking if needed
                        if (this.hasEnemy(checkX, checkY)) {
                            return true;
                        }
                    }
                }
            }
            return false;
        };
        this.checkForNoEnemies = () => {
            if (this.hasNoEnemies()) {
                let bossFlag = false;
                this.doors.forEach((d) => {
                    if (d.type === door_1.DoorType.GUARDEDDOOR) {
                        d.unGuard();
                        bossFlag = true;
                        this.game.startCameraAnimation(this.getBossDoor().x, this.getBossDoor().y, 175);
                    }
                });
                if (bossFlag) {
                    this.game.pushMessage("The foes have been slain and the door allows you passage.");
                }
            }
        };
        // checks for obstructions between doors and finds paths avoiding obstacles.
        this.removeDoorObstructions = () => {
            let obstacles = [];
            for (const door of this.doors) {
                for (const otherDoor of this.doors) {
                    if (door === otherDoor || door === null || otherDoor === null)
                        continue; // Fixed: use continue instead of break
                    const pathObstacles = this.findPath(door, otherDoor);
                    if (pathObstacles.length > 0) {
                        obstacles.push(...pathObstacles); // Fixed: actually collect the obstacles
                    }
                }
            }
            if (obstacles.length > 0) {
                for (let obstacle of obstacles) {
                    // console.log(`Removing obstacle at (${obstacle.x},${obstacle.y})`);
                    this.entities = this.entities.filter((e) => e !== obstacle);
                    obstacle = null;
                }
            }
        };
        // avoid blocking doorways with unbreakable entities
        this.findPath = (startTile, targetTile, additionalBlockedPositions) => {
            let disablePositions = Array();
            let obstacleCandidates = [];
            // Expand entity types that can block paths
            for (const e of this.entities) {
                if (e instanceof vendingMachine_1.VendingMachine ||
                    e instanceof rockResource_1.Rock ||
                    e instanceof barrel_1.Barrel ||
                    e instanceof crate_1.Crate ||
                    e instanceof block_1.Block ||
                    e instanceof tombStone_1.TombStone ||
                    e instanceof pottedPlant_1.PottedPlant) {
                    disablePositions.push({ x: e.x, y: e.y });
                    obstacleCandidates.push(e);
                }
            }
            // Add any additional blocked positions (for testing if a position would block)
            if (additionalBlockedPositions) {
                disablePositions.push(...additionalBlockedPositions);
            }
            // Create a grid of the room - Fixed bounds
            let grid = [];
            for (let x = 0; x < this.width; x++) {
                grid[x] = [];
                for (let y = 0; y < this.height; y++) {
                    const roomX = this.roomX + x;
                    const roomY = this.roomY + y;
                    if (this.roomArray[roomX] && this.roomArray[roomX][roomY])
                        grid[x][y] = this.roomArray[roomX][roomY];
                    else
                        grid[x][y] = false;
                }
            }
            // Adjust start and target positions to grid coordinates
            const startGridPos = {
                x: startTile.x - this.roomX,
                y: startTile.y - this.roomY,
            };
            const targetGridPos = {
                x: targetTile.x - this.roomX,
                y: targetTile.y - this.roomY,
            };
            // Adjust disabled positions to grid coordinates
            const gridDisabledPositions = disablePositions.map((pos) => ({
                x: pos.x - this.roomX,
                y: pos.y - this.roomY,
            }));
            let moves = astarclass_1.astar.AStar.search(grid, startGridPos, targetGridPos, gridDisabledPositions, false, false, false);
            if (moves.length === 0) {
                return obstacleCandidates;
            }
            else {
                return [];
            }
        };
        /**
         * Checks if placing an entity at the given coordinates would block any door-to-door paths.
         * This is useful for preventing placement of objects that would obstruct navigation.
         *
         * @param x - The x-coordinate to test
         * @param y - The y-coordinate to test
         * @returns True if placing an entity here would block a door, false otherwise
         */
        this.wouldBlockDoor = (x, y) => {
            // If there are fewer than 2 doors, no paths to block
            if (this.doors.length < 2) {
                return false;
            }
            // Test each pair of doors
            for (let i = 0; i < this.doors.length; i++) {
                for (let j = i + 1; j < this.doors.length; j++) {
                    const door1 = this.doors[i];
                    const door2 = this.doors[j];
                    if (!door1 || !door2)
                        continue;
                    // First test: can we find a path WITHOUT the blocking position?
                    const obstaclesWithoutBlock = this.findPath(door1, door2);
                    // If there's already no path without our test position, skip this door pair
                    if (obstaclesWithoutBlock.length > 0) {
                        continue;
                    }
                    // Second test: can we find a path WITH the blocking position?
                    const additionalBlockedPos = [{ x, y }];
                    const obstaclesWithBlock = this.findPath(door1, door2, additionalBlockedPos);
                    // If path existed without block but doesn't exist with block, then this position blocks the door
                    if (obstaclesWithBlock.length > 0) {
                        console.warn("DOOR WOULD BE BLOCKED!");
                        return true;
                    }
                }
            }
            return false;
        };
        /**
         * Gets empty tiles that don't block door-to-door paths.
         * This is a filtered version of getEmptyTiles() that excludes positions that would obstruct navigation.
         *
         * @returns Array of tiles that are empty and don't block door paths
         */
        this.getEmptyTilesNotBlockingDoors = () => {
            const emptyTiles = this.getEmptyTiles();
            return emptyTiles.filter((tile) => !this.wouldBlockDoor(tile.x, tile.y));
        };
        // #endregion
        /**
         * Adds a door with offset to prevent overlapping doors.
         * If a door already exists at the desired (x, y) position, it offsets the door randomly to either side.
         * Ensures the new door is at least one tile away from the room's edge based on its direction.
         *
         * @param x - The x-coordinate for the door placement.
         * @param y - The y-coordinate for the door placement.
         * @param room - The Room object where the door is being placed. Defaults to the current room.
         * @param tunnelDoor - Whether the door is a tunnel door. Defaults to false.
         * @returns The created Door object or null if placement failed.
         */
        this.addDoorWithOffset = (x, y, room = this, tunnelDoor = false) => {
            // Helper function to check if any vending machine is at a position
            const hasVendingMachineAt = (checkX, checkY) => {
                return room.entities.some((entity) => entity instanceof vendingMachine_1.VendingMachine &&
                    entity.x === checkX &&
                    entity.y === checkY);
            };
            // Check if a door already exists at the desired position
            if (room.roomArray[x]?.[y] instanceof door_1.Door) {
                // Determine the direction based on the door's position
                let direction = null;
                if (x === room.roomX) {
                    direction = game_1.Direction.RIGHT;
                }
                else if (x === room.roomX + room.width - 1) {
                    direction = game_1.Direction.LEFT;
                }
                else if (y === room.roomY) {
                    direction = game_1.Direction.DOWN;
                }
                else if (y === room.roomY + room.height - 1) {
                    direction = game_1.Direction.UP;
                }
                if (!direction) {
                    // console.log("Invalid door position.");
                    return null;
                }
                // Define possible offset adjustments based on door direction
                const offsetOptions = [];
                switch (direction) {
                    case game_1.Direction.RIGHT:
                    case game_1.Direction.LEFT:
                        // Offsets along the y-axis for vertical walls
                        offsetOptions.push({ dx: 0, dy: 1 }, { dx: 0, dy: -1 });
                        break;
                }
                // Shuffle the offset options to randomize placement
                const shuffledOffsets = offsetOptions.sort(() => random_1.Random.rand() - 0.5);
                // Check if original position has vending machine
                if (hasVendingMachineAt(x, y)) {
                    return null;
                }
                for (const offset of shuffledOffsets) {
                    const newX = x + offset.dx;
                    const newY = y + offset.dy;
                    // Ensure the new position is within bounds and not on the edge
                    const isWithinBounds = newX > room.roomX &&
                        newX < room.roomX + room.width - 1 &&
                        newY > room.roomY &&
                        newY < room.roomY + room.height - 1;
                    if (isWithinBounds &&
                        !(room.roomArray[newX]?.[newY] instanceof door_1.Door) &&
                        !hasVendingMachineAt(newX, newY)) {
                        // Offset the door placement
                        return room.addDoor(newX, newY, room, tunnelDoor);
                    }
                }
                return null;
            }
            // Check for vending machine at original position before placing door normally
            if (hasVendingMachineAt(x, y)) {
                return null;
            }
            // If no door exists at the desired position and no vending machine, place it normally
            return room.addDoor(x, y, room, tunnelDoor);
        };
        this.pointExists = (x, y) => {
            return this.roomArray[x] && this.roomArray[x][y];
        };
        // Add methods to manage blur cache
        this.invalidateBlurCache = () => {
            this.blurCache.isValid = false;
            this.blurCache.lastLightingUpdate = this.lastLightingUpdate;
        };
        this.shouldUseBlurCache = () => {
            return (!this.active &&
                this.blurCache.isValid &&
                this.blurCache.lastLightingUpdate === this.lastLightingUpdate);
        };
        this.getPlayer = () => {
            for (const i in this.game.players) {
                if (this.game.rooms[this.game.players[i].levelID] === this) {
                    return this.game.players[i];
                }
            }
            return null;
        };
        this.cacheBlurResult = (type, canvas) => {
            if (!this.active) {
                // Clone the canvas to cache it
                const cachedCanvas = document.createElement("canvas");
                cachedCanvas.width = canvas.width;
                cachedCanvas.height = canvas.height;
                const ctx = cachedCanvas.getContext("2d");
                if (ctx) {
                    ctx.drawImage(canvas, 0, 0);
                    this.blurCache[type] = cachedCanvas;
                    this.blurCache.isValid = true;
                    this.blurCache.lastLightingUpdate = this.lastLightingUpdate;
                }
            }
        };
        this.globalId = IdGenerator_1.IdGenerator.generate("R");
        this.game = game;
        this.roomX = x; //Math.floor(- this.width / 2);
        this.roomY = y; //Math.floor(- this.height / 2);
        this.width = w;
        this.height = h;
        this.type = type;
        this.depth = depth;
        this.mapGroup = mapGroup;
        this.entered = false;
        this.turn = TurnState.playerTurn;
        this.playerTurnTime = Date.now();
        this.items = Array();
        this.projectiles = Array();
        this.hitwarnings = Array();
        this.particles = Array();
        this.doors = Array();
        this.entities = Array();
        this.lightSources = Array();
        this.innerWalls = Array();
        this.level = level;
        this.id = 0;
        this.currentSpawnerCount = 0;
        this.deadEntities = Array();
        this.active = false;
        this.lastLightingUpdate = 0;
        this.walls = Array();
        this.decorations = Array();
        // Initialize Color Offscreen Canvas
        this.colorOffscreenCanvas = document.createElement("canvas");
        this.colorOffscreenCanvas.width =
            (this.width + 10) * gameConstants_1.GameConstants.TILESIZE;
        this.colorOffscreenCanvas.height =
            (this.height + 10) * gameConstants_1.GameConstants.TILESIZE;
        const colorCtx = this.colorOffscreenCanvas.getContext("2d");
        if (!colorCtx) {
            throw new Error("Failed to initialize color offscreen canvas context.");
        }
        this.colorOffscreenCtx = colorCtx;
        // Initialize Shade Offscreen Canvas
        this.shadeOffscreenCanvas = document.createElement("canvas");
        this.shadeOffscreenCanvas.width =
            (this.width + 10) * gameConstants_1.GameConstants.TILESIZE;
        this.shadeOffscreenCanvas.height =
            (this.height + 10) * gameConstants_1.GameConstants.TILESIZE;
        const shadeCtx = this.shadeOffscreenCanvas.getContext("2d");
        if (!shadeCtx) {
            throw new Error("Failed to initialize shade offscreen canvas context.");
        }
        this.shadeOffscreenCtx = shadeCtx;
        // Initialize Bloom Offscreen Canvas
        this.bloomOffscreenCanvas = document.createElement("canvas");
        this.bloomOffscreenCanvas.width =
            (this.width + 10) * gameConstants_1.GameConstants.TILESIZE;
        this.bloomOffscreenCanvas.height =
            (this.height + 10) * gameConstants_1.GameConstants.TILESIZE;
        const bloomCtx = this.bloomOffscreenCanvas.getContext("2d");
        if (!bloomCtx) {
            throw new Error("Failed to initialize bloom offscreen canvas context.");
        }
        this.bloomOffscreenCtx = bloomCtx;
        // #region initialize arrays
        //initialize room array
        this.roomArray = [];
        for (let x = this.roomX - 1; x < this.roomX + this.width + 1; x++) {
            this.roomArray[x] = [];
            for (let y = this.roomY - 1; y < this.roomY + this.height + 1; y++) {
                this.roomArray[x][y] = null;
            }
        }
        //initialize visibility & color arrays, as well as their soft variants
        this.vis = [];
        this.softVis = [];
        this.col = [];
        this.softCol = [];
        for (let x = this.roomX; x < this.roomX + this.width; x++) {
            this.vis[x] = [];
            this.softVis[x] = [];
            this.col[x] = [];
            this.softCol[x] = [];
            for (let y = this.roomY; y < this.roomY + this.height; y++) {
                this.vis[x][y] = 1;
                this.softVis[x][y] = 1;
                this.col[x][y] = [0, 0, 0];
                this.softCol[x][y] = [0, 0, 0];
            }
        }
        //initialize the render buffer array
        this.renderBuffer = [];
        for (let x = this.roomX; x < this.roomX + this.width; x++) {
            this.renderBuffer[x] = [];
            for (let y = this.roomY; y < this.roomY + this.height; y++) {
                this.renderBuffer[x][y] = [];
            }
        }
        //initialize the skin for the given environment
        this.envType = envType;
        this.skin = envType;
        /*
        if (this.type === RoomType.ROPECAVE || this.type === RoomType.CAVE) {
          this.skin = SkinType.CAVE;
        }
        if (this.type === RoomType.ROPEUP || this.type === RoomType.FOREST) {
          this.skin = SkinType.FOREST;
        }
        */
        this.builder = new roomBuilder_1.RoomBuilder(this);
        // #endregion
    }
    addDoorTorches(x, y, doorDir) {
        if (doorDir !== game_1.Direction.UP && doorDir !== game_1.Direction.DOWN) {
            return;
        }
        if (x && y) {
            this.calculateWallInfo();
            const leftWallInfo = this.wallInfo.get(`${x - 1},${y}`);
            const rightWallInfo = this.wallInfo.get(`${x + 1},${y}`);
            const leftTile = this.roomArray[x - 1]?.[y];
            const rightTile = this.roomArray[x + 1]?.[y];
            const leftOpen = leftWallInfo?.isLeftWall === false;
            const rightOpen = rightWallInfo?.isRightWall === false;
            if (leftOpen) {
                this.roomArray[x - 1][y] = new wallTorch_1.WallTorch(this, x - 1, y);
            }
            if (rightOpen) {
                this.roomArray[x + 1][y] = new wallTorch_1.WallTorch(this, x + 1, y);
            }
        }
    }
    addTorches(numTorches, rand, placeX, placeY) {
        if (this.level.environment.type === environmentTypes_1.EnvType.FOREST &&
            this.type !== RoomType.DOWNLADDER)
            return;
        if (placeX !== undefined &&
            placeY !== undefined &&
            this.roomArray[placeX]?.[placeY] instanceof wall_1.Wall) {
            this.roomArray[placeX][placeY] = new wallTorch_1.WallTorch(this, placeX, placeY);
            return;
        }
        let walls = [];
        for (let xx = this.roomX + 1; xx < this.roomX + this.width - 2; xx++) {
            for (let yy = this.roomY; yy < this.roomY + this.height - 1; yy++) {
                if (this.roomArray[xx][yy] instanceof wall_1.Wall &&
                    !(this.roomArray[xx][yy + 1] instanceof wall_1.Wall)) {
                    walls.push(this.roomArray[xx][yy]);
                }
            }
        }
        let bottomWalls = [];
        // Separate loop for bottom wall
        for (let xx = this.roomX + 1; xx < this.roomX + this.width - 2; xx++) {
            const yy = this.roomY + this.height - 1; // Bottom wall
            if (this.roomArray[xx][yy] instanceof wall_1.Wall &&
                !(this.roomArray[xx][yy + 1] instanceof wall_1.Wall)) {
                bottomWalls.push(this.roomArray[xx][yy]);
            }
        }
        // Randomly distribute torches between walls and bottom walls
        const wallTorches = game_1.Game.rand(0, numTorches, rand);
        const bottomWallTorches = numTorches - wallTorches;
        for (let i = 0; i < wallTorches; i++) {
            if (walls.length == 0)
                break;
            const randomIndex = game_1.Game.rand(0, walls.length - 1, rand);
            const t = walls.splice(randomIndex, 1)[0];
            const x = t.x;
            const y = t.y;
            this.roomArray[x][y] = new wallTorch_1.WallTorch(this, x, y);
        }
        for (let i = 0; i < bottomWallTorches; i++) {
            if (bottomWalls.length == 0)
                break;
            const randomIndex = game_1.Game.rand(0, bottomWalls.length - 1, rand);
            const t = bottomWalls.splice(randomIndex, 1)[0];
            const x = t.x;
            const y = t.y;
            this.roomArray[x][y] = new wallTorch_1.WallTorch(this, x, y, true);
        }
    }
    addChasms(rand) {
        // add chasms
        let w = game_1.Game.rand(2, 4, rand);
        let h = game_1.Game.rand(2, 4, rand);
        let xmin = this.roomX + 2;
        let xmax = this.roomX + this.width - w - 2;
        let ymin = this.roomY + 2;
        let ymax = this.roomY + this.height - h - 2;
        if (xmax < xmin || ymax < ymin)
            return;
        let x = game_1.Game.rand(xmin, xmax, rand);
        let y = game_1.Game.rand(ymin, ymax, rand);
        for (let xx = x - 1; xx < x + w + 1; xx++) {
            for (let yy = y - 1; yy < y + h + 1; yy++) {
                // add a floor border
                if (xx === x - 1 || xx === x + w || yy === y - 1 || yy === y + h) {
                    if (!(this.roomArray[xx][yy] instanceof spawnfloor_1.SpawnFloor))
                        this.roomArray[xx][yy] = new floor_1.Floor(this, xx, yy);
                }
                else
                    this.roomArray[xx][yy] = new chasm_1.Chasm(this, xx, yy, xx === x, xx === x + w - 1, yy === y, yy === y + h - 1);
            }
        }
    }
    // ... start of file ...
    addSpikeTraps(numSpikes, rand) {
        if (this.level.environment.type === environmentTypes_1.EnvType.FOREST ||
            this.envType === environmentTypes_1.EnvType.FOREST)
            return;
        // add spikes
        let tiles = this.getEmptyTiles();
        for (let i = 0; i < numSpikes; i++) {
            const { x, y } = this.getRandomEmptyPosition(tiles);
            this.roomArray[x][y] = new spiketrap_1.SpikeTrap(this, x, y);
        }
    }
    // #endregion
    // #region ADDING ENTITIES
    // Function to add enemies to the room
    addEnemies(numEnemies, rand) {
        if (gameplaySettings_1.GameplaySettings.NO_ENEMIES === true)
            return;
        if (this.envType === environmentTypes_1.EnvType.FOREST)
            numEnemies /= 2;
        // Get all empty tiles in the room
        let tiles = this.getEmptyTiles();
        if (tiles === null)
            return;
        //don't put enemies near the entrances so you don't get screwed instantly
        // Create a Set to store coordinates that should be excluded
        const excludedCoords = new Set();
        // For each door, add coordinates in a 5x5 area around it to excluded set
        for (const door of this.doors) {
            for (let dx = -2; dx <= 2; dx++) {
                for (let dy = -2; dy <= 2; dy++) {
                    excludedCoords.add(`${door.x + dx},${door.y + dy}`);
                }
            }
        }
        // Filter tiles that aren't in the excluded set
        tiles = tiles.filter((tile) => !excludedCoords.has(`${tile.x},${tile.y}`));
        // Loop through the number of enemies to be added
        for (let i = 0; i < numEnemies; i++) {
            let rerolls = 1;
            if (tiles.length === 0) {
                console.log(`No tiles left to spawn enemies`);
                break;
            }
            let emptyTiles = this.getRandomEmptyPosition(tiles);
            if (emptyTiles.x === null || emptyTiles.y === null) {
                i = numEnemies;
                break;
            }
            const { x, y } = emptyTiles;
            // Define the enemy tables for each depth level
            let tables = this.level.enemyParameters.enemyTables;
            // Define the maximum depth level
            let max_depth_table = this.level.enemyParameters.maxDepthTable;
            // Get the current depth level, capped at the maximum
            let d = Math.min(this.depth, max_depth_table);
            // If there is a table for the current depth level
            if (tables[d] && tables[d].length > 0) {
                // Function to add an enemy to the room
                let addEnemy = (enemy) => {
                    // Check if the enemy overlaps with any other enemies
                    for (let xx = 0; xx < enemy.w; xx++) {
                        for (let yy = 0; yy < enemy.h; yy++) {
                            if (!tiles.some((tt) => tt.x === x + xx && tt.y === y + yy)) {
                                // If it does, increment the enemy count and return false
                                numEnemies++;
                                return false;
                            }
                        }
                    }
                    // If it doesn't, add the enemy to the room, remove the tiles used from the available pool, and return true
                    this.entities.push(enemy);
                    for (let xx = 0; xx < enemy.w; xx++) {
                        for (let yy = 0; yy < enemy.h; yy++) {
                            tiles = tiles.filter((t) => !(t.x === x + xx && t.y === y + yy));
                        }
                    }
                    return true;
                };
                // Randomly select an enemy type from the table
                let type = game_1.Game.randTable(tables[d], random_1.Random.rand);
                switch (type) {
                    case 1:
                        crabEnemy_1.CrabEnemy.add(this, this.game, x, y);
                        break;
                    case 2:
                        frogEnemy_1.FrogEnemy.add(this, this.game, x, y);
                        break;
                    case 3:
                        zombieEnemy_1.ZombieEnemy.add(this, this.game, x, y);
                        break;
                    case 4:
                        skullEnemy_1.SkullEnemy.add(this, this.game, x, y);
                        break;
                    case 5:
                        energyWizard_1.EnergyWizardEnemy.add(this, this.game, x, y);
                        break;
                    case 6:
                        chargeEnemy_1.ChargeEnemy.add(this, this.game, x, y);
                        break;
                    case 7:
                        rookEnemy_1.RookEnemy.add(this, this.game, x, y);
                        break;
                    case 8:
                        bishopEnemy_1.BishopEnemy.add(this, this.game, x, y);
                        break;
                    case 9:
                        armoredzombieEnemy_1.ArmoredzombieEnemy.add(this, this.game, x, y);
                        break;
                    case 10:
                        if (addEnemy(new bigSkullEnemy_1.BigSkullEnemy(this, this.game, x, y))) {
                            // clear out some space
                            for (let xx = 0; xx < 2; xx++) {
                                for (let yy = 0; yy < 2; yy++) {
                                    this.roomArray[x + xx][y + yy] = new floor_1.Floor(this, x + xx, y + yy); // remove any walls
                                }
                            }
                        }
                        break;
                    case 11:
                        queenEnemy_1.QueenEnemy.add(this, this.game, x, y);
                        break;
                    case 12:
                        knightEnemy_1.KnightEnemy.add(this, this.game, x, y);
                        break;
                    case 13:
                        if (addEnemy(new bigKnightEnemy_1.BigKnightEnemy(this, this.game, x, y))) {
                            // clear out some space
                            for (let xx = 0; xx < 2; xx++) {
                                for (let yy = 0; yy < 2; yy++) {
                                    this.roomArray[x + xx][y + yy] = new floor_1.Floor(this, x + xx, y + yy); // remove any walls
                                }
                            }
                        }
                        break;
                    case 14:
                        armoredSkullEnemy_1.ArmoredSkullEnemy.add(this, this.game, x, y);
                        break;
                    case 15:
                        fireWizard_1.FireWizardEnemy.add(this, this.game, x, y);
                        break;
                }
            }
        }
        let spawnerAmounts = [
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2,
            2, 2, 3, 3, 4, 5, 3,
        ];
        if (this.depth > 0) {
            let spawnerAmount = game_1.Game.randTable(spawnerAmounts, rand);
            //console.log(`Adding ${spawnerAmount} spawners`);
            this.addSpawners(spawnerAmount, rand);
        }
        let occultistAmounts = [
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1,
        ];
        if (this.depth > 1) {
            let occultistAmount = game_1.Game.randTable(occultistAmounts, rand);
            //console.log(`Adding ${occultistAmount} occultists`);
            this.addOccultists(occultistAmount, rand);
        }
    }
    addRandomEnemies() {
        let numEmptyTiles = this.getEmptyTiles().length;
        /*
        let numEnemies = Math.ceil(
          numEmptyTiles * Math.min(this.depth * 0.1 + 0.5, 0.15), //this.depth * 0.01 is starting value
        );
        */
        const factor = Math.min((this.depth + 2) * 0.05, 0.3);
        const numEnemies = Math.ceil(Math.max(utils_1.Utils.randomNormalInt(0, numEmptyTiles * factor), numEmptyTiles * factor));
        //if (numEnemies > numEmptyTiles / 2) numEnemies = numEmptyTiles / 2;
        this.addEnemies(numEnemies, random_1.Random.rand);
    }
    addSpawners(numSpawners, rand) {
        let tiles = this.getEmptyTiles();
        if (tiles === null) {
            //console.log(`No tiles left to spawn spawners`);
            return;
        }
        for (let i = 0; i < numSpawners; i++) {
            const { x, y } = this.getRandomEmptyPosition(tiles);
            let spawnTable = this.level.populator
                .getEnemyPoolForDepth(Math.max(0, this.depth - 1))
                .filter((t) => t !== 7);
            const spawner = spawner_1.Spawner.add(this, this.game, x, y, spawnTable);
            return spawner;
        }
    }
    addOccultists(numOccultists, rand) {
        let tiles = this.getEmptyTiles();
        if (tiles === null) {
            //console.log(`No tiles left to spawn spawners`);
            return;
        }
        for (let i = 0; i < numOccultists; i++) {
            const { x, y } = this.getRandomEmptyPosition(tiles);
            const occultist = occultistEnemy_1.OccultistEnemy.add(this, this.game, x, y);
            return occultist;
        }
    }
    addBosses(depth) {
        if (gameplaySettings_1.GameplaySettings.NO_ENEMIES === true)
            return;
        let tiles = this.getEmptyTiles();
        if (tiles === null) {
            //console.log(`No tiles left to spawn spawners`);
            return;
        }
        let bosses = ["reaper", "queen", "bigskullenemy", "bigzombieenemy"];
        if (depth > 0) {
            bosses.push("occultist");
            bosses.filter((b) => b !== "queen");
        }
        const boss = game_1.Game.randTable(bosses, random_1.Random.rand);
        const { x, y } = boss.startsWith("big")
            ? this.getBigRandomEmptyPosition(tiles)
            : this.getRandomEmptyPosition(tiles);
        switch (boss) {
            case "reaper":
                const spawner = this.addSpawners(1, random_1.Random.rand);
                spawner.dropTable = ["weapon", "equipment"];
                spawner.dropChance = 1;
                break;
            case "queen":
                const queen = queenEnemy_1.QueenEnemy.add(this, this.game, x, y);
                queen.dropTable = ["weapon", "equipment"];
                queen.dropChance = 1;
                break;
            case "bigskullenemy":
                const bigSkull = bigSkullEnemy_1.BigSkullEnemy.add(this, this.game, x, y);
                bigSkull.dropTable = [
                    "weapon",
                    "equipment",
                    "consumable",
                    "gem",
                    "tool",
                ];
                break;
            case "occultist":
                const occultist = this.addOccultists(1, random_1.Random.rand);
                occultist.dropTable = ["weapon", "equipment"];
                occultist.dropChance = 1;
                break;
            case "bigzombieenemy":
                const bigZombie = bigZombieEnemy_1.BigZombieEnemy.add(this, this.game, x, y);
                bigZombie.dropTable = [
                    "weapon",
                    "equipment",
                    "consumable",
                    "gem",
                    "tool",
                ];
                bigZombie.dropChance = 1;
                break;
        }
    }
    addChests(numChests, rand) {
        // add chests
        let tiles = this.getEmptyTiles();
        for (let i = 0; i < numChests; i++) {
            const position = this.getRandomEmptyPosition(tiles);
            if (!position) {
                // No more empty tiles available, break out of loop
                break;
            }
            const { x, y } = position;
            this.entities.push(new chest_1.Chest(this, this.game, x, y));
        }
    }
    addBombs(numBombs, rand) {
        let tiles = this.getEmptyTiles();
        for (let i = 0; i < this.getEmptyTiles().length; i++) {
            const { x, y } = this.getRandomEmptyPosition(tiles);
            bomb_1.Bomb.add(this, this.game, x, y);
        }
    }
    addResources(numResources, rand) {
        let tiles = this.getEmptyTiles();
        for (let i = 0; i < numResources; i++) {
            const { x, y } = this.getRandomEmptyPosition(tiles);
            let r = rand();
            if (r <= (10 - this.depth ** 3) / 10)
                coalResource_1.CoalResource.add(this, this.game, x, y);
            else if (r <= (10 - (this.depth - 2) ** 3) / 10)
                goldResource_1.GoldResource.add(this, this.game, x, y);
            else
                emeraldResource_1.EmeraldResource.add(this, this.game, x, y);
        }
    }
    addVendingMachine(rand, placeX, placeY, item) {
        const pos = this.getRandomEmptyPosition(this.getEmptyTiles());
        let x = placeX ? placeX : pos.x;
        let y = placeY ? placeY : pos.y;
        let table = this.depth > 0
            ? [
                1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 1, 1, 1, 2, 2, 1, 1, 3, 4, 5, 5, 5,
                5, 5,
            ]
            : [1, 1, 1];
        let type = game_1.Game.randTable(table, rand);
        if (item) {
            vendingMachine_1.VendingMachine.add(this, this.game, x, y, item);
            return;
        }
        switch (type) {
            case 1:
                vendingMachine_1.VendingMachine.add(this, this.game, x, y, new heart_1.Heart(this, x, y));
                break;
            case 2:
                vendingMachine_1.VendingMachine.add(this, this.game, x, y, new candle_1.Candle(this, x, y));
                break;
            case 3:
                vendingMachine_1.VendingMachine.add(this, this.game, x, y, new armor_1.Armor(this, x, y));
                break;
            case 4:
                vendingMachine_1.VendingMachine.add(this, this.game, x, y, new spear_1.Spear(this, x, y));
                break;
            case 5:
                vendingMachine_1.VendingMachine.add(this, this.game, x, y, new torch_1.Torch(this, x, y));
                break;
        }
    }
    /**
     * Applies Gaussian blur to the specified offscreen canvas.
     *
     * @param {HTMLCanvasElement} canvas - The offscreen canvas to blur.
     * @param {number} radius - The radius of the blur.
     */
    applyGaussianBlur(canvas, radius) {
        //DEPRECATED
        //const StackBlur = require("stackblur-canvas");
        const ctx = canvas.getContext("2d");
        if (!ctx) {
            throw new Error("Failed to get canvas context for Gaussian blur.");
        }
        // Get the image data from the canvas
        const width = canvas.width;
        const height = canvas.height;
        //const imageData = ctx.getImageData(0, 0, width, height);
        let r = radius;
        if (!gameConstants_1.GameConstants.BLUR_ENABLED)
            r = 0;
        // Apply StackBlur
        //StackBlur.canvasRGBA(canvas, 0, 0, width, height, Math.floor(r / 2));
    }
    //calculate wall info for proper wall rendering
    calculateWallInfo() {
        this.wallInfo.clear();
        for (let x = this.roomX; x < this.roomX + this.width; x++) {
            for (let y = this.roomY; y < this.roomY + this.height; y++) {
                const tile = this.getTile(x, y);
                if (tile instanceof wall_1.Wall || tile instanceof wallTorch_1.WallTorch) {
                    this.walls.push(tile);
                    const isTopWall = y === this.roomY;
                    const isBottomWall = y === this.roomY + this.height - 1;
                    const isLeftWall = x === this.roomX;
                    const isRightWall = x === this.roomX + this.width - 1;
                    const isInnerWall = !isTopWall && !isBottomWall && !isLeftWall && !isRightWall;
                    const isBelowDoorWall = y < this.roomY + this.height - 1 && this.getTile(x, y + 1)?.isDoor;
                    const isAboveDoorWall = y < this.roomY + this.height - 1 && this.getTile(x, y - 1)?.isDoor;
                    const isDoorWall = y < this.roomY + this.height && this.getTile(x, y + 1)?.isDoor;
                    let innerWallType = null;
                    if (isInnerWall) {
                        const hasWallAbove = this.getTile(x, y - 1) instanceof wall_1.Wall;
                        const hasWallBelow = this.getTile(x, y + 1) instanceof wall_1.Wall;
                        if (!hasWallAbove && hasWallBelow) {
                            innerWallType = "topInner";
                        }
                        else if (hasWallAbove && !hasWallBelow) {
                            innerWallType = "bottomInner";
                        }
                        else if (hasWallAbove && hasWallBelow) {
                            innerWallType = "surroundedInner";
                        }
                        else {
                            innerWallType = "isolatedInner";
                        }
                    }
                    this.wallInfo.set(`${x},${y}`, {
                        isTopWall,
                        isBottomWall,
                        isLeftWall,
                        isRightWall,
                        isInnerWall,
                        isBelowDoorWall,
                        isDoorWall,
                        innerWallType,
                        isAboveDoorWall,
                        shouldDrawBottom: isDoorWall ||
                            isBelowDoorWall ||
                            (isTopWall && !isLeftWall && !isRightWall) ||
                            isInnerWall,
                    });
                }
            }
        }
    }
    // #endregion
    // #region UTILITIES
    pointInside(x, y, rX, rY, rW, rH) {
        if (x < rX || x >= rX + rW)
            return false;
        if (y < rY || y >= rY + rH)
            return false;
        return true;
    }
    // This pattern appears in multiple methods like addVendingMachine, addChests, addSpikes, etc.
    getRandomEmptyPosition(tiles, ignore) {
        if (tiles.length === 0)
            return null;
        const tile = tiles.splice(game_1.Game.rand(0, tiles.length - 1, random_1.Random.rand), 1)[0];
        if (ignore && tile.x === ignore.x && tile.y === ignore.y) {
            return this.getRandomEmptyPosition(tiles, ignore);
        }
        return { x: tile.x, y: tile.y };
    }
    getBigRandomEmptyPosition(tiles) {
        if (tiles.length === 0)
            return null;
        // Create a set for O(1) lookup of tile coordinates
        const tileSet = new Set(tiles.map((t) => `${t.x},${t.y}`));
        // Find all tiles that can be the top-left corner of a 2x2 patch
        const bigTilePositions = tiles.filter((t) => {
            // Check if this tile and the 3 adjacent tiles (right, below, diagonal) are all empty
            return (tileSet.has(`${t.x + 1},${t.y}`) && // right
                tileSet.has(`${t.x},${t.y + 1}`) && // below
                tileSet.has(`${t.x + 1},${t.y + 1}`)); // diagonal
        });
        if (bigTilePositions.length === 0)
            return null;
        // Randomly select one of the valid 2x2 positions
        const selectedTile = bigTilePositions[game_1.Game.rand(0, bigTilePositions.length - 1, random_1.Random.rand)];
        return { x: selectedTile.x, y: selectedTile.y };
    }
    // Used in populateUpLadder, populateDownLadder, populateRopeHole, populateRopeCave
    getRoomCenter() {
        return {
            x: Math.floor(this.roomX + this.width / 2),
            y: Math.floor(this.roomY + this.height / 2),
        };
    }
    // Used in multiple methods including castShadowsAtAngle
    isPositionInRoom(x, y) {
        return !(Math.floor(x) < this.roomX ||
            Math.floor(x) >= this.roomX + this.width ||
            Math.floor(y) < this.roomY ||
            Math.floor(y) >= this.roomY + this.height);
    }
    pathIsBlockedBy(tile, otherTile) {
        const entities = [];
        if (tile.isSolid())
            entities.push(tile);
        if (otherTile.isSolid())
            entities.push(otherTile);
        return entities;
    }
    // #endregion
    // #region MISC
    /**
     * Adds a new BeamEffect to the room.
     *
     * @param x1 - Starting tile X coordinate.
     * @param y1 - Starting tile Y coordinate.
     * @param x2 - Ending tile X coordinate.
     * @param y2 - Ending tile Y coordinate.
     */
    addBeamEffect(x1, y1, x2, y2, parent) {
        const beam = new beamEffect_1.BeamEffect(x1, y1, x2, y2, parent);
        this.beamEffects.push(beam);
    }
    async changeReverb(newImpulsePath) {
        await reverb_1.ReverbEngine.setReverbImpulse(newImpulsePath);
    }
    get roomArea() {
        let area = (this.width - 2) * (this.height - 2);
        let openTiles = [];
        for (let x = this.roomX + 1; x < this.roomX + this.width - 1; x++) {
            for (let y = this.roomY + 1; y < this.roomY + this.height - 1; y++) {
                if (this.roomArray[x][y] instanceof floor_1.Floor)
                    openTiles.push({ x, y });
            }
        }
        //console.log(area, openTiles.length);
        return openTiles.length;
    }
    /**
     * Determines if the room is currently on screen.
     * Uses a buffer of 2 tiles beyond the room's dimensions to account for partial visibility.
     *
     * @returns {boolean} - True if the room is on screen, otherwise false.
     */
    roomOnScreen(player) {
        const tileSize = gameConstants_1.GameConstants.TILESIZE;
        // Calculate room boundaries with a buffer of 2 tiles
        const roomLeft = (this.roomX - 2) * tileSize;
        const roomRight = (this.roomX + this.width + 2) * tileSize;
        const roomTop = (this.roomY - 2) * tileSize;
        const roomBottom = (this.roomY + this.height + 2) * tileSize;
        // Convert player position from tiles to pixels
        const playerPosX = player.x * tileSize;
        const playerPosY = player.y * tileSize;
        // Calculate camera position in pixels
        const cameraX = playerPosX -
            player.drawX +
            0.5 * tileSize -
            0.5 * gameConstants_1.GameConstants.WIDTH -
            this.game.screenShakeX; // X-coordinate of the camera's top-left corner
        const cameraY = playerPosY -
            player.drawY +
            0.5 * tileSize -
            0.5 * gameConstants_1.GameConstants.HEIGHT - // Corrected from WIDTH to HEIGHT
            this.game.screenShakeY; // Y-coordinate of the camera's top-left corner
        const cameraWidth = gameConstants_1.GameConstants.WIDTH; // Corrected from innerWidth
        const cameraHeight = gameConstants_1.GameConstants.HEIGHT; // Corrected from innerHeight
        // Define the camera's boundaries
        const cameraLeft = cameraX;
        const cameraRight = cameraX + cameraWidth;
        const cameraTop = cameraY;
        const cameraBottom = cameraY + cameraHeight;
        // Check if the room's boundaries overlap with the camera's view
        const isOverlapping = !(roomRight < cameraLeft ||
            roomLeft > cameraRight ||
            roomBottom < cameraTop ||
            roomTop > cameraBottom);
        this.onScreen = isOverlapping;
    }
    setReverb() {
        const roomArea = this.roomArea;
        if (roomArea < 10) {
            this.changeReverb(`res/SFX/impulses/small.mp3`);
        }
        else if (roomArea < 55) {
            this.changeReverb(`res/SFX/impulses/medium.mp3`);
        }
        else {
            this.changeReverb(`res/SFX/impulses/large.mp3`);
        }
    }
    /**
     * Finds all wall tiles that do not have a door in them or adjacent to them.
     * @returns An array of wall tiles without doors or adjacent doors.
     */
    getEmptyWall() {
        const emptyWalls = [];
        for (let x = this.roomX + 1; x < this.roomX + this.width - 1; x++) {
            for (let y = this.roomY - 1; y < this.roomY + this.height - 1; y++) {
                const tile = this.roomArray[x][y];
                if (tile instanceof wall_1.Wall || tile instanceof wallTorch_1.WallTorch) {
                    // Check if the current wall tile is not a door
                    if (!(tile instanceof door_1.Door)) {
                        // Check adjacent tiles for doors
                        const adjacentTiles = [
                            this.roomArray[x + 1]?.[y],
                            this.roomArray[x - 1]?.[y],
                            this.roomArray[x]?.[y + 1],
                            this.roomArray[x]?.[y - 1],
                        ];
                        const hasAdjacentDoor = adjacentTiles.some((adjTile) => adjTile instanceof door_1.Door);
                        if (!hasAdjacentDoor) {
                            emptyWalls.push(tile);
                        }
                    }
                }
            }
        }
        return emptyWalls;
    }
    /**
     * Removes a specified empty wall from the room.
     * @param wall - The wall tile to remove.
     * @returns An object containing the x and y coordinates of the removed wall.
     */
    removeEmptyWall(wall) {
        if (!(wall instanceof wall_1.Wall))
            return null;
        const { x, y } = wall;
        // Replace the wall with a Floor tile to maintain room integrity
        this.roomArray[x][y] = new floor_1.Floor(this, x, y);
        // Remove from innerWalls or outerWalls if applicable
        const initialInnerWallsCount = this.innerWalls.length;
        this.innerWalls = this.innerWalls.filter((w) => w !== wall);
        const finalInnerWallsCount = this.innerWalls.length;
        return { x, y };
    }
    /**
     * Places a VendingMachine in an empty wall.
     */
    placeVendingMachineInWall(item) {
        let emptyWalls = this.getEmptyWall();
        emptyWalls = emptyWalls.filter((wall) => {
            const wallInfo = wall.wallInfo();
            return wallInfo && !wallInfo.isInnerWall;
        });
        if (emptyWalls.length === 0)
            return;
        // Select a random empty wall
        const selectedWall = game_1.Game.randTable(emptyWalls, random_1.Random.rand);
        if (!selectedWall)
            return;
        // Remove the selected wall
        const removedWallInfo = this.removeEmptyWall(selectedWall);
        if (!removedWallInfo)
            return;
        const { x, y } = removedWallInfo;
        // Create and add the VendingMachine
        this.addVendingMachine(random_1.Random.rand, x, y, item);
    }
}
exports.Room = Room;


/***/ }),

/***/ "./src/room/roomBuilder.ts":
/*!*********************************!*\
  !*** ./src/room/roomBuilder.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RoomBuilder = void 0;
const game_1 = __webpack_require__(/*! ../game */ "./src/game.ts");
const floor_1 = __webpack_require__(/*! ../tile/floor */ "./src/tile/floor.ts");
const wall_1 = __webpack_require__(/*! ../tile/wall */ "./src/tile/wall.ts");
const room_1 = __webpack_require__(/*! ./room */ "./src/room/room.ts");
class RoomBuilder {
    constructor(room) {
        this.getWallType = (pointX, pointY, rectX, rectY, width, height) => {
            let directions = [];
            if (pointY === rectY && pointX >= rectX && pointX <= rectX + width)
                directions.push(room_1.WallDirection.NORTH);
            if (pointY === rectY + height && pointX >= rectX && pointX <= rectX + width)
                directions.push(room_1.WallDirection.SOUTH);
            if (pointX === rectX && pointY >= rectY && pointY <= rectY + height)
                directions.push(room_1.WallDirection.WEST);
            if (pointX === rectX + width && pointY >= rectY && pointY <= rectY + height)
                directions.push(room_1.WallDirection.EAST);
            return directions;
        };
        this.room = room;
        this.buildEmptyRoom();
    }
    buildEmptyRoom() {
        // fill in wall and floor
        for (let x = this.room.roomX; x < this.room.roomX + this.room.width; x++) {
            for (let y = this.room.roomY; y < this.room.roomY + this.room.height; y++) {
                if (this.room.pointInside(x, y, this.room.roomX + 1, this.room.roomY + 1, this.room.width - 2, this.room.height - 2)) {
                    this.room.roomArray[x][y] = new floor_1.Floor(this.room, x, y);
                }
                else {
                    this.room.roomArray[x][y] = new wall_1.Wall(this.room, x, y, this.getWallType(x, y, this.room.roomX, this.room.roomY, this.room.width, this.room.height));
                }
            }
        }
    }
    addWallBlocks(rand) {
        let numBlocks = game_1.Game.randTable([0, 0, 1, 1, 2, 2, 2, 2, 3], rand);
        if (this.room.width > 8 && rand() > 0.5)
            numBlocks *= 4;
        for (let i = 0; i < numBlocks; i++) {
            let blockW = Math.min(game_1.Game.randTable([2, 2, 2, 2, 2, 2, 3, 3, 3, 4, 5], rand), this.room.width - 4);
            let blockH = Math.min(blockW + game_1.Game.rand(-2, 2, rand), this.room.height - 4);
            let x = game_1.Game.rand(this.room.roomX + 2, this.room.roomX + this.room.width - blockW - 2, rand);
            let y = game_1.Game.rand(this.room.roomY + 2, this.room.roomY + this.room.height - blockH - 2, rand);
            let neighborCount = (wall) => {
                let count = 0;
                for (let xx = wall.x - 1; xx <= wall.x + 1; xx++) {
                    for (let yy = wall.y - 1; yy <= wall.y + 1; yy++) {
                        if (this.room.roomArray[xx]?.[yy] instanceof wall_1.Wall &&
                            !(xx === wall.x && yy === wall.y))
                            count++;
                    }
                }
                return count;
            };
            for (let xx = x; xx < x + blockW; xx++) {
                for (let yy = y; yy < y + blockH; yy++) {
                    let w = new wall_1.Wall(this.room, xx, yy);
                    this.room.roomArray[xx][yy] = w;
                    this.room.innerWalls.push(w);
                }
            }
            this.room.innerWalls.forEach((wall) => {
                if (neighborCount(wall) <= 1) {
                    this.room.removeWall(wall.x, wall.y);
                    this.room.roomArray[wall.x][wall.y] = new floor_1.Floor(this.room, wall.x, wall.y);
                    this.room.innerWalls = this.room.innerWalls.filter((w) => w !== wall);
                }
            });
        }
    }
}
exports.RoomBuilder = RoomBuilder;


/***/ }),

/***/ "./src/room/roomPopulator.ts":
/*!***********************************!*\
  !*** ./src/room/roomPopulator.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Populator = void 0;
const crate_1 = __webpack_require__(/*! ../entity/object/crate */ "./src/entity/object/crate.ts");
const game_1 = __webpack_require__(/*! ../game */ "./src/game.ts");
const gameplaySettings_1 = __webpack_require__(/*! ../game/gameplaySettings */ "./src/game/gameplaySettings.ts");
const environment_1 = __webpack_require__(/*! ../level/environment */ "./src/level/environment.ts");
const environmentTypes_1 = __webpack_require__(/*! ../constants/environmentTypes */ "./src/constants/environmentTypes.ts");
const random_1 = __webpack_require__(/*! ../utility/random */ "./src/utility/random.ts");
const utils_1 = __webpack_require__(/*! ../utility/utils */ "./src/utility/utils.ts");
const propClusterer_1 = __webpack_require__(/*! ./propClusterer */ "./src/room/propClusterer.ts");
const room_1 = __webpack_require__(/*! ./room */ "./src/room/room.ts");
const downladderMaker_1 = __webpack_require__(/*! ../entity/downladderMaker */ "./src/entity/downladderMaker.ts");
const game_2 = __webpack_require__(/*! ../game */ "./src/game.ts");
const wallTorch_1 = __webpack_require__(/*! ../tile/wallTorch */ "./src/tile/wallTorch.ts");
const wall_1 = __webpack_require__(/*! ../tile/wall */ "./src/tile/wall.ts");
const spiketrap_1 = __webpack_require__(/*! ../tile/spiketrap */ "./src/tile/spiketrap.ts");
const chasm_1 = __webpack_require__(/*! ../tile/chasm */ "./src/tile/chasm.ts");
const floor_1 = __webpack_require__(/*! ../tile/floor */ "./src/tile/floor.ts");
const spawnfloor_1 = __webpack_require__(/*! ../tile/spawnfloor */ "./src/tile/spawnfloor.ts");
const vendingMachine_1 = __webpack_require__(/*! ../entity/object/vendingMachine */ "./src/entity/object/vendingMachine.ts");
const chest_1 = __webpack_require__(/*! ../entity/object/chest */ "./src/entity/object/chest.ts");
const bomb_1 = __webpack_require__(/*! ../entity/object/bomb */ "./src/entity/object/bomb.ts");
const heart_1 = __webpack_require__(/*! ../item/usable/heart */ "./src/item/usable/heart.ts");
const candle_1 = __webpack_require__(/*! ../item/light/candle */ "./src/item/light/candle.ts");
const armor_1 = __webpack_require__(/*! ../item/armor */ "./src/item/armor.ts");
const spear_1 = __webpack_require__(/*! ../item/weapon/spear */ "./src/item/weapon/spear.ts");
const torch_1 = __webpack_require__(/*! ../item/light/torch */ "./src/item/light/torch.ts");
const goldenKey_1 = __webpack_require__(/*! ../item/goldenKey */ "./src/item/goldenKey.ts");
const fountainTile_1 = __webpack_require__(/*! ../tile/fountainTile */ "./src/tile/fountainTile.ts");
const insideLevelDoor_1 = __webpack_require__(/*! ../tile/insideLevelDoor */ "./src/tile/insideLevelDoor.ts");
const button_1 = __webpack_require__(/*! ../tile/button */ "./src/tile/button.ts");
const upLadder_1 = __webpack_require__(/*! ../tile/upLadder */ "./src/tile/upLadder.ts");
const downLadder_1 = __webpack_require__(/*! ../tile/downLadder */ "./src/tile/downLadder.ts");
const itemGroup_1 = __webpack_require__(/*! ../item/itemGroup */ "./src/item/itemGroup.ts");
const warhammer_1 = __webpack_require__(/*! ../item/weapon/warhammer */ "./src/item/weapon/warhammer.ts");
const sword_1 = __webpack_require__(/*! ../item/weapon/sword */ "./src/item/weapon/sword.ts");
const pickaxe_1 = __webpack_require__(/*! ../item/tool/pickaxe */ "./src/item/tool/pickaxe.ts");
const shotgun_1 = __webpack_require__(/*! ../item/weapon/shotgun */ "./src/item/weapon/shotgun.ts");
const bigSkullEnemy_1 = __webpack_require__(/*! ../entity/enemy/bigSkullEnemy */ "./src/entity/enemy/bigSkullEnemy.ts");
const queenEnemy_1 = __webpack_require__(/*! ../entity/enemy/queenEnemy */ "./src/entity/enemy/queenEnemy.ts");
const occultistEnemy_1 = __webpack_require__(/*! ../entity/enemy/occultistEnemy */ "./src/entity/enemy/occultistEnemy.ts");
const spawner_1 = __webpack_require__(/*! ../entity/enemy/spawner */ "./src/entity/enemy/spawner.ts");
const bigZombieEnemy_1 = __webpack_require__(/*! ../entity/enemy/bigZombieEnemy */ "./src/entity/enemy/bigZombieEnemy.ts");
const coalResource_1 = __webpack_require__(/*! ../entity/resource/coalResource */ "./src/entity/resource/coalResource.ts");
const goldResource_1 = __webpack_require__(/*! ../entity/resource/goldResource */ "./src/entity/resource/goldResource.ts");
const emeraldResource_1 = __webpack_require__(/*! ../entity/resource/emeraldResource */ "./src/entity/resource/emeraldResource.ts");
const pool_1 = __webpack_require__(/*! ../tile/pool */ "./src/tile/pool.ts");
// Add after the imports, create a reverse mapping from ID to enemy name
const enemyIdToName = {};
for (const [enemyClass, id] of environment_1.enemyClassToId.entries()) {
    enemyIdToName[id] = enemyClass.name;
}
class Populator {
    constructor(level) {
        this.props = [];
        this.addedDownladder = false;
        this.populateRooms = () => {
            for (let room of this.level.rooms) {
                this.populate(room, random_1.Random.rand);
            }
            this.level.rooms.forEach((room) => {
                if (room.type === room_1.RoomType.START ||
                    room.type === room_1.RoomType.DOWNLADDER ||
                    room.type === room_1.RoomType.UPLADDER ||
                    room.type === room_1.RoomType.ROPEHOLE)
                    return;
                this.populateByEnvironment(room);
            });
            this.addDownladder();
            //this.level.distributeKeys();
        };
        this.populateByEnvironment = (room) => {
            switch (room.envType) {
                case environmentTypes_1.EnvType.CAVE:
                    this.populateCaveEnvironment(room);
                    break;
                case environmentTypes_1.EnvType.FOREST:
                    this.populateForestEnvironment(room);
                    break;
                default:
                    this.populateDefaultEnvironment(room);
                    break;
            }
        };
        this.addDownladder = () => {
            if (this.level.environment.type !== environmentTypes_1.EnvType.DUNGEON)
                return;
            const rooms = this.level.rooms.filter((room) => room.type !== room_1.RoomType.START &&
                room.type !== room_1.RoomType.DOWNLADDER &&
                room.type !== room_1.RoomType.UPLADDER &&
                room.type !== room_1.RoomType.ROPEHOLE &&
                room.type !== room_1.RoomType.BOSS);
            const downLadderRoom = rooms[Math.floor(random_1.Random.rand() * rooms.length)];
            console.log(`Selected room for downladder: Type=${downLadderRoom.type}, Doors=${downLadderRoom.doors.length}`);
            // Use the new method to get empty tiles that don't block doors
            const validTiles = downLadderRoom.getEmptyTilesNotBlockingDoors();
            if (validTiles.length === 0) {
                console.warn("No valid positions for downladder that don't block doors");
                return;
            }
            const position = downLadderRoom.getRandomEmptyPosition(validTiles);
            if (position === null ||
                position.x === undefined ||
                position.y === undefined)
                return;
            console.log(`Placing downladder at position (${position.x}, ${position.y})`);
            const downLadder = new downladderMaker_1.DownladderMaker(downLadderRoom, this.level.game, position.x, position.y);
            downLadderRoom.entities.push(downLadder);
        };
        this.populateByType = (room) => { };
        // #endregion
        // #region POPULATING METHODS
        this.populateEmpty = (room, rand) => {
            this.addTorchesByArea(room);
        };
        this.populateTreasure = (room, rand) => {
            this.addChests(room, 10, rand);
            this.addTorchesByArea(room);
        };
        this.populateDungeon = (room, rand) => {
            //this.addChests(10, rand);
            let factor = game_1.Game.rand(1, 36, rand);
            if (factor < 30)
                room.builder.addWallBlocks(rand);
            if (factor % 4 === 0)
                this.addChasms(room, rand);
            if (factor % 3 === 0)
                this.addPools(room, rand);
            this.addTorchesByArea(room);
            if (factor > 15)
                this.addSpikeTraps(room, game_1.Game.randTable([0, 0, 0, 1, 1, 2, 3], rand), rand);
            if (factor <= 6)
                this.placeVendingMachineInWall(room);
            room.removeDoorObstructions();
        };
        this.populateBoss = (room, rand) => {
            const bossDoor = room.getBossDoor();
            this.addDoorTorches(room, bossDoor.x, bossDoor.y, bossDoor.doorDir);
            this.addTorchesByArea(room);
            this.addSpikeTraps(room, game_1.Game.randTable([0, 0, 0, 1, 1, 2, 5], rand), rand);
            this.addBosses(room, room.depth);
        };
        this.populateBigDungeon = (room, rand) => {
            if (game_1.Game.rand(1, 4, rand) === 1)
                this.addChasms(room, rand);
            this.addTorchesByArea(room);
            if (game_1.Game.rand(1, 3, rand) === 1)
                this.addSpikeTraps(room, game_1.Game.randTable([3, 5, 7, 8], rand), rand);
            room.removeDoorObstructions();
        };
        this.populateSpawner = (room, rand) => {
            this.addTorchesByArea(room);
            spawner_1.Spawner.add(room, room.game, Math.floor(room.roomX + room.width / 2), Math.floor(room.roomY + room.height / 2));
            room.removeDoorObstructions();
        };
        this.populateKeyRoom = (room, rand) => {
            this.addRandomTorches(room, "medium");
            room.items.push(new goldenKey_1.GoldenKey(room, Math.floor(room.roomX + room.width / 2), Math.floor(room.roomY + room.height / 2)));
        };
        this.populateFountain = (room, rand) => {
            this.addRandomTorches(room, "medium");
            let centerX = Math.floor(room.roomX + room.width / 2);
            let centerY = Math.floor(room.roomY + room.height / 2);
            for (let x = centerX - 1; x <= centerX + 1; x++) {
                for (let y = centerY - 1; y <= centerY + 1; y++) {
                    room.roomArray[x][y] = new fountainTile_1.FountainTile(room, x, y, x - (centerX - 1), y - (centerY - 1));
                }
            }
        };
        this.populatePuzzle = (room, rand) => {
            let d;
            for (let x = room.roomX; x < room.roomX + room.width; x++) {
                let y = room.roomY + Math.floor(room.height / 2);
                if (x === room.roomX + Math.floor(room.width / 2)) {
                    d = new insideLevelDoor_1.InsideLevelDoor(room, room.game, x, y + 1);
                    room.roomArray[x][y + 1] = d;
                }
                else {
                    room.roomArray[x][y] = new wall_1.Wall(room, x, y);
                }
            }
            let x = game_1.Game.rand(room.roomX, room.roomX + room.width - 1, rand);
            let y = game_1.Game.rand(room.roomY + Math.floor(room.height / 2) + 3, room.roomY + room.height - 2, rand);
            room.roomArray[x][y] = new button_1.Button(room, x, y, d);
            let crateTiles = room
                .getEmptyTiles()
                .filter((t) => t.x >= room.roomX + 1 &&
                t.x <= room.roomX + room.width - 2 &&
                t.y >= room.roomY + Math.floor(room.height / 2) + 3 &&
                t.y <= room.roomY + room.height - 2);
            let numCrates = game_1.Game.randTable([1, 2, 2, 3, 4], rand);
            for (let i = 0; i < numCrates; i++) {
                let t = crateTiles.splice(game_1.Game.rand(0, crateTiles.length - 1, rand), 1)[0];
                if (t)
                    room.entities.push(new crate_1.Crate(room, room.game, t.x, t.y));
            }
            room.removeDoorObstructions();
        };
        this.populateSpikeCorridor = (room, rand) => {
            for (let x = room.roomX; x < room.roomX + room.width; x++) {
                for (let y = room.roomY + 1; y < room.roomY + room.height - 1; y++) {
                    room.roomArray[x][y] = new spiketrap_1.SpikeTrap(room, x, y, game_1.Game.rand(0, 3, rand));
                }
            }
            room.removeDoorObstructions();
            this.addRandomTorches(room, "medium");
        };
        this.populateCave = (room, rand) => {
            let factor = game_1.Game.rand(1, 36, rand);
            room.builder.addWallBlocks(rand);
            if (factor > 15)
                this.addSpikeTraps(room, game_1.Game.randTable([0, 0, 0, 1, 1, 2, 5], rand), rand);
            let numEmptyTiles = room.getEmptyTiles().length;
            let numEnemies = Math.ceil(numEmptyTiles * game_1.Game.randTable([0.25, 0.3, 0.35], rand));
            this.addEnemiesUnified(room, numEnemies, room.envType); // Use unified system directly
            if (room.level.environment.type === environmentTypes_1.EnvType.CAVE)
                this.addResources(room, (numEmptyTiles - numEnemies) * game_1.Game.randTable([0.1, 0.2, 0.3], rand), rand);
            room.removeDoorObstructions();
        };
        this.populateUpLadder = (room, rand) => {
            this.addRandomTorches(room, "medium");
            const { x, y } = room.getRoomCenter();
            room.roomArray[x - 1][y - 1] = new upLadder_1.UpLadder(room, room.game, x - 1, y - 1);
        };
        this.populateDownLadder = (room, rand) => {
            this.addTorches(room, 1, rand, room.roomX + 3, room.roomY);
            const { x, y } = room.getRoomCenter();
            room.roomArray[x + 1][y - 1] = new downLadder_1.DownLadder(room, room.game, x + 1, y - 1);
            const numChests = Math.ceil(random_1.Random.rand() * 5);
            let tiles = room.getEmptyTiles();
            tiles = tiles.filter((tile) => tile.x !== x || tile.y !== y);
            let weaponDropped = false;
            let toolDropped = false;
            let lightDropped = false;
            for (let i = 0; i < numChests; i++) {
                if (tiles.length > 0) {
                    const position = room.getRandomEmptyPosition(tiles);
                    if (position === null)
                        break;
                    const { x, y } = position;
                    let chest = new chest_1.Chest(room, room.game, x, y);
                    /*
                    if (!weaponDropped) {
                      chest.getDrop(["weapon"], true);
                      weaponDropped = true;
                    } else
                     */
                    chest.getDrop([
                        "consumable",
                        "gem",
                        "light",
                        "tool",
                        "fuel",
                        "backpack",
                        "weapon",
                        "coin",
                    ], false);
                    tiles.filter((tile) => tile.x !== x && tile.y !== y);
                    room.entities.push(chest);
                }
            }
            if (room.depth === 0)
                this.populateWeaponGroup(room, tiles);
        };
        this.populateWeaponGroup = (room, tiles) => {
            const emptyTile = room.getRandomEmptyPosition(tiles);
            const emptyTile2 = room.getRandomEmptyPosition(tiles, emptyTile);
            const emptyTile3 = room.getRandomEmptyPosition(tiles, emptyTile2);
            const weapons = new itemGroup_1.ItemGroup([
                new spear_1.Spear(room, emptyTile.x, emptyTile.y),
                new warhammer_1.Warhammer(room, emptyTile2.x, emptyTile2.y),
                new sword_1.Sword(room, emptyTile3.x, emptyTile3.y),
            ]);
            for (const item of weapons.items) {
                item.grouped = true;
                item.group = weapons;
                room.items.push(item);
            }
        };
        this.populateRopeHole = (room, rand) => {
            this.addRandomTorches(room, "medium");
            const { x, y } = room.getRoomCenter();
            const environment = room.depth < 1 ? environmentTypes_1.EnvType.FOREST : environmentTypes_1.EnvType.CAVE;
            //console.log("About to create DownLadder in rope hole");
            let d = new downLadder_1.DownLadder(room, room.game, x, y, true, environment);
            //console.log("DownLadder created, about to add to room array");
            // Delay adding to room array to avoid triggering side path generation during level setup
            setTimeout(() => {
                room.roomArray[x][y] = d;
                //console.log("DownLadder added to room array successfully (delayed)");
            }, 0);
        };
        this.populateRopeCave = (room, rand) => {
            const { x, y } = room.getRoomCenter();
            let upLadder = new upLadder_1.UpLadder(room, room.game, x, y);
            upLadder.isRope = true;
            room.roomArray[x][y] = upLadder;
            if (room.envType === environmentTypes_1.EnvType.CAVE)
                this.placeVendingMachineInWall(room, new pickaxe_1.Pickaxe(room, 0, 0));
            else
                this.placeVendingMachineInWall(room);
            room.removeDoorObstructions();
        };
        this.populateShop = (room, rand) => {
            this.addTorches(room, 2, rand);
            const { x, y } = room.getRoomCenter();
            vendingMachine_1.VendingMachine.add(room, room.game, x - 2, y - 1, new shotgun_1.Shotgun(room, 0, 0));
            vendingMachine_1.VendingMachine.add(room, room.game, x + 2, y - 1, new heart_1.Heart(room, 0, 0));
            vendingMachine_1.VendingMachine.add(room, room.game, x - 2, y + 2, new armor_1.Armor(room, 0, 0));
            vendingMachine_1.VendingMachine.add(room, room.game, x + 2, y + 2, new spear_1.Spear(room, 0, 0));
            room.removeDoorObstructions();
        };
        this.addTorchesByArea = (room) => {
            let numTorches = Math.max(1, Math.floor(Math.sqrt(room.roomArea) / 3) -
                Math.floor(Math.sqrt(room.depth)));
            if (room.depth === 0) {
                if (random_1.Random.rand() < 0.25) {
                    numTorches = 0;
                }
            }
            else {
                // Exponential falloff starting at depth 1, approaching 90% chance
                const falloffRate = 0.4; // Controls how quickly it approaches 90%
                const maxChance = 0.9;
                const chance = maxChance * (1 - Math.exp(-falloffRate * (room.depth - 1)));
                if (random_1.Random.rand() < chance) {
                    numTorches = 0;
                }
            }
            this.addTorches(room, numTorches, random_1.Random.rand);
        };
        this.populate = (room, rand) => {
            room.name = "";
            switch (room.type) {
                case room_1.RoomType.START:
                    if (room.depth !== 0) {
                        this.populateUpLadder(room, rand);
                        this.placeVendingMachineInWall(room);
                    }
                    this.populateEmpty(room, rand);
                    room.name = "FLOOR " + -room.depth;
                    break;
                case room_1.RoomType.BOSS:
                    this.populateBoss(room, rand);
                    room.name = "BOSS";
                    break;
                case room_1.RoomType.DUNGEON:
                    if (room.level.environment.type === environmentTypes_1.EnvType.CAVE &&
                        random_1.Random.rand() <= 0.2) {
                        this.populateCave(room, rand);
                    }
                    else {
                        this.populateDungeon(room, rand);
                    }
                    break;
                case room_1.RoomType.BIGDUNGEON:
                    this.populateBigDungeon(room, rand);
                    break;
                case room_1.RoomType.FOUNTAIN:
                    this.populateFountain(room, rand);
                    break;
                case room_1.RoomType.PUZZLE:
                    this.populatePuzzle(room, rand);
                    break;
                case room_1.RoomType.SPIKECORRIDOR:
                    this.populateSpikeCorridor(room, rand);
                    break;
                case room_1.RoomType.TREASURE:
                    this.populateTreasure(room, rand);
                    break;
                case room_1.RoomType.KEYROOM:
                    this.populateKeyRoom(room, rand);
                    break;
                case room_1.RoomType.GRASS:
                    this.populateDungeon(room, rand);
                    break;
                case room_1.RoomType.BIGCAVE:
                    this.populateCave(room, rand);
                case room_1.RoomType.CAVE:
                    this.populateCave(room, rand);
                    break;
                case room_1.RoomType.UPLADDER:
                    this.populateUpLadder(room, rand);
                    room.name = "FLOOR " + -room.depth;
                    break;
                case room_1.RoomType.DOWNLADDER:
                    this.populateDownLadder(room, rand);
                    room.name = "FLOOR " + -room.depth;
                    break;
                case room_1.RoomType.ROPEHOLE:
                    this.populateRopeHole(room, rand);
                    break;
                case room_1.RoomType.ROPECAVE:
                    this.populateRopeCave(room, rand);
                    break;
                case room_1.RoomType.SHOP:
                    this.populateShop(room, rand);
                    break;
                case room_1.RoomType.SPAWNER:
                    this.populateSpawner(room, rand);
                    break;
            }
            room.message = room.name;
        };
        this.level = level;
        this.props = [];
        this.medianDensity = gameplaySettings_1.GameplaySettings.MEDIAN_ROOM_DENSITY;
        // Calculate enemy pool once for this level
        this.levelEnemyPoolIds = this.generateEnemyPoolIds(this.level.depth);
    }
    addProps(room, numProps, envType) {
        const envData = envType
            ? environment_1.environmentData[envType]
            : environment_1.environmentData[room.level.environment.type];
        let tiles = room.getEmptyTiles();
        for (let i = 0; i < numProps; i++) {
            if (tiles.length === 0)
                break;
            const position = room.getRandomEmptyPosition(tiles);
            if (position === null)
                break;
            const { x, y } = position;
            const selectedProp = utils_1.Utils.randTableWeighted(envData.props);
            if (selectedProp && selectedProp.class && selectedProp.class.add) {
                const args = selectedProp.additionalParams || [];
                selectedProp.class.add(room, room.game, x, y, ...args);
            }
        }
    }
    /**
     * Adds props with clustering behavior - entities are more likely to be placed near existing entities
     * @param room - The room to populate
     * @param numProps - Number of props to place
     * @param envType - Environment type for prop selection
     * @param clusteringOptions - Optional clustering configuration
     */
    addPropsWithClustering(room, numProps, envType, clusteringOptions) {
        const envData = envType
            ? environment_1.environmentData[envType]
            : environment_1.environmentData[room.level.environment.type];
        const clusterer = new propClusterer_1.PropClusterer(room, clusteringOptions);
        const positions = clusterer.generateClusteredPositions(numProps);
        for (const { x, y } of positions) {
            const selectedProp = utils_1.Utils.randTableWeighted(envData.props);
            if (selectedProp && selectedProp.class && selectedProp.class.add) {
                const args = selectedProp.additionalParams || [];
                selectedProp.class.add(room, room.game, x, y, ...args);
            }
        }
    }
    populateDungeonEnvironment(room) {
        this.populateDefaultEnvironment(room);
    }
    populateCaveEnvironment(room) {
        const numProps = this.getNumProps(room);
        //this.addProps(room, numProps, room.envType);
        this.addPropsWithClustering(room, numProps, room.envType, {
            falloffExponent: 2,
            baseScore: 0.1,
            maxInfluenceDistance: 12,
            useSeedPosition: false,
        });
        // ADD: Enemies after props, based on remaining space
        this.addRandomEnemies(room);
    }
    populateForestEnvironment(room) {
        const numProps = this.getNumProps(room, 0.75);
        //this.addProps(room, numProps, room.envType);
        this.addPropsWithClustering(room, numProps, room.envType, {
            falloffExponent: 2,
            baseScore: 0.1,
            maxInfluenceDistance: 12,
            useSeedPosition: false,
        });
        // ADD: Enemies after props, based on remaining space
        this.addRandomEnemies(room);
    }
    getNumProps(room, medianDensity) {
        medianDensity = medianDensity || this.medianDensity;
        const numEmptyTiles = room.getEmptyTiles().length;
        const numProps = utils_1.Utils.randomNormalInt(0, numEmptyTiles, {
            median: Math.ceil(medianDensity * numEmptyTiles),
        });
        const percentFull = Math.round((numProps / numEmptyTiles) * 100);
        //console.log("percentFull", `${percentFull}%`);
        return numProps;
    }
    populateDefaultEnvironment(room) {
        const numProps = this.getNumProps(room);
        //this.addProps(room, numProps, room.envType);
        this.addPropsWithClustering(room, numProps, room.envType, {
            falloffExponent: 2,
            baseScore: 0.1,
            maxInfluenceDistance: 12,
            useSeedPosition: false,
        });
        // ADD: Enemies after props, based on remaining space
        this.addRandomEnemies(room);
    }
    // #region TILE ADDING METHODS
    addDoorTorches(room, x, y, doorDir) {
        if (doorDir !== game_2.Direction.UP && doorDir !== game_2.Direction.DOWN) {
            return;
        }
        if (x && y) {
            room.calculateWallInfo();
            const leftWallInfo = room.wallInfo.get(`${x - 1},${y}`);
            const rightWallInfo = room.wallInfo.get(`${x + 1},${y}`);
            const leftTile = room.roomArray[x - 1]?.[y];
            const rightTile = room.roomArray[x + 1]?.[y];
            const leftOpen = leftWallInfo?.isLeftWall === false;
            const rightOpen = rightWallInfo?.isRightWall === false;
            if (leftOpen) {
                room.roomArray[x - 1][y] = new wallTorch_1.WallTorch(room, x - 1, y);
            }
            if (rightOpen) {
                room.roomArray[x + 1][y] = new wallTorch_1.WallTorch(room, x + 1, y);
            }
        }
    }
    addTorches(room, numTorches, rand, placeX, placeY) {
        if (room.level.environment.type === environmentTypes_1.EnvType.FOREST &&
            room.type !== room_1.RoomType.DOWNLADDER)
            return;
        if (placeX !== undefined &&
            placeY !== undefined &&
            room.roomArray[placeX]?.[placeY] instanceof wall_1.Wall) {
            room.roomArray[placeX][placeY] = new wallTorch_1.WallTorch(room, placeX, placeY);
            return;
        }
        let walls = [];
        for (let xx = room.roomX + 1; xx < room.roomX + room.width - 2; xx++) {
            for (let yy = room.roomY; yy < room.roomY + room.height - 1; yy++) {
                if (room.roomArray[xx][yy] instanceof wall_1.Wall &&
                    !(room.roomArray[xx][yy + 1] instanceof wall_1.Wall)) {
                    walls.push(room.roomArray[xx][yy]);
                }
            }
        }
        let bottomWalls = [];
        // Separate loop for bottom wall
        for (let xx = room.roomX + 1; xx < room.roomX + room.width - 2; xx++) {
            const yy = room.roomY + room.height - 1; // Bottom wall
            if (room.roomArray[xx][yy] instanceof wall_1.Wall &&
                !(room.roomArray[xx][yy + 1] instanceof wall_1.Wall)) {
                bottomWalls.push(room.roomArray[xx][yy]);
            }
        }
        // Randomly distribute torches between walls and bottom walls
        const wallTorches = game_1.Game.rand(0, numTorches, rand);
        const bottomWallTorches = numTorches - wallTorches;
        for (let i = 0; i < wallTorches; i++) {
            if (walls.length == 0)
                break;
            const randomIndex = game_1.Game.rand(0, walls.length - 1, rand);
            const t = walls.splice(randomIndex, 1)[0];
            const x = t.x;
            const y = t.y;
            room.roomArray[x][y] = new wallTorch_1.WallTorch(room, x, y);
        }
        for (let i = 0; i < bottomWallTorches; i++) {
            if (bottomWalls.length == 0)
                break;
            const randomIndex = game_1.Game.rand(0, bottomWalls.length - 1, rand);
            const t = bottomWalls.splice(randomIndex, 1)[0];
            const x = t.x;
            const y = t.y;
            room.roomArray[x][y] = new wallTorch_1.WallTorch(room, x, y, true);
        }
    }
    addChasms(room, rand) {
        // add chasms
        let w = game_1.Game.rand(2, 4, rand);
        let h = game_1.Game.rand(2, 4, rand);
        let xmin = room.roomX + 2;
        let xmax = room.roomX + room.width - w - 2;
        let ymin = room.roomY + 2;
        let ymax = room.roomY + room.height - h - 2;
        if (xmax < xmin || ymax < ymin)
            return;
        let x = game_1.Game.rand(xmin, xmax, rand);
        let y = game_1.Game.rand(ymin, ymax, rand);
        for (let xx = x - 1; xx < x + w + 1; xx++) {
            for (let yy = y - 1; yy < y + h + 1; yy++) {
                // add a floor border
                if (xx === x - 1 || xx === x + w || yy === y - 1 || yy === y + h) {
                    if (!(room.roomArray[xx][yy] instanceof spawnfloor_1.SpawnFloor))
                        room.roomArray[xx][yy] = new floor_1.Floor(room, xx, yy);
                }
                else
                    room.roomArray[xx][yy] = new chasm_1.Chasm(room, xx, yy, xx === x, xx === x + w - 1, yy === y, yy === y + h - 1);
            }
        }
    }
    addPools(room, rand) {
        // add chasms
        let w = game_1.Game.rand(2, 4, rand);
        let h = game_1.Game.rand(2, 4, rand);
        let xmin = room.roomX + 2;
        let xmax = room.roomX + room.width - w - 2;
        let ymin = room.roomY + 2;
        let ymax = room.roomY + room.height - h - 2;
        if (xmax < xmin || ymax < ymin)
            return;
        let x = game_1.Game.rand(xmin, xmax, rand);
        let y = game_1.Game.rand(ymin, ymax, rand);
        for (let xx = x - 1; xx < x + w + 1; xx++) {
            for (let yy = y - 1; yy < y + h + 1; yy++) {
                // add a floor border
                if (xx === x - 1 || xx === x + w || yy === y - 1 || yy === y + h) {
                    if (!(room.roomArray[xx][yy] instanceof spawnfloor_1.SpawnFloor))
                        room.roomArray[xx][yy] = new floor_1.Floor(room, xx, yy);
                }
                else
                    room.roomArray[xx][yy] = new pool_1.Pool(room, xx, yy, xx === x, xx === x + w - 1, yy === y, yy === y + h - 1);
            }
        }
    }
    addSpikeTraps(room, numSpikes, rand) {
        if (room.level.environment.type === environmentTypes_1.EnvType.FOREST ||
            room.envType === environmentTypes_1.EnvType.FOREST)
            return;
        // add spikes
        let tiles = room.getEmptyTiles();
        for (let i = 0; i < numSpikes; i++) {
            const position = room.getRandomEmptyPosition(tiles);
            if (position === null)
                break;
            const { x, y } = position;
            room.roomArray[x][y] = new spiketrap_1.SpikeTrap(room, x, y);
        }
    }
    // #endregion
    // #region ADDING ENTITIES
    /**
     * Elegant enemy spawning that combines environment selection with progression control
     */
    addEnemiesUnified(room, numEnemies, envType) {
        if (gameplaySettings_1.GameplaySettings.NO_ENEMIES === true)
            return;
        // Get filtered enemies using our centralized logic
        const availableEnemies = this.getAvailableEnemiesForRoom(room, envType);
        if (availableEnemies.length === 0) {
            console.log(`No enemies available for environment ${envType || room.level.environment.type} at depth ${room.depth}`);
            return;
        }
        // Use existing spawning logic with filtered enemies
        this.spawnEnemiesFromPool(room, numEnemies, availableEnemies);
        // Add special enemies (spawners, occultists)
        this.addSpecialEnemies(room);
    }
    /**
     * Core method: Get available enemies filtered by environment and progression
     */
    getAvailableEnemiesForRoom(room, envType) {
        const environment = envType || room.level.environment.type;
        const envData = environment_1.environmentData[environment];
        // Use pre-calculated enemy pool instead of generating it for each room
        const allowedEnemyIds = this.levelEnemyPoolIds;
        // Filter environment enemies by allowed pool and add IDs
        const availableEnemies = envData.enemies
            .map((enemy) => ({
            ...enemy,
            id: environment_1.enemyClassToId.get(enemy.class), // Add ID dynamically
        }))
            .filter((enemy) => enemy.id &&
            allowedEnemyIds.includes(enemy.id) &&
            (enemy.minDepth ?? 0) <= room.depth);
        console.log(`Depth ${room.depth}, Env ${environment}: Pool [${allowedEnemyIds.map((id) => enemyIdToName[id] || `Unknown(${id})`).join(", ")}] -> Available [${availableEnemies.map((e) => enemyIdToName[e.id] || `Unknown(${e.id})`).join(", ")}]`);
        return availableEnemies;
    }
    /**
     * Spawn enemies from the filtered pool using existing logic
     */
    spawnEnemiesFromPool(room, numEnemies, enemyPool) {
        let tiles = room.getEmptyTiles();
        if (tiles.length === 0)
            return;
        // Existing door avoidance logic
        const excludedCoords = new Set();
        for (const door of room.doors) {
            for (let dx = -2; dx <= 2; dx++) {
                for (let dy = -2; dy <= 2; dy++) {
                    excludedCoords.add(`${door.x + dx},${door.y + dy}`);
                }
            }
        }
        tiles = tiles.filter((tile) => !excludedCoords.has(`${tile.x},${tile.y}`));
        // Spawn enemies
        for (let i = 0; i < numEnemies; i++) {
            if (tiles.length === 0)
                break;
            const position = room.getRandomEmptyPosition(tiles);
            if (position === null)
                break;
            const { x, y } = position;
            const selectedEnemy = utils_1.Utils.randTableWeighted(enemyPool);
            if (!selectedEnemy?.class?.add)
                continue;
            const args = selectedEnemy.additionalParams || [];
            // Handle special spawn logic
            if (selectedEnemy.specialSpawnLogic === "clearFloor") {
                const enemy = new selectedEnemy.class(room, room.game, x, y, ...args);
                if (this.canPlaceBigEnemy(room, enemy, x, y, tiles)) {
                    room.entities.push(enemy);
                    this.clearFloorForBigEnemy(room, x, y, enemy.w, enemy.h);
                    this.removeTilesForEnemy(tiles, x, y, enemy.w, enemy.h);
                }
                else {
                    numEnemies++; // Retry
                }
            }
            else {
                selectedEnemy.class.add(room, room.game, x, y, ...args);
                tiles = tiles.filter((t) => !(t.x === x && t.y === y));
            }
        }
    }
    /**
     * Add special enemies (spawners, occultists) - extracted for clarity
     */
    addSpecialEnemies(room) {
        // Spawner logic - now based on room area and probability
        if (room.depth > gameplaySettings_1.GameplaySettings.SPAWNER_MIN_DEPTH) {
            this.addSpawners(room, random_1.Random.rand);
        }
        // Occultist logic - now based on room area and probability
        if (room.depth > gameplaySettings_1.GameplaySettings.OCCULTIST_MIN_DEPTH) {
            this.addOccultists(room, random_1.Random.rand);
        }
    }
    // === ENEMY POOL GENERATION LOGIC (moved from Level) ===
    /**
     * Generate enemy pool IDs based on depth and progression rules
     */
    generateEnemyPoolIds(depth) {
        const availableEnemies = Object.entries(environment_1.enemyMinimumDepth)
            .filter(([enemyId, minDepth]) => depth >= minDepth)
            .map(([enemyId]) => Number(enemyId));
        // Get new enemies not yet encountered
        const newEnemies = availableEnemies.filter((id) => !this.level.game.encounteredEnemies.includes(id));
        // Add 1-2 new enemies per level (if limiting is enabled)
        const newEnemiesToAddCount = gameplaySettings_1.GameplaySettings.LIMIT_ENEMY_TYPES
            ? Math.min(newEnemies.length, gameplaySettings_1.GameplaySettings.NEW_ENEMIES_PER_LEVEL)
            : newEnemies.length;
        const newEnemiesToAdd = this.getRandomElements(newEnemies, newEnemiesToAddCount);
        this.level.game.encounteredEnemies.push(...newEnemiesToAdd);
        // Get current enemy pool
        const enemyPoolIds = this.level.game.encounteredEnemies.slice();
        // Limit variety if setting is enabled
        const numberOfTypes = gameplaySettings_1.GameplaySettings.LIMIT_ENEMY_TYPES
            ? this.getNumberOfEnemyTypes(depth)
            : enemyPoolIds.length;
        const selectedEnemyIds = this.getRandomElements(enemyPoolIds, numberOfTypes);
        return Array.from(new Set(selectedEnemyIds)).slice(0, numberOfTypes);
    }
    /**
     * Public method to get enemy pool for spawners and other external use
     */
    getEnemyPoolForDepth(depth) {
        // Use pre-calculated pool instead of generating new one, but filter by depth if different
        if (depth === this.level.depth) {
            return this.levelEnemyPoolIds;
        }
        // If a different depth is requested, generate it on demand (for spawners that might spawn at different depths)
        return this.generateEnemyPoolIds(depth);
    }
    /**
     * Calculate number of enemy types for depth
     */
    getNumberOfEnemyTypes(depth) {
        return depth === 0
            ? gameplaySettings_1.GameplaySettings.DEPTH_ZERO_ENEMY_TYPES
            : Math.ceil(Math.sqrt(depth + 1)) +
                gameplaySettings_1.GameplaySettings.ENEMY_TYPES_BASE_COUNT;
    }
    /**
     * Utility: Get random elements from array
     */
    getRandomElements(array, count) {
        const shuffled = [...array];
        for (let i = shuffled.length - 1; i > 0; i--) {
            const j = Math.floor(random_1.Random.rand() * (i + 1));
            [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
        }
        return shuffled.slice(0, Math.min(count, shuffled.length));
    }
    /**
     * Check if a big enemy can be placed at the given position
     */
    canPlaceBigEnemy(room, enemy, x, y, tiles) {
        for (let xx = 0; xx < enemy.w; xx++) {
            for (let yy = 0; yy < enemy.h; yy++) {
                if (!tiles.some((tile) => tile.x === x + xx && tile.y === y + yy)) {
                    return false;
                }
            }
        }
        return true;
    }
    /**
     * Clear floor tiles for big enemies (preserves existing logic)
     */
    clearFloorForBigEnemy(room, x, y, w, h) {
        for (let xx = 0; xx < w; xx++) {
            for (let yy = 0; yy < h; yy++) {
                room.roomArray[x + xx][y + yy] = new floor_1.Floor(room, x + xx, y + yy);
            }
        }
    }
    /**
     * Remove tiles that are now occupied by an enemy
     */
    removeTilesForEnemy(tiles, x, y, w, h) {
        for (let xx = 0; xx < w; xx++) {
            for (let yy = 0; yy < h; yy++) {
                const index = tiles.findIndex((t) => t.x === x + xx && t.y === y + yy);
                if (index !== -1)
                    tiles.splice(index, 1);
            }
        }
    }
    addRandomEnemies(room) {
        const numEmptyTiles = room.getEmptyTiles().length;
        const meanValue = (room.roomArea + numEmptyTiles) / 2;
        const factor = Math.min((room.depth + gameplaySettings_1.GameplaySettings.ENEMY_DENSITY_DEPTH_OFFSET) *
            gameplaySettings_1.GameplaySettings.ENEMY_DENSITY_DEPTH_MULTIPLIER, gameplaySettings_1.GameplaySettings.MAX_ENEMY_DENSITY);
        const baseEnemyCount = Math.ceil(Math.max(utils_1.Utils.randomNormalInt(0, meanValue * factor), meanValue * factor));
        // Cap at the number of empty tiles (hard limit)
        const numEnemies = Math.min(baseEnemyCount, numEmptyTiles);
        // Apply forest reduction (moved from old addEnemies method)
        const adjustedEnemies = room.envType === environmentTypes_1.EnvType.FOREST
            ? Math.floor(numEnemies * gameplaySettings_1.GameplaySettings.FOREST_ENEMY_REDUCTION)
            : numEnemies;
        this.addEnemiesUnified(room, adjustedEnemies, room.envType);
    }
    addSpawners(room, rand, numSpawners) {
        let tiles = room.getEmptyTiles();
        if (tiles.length === 0) {
            return;
        }
        let lastSpawner = null;
        // If numSpawners is provided, force generate that many
        if (numSpawners !== undefined) {
            for (let i = 0; i < numSpawners; i++) {
                const position = room.getRandomEmptyPosition(tiles);
                if (position === null)
                    break;
                const { x, y } = position;
                const spawnTable = this.getEnemyPoolForDepth(Math.max(0, room.depth - 1)).filter((t) => t !== 7);
                lastSpawner = spawner_1.Spawner.add(room, room.game, x, y, spawnTable);
                // Remove used tile
                tiles = tiles.filter((t) => !(t.x === x && t.y === y));
            }
        }
        else {
            // Original random spawner logic with configurable parameters
            const maxPossibleSpawners = Math.ceil(room.roomArea / gameplaySettings_1.GameplaySettings.SPAWNER_AREA_THRESHOLD);
            for (let i = 0; i < maxPossibleSpawners; i++) {
                if (rand() > gameplaySettings_1.GameplaySettings.SPAWNER_SPAWN_CHANCE)
                    continue;
                const position = room.getRandomEmptyPosition(tiles);
                if (position === null)
                    break;
                const { x, y } = position;
                const spawnTable = this.getEnemyPoolForDepth(Math.max(0, room.depth - 1)).filter((t) => t !== 7);
                lastSpawner = spawner_1.Spawner.add(room, room.game, x, y, spawnTable);
                tiles = tiles.filter((t) => !(t.x === x && t.y === y));
            }
        }
        return lastSpawner;
    }
    addOccultists(room, rand, numOccultists) {
        let tiles = room.getEmptyTiles();
        if (tiles.length === 0) {
            return;
        }
        let lastOccultist = null;
        // If numOccultists is provided, force generate that many
        if (numOccultists !== undefined) {
            for (let i = 0; i < numOccultists; i++) {
                const position = room.getRandomEmptyPosition(tiles);
                if (position === null)
                    break;
                const { x, y } = position;
                lastOccultist = occultistEnemy_1.OccultistEnemy.add(room, room.game, x, y);
                // Remove used tile
                tiles = tiles.filter((t) => !(t.x === x && t.y === y));
            }
        }
        else {
            // Original random occultist logic with configurable parameters
            const maxPossibleOccultists = Math.floor(room.roomArea / gameplaySettings_1.GameplaySettings.OCCULTIST_AREA_THRESHOLD);
            for (let i = 0; i < maxPossibleOccultists; i++) {
                if (rand() > gameplaySettings_1.GameplaySettings.OCCULTIST_SPAWN_CHANCE)
                    continue;
                const position = room.getRandomEmptyPosition(tiles);
                if (position === null)
                    break;
                const { x, y } = position;
                lastOccultist = occultistEnemy_1.OccultistEnemy.add(room, room.game, x, y);
                tiles = tiles.filter((t) => !(t.x === x && t.y === y));
            }
        }
        return lastOccultist;
    }
    addBosses(room, depth) {
        if (gameplaySettings_1.GameplaySettings.NO_ENEMIES === true)
            return;
        let tiles = room.getEmptyTiles();
        if (tiles.length === 0) {
            //console.log(`No tiles left to spawn spawners`);
            return;
        }
        let bosses = ["reaper", "queen", "bigskullenemy", "bigzombieenemy"];
        if (depth > 0) {
            bosses.push("occultist");
            bosses = bosses.filter((b) => b !== "queen");
        }
        const boss = game_1.Game.randTable(bosses, random_1.Random.rand);
        const position = boss.startsWith("big")
            ? room.getBigRandomEmptyPosition(tiles)
            : room.getRandomEmptyPosition(tiles);
        if (position === null)
            return;
        const { x, y } = position;
        switch (boss) {
            case "reaper":
                const spawner = this.addSpawners(room, random_1.Random.rand, 1);
                spawner.dropTable = ["weapon", "equipment"];
                spawner.dropChance = 1;
                break;
            case "queen":
                const queen = queenEnemy_1.QueenEnemy.add(room, room.game, x, y);
                queen.dropTable = ["weapon", "equipment"];
                queen.dropChance = 1;
                break;
            case "bigskullenemy":
                const bigSkull = bigSkullEnemy_1.BigSkullEnemy.add(room, room.game, x, y);
                bigSkull.dropTable = [
                    "weapon",
                    "equipment",
                    "consumable",
                    "gem",
                    "tool",
                ];
                break;
            case "occultist":
                const occultist = this.addOccultists(room, random_1.Random.rand, 1);
                occultist.dropTable = ["weapon", "equipment"];
                occultist.dropChance = 1;
                break;
            case "bigzombieenemy":
                const bigZombie = bigZombieEnemy_1.BigZombieEnemy.add(room, room.game, x, y);
                bigZombie.dropTable = [
                    "weapon",
                    "equipment",
                    "consumable",
                    "gem",
                    "tool",
                ];
                bigZombie.dropChance = 1;
                break;
        }
    }
    addChests(room, numChests, rand) {
        // add chests
        let tiles = room.getEmptyTiles();
        for (let i = 0; i < numChests; i++) {
            const position = room.getRandomEmptyPosition(tiles);
            if (!position) {
                // No more empty tiles available, break out of loop
                break;
            }
            const { x, y } = position;
            room.entities.push(new chest_1.Chest(room, room.game, x, y));
        }
    }
    addBombs(room, numBombs, rand) {
        let tiles = room.getEmptyTiles();
        for (let i = 0; i < room.getEmptyTiles().length; i++) {
            const position = room.getRandomEmptyPosition(tiles);
            if (position === null)
                break;
            const { x, y } = position;
            bomb_1.Bomb.add(room, room.game, x, y);
        }
    }
    addResources(room, numResources, rand) {
        let tiles = room.getEmptyTiles();
        for (let i = 0; i < numResources; i++) {
            const position = room.getRandomEmptyPosition(tiles);
            if (position === null)
                break;
            const { x, y } = position;
            let r = rand();
            if (r <= (10 - room.depth ** 3) / 10)
                coalResource_1.CoalResource.add(room, room.game, x, y);
            else if (r <= (10 - (room.depth - 2) ** 3) / 10)
                goldResource_1.GoldResource.add(room, room.game, x, y);
            else
                emeraldResource_1.EmeraldResource.add(room, room.game, x, y);
        }
    }
    addVendingMachine(room, rand, placeX, placeY, item) {
        const pos = room.getRandomEmptyPosition(room.getEmptyTiles());
        if (pos === null)
            return;
        let x = placeX ? placeX : pos.x;
        let y = placeY ? placeY : pos.y;
        let table = room.depth > 0
            ? [
                1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 1, 1, 1, 2, 2, 1, 1, 3, 4, 5, 5, 5,
                5, 5,
            ]
            : [1, 1, 1];
        let type = game_1.Game.randTable(table, rand);
        if (item) {
            vendingMachine_1.VendingMachine.add(room, room.game, x, y, item);
            return;
        }
        switch (type) {
            case 1:
                vendingMachine_1.VendingMachine.add(room, room.game, x, y, new heart_1.Heart(room, x, y));
                break;
            case 2:
                vendingMachine_1.VendingMachine.add(room, room.game, x, y, new candle_1.Candle(room, x, y));
                break;
            case 3:
                vendingMachine_1.VendingMachine.add(room, room.game, x, y, new armor_1.Armor(room, x, y));
                break;
            case 4:
                vendingMachine_1.VendingMachine.add(room, room.game, x, y, new spear_1.Spear(room, x, y));
                break;
            case 5:
                vendingMachine_1.VendingMachine.add(room, room.game, x, y, new torch_1.Torch(room, x, y));
                break;
        }
    }
    // Many populate methods start with adding torches using the same pattern
    addRandomTorches(room, intensity = "medium") {
        const torchPatterns = {
            none: [0, 0, 0],
            low: [0, 0, 0, 1, 1],
            medium: [0, 0, 0, 1, 1, 2, 2, 3],
            high: [1, 1, 2, 2, 3, 3, 4],
        };
        const randTorches = game_1.Game.randTable(torchPatterns[intensity], random_1.Random.rand);
        this.addTorches(room, randTorches, random_1.Random.rand);
    }
    /**
     * Places a VendingMachine in an empty wall.
     */
    placeVendingMachineInWall(room, item) {
        const emptyWalls = room.getEmptyWall();
        if (emptyWalls.length === 0)
            return;
        // Select a random empty wall
        const selectedWall = game_1.Game.randTable(emptyWalls, random_1.Random.rand);
        if (!selectedWall)
            return;
        // Remove the selected wall
        const removedWallInfo = room.removeEmptyWall(selectedWall);
        if (!removedWallInfo)
            return;
        const { x, y } = removedWallInfo;
        // Create and add the VendingMachine
        this.addVendingMachine(room, random_1.Random.rand, x, y, item);
    }
}
exports.Populator = Populator;


/***/ }),

/***/ "./src/sound/reverb.ts":
/*!*****************************!*\
  !*** ./src/sound/reverb.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ReverbEngine = void 0;
const game_1 = __webpack_require__(/*! ../game */ "./src/game.ts");
const sound_1 = __webpack_require__(/*! ./sound */ "./src/sound/sound.ts");
const howler_1 = __webpack_require__(/*! howler */ "./node_modules/howler/dist/howler.js");
class ReverbEngine {
    static isMobile() {
        return sound_1.Sound.isMobile;
    }
    // Mobile-specific audio context unlock
    static async unlockMobileAudio() {
        if (ReverbEngine.mobileUnlockAttempted || !ReverbEngine.isMobile()) {
            return;
        }
        ReverbEngine.mobileUnlockAttempted = true;
        try {
            // Create a silent buffer and play it to unlock the audio context
            const buffer = ReverbEngine.audioContext.createBuffer(1, 1, 22050);
            const source = ReverbEngine.audioContext.createBufferSource();
            source.buffer = buffer;
            source.connect(ReverbEngine.audioContext.destination);
            if (typeof source.start === "undefined") {
                source.noteOn(0);
            }
            else {
                source.start(0);
            }
            // Resume the context
            if (ReverbEngine.audioContext.state === "suspended") {
                await ReverbEngine.audioContext.resume();
            }
        }
        catch (error) {
            console.warn("[REVERB-MOBILE] Failed to unlock audio context:", error);
        }
    }
    // Helper function to get sound identifier for logging
    static getSoundName(sound) {
        const src = sound._src;
        if (Array.isArray(src) && src.length > 0) {
            return src[0].split("/").pop() || "unknown";
        }
        else if (typeof src === "string") {
            return src.split("/").pop() || "unknown";
        }
        return "unknown";
    }
    // General logging function to avoid repetition
    static logStep(step, soundName, message, soundId) {
        const idStr = soundId !== undefined ? ` [ID:${soundId}]` : "";
    }
    static async initialize() {
        if (ReverbEngine.initialized)
            return;
        let canInitialize = game_1.Game.inputReceived;
        // For mobile, we need to be extra careful about timing
        if (!canInitialize) {
            try {
                await new Promise((resolve) => {
                    const checkInput = () => {
                        if (game_1.Game.inputReceived) {
                            resolve();
                            canInitialize = true;
                        }
                        else {
                            requestAnimationFrame(checkInput);
                        }
                    };
                    checkInput();
                });
            }
            catch (error) {
                console.error("Failed to wait for input:", error);
                return;
            }
        }
        if (!ReverbEngine.audioContext &&
            !ReverbEngine.initialized &&
            canInitialize) {
            try {
                // Wait for Howler to initialize its context
                if (!howler_1.Howler.ctx) {
                    await new Promise((resolve) => setTimeout(resolve, 100));
                }
                ReverbEngine.audioContext =
                    howler_1.Howler.ctx ||
                        new (window.AudioContext || window.webkitAudioContext)();
                // Mobile-specific: Unlock audio context immediately after user interaction
                if (ReverbEngine.isMobile()) {
                    await ReverbEngine.unlockMobileAudio();
                }
                // Resume context if suspended (common on mobile)
                if (ReverbEngine.audioContext.state === "suspended") {
                    await ReverbEngine.audioContext.resume();
                }
                // Set up the convolver
                ReverbEngine.convolver = ReverbEngine.audioContext.createConvolver();
                ReverbEngine.convolver.connect(ReverbEngine.audioContext.destination);
                await ReverbEngine.loadReverbBuffer(`res/SFX/impulses/small.mp3`);
                ReverbEngine.setDefaultReverb();
                // HOOK INTO _refreshBuffer METHOD
                if (!ReverbEngine.originalRefreshBuffer) {
                    ReverbEngine.originalRefreshBuffer = howler_1.Howl.prototype._refreshBuffer;
                    howler_1.Howl.prototype._refreshBuffer = function (sound) {
                        const soundName = ReverbEngine.getSoundName(this);
                        ReverbEngine.logStep("A", soundName, "Intercepted _refreshBuffer", sound._id);
                        // Mobile check: ensure audio context is not suspended
                        if (ReverbEngine.isMobile() &&
                            ReverbEngine.audioContext.state === "suspended") {
                            ReverbEngine.audioContext.resume().then(() => {
                                ReverbEngine.logStep("A-MOBILE", soundName, "Resumed suspended context", sound._id);
                            });
                        }
                        // Call the original method first
                        ReverbEngine.originalRefreshBuffer.call(this, sound);
                        // Now intercept the connection and add our reverb routing
                        if (sound._node && sound._node.bufferSource) {
                            ReverbEngine.logStep("B", soundName, "Setting up reverb routing", sound._id);
                            // Disconnect from the original destination
                            sound._node.bufferSource.disconnect();
                            // Create or get gain node for this sound
                            let gainNode = ReverbEngine.gainNodes.get(sound._id);
                            if (!gainNode) {
                                gainNode = ReverbEngine.audioContext.createGain();
                                const volume = this._volume || 1.0;
                                gainNode.gain.setValueAtTime(volume, ReverbEngine.audioContext.currentTime);
                                gainNode.connect(ReverbEngine.convolver);
                                ReverbEngine.gainNodes.set(sound._id, gainNode);
                                ReverbEngine.logStep("C", soundName, `Created gain node with volume ${volume}`, sound._id);
                            }
                            // Connect buffer source to our gain node instead of the original destination
                            sound._node.bufferSource.connect(gainNode);
                            ReverbEngine.logStep("D", soundName, "Connected to reverb gain node", sound._id);
                        }
                    };
                }
                ReverbEngine.initialized = true;
                if (sound_1.Sound.initialized)
                    sound_1.Sound.audioMuted = false;
                const deviceType = ReverbEngine.isMobile() ? "MOBILE" : "DESKTOP";
            }
            catch (error) {
                console.error("Failed to initialize ReverbEngine:", error);
                ReverbEngine.initialized = true;
                if (sound_1.Sound.initialized)
                    sound_1.Sound.audioMuted = false;
            }
        }
    }
    // Load a specified impulse response
    static async loadReverbBuffer(filePath) {
        try {
            const response = await fetch(filePath);
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            const arrayBuffer = await response.arrayBuffer();
            ReverbEngine.reverbBuffer =
                await ReverbEngine.audioContext.decodeAudioData(arrayBuffer);
        }
        catch (error) {
            console.error("Error loading reverb buffer:", error);
        }
    }
    // Set the default reverb buffer
    static setDefaultReverb() {
        if (ReverbEngine.reverbBuffer) {
            ReverbEngine.convolver.buffer = ReverbEngine.reverbBuffer;
        }
    }
    /**
     * Set the reverb characteristics by specifying an impulse response file.
     * @param filePath - The path to the impulse response file.
     */
    static async setReverbImpulse(filePath) {
        if (!ReverbEngine.initialized)
            return;
        try {
            await ReverbEngine.loadReverbBuffer(filePath);
            if (ReverbEngine.reverbBuffer) {
                ReverbEngine.convolver.buffer = ReverbEngine.reverbBuffer;
            }
        }
        catch (error) {
            console.error("Error setting reverb impulse:", error);
        }
    }
    // CONNECTION INTERCEPT APPROACH: The _refreshBuffer hook handles everything
    static applyReverb(sound) {
        const soundName = ReverbEngine.getSoundName(sound);
        ReverbEngine.logStep("E", soundName, "CONNECTION INTERCEPT - _refreshBuffer hook will handle reverb");
        if (!ReverbEngine.initialized) {
            ReverbEngine.logStep("E1", soundName, "Not initialized, playing without reverb");
            return sound.play();
        }
        // Mobile check: ensure we have an active audio context
        if (ReverbEngine.isMobile() &&
            ReverbEngine.audioContext.state !== "running") {
            ReverbEngine.audioContext.resume().catch((error) => {
                console.warn("[REVERB-MOBILE] Could not resume audio context:", error);
            });
        }
        // Just call play normally - our _refreshBuffer hook will handle the rest
        return sound.play();
    }
    // Remove reverb from a given Howl sound
    static removeReverb(sound) {
        const soundName = ReverbEngine.getSoundName(sound);
        // Clean up any gain nodes associated with this sound
        for (const [soundId, gainNode] of ReverbEngine.gainNodes.entries()) {
            if (gainNode) {
                gainNode.disconnect();
                ReverbEngine.gainNodes.delete(soundId);
            }
        }
        ReverbEngine.logStep("R", soundName, "Reverb removed and gain nodes cleaned up");
    }
    // Cleanup method
    static cleanup() {
        // Restore original _refreshBuffer method
        if (ReverbEngine.originalRefreshBuffer) {
            howler_1.Howl.prototype._refreshBuffer = ReverbEngine.originalRefreshBuffer;
        }
        // Clean up all gain nodes
        for (const [soundId, gainNode] of ReverbEngine.gainNodes.entries()) {
            if (gainNode) {
                gainNode.disconnect();
            }
        }
        ReverbEngine.gainNodes.clear();
        if (ReverbEngine.convolver) {
            ReverbEngine.convolver.disconnect();
        }
        if (ReverbEngine.audioContext &&
            ReverbEngine.audioContext.state !== "closed") {
            ReverbEngine.audioContext.close();
        }
        ReverbEngine.initialized = false;
    }
}
exports.ReverbEngine = ReverbEngine;
ReverbEngine.reverbBuffer = null;
ReverbEngine.gainNodes = new Map();
ReverbEngine.mobileUnlockAttempted = false;
ReverbEngine.initialized = false;


/***/ }),

/***/ "./src/sound/sound.ts":
/*!****************************!*\
  !*** ./src/sound/sound.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Sound = void 0;
const game_1 = __webpack_require__(/*! ../game */ "./src/game.ts");
const random_1 = __webpack_require__(/*! ../utility/random */ "./src/utility/random.ts");
const reverb_1 = __webpack_require__(/*! ./reverb */ "./src/sound/reverb.ts");
const howler_1 = __webpack_require__(/*! howler */ "./node_modules/howler/dist/howler.js");
class Sound {
    static detectMobile() {
        const userAgent = navigator.userAgent || navigator.vendor || window.opera;
        Sound.isMobile =
            /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(userAgent);
        return Sound.isMobile;
    }
    static async enableAudioForMobile() {
        if (Sound.audioContextResumed)
            return;
        try {
            if (howler_1.Howler.ctx && howler_1.Howler.ctx.state === "suspended") {
                await howler_1.Howler.ctx.resume();
                Sound.audioContextResumed = true;
                console.log("AudioContext resumed");
            }
        }
        catch (error) {
            console.warn("Could not resume AudioContext:", error);
        }
    }
    static addMobileAudioHandlers() {
        const enableAudio = async () => {
            await Sound.enableAudioForMobile();
            if (Sound.audioMuted && reverb_1.ReverbEngine.initialized) {
                Sound.audioMuted = false;
                howler_1.Howler.mute(false);
            }
        };
        const events = ["touchstart", "click", "keydown"];
        const handler = () => {
            enableAudio();
            events.forEach((event) => {
                document.removeEventListener(event, handler);
            });
        };
        events.forEach((event) => {
            document.addEventListener(event, handler, { once: true });
        });
    }
    static toggleMute() {
        Sound.audioMuted = !Sound.audioMuted;
        if (Sound.audioMuted) {
            howler_1.Howler.mute(true);
        }
        else {
            howler_1.Howler.mute(false);
            if (Sound.isMobile) {
                Sound.enableAudioForMobile();
            }
        }
    }
    static playWithReverb(sound, priority = Sound.PRIORITY.INTERACTIONS) {
        if (Sound.audioMuted)
            return null;
        try {
            // Simple volume-based priority system
            if (Sound.currentlyPlaying.size > 10 &&
                priority < Sound.PRIORITY.COMBAT) {
                return null;
            }
            let soundId = null;
            // Always try to use reverb if available and not on mobile
            if (reverb_1.ReverbEngine.initialized && !Sound.isMobile) {
                soundId = reverb_1.ReverbEngine.applyReverb(sound);
            }
            else {
                soundId = sound.play();
            }
            if (soundId) {
                Sound.currentlyPlaying.add(soundId);
                // Clean up tracking
                sound.once("end", () => {
                    Sound.currentlyPlaying.delete(soundId);
                });
                // Fallback cleanup
                setTimeout(() => {
                    Sound.currentlyPlaying.delete(soundId);
                }, 5000);
            }
            return soundId;
        }
        catch (error) {
            console.error("Error playing sound:", error);
            return null;
        }
    }
    static stopSound(sound) {
        sound.stop();
    }
    static stopSoundWithReverb(sound) {
        reverb_1.ReverbEngine.removeReverb(sound);
        this.stopSound(sound);
    }
    static cleanup() {
        Sound.currentlyPlaying.clear();
        howler_1.Howler.unload();
    }
}
exports.Sound = Sound;
_a = Sound;
Sound.initialized = false;
Sound.audioMuted = true;
Sound.currentlyPlaying = new Set();
Sound.PRIORITY = {
    AMBIENT: 1,
    FOOTSTEPS: 2,
    INTERACTIONS: 3,
    COMBAT: 4,
    CRITICAL: 5,
};
Sound.isMobile = false;
Sound.audioContextResumed = false;
Sound.forestMusicId = null;
Sound.caveMusicId = null;
Sound.ambientSoundId = null;
Sound.loadSounds = async () => {
    if (Sound.initialized)
        return;
    Sound.initialized = true;
    Sound.detectMobile();
    if (Sound.isMobile) {
        Sound.addMobileAudioHandlers();
    }
    if (reverb_1.ReverbEngine.initialized) {
        Sound.audioMuted = false;
    }
    // Optimized Howl creation - always use Web Audio API for better performance
    const createHowlArray = (basePath, indices, volume = 1.0, maxConcurrent = 3) => {
        return indices.map((i) => {
            return new howler_1.Howl({
                src: [`${basePath}${i}.mp3`],
                volume: volume,
                preload: true,
                html5: false,
                pool: maxConcurrent,
            });
        });
    };
    const createHowl = (src, volume = 1.0, loop = false, maxConcurrent = 2) => {
        return new howler_1.Howl({
            src: [src],
            volume: volume,
            preload: true,
            loop: loop,
            html5: false,
            pool: maxConcurrent,
        });
    };
    try {
        // Load all sounds with optimized settings
        Sound.magicSound = createHowl("res/SFX/attacks/magic2.mp3", 0.25, false, 3);
        Sound.warHammerSound = createHowl("res/SFX/attacks/warhammer.mp3", 1, false, 3);
        Sound.healSound = createHowl("res/SFX/items/powerup1.mp3", 0.5, false, 1);
        Sound.eatSounds = createHowlArray("res/SFX/items/eat", [1, 2], 1.0, 5);
        // Footstep sounds
        Sound.playerStoneFootsteps = createHowlArray("res/SFX/footsteps/stone/footstep", [1, 2, 3], 1.0, 4);
        Sound.playerGrassFootsteps = createHowlArray("res/SFX/footsteps/grass/footstep", [1, 2, 3, 6], 1.0, 4);
        Sound.playerDirtFootsteps = createHowlArray("res/SFX/footsteps/dirt/footstep", [1, 2, 3, 4, 5], 1.0, 4);
        Sound.enemyFootsteps = createHowlArray("res/SFX/footsteps/enemy/enemyfootstep", [1, 2, 3, 4, 5], 1.0, 4);
        // Combat sounds
        Sound.swingSounds = createHowlArray("res/SFX/attacks/swing", [1, 2, 3, 4], 0.5, 6);
        Sound.hitSounds = createHowlArray("res/SFX/attacks/hurt", [1, 2, 3, 4], 0.5, 4);
        Sound.hurtSounds = [createHowl("res/SFX/attacks/hit.mp3", 0.3, false, 0)];
        Sound.sliceSound = createHowlArray("res/SFX/attacks/slice", [1, 2, 3], 0.5, 4);
        Sound.shortSliceSound = createHowlArray("res/SFX/attacks/sliceShort", [1, 2, 3], 0.5, 4);
        Sound.parrySounds = createHowlArray("res/SFX/attacks/parry", [1, 2], 0.5, 3);
        Sound.gruntSounds = createHowlArray("res/SFX/attacks/grunt", [1], 0.35, 1);
        // Single sounds
        Sound.enemySpawnSound = createHowl("res/SFX/attacks/enemyspawn.mp3", 0.7, false, 3);
        Sound.wooshSound = createHowl("res/SFX/attacks/woosh1.mp3", 0.2, false, 3);
        // Interaction sounds
        Sound.chestSounds = createHowlArray("res/SFX/chest/chest", [1, 2, 3], 0.5, 3);
        Sound.coinPickupSounds = createHowlArray("res/SFX/items/coins", [1, 2, 3, 4], 1.0, 5);
        Sound.genericPickupSound = createHowl("res/SFX/items/pickup.mp3", 0.8, false, 3);
        Sound.keyPickupSound = createHowl("res/SFX/items/keyPickup.mp3", 1.0, false, 2);
        Sound.backpackSound = createHowl("res/SFX/items/backpack.mp3", 0.75, false, 2);
        Sound.smithSound = createHowl("res/SFX/items/smith.mp3", 0.5, false, 2);
        Sound.lockedSound = createHowl("res/SFX/door/locked1.mp3", 0.75, false, 2);
        Sound.woodSound = createHowl("res/SFX/objects/woodHit1.mp3", 1.25, false, 2);
        Sound.squishSound = createHowl("res/SFX/attacks/squish1.mp3", 0.75, false, 2);
        // Mining sounds
        Sound.miningSounds = createHowlArray("res/SFX/resources/Pickaxe", [1, 2, 3, 4], 0.3, 3);
        Sound.breakRockSound = createHowl("res/SFX/resources/rockbreak.mp3", 1.0, false, 2);
        // Door sounds
        Sound.unlockSounds = createHowlArray("res/SFX/door/unlock", [1], 0.5, 2);
        Sound.doorOpenSounds = createHowlArray("res/SFX/door/open", [1, 2], 0.5, 3);
        // Object sounds
        Sound.potSmashSounds = createHowlArray("res/SFX/objects/potSmash", [1, 2, 3], 0.5, 3);
        Sound.bushSounds = createHowlArray("res/SFX/objects/plantHit", [1, 2], 0.75, 3);
        Sound.pushSounds = createHowlArray("res/SFX/pushing/push", [1, 2], 1.0, 3);
        Sound.fishingCastSounds = createHowlArray("res/SFX/fishing/cast", [1, 2], 0.5, 3);
        Sound.fishingReelSound = createHowl("res/SFX/fishing/catch.mp3", 0.5, false, 2);
        Sound.fishingCatchSounds = createHowlArray("res/SFX/fishing/splash", [1, 2], 0.85, 3);
        // Bomb sounds
        Sound.bombSounds = createHowlArray("res/SFX/attacks/explode", [1, 2], 0.7, 3);
        Sound.fuseBurnSound = createHowl("res/SFX/attacks/fuse.mp3", 0.2, false, 2);
        Sound.fuseLoopSound = createHowl("res/SFX/attacks/fuseLoop.mp3", 0.2, true, 1);
        Sound.fuseStartSound = createHowl("res/SFX/attacks/fuseStart.mp3", 0.2, false, 2);
        // Ambient sounds - critical for mobile
        Sound.forestMusic = createHowl("res/music/forest1.mp3", 0.25, true, 1);
        Sound.caveMusic = createHowl("res/music/cave1.mp3", 0.25, true, 1);
        Sound.graveSound = createHowl("res/SFX/attacks/skelespawn.mp3", 1.0, false, 2);
        Sound.ambientSound = createHowl("res/SFX/ambient/ambientDark2.mp3", 0.3, true, 1); // Reduced volume
        Sound.goreSound = createHowl("res/SFX/misc Unused/gore2.mp3", 0.5, false, 2);
        console.log("All sounds loaded successfully");
    }
    catch (error) {
        console.error("Error loading sounds:", error);
    }
};
Sound.playerStoneFootstep = (environment) => {
    if (Sound.audioMuted)
        return;
    let sound = Sound.playerStoneFootsteps;
    if (environment === 2)
        sound = Sound.playerGrassFootsteps;
    if (environment === 1)
        sound = Sound.playerDirtFootsteps;
    let f = game_1.Game.randTable(sound, random_1.Random.rand);
    _a.playWithReverb(f, Sound.PRIORITY.FOOTSTEPS);
};
Sound.enemyFootstep = () => {
    if (Sound.audioMuted)
        return;
    let f = game_1.Game.randTable(Sound.enemyFootsteps, random_1.Random.rand);
    _a.playWithReverb(f, Sound.PRIORITY.FOOTSTEPS);
};
Sound.swing = () => {
    if (Sound.audioMuted)
        return;
    let f = game_1.Game.randTable(Sound.swingSounds, random_1.Random.rand);
    _a.playWithReverb(f, Sound.PRIORITY.COMBAT);
};
Sound.hit = (hard = false) => {
    if (Sound.audioMuted)
        return;
    let sounds = Sound.hitSounds.slice(hard ? 2 : 0, hard ? 3 : 2);
    setTimeout(() => {
        let f = game_1.Game.randTable(sounds, random_1.Random.rand);
        _a.playWithReverb(f, Sound.PRIORITY.COMBAT);
    }, 100);
};
Sound.hurt = () => {
    if (Sound.audioMuted)
        return;
    let f = game_1.Game.randTable(Sound.hurtSounds, random_1.Random.rand);
    _a.playWithReverb(f, Sound.PRIORITY.CRITICAL);
};
Sound.enemySpawn = () => {
    if (Sound.audioMuted)
        return;
    _a.playWithReverb(Sound.enemySpawnSound, Sound.PRIORITY.CRITICAL);
};
Sound.chest = () => {
    if (Sound.audioMuted)
        return;
    let f = game_1.Game.randTable(Sound.chestSounds, random_1.Random.rand);
    _a.playWithReverb(f, Sound.PRIORITY.INTERACTIONS);
};
Sound.potSmash = () => {
    if (Sound.audioMuted)
        return;
    let f = game_1.Game.randTable(Sound.potSmashSounds, random_1.Random.rand);
    _a.delayPlay(() => _a.playWithReverb(f, Sound.PRIORITY.INTERACTIONS), 100);
};
Sound.pickupCoin = () => {
    if (Sound.audioMuted)
        return;
    let f = game_1.Game.randTable(Sound.coinPickupSounds, random_1.Random.rand);
    _a.playWithReverb(f, Sound.PRIORITY.INTERACTIONS);
};
Sound.mine = () => {
    if (Sound.audioMuted)
        return;
    let f = game_1.Game.randTable(Sound.miningSounds, random_1.Random.rand);
    _a.playWithReverb(f, Sound.PRIORITY.INTERACTIONS);
};
Sound.breakRock = () => {
    if (Sound.audioMuted)
        return;
    setTimeout(() => {
        _a.playWithReverb(Sound.breakRockSound, Sound.PRIORITY.INTERACTIONS);
    }, 100);
};
Sound.heal = () => {
    if (Sound.audioMuted)
        return;
    _a.playWithReverb(Sound.healSound, Sound.PRIORITY.CRITICAL);
};
Sound.genericPickup = () => {
    if (Sound.audioMuted)
        return;
    _a.playWithReverb(Sound.genericPickupSound, Sound.PRIORITY.INTERACTIONS);
};
Sound.keyPickup = () => {
    if (Sound.audioMuted)
        return;
    _a.playWithReverb(Sound.keyPickupSound, Sound.PRIORITY.INTERACTIONS);
};
Sound.push = () => {
    if (Sound.audioMuted)
        return;
    let f = game_1.Game.randTable(Sound.pushSounds, random_1.Random.rand);
    _a.playWithReverb(f, Sound.PRIORITY.INTERACTIONS);
};
Sound.skeleSpawn = () => {
    if (Sound.audioMuted)
        return;
    // IMPORTANT: Original implementation set volume to 0.3 in this method
    Sound.graveSound.volume(0.3);
    _a.playWithReverb(Sound.graveSound, Sound.PRIORITY.CRITICAL);
};
Sound.unlock = () => {
    if (Sound.audioMuted)
        return;
    let f = game_1.Game.randTable(Sound.unlockSounds, random_1.Random.rand);
    _a.playWithReverb(f, Sound.PRIORITY.INTERACTIONS);
};
Sound.playCaveMusic = (index = 0) => {
    if (Sound.audioMuted)
        return;
    try {
        // Stop any existing forest music
        if (Sound.caveMusicId) {
            Sound.caveMusic.stop(Sound.caveMusicId);
        }
        // Play new instance
        Sound.caveMusicId = Sound.caveMusic.play();
        // Handle mobile audio context
        if (Sound.isMobile && !Sound.audioContextResumed) {
            Sound.enableAudioForMobile();
        }
    }
    catch (error) {
        console.error("Error playing cave music:", error);
    }
};
Sound.playForestMusic = (index = 0) => {
    if (Sound.audioMuted)
        return;
    try {
        // Stop any existing forest music
        if (Sound.forestMusicId) {
            Sound.forestMusic.stop(Sound.forestMusicId);
        }
        // Play new instance
        Sound.forestMusicId = Sound.forestMusic.play();
        // Handle mobile audio context
        if (Sound.isMobile && !Sound.audioContextResumed) {
            Sound.enableAudioForMobile();
        }
    }
    catch (error) {
        console.error("Error playing forest music:", error);
    }
};
Sound.doorOpen = () => {
    if (Sound.audioMuted)
        return;
    let f = game_1.Game.randTable(Sound.doorOpenSounds, random_1.Random.rand);
    _a.playWithReverb(f, Sound.PRIORITY.INTERACTIONS);
};
Sound.playAmbient = () => {
    if (Sound.audioMuted)
        return;
    try {
        // Only play if not already playing
        if (!Sound.ambientSoundId ||
            !Sound.ambientSound.playing(Sound.ambientSoundId)) {
            Sound.ambientSoundId = Sound.ambientSound.play();
        }
    }
    catch (error) {
        console.error("Error playing ambient sound:", error);
    }
};
Sound.stopAmbient = () => {
    if (Sound.ambientSoundId) {
        Sound.ambientSound.stop(Sound.ambientSoundId);
        Sound.ambientSoundId = null;
    }
};
Sound.playFuse = () => {
    if (Sound.audioMuted)
        return;
    Sound.fuseStartSound.play();
    Sound.fuseStartSound.once("end", () => {
        Sound.fuseLoopSound.play();
    });
};
Sound.stopFuse = () => {
    Sound.fuseLoopSound.stop();
    Sound.fuseStartSound.stop();
};
Sound.playGore = () => {
    if (Sound.audioMuted)
        return;
    _a.playWithReverb(Sound.goreSound, Sound.PRIORITY.COMBAT);
};
Sound.playBomb = () => {
    if (Sound.audioMuted)
        return;
    let f = game_1.Game.randTable(Sound.bombSounds, random_1.Random.rand);
    _a.playWithReverb(f, Sound.PRIORITY.CRITICAL);
};
Sound.playWarHammer = () => {
    if (Sound.audioMuted)
        return;
    _a.delayPlay(() => {
        _a.playWithReverb(Sound.hitSounds[2], Sound.PRIORITY.COMBAT);
    }, 200);
};
Sound.playMagic = () => {
    if (Sound.audioMuted)
        return;
    _a.playWithReverb(Sound.magicSound, Sound.PRIORITY.COMBAT);
    _a.playWithReverb(Sound.wooshSound, Sound.PRIORITY.COMBAT);
};
Sound.playSlice = () => {
    if (Sound.audioMuted)
        return;
    let f = game_1.Game.randTable(Sound.sliceSound, random_1.Random.rand);
    _a.playWithReverb(f, Sound.PRIORITY.COMBAT);
};
Sound.playShortSlice = () => {
    if (Sound.audioMuted)
        return;
    let f = game_1.Game.randTable(Sound.shortSliceSound, random_1.Random.rand);
    _a.playWithReverb(f, Sound.PRIORITY.COMBAT);
};
Sound.playBackpack = () => {
    if (Sound.audioMuted)
        return;
    _a.playWithReverb(Sound.backpackSound, Sound.PRIORITY.INTERACTIONS);
};
Sound.playSmith = () => {
    if (Sound.audioMuted)
        return;
    _a.playWithReverb(Sound.smithSound, Sound.PRIORITY.INTERACTIONS);
};
Sound.playBush = () => {
    if (Sound.audioMuted)
        return;
    let f = game_1.Game.randTable(Sound.bushSounds, random_1.Random.rand);
    _a.delayPlay(() => _a.playWithReverb(f, Sound.PRIORITY.INTERACTIONS), 100);
};
Sound.playParry = () => {
    if (Sound.audioMuted)
        return;
    let f = game_1.Game.randTable(Sound.parrySounds, random_1.Random.rand);
    _a.delayPlay(() => _a.playWithReverb(f, Sound.PRIORITY.CRITICAL), 100);
};
Sound.playEat = () => {
    if (Sound.audioMuted)
        return;
    let f = game_1.Game.randTable(Sound.eatSounds, random_1.Random.rand);
    _a.playWithReverb(f, Sound.PRIORITY.INTERACTIONS);
};
Sound.playGrunt = () => {
    if (Sound.audioMuted)
        return;
    let f = game_1.Game.randTable(Sound.gruntSounds, random_1.Random.rand);
    _a.playWithReverb(f, Sound.PRIORITY.COMBAT);
};
Sound.playLocked = () => {
    if (Sound.audioMuted)
        return;
    _a.playWithReverb(Sound.lockedSound, Sound.PRIORITY.INTERACTIONS);
};
Sound.playWood = () => {
    if (Sound.audioMuted)
        return;
    _a.delayPlay(() => {
        _a.playWithReverb(Sound.woodSound, Sound.PRIORITY.INTERACTIONS);
    }, 150);
};
Sound.playSquish = () => {
    if (Sound.audioMuted)
        return;
    _a.playWithReverb(Sound.squishSound, Sound.PRIORITY.INTERACTIONS);
};
Sound.playFishingCast = () => {
    if (Sound.audioMuted)
        return;
    let f = game_1.Game.randTable(Sound.fishingCastSounds, random_1.Random.rand);
    _a.playWithReverb(f, Sound.PRIORITY.INTERACTIONS);
};
Sound.playFishingReel = () => {
    if (Sound.audioMuted)
        return;
    _a.playWithReverb(Sound.fishingReelSound, Sound.PRIORITY.INTERACTIONS);
};
Sound.playFishingCatch = () => {
    if (Sound.audioMuted)
        return;
    let f = game_1.Game.randTable(Sound.fishingCatchSounds, random_1.Random.rand);
    _a.delayPlay(() => _a.playWithReverb(f, Sound.PRIORITY.INTERACTIONS), 100);
};
Sound.delayPlay = (method, delay) => {
    setTimeout(method, delay);
};


/***/ }),

/***/ "./src/tile/button.ts":
/*!****************************!*\
  !*** ./src/tile/button.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Button = void 0;
const game_1 = __webpack_require__(/*! ../game */ "./src/game.ts");
const tile_1 = __webpack_require__(/*! ./tile */ "./src/tile/tile.ts");
class Button extends tile_1.Tile {
    constructor(room, x, y, linkedDoor) {
        super(room, x, y);
        this.press = () => {
            this.pressed = true;
            this.linkedDoor.opened = true;
        };
        this.unpress = () => {
            this.pressed = false;
            this.linkedDoor.opened = false;
        };
        this.onCollide = (player) => {
            this.press();
        };
        this.onCollideEnemy = (enemy) => {
            this.press();
        };
        this.tickEnd = () => {
            this.unpress();
            for (const i in this.room.game.players) {
                if (this.room.game.players[i].x === this.x &&
                    this.room.game.players[i].y === this.y)
                    this.press();
            }
            for (const e of this.room.entities) {
                if (e.x === this.x && e.y === this.y)
                    this.press();
            }
        };
        this.draw = (delta) => {
            game_1.Game.drawTile(1, 0, 1, 1, this.x, this.y, 1, 1, this.room.shadeColor, this.shadeAmount());
            if (this.pressed)
                game_1.Game.drawTile(18, 0, 1, 1, this.x, this.y, this.w, this.h, this.room.shadeColor, this.shadeAmount());
            else
                game_1.Game.drawTile(17, 0, 1, 1, this.x, this.y, this.w, this.h, this.room.shadeColor, this.shadeAmount());
        };
        this.w = 1;
        this.h = 1;
        this.pressed = false;
        this.turnsSincePressed = 1;
        this.linkedDoor = linkedDoor;
    }
}
exports.Button = Button;


/***/ }),

/***/ "./src/tile/chasm.ts":
/*!***************************!*\
  !*** ./src/tile/chasm.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Chasm = void 0;
const game_1 = __webpack_require__(/*! ../game */ "./src/game.ts");
const tile_1 = __webpack_require__(/*! ./tile */ "./src/tile/tile.ts");
class Chasm extends tile_1.Tile {
    constructor(room, x, y, leftEdge, rightEdge, topEdge, bottomEdge) {
        super(room, x, y);
        this.isSolid = () => {
            return true;
        };
        this.canCrushEnemy = () => {
            return true;
        };
        this.draw = (delta) => {
            if (this.topEdge)
                game_1.Game.drawTile(22, 0, 1, 2, this.x, this.y, 1, 2, this.room.shadeColor, this.shadeAmount());
            game_1.Game.drawTile(this.tileX, this.tileY, 1, 1, this.x, this.y, 1, 1, this.room.shadeColor, this.shadeAmount());
        };
        this.tileX = this.skin === 1 ? 24 : 20;
        this.tileY = 1;
        if (leftEdge)
            this.tileX--;
        else if (rightEdge)
            this.tileX++;
        if (topEdge)
            this.tileY--;
        else if (bottomEdge)
            this.tileY++;
        this.topEdge = topEdge;
    }
}
exports.Chasm = Chasm;


/***/ }),

/***/ "./src/tile/decorations/decoration.ts":
/*!********************************************!*\
  !*** ./src/tile/decorations/decoration.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Decoration = void 0;
const drawable_1 = __webpack_require__(/*! ../../drawable/drawable */ "./src/drawable/drawable.ts");
const gameConstants_1 = __webpack_require__(/*! ../../game/gameConstants */ "./src/game/gameConstants.ts");
const game_1 = __webpack_require__(/*! ../../game */ "./src/game.ts");
class Decoration extends drawable_1.Drawable {
    constructor(room, x, y) {
        super();
        this.shadeAmount = (offsetX = 0, offsetY = 0) => {
            if (gameConstants_1.GameConstants.SMOOTH_LIGHTING)
                return 0;
            return this.room.softVis[this.x + offsetX][this.y + offsetY];
        };
        this.isSolid = () => {
            return false;
        };
        this.canCrushEnemy = () => {
            return false;
        };
        this.isOpaque = () => {
            return false;
        };
        this.onCollide = (player) => { };
        this.onCollideEnemy = (enemy) => { };
        this.tick = () => { };
        this.tickEnd = () => { };
        this.draw = (delta) => { };
        this.drawUnderPlayer = (delta) => {
            let tileY = 1;
            if (this.applySkin)
                tileY = this.skin;
            game_1.Game.drawTile(1, tileY, 1, 1, this.x, this.y, 1, 1, this.room.shadeColor, this.shadeAmount());
        };
        this.drawAbovePlayer = (delta) => { };
        this.drawAboveShading = (delta) => { };
        this.skin = room.skin;
        this.room = room;
        this.x = x;
        this.y = y;
        this.drawableY = y;
        this.isDoor = false;
        this.opacity = 1;
        this.applySkin = false;
    }
}
exports.Decoration = Decoration;


/***/ }),

/***/ "./src/tile/door.ts":
/*!**************************!*\
  !*** ./src/tile/door.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Door = exports.DoorType = exports.DoorDir = void 0;
const game_1 = __webpack_require__(/*! ../game */ "./src/game.ts");
const gameConstants_1 = __webpack_require__(/*! ../game/gameConstants */ "./src/game/gameConstants.ts");
const key_1 = __webpack_require__(/*! ../item/key */ "./src/item/key.ts");
const sound_1 = __webpack_require__(/*! ../sound/sound */ "./src/sound/sound.ts");
const lightSource_1 = __webpack_require__(/*! ../lighting/lightSource */ "./src/lighting/lightSource.ts");
const gameplaySettings_1 = __webpack_require__(/*! ../game/gameplaySettings */ "./src/game/gameplaySettings.ts");
const passageway_1 = __webpack_require__(/*! ./passageway */ "./src/tile/passageway.ts");
var DoorDir;
(function (DoorDir) {
    DoorDir["North"] = "North";
    DoorDir["East"] = "East";
    DoorDir["South"] = "South";
    DoorDir["West"] = "West";
})(DoorDir = exports.DoorDir || (exports.DoorDir = {}));
var DoorType;
(function (DoorType) {
    DoorType[DoorType["DOOR"] = 0] = "DOOR";
    DoorType[DoorType["LOCKEDDOOR"] = 1] = "LOCKEDDOOR";
    DoorType[DoorType["GUARDEDDOOR"] = 2] = "GUARDEDDOOR";
    DoorType[DoorType["TUNNELDOOR"] = 3] = "TUNNELDOOR";
})(DoorType = exports.DoorType || (exports.DoorType = {}));
class Door extends passageway_1.Passageway {
    constructor(room, game, x, y, doorDir, doorType) {
        super(room, game, x, y);
        this.shadeAmount = (offsetX = 0, offsetY = 0) => {
            if (gameConstants_1.GameConstants.SMOOTH_LIGHTING)
                return 0;
            const vis = this.room.softVis[this.x + offsetX][this.y + offsetY];
            if (this.opened)
                return vis / 2;
            else
                return vis;
        };
        this.openTunnelXOffset = () => {
            if (this.type === DoorType.TUNNELDOOR) {
                if (!this.opened) {
                    return 0;
                }
                else {
                    return -3;
                }
            }
            return 0;
        };
        this.guard = () => {
            this.type = DoorType.GUARDEDDOOR;
            this.locked = true;
            this.iconTileX = 9;
            this.iconXOffset = 1 / 32;
        };
        this.lock = () => {
            this.type = DoorType.LOCKEDDOOR;
            this.locked = true;
            this.iconTileX = 10;
            this.iconXOffset = 1 / 32;
        };
        this.removeLock = () => {
            if (this.type !== DoorType.TUNNELDOOR)
                this.type = DoorType.DOOR;
            this.locked = false;
        };
        this.removeLockIcon = () => {
            this.iconYOffset = 0;
            this.unlocking = false;
            this.iconTileX = 2;
            this.iconXOffset = 0;
            this.iconAlpha = 1;
        };
        this.canUnlock = (player) => {
            if (this.type === DoorType.LOCKEDDOOR) {
                let k = player.inventory.hasItem(key_1.Key);
                if (k !== null) {
                    if (k.doorID === this.lockable.keyID) {
                        this.game.pushMessage("You use the key to unlock the door.");
                        return true;
                    }
                    else {
                        this.game.pushMessage("The key doesn't fit the lock.");
                        return false;
                    }
                }
                else
                    this.game.pushMessage("The door is locked tightly and won't budge.");
                return false;
            }
            if (this.type === DoorType.GUARDEDDOOR) {
                this.room.checkForNoEnemies();
                this.game.pushMessage("There are still remaining foes guarding this door...");
                return false;
            }
            if (this.type === DoorType.TUNNELDOOR &&
                (!this.opened || !this.linkedDoor.opened)) {
                if (this.linkedDoor === this.room.level.exitRoom.tunnelDoor) {
                    this.game.pushMessage("The door refuses to budge from this side.");
                    return false;
                }
                else {
                    this.game.pushMessage("You clear the debris, revealing a narrow tunnel.");
                    return true;
                }
            }
            return true;
        };
        this.unlock = (player) => {
            if (this.type === DoorType.LOCKEDDOOR) {
                let k = player.inventory.hasItem(key_1.Key);
                if (k !== null) {
                    // remove key
                    player.inventory.removeItem(k);
                    sound_1.Sound.unlock();
                    this.removeLock();
                    this.unlocking = true;
                }
            }
            else if (this.type === DoorType.TUNNELDOOR) {
                this.locked = false;
                this.unlocking = true;
            }
        };
        this.unGuard = () => {
            if (this.type === DoorType.GUARDEDDOOR) {
                this.removeLock();
                sound_1.Sound.unlock();
                this.game.tutorialActive = false;
            }
            setTimeout(() => {
                this.removeLockIcon();
            }, 1000);
        };
        this.link = (other) => {
            this.linkedDoor = other;
        };
        this.isSolid = () => {
            if (this.locked) {
                return true;
            }
            else
                false;
        };
        this.canCrushEnemy = () => {
            return true;
        };
        this.onCollide = (player) => {
            if (!this.opened) {
                sound_1.Sound.doorOpen();
            }
            this.opened = true;
            this.linkedDoor.opened = true;
            if (this.doorDir === game_1.Direction.UP || this.doorDir === game_1.Direction.DOWN) {
                this.game.changeLevelThroughDoor(player, this.linkedDoor);
            }
            else
                this.game.changeLevelThroughDoor(player, this.linkedDoor, this.linkedDoor.room.roomX - this.room.roomX > 0 ? 1 : -1);
            this.linkedDoor.removeLock();
            this.linkedDoor.removeLockIcon();
            this.removeLockIcon();
        };
        this.draw = (delta) => {
            game_1.Game.ctx.save();
            if (this.doorDir === game_1.Direction.DOWN) {
                game_1.Game.drawTile(1, this.skin, 1, 1, this.x, this.y, 1, 1, this.room.shadeColor, this.shadeAmount());
            }
            if (this.doorDir === game_1.Direction.UP) {
                //if top door
                if (this.opened)
                    game_1.Game.drawTile(6 + this.tileXOffset + this.openTunnelXOffset(), this.skin, 1, 1, this.x, this.y, 1, 1, this.room.shadeColor, this.shadeAmount(0, 1));
                else
                    game_1.Game.drawTile(3 + this.tileXOffset + this.openTunnelXOffset(), this.skin, 1, 1, this.x, this.y, 1, 1, this.room.shadeColor, this.shadeAmount());
            }
            if (this.doorDir !== game_1.Direction.UP)
                //if not top door
                game_1.Game.drawTile(1, this.skin, 1, 1, this.x, this.y, 1, 1, this.room.shadeColor, this.shadeAmount());
            //the following used to be in the drawaboveplayer function
            if (this.doorDir === game_1.Direction.UP) {
                //if top door
                if (!this.drawTopOf)
                    return;
                if (!this.opened)
                    game_1.Game.drawTile(13, 0, 1, 1, this.x, this.y - 1, 1, 1, this.room.shadeColor, this.shadeAmount(0, 1));
                else
                    game_1.Game.drawTile(14, 0, 1, 1, this.x, this.y - 1, 1, 1, this.room.shadeColor, this.shadeAmount(0, 1));
            }
            game_1.Game.ctx.restore();
        };
        this.drawAbovePlayer = (delta) => { };
        this.drawAboveShading = (delta) => {
            //if (this.type === DoorType.TUNNELDOOR) return;
            this.updateFrame(delta);
            game_1.Game.ctx.globalAlpha = this.iconAlpha;
            let multiplier = 0.125;
            if (this.unlocking === true) {
                this.iconAlpha *= 0.92 ** delta;
                this.iconYOffset -= 0.035 * delta;
                multiplier = 0;
                if (this.iconAlpha <= 0.01) {
                    this.removeLockIcon();
                }
            }
            if (this.doorDir === game_1.Direction.UP) {
                //if top door
                game_1.Game.drawFX(this.iconTileX, 2, 1, 1, this.x + this.iconXOffset, this.y -
                    1.25 +
                    multiplier * Math.sin((this.frame * Math.PI) / 50) +
                    this.iconYOffset, 1, 1);
            }
            else {
                game_1.Game.drawFX(this.iconTileX, 2, 1, 1, this.x + this.iconXOffset, this.y -
                    1.25 +
                    multiplier * Math.sin((this.frame * Math.PI) / 50) +
                    this.iconYOffset, 1, 1); //if not top door
            }
            game_1.Game.ctx.globalAlpha = 1;
        };
        this.opened = false;
        this.doorDir = doorDir;
        this.locked = false;
        this.isDoor = true;
        this.type = doorType;
        this.iconTileX = 2;
        this.iconXOffset = 0;
        this.iconYOffset = 0;
        this.unlocking = false;
        this.iconAlpha = 1;
        this.tileXOffset = 0;
        this.tileX = 2;
        this.drawTopOf = true;
        let lightOffsetX = 0;
        let lightOffsetY = 0;
        this.alpha = 1;
        switch (this.doorDir) {
            case game_1.Direction.UP:
                lightOffsetY = -0.5;
            case game_1.Direction.DOWN:
                lightOffsetY = 0.5;
            case game_1.Direction.LEFT:
                lightOffsetX = -0.5;
            case game_1.Direction.RIGHT:
                lightOffsetX = 0.5;
        }
        this.lightSource = new lightSource_1.LightSource(x + 0.5, y + 0.5, 0, [0, 0, 0], 9);
        this.room.lightSources.push(this.lightSource);
        switch (this.type) {
            case DoorType.GUARDEDDOOR:
                if (gameplaySettings_1.GameplaySettings.NO_ENEMIES)
                    break;
                this.guard();
                break;
            case DoorType.LOCKEDDOOR:
                this.lock();
                break;
            case DoorType.DOOR:
                this.removeLock();
                break;
            case DoorType.TUNNELDOOR:
                // this.tileX = ? find the right tile for this
                this.locked = true;
                this.iconTileX = 10;
                this.iconXOffset = 1 / 32;
                this.tileXOffset = 12;
                this.drawTopOf = false;
                break;
        }
    }
}
exports.Door = Door;


/***/ }),

/***/ "./src/tile/downLadder.ts":
/*!********************************!*\
  !*** ./src/tile/downLadder.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DownLadder = void 0;
const game_1 = __webpack_require__(/*! ../game */ "./src/game.ts");
const gameConstants_1 = __webpack_require__(/*! ../game/gameConstants */ "./src/game/gameConstants.ts");
const upLadder_1 = __webpack_require__(/*! ./upLadder */ "./src/tile/upLadder.ts");
const events_1 = __webpack_require__(/*! ../event/events */ "./src/event/events.ts");
const eventBus_1 = __webpack_require__(/*! ../event/eventBus */ "./src/event/eventBus.ts");
const environmentTypes_1 = __webpack_require__(/*! ../constants/environmentTypes */ "./src/constants/environmentTypes.ts");
const lockable_1 = __webpack_require__(/*! ./lockable */ "./src/tile/lockable.ts");
const passageway_1 = __webpack_require__(/*! ./passageway */ "./src/tile/passageway.ts");
class DownLadder extends passageway_1.Passageway {
    constructor(room, game, x, y, isSidePath = false, environment = environmentTypes_1.EnvType.DUNGEON, lockType = lockable_1.LockType.NONE) {
        super(room, game, x, y);
        this.isSidePath = false;
        this.getName = () => {
            return this.isSidePath ? "rope down" : "staircase down";
        };
        this.generate = async () => {
            if (!this.linkedRoom) {
                const targetDepth = this.room.depth + (this.isSidePath ? 0 : 1);
                await this.game.levelgen.generate(this.game, targetDepth, this.isSidePath, this.handleLinkedRoom, this.environment);
            }
            else {
                console.log("LinkedRoom already exists:", this.linkedRoom);
            }
        };
        this.handleLinkedRoom = (linkedRoom) => {
            if (this.isSidePath) {
                this.handleSidePathRooms(linkedRoom);
            }
            this.linkedRoom = linkedRoom;
            this.linkUpLadder();
        };
        this.handleSidePathRooms = (linkedRoom) => {
            const targetDepth = this.room.depth;
            const level = linkedRoom.level;
            const sidePathRooms = this.game.rooms.filter((room) => room.mapGroup === linkedRoom.mapGroup);
            const startingId = level.rooms.length;
            sidePathRooms.forEach((room, index) => {
                room.id = startingId + index;
                level.rooms.push(room);
            });
        };
        this.linkUpLadder = () => {
            for (let x = this.linkedRoom.roomX; x < this.linkedRoom.roomX + this.linkedRoom.width; x++) {
                for (let y = this.linkedRoom.roomY; y < this.linkedRoom.roomY + this.linkedRoom.height; y++) {
                    let tile = this.linkedRoom.roomArray[x][y];
                    if (tile instanceof upLadder_1.UpLadder) {
                        this.setUpLadderLink(tile);
                        return; // Exit both loops
                    }
                }
            }
        };
        this.setUpLadderLink = (upLadder) => {
            if (this.isSidePath) {
                upLadder.linkedRoom = this.room;
            }
            else {
                upLadder.linkedRoom = this.game.levels[this.room.depth].exitRoom;
            }
        };
        this.onCollide = (player) => {
            let allPlayersHere = true;
            for (const i in this.game.players) {
                if (this.game.levels[this.game.players[i].depth].rooms[this.game.players[i].levelID] !== this.room ||
                    this.game.players[i].x !== this.x ||
                    this.game.players[i].y !== this.y) {
                    allPlayersHere = false;
                }
            }
            if (allPlayersHere) {
                eventBus_1.globalEventBus.emit(events_1.EVENTS.LEVEL_GENERATION_STARTED, {});
                this.generate().then(() => {
                    eventBus_1.globalEventBus.emit(events_1.EVENTS.LEVEL_GENERATION_COMPLETED, {});
                    for (const i in this.game.players) {
                        this.game.changeLevelThroughLadder(this.game.players[i], this);
                    }
                });
            }
            else {
                if (player === this.game.players[this.game.localPlayerID])
                    this.game.pushMessage("all players must be present");
            }
        };
        this.draw = (delta) => {
            let xx = 4;
            if (this.isSidePath) {
                xx = 16;
                if (this.lockable.isLocked())
                    xx = 17;
            }
            //if (this.environment === EnvType.FOREST) xx = 16;
            game_1.Game.drawTile(1, this.skin, 1, 1, this.x, this.y, 1, 1, this.room.shadeColor, this.shadeAmount());
            game_1.Game.drawTile(xx, this.skin, 1, 1, this.x, this.y, 1, 1, this.room.shadeColor, this.shadeAmount());
        };
        this.drawAboveShading = (delta) => {
            // Update lockable animation
            this.lockable.update(delta);
            // Draw lock icon
            this.lockable.drawIcon(this.x, this.y, delta);
            // Update frame using parent method
            this.updateFrame(delta);
        };
        this.drawAbovePlayer = (delta) => { };
        this.linkedRoom = null;
        this.depth = room.depth;
        this.isSidePath = isSidePath;
        this.environment = environment;
        const lock = isSidePath && !gameConstants_1.GameConstants.DEVELOPER_MODE
            ? lockable_1.LockType.LOCKED
            : lockable_1.LockType.NONE;
        // Initialize lockable with the passed lockType
        this.lockable = new lockable_1.Lockable(game, {
            lockType: lock,
            isTopDoor: false,
        });
        if (this.lockable.isLocked()) {
            console.log("adding key to downladder");
            this.game.levels[this.depth].distributeKey(this);
        }
        this.addLightSource();
    }
    isLocked() {
        return this.lockable.isLocked();
    }
}
exports.DownLadder = DownLadder;


/***/ }),

/***/ "./src/tile/floor.ts":
/*!***************************!*\
  !*** ./src/tile/floor.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Floor = void 0;
const game_1 = __webpack_require__(/*! ../game */ "./src/game.ts");
const tile_1 = __webpack_require__(/*! ./tile */ "./src/tile/tile.ts");
const random_1 = __webpack_require__(/*! ../utility/random */ "./src/utility/random.ts");
class Floor extends tile_1.Tile {
    constructor(room, x, y) {
        super(room, x, y);
        this.draw = (delta) => {
            game_1.Game.drawTile(this.variation, this.skin, 1, 1, this.x, this.y, 1, 1, this.room.shadeColor, this.shadeAmount());
        };
        this.variation = 1;
        if (this.skin == tile_1.SkinType.DUNGEON)
            this.variation = game_1.Game.randTable([1, 1, 1, 1, 1, 1, 8, 8, 8, 9, 10, 10, 10, 10, 10, 12], random_1.Random.rand);
        if (this.skin == tile_1.SkinType.CAVE)
            //this.variation = Game.randTable([1, 1, 1, 1, 8, 9, 10, 12], Random.rand);
            this.variation = game_1.Game.randTable([1, 1, 1, 1, 1, 1, 8, 8, 8, 9, 10, 10, 10, 10, 10, 12], random_1.Random.rand);
        if (this.skin == tile_1.SkinType.FOREST)
            //this.variation = Game.randTable([1, 1, 1, 1, 8, 9, 10, 12], Random.rand);
            this.variation = game_1.Game.randTable([1, 1, 1, 1, 1, 1, 8, 8, 8, 9, 10, 10, 10, 10, 10, 12], random_1.Random.rand);
    }
}
exports.Floor = Floor;


/***/ }),

/***/ "./src/tile/fountainTile.ts":
/*!**********************************!*\
  !*** ./src/tile/fountainTile.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FountainTile = void 0;
const game_1 = __webpack_require__(/*! ../game */ "./src/game.ts");
const tile_1 = __webpack_require__(/*! ./tile */ "./src/tile/tile.ts");
class FountainTile extends tile_1.Tile {
    constructor(room, x, y, subTileX, subTileY) {
        super(room, x, y);
        this.isSolid = () => {
            return true;
        };
        this.canCrushEnemy = () => {
            return true;
        };
        this.draw = (delta) => {
            game_1.Game.drawTile(1, this.skin, 1, 1, this.x, this.y, 1, 1, this.room.shadeColor, this.shadeAmount());
            game_1.Game.drawTile(this.subTileX, 2 + this.subTileY, 1, 1, this.x, this.y, 1, 1, this.room.shadeColor, this.shadeAmount());
        };
        this.subTileX = subTileX;
        this.subTileY = subTileY;
    }
}
exports.FountainTile = FountainTile;


/***/ }),

/***/ "./src/tile/insideLevelDoor.ts":
/*!*************************************!*\
  !*** ./src/tile/insideLevelDoor.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InsideLevelDoor = void 0;
const game_1 = __webpack_require__(/*! ../game */ "./src/game.ts");
const tile_1 = __webpack_require__(/*! ./tile */ "./src/tile/tile.ts");
class InsideLevelDoor extends tile_1.Tile {
    constructor(room, game, x, y) {
        super(room, x, y);
        this.isSolid = () => {
            return !this.opened;
        };
        this.canCrushEnemy = () => {
            return !this.opened;
        };
        this.isOpaque = () => {
            return !this.opened;
        };
        this.draw = (delta) => {
            game_1.Game.drawTile(1, 0, 1, 1, this.x, this.y, 1, 1, this.room.shadeColor, this.shadeAmount());
            if (this.opened)
                game_1.Game.drawTile(15, 1, 1, 1, this.x, this.y, 1, 1, this.room.shadeColor, this.shadeAmount());
            else
                game_1.Game.drawTile(3, this.skin, 1, 1, this.x, this.y, 1, 1, this.room.shadeColor, this.shadeAmount());
        };
        this.drawAbovePlayer = (delta) => {
            if (!this.opened)
                game_1.Game.drawTile(13, 0, 1, 1, this.x, this.y - 1, 1, 1, this.room.shadeColor, this.shadeAmount());
            else
                game_1.Game.drawTile(14, 0, 1, 1, this.x, this.y - 1, 1, 1, this.room.shadeColor, this.shadeAmount());
        };
        this.game = game;
        this.opened = false;
    }
}
exports.InsideLevelDoor = InsideLevelDoor;


/***/ }),

/***/ "./src/tile/lockable.ts":
/*!******************************!*\
  !*** ./src/tile/lockable.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Lockable = exports.LockType = void 0;
const game_1 = __webpack_require__(/*! ../game */ "./src/game.ts");
const key_1 = __webpack_require__(/*! ../item/key */ "./src/item/key.ts");
const sound_1 = __webpack_require__(/*! ../sound/sound */ "./src/sound/sound.ts");
const random_1 = __webpack_require__(/*! ../utility/random */ "./src/utility/random.ts");
var LockType;
(function (LockType) {
    LockType[LockType["NONE"] = 0] = "NONE";
    LockType[LockType["LOCKED"] = 1] = "LOCKED";
    LockType[LockType["GUARDED"] = 2] = "GUARDED";
    LockType[LockType["TUNNEL"] = 3] = "TUNNEL";
})(LockType = exports.LockType || (exports.LockType = {}));
class Lockable {
    constructor(game, config) {
        this.locked = false;
        this.unlocking = false;
        this.iconAlpha = 1;
        this.iconYOffset = 0;
        this.frame = 0;
        this.keyID = 0;
        this.game = game;
        this.lockType = config.lockType;
        this.keyID = config.keyID || 0;
        this.iconTileX = config.iconTileX || 2;
        this.iconXOffset = config.iconXOffset || 0;
        this.isTopDoor = config.isTopDoor || false;
        this.initializeLockState();
    }
    initializeLockState() {
        switch (this.lockType) {
            case LockType.LOCKED:
                this.lock();
                break;
            case LockType.GUARDED:
                this.guard();
                break;
            case LockType.TUNNEL:
                this.lock();
                this.iconTileX = 10;
                this.iconXOffset = 1 / 32;
                break;
            case LockType.NONE:
                this.removeLock();
                break;
        }
    }
    isLocked() {
        return this.locked;
    }
    isUnlocking() {
        return this.unlocking;
    }
    lock() {
        this.locked = true;
        this.iconTileX = 10;
        this.iconXOffset = 1 / 32;
    }
    guard() {
        this.lockType = LockType.GUARDED;
        this.locked = true;
        this.iconTileX = 9;
        this.iconXOffset = 1 / 32;
    }
    removeLock() {
        this.lockType = LockType.NONE;
        this.locked = false;
    }
    removeLockIcon() {
        this.iconYOffset = 0;
        this.unlocking = false;
        this.iconTileX = 2;
        this.iconXOffset = 0;
        this.iconAlpha = 1;
    }
    canUnlock(player) {
        if (this.lockType === LockType.LOCKED) {
            const key = this.hasKeyWithID(this.keyID, player);
            console.log(this.keyID);
            if (key !== null) {
                this.game.pushMessage("You use the key to unlock.");
                console.log("key.doorID", key.doorID, "lock.keyID", this.keyID);
                return true;
            }
            // If no matching key, check if player has any key at all
            const hasAnyKey = player.inventory.hasItem(key_1.Key);
            if (hasAnyKey) {
                this.game.pushMessage("The key doesn't fit the lock.");
            }
            else {
                this.game.pushMessage("It's locked tightly and won't budge.");
            }
            return false;
        }
        if (this.lockType === LockType.GUARDED) {
            // Check if room has no enemies - access through game.room
            const hasEnemies = this.game.room.entities.some((entity) => entity.constructor.name.includes("Enemy") && !entity.dead);
            if (hasEnemies) {
                this.game.pushMessage("There are still remaining foes guarding this...");
                return false;
            }
        }
        return true;
    }
    unlock(player) {
        if (this.lockType === LockType.LOCKED) {
            const key = this.hasKeyWithID(this.keyID, player);
            if (key !== null) {
                player.inventory.removeItem(key);
                sound_1.Sound.unlock();
                this.removeLock();
                this.unlocking = true;
            }
        }
        else if (this.lockType === LockType.TUNNEL) {
            this.locked = false;
            this.unlocking = true;
        }
    }
    hasKeyWithID(keyID, player) {
        const inventory = player.inventory;
        for (const item of inventory.items) {
            if (item instanceof key_1.Key) {
                if (item.doorID === keyID) {
                    return item;
                }
            }
        }
        return null;
    }
    unGuard() {
        if (this.lockType === LockType.GUARDED) {
            this.removeLock();
            sound_1.Sound.unlock();
            this.game.tutorialActive = false;
        }
        setTimeout(() => {
            this.removeLockIcon();
        }, 1000);
    }
    update(delta) {
        if (this.frame > 100)
            this.frame = 0;
        this.frame += 1 * delta;
    }
    drawIcon(x, y, delta) {
        game_1.Game.ctx.globalAlpha = this.iconAlpha;
        let multiplier = 0.125;
        if (this.unlocking) {
            this.iconAlpha *= 0.92 ** delta;
            this.iconYOffset -= 0.035 * delta;
            multiplier = 0;
            if (this.iconAlpha <= 0.01) {
                this.removeLockIcon();
            }
        }
        const iconY = this.isTopDoor ? y - 1.25 : y - 1.25;
        // Only draw the arrow if not unlocking and lockType is NONE
        if (this.lockType === LockType.NONE && !this.unlocking) {
            game_1.Game.drawFX(2, 2, 1, 1, x, y - 1.25 + multiplier * Math.sin((this.frame * Math.PI) / 50), 1, 1);
            return;
        }
        // Draw the lock icon (even when unlocking, to show the fade animation)
        game_1.Game.drawFX(this.iconTileX, 2, 1, 1, x + this.iconXOffset, iconY +
            multiplier * Math.sin((this.frame * Math.PI) / 50) +
            this.iconYOffset, 1, 1);
        game_1.Game.ctx.globalAlpha = 1;
    }
    setKey(key) {
        this.keyID = Lockable.generateID();
        key.doorID = this.keyID;
    }
    static generateID() {
        return Math.floor(random_1.Random.rand() * 1000000);
    }
}
exports.Lockable = Lockable;


/***/ }),

/***/ "./src/tile/passageway.ts":
/*!********************************!*\
  !*** ./src/tile/passageway.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Passageway = void 0;
const tile_1 = __webpack_require__(/*! ./tile */ "./src/tile/tile.ts");
const lightSource_1 = __webpack_require__(/*! ../lighting/lightSource */ "./src/lighting/lightSource.ts");
const environmentTypes_1 = __webpack_require__(/*! ../constants/environmentTypes */ "./src/constants/environmentTypes.ts");
class Passageway extends tile_1.Tile {
    constructor(room, game, x, y) {
        super(room, x, y);
        this.addLightSource = () => {
            if (this.environment === environmentTypes_1.EnvType.FOREST && !this.lockable.isLocked()) {
                this.lightSource = new lightSource_1.LightSource(this.x + 0.5, this.y + 0.5, 6, [0, 100, 100]);
                this.room.lightSources.push(this.lightSource);
            }
        };
        this.game = game;
        this.frame = 0;
        this.keyID = 0;
    }
    // Common frame animation logic
    updateFrame(delta) {
        if (this.frame > 100)
            this.frame = 0;
        this.frame += 1 * delta;
    }
    // Common floating animation calculation
    getFloatingOffset() {
        return 0.125 * Math.sin((this.frame * Math.PI) / 50);
    }
}
exports.Passageway = Passageway;


/***/ }),

/***/ "./src/tile/pool.ts":
/*!**************************!*\
  !*** ./src/tile/pool.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Pool = void 0;
const game_1 = __webpack_require__(/*! ../game */ "./src/game.ts");
const tile_1 = __webpack_require__(/*! ./tile */ "./src/tile/tile.ts");
const fishingSpot_1 = __webpack_require__(/*! ../entity/object/fishingSpot */ "./src/entity/object/fishingSpot.ts");
class Pool extends tile_1.Tile {
    constructor(room, x, y, leftEdge, rightEdge, topEdge, bottomEdge) {
        super(room, x, y);
        this.interact = () => {
            this.room.game.pushMessage("You jump into the pool.");
        };
        this.isSolid = () => {
            return true;
        };
        this.canCrushEnemy = () => {
            return true;
        };
        this.draw = (delta) => {
            if (this.topEdge)
                game_1.Game.drawTile(22, 3, 1, 2, this.x, this.y, 1, 2, this.room.shadeColor, this.shadeAmount());
            game_1.Game.drawTile(this.tileX, this.tileY, 1, 1, this.x, this.y, 1, 1, this.room.shadeColor, this.shadeAmount());
        };
        this.tileX = this.skin === 1 ? 24 : 20;
        this.tileY = 4;
        if (leftEdge)
            this.tileX--;
        else if (rightEdge)
            this.tileX++;
        if (topEdge)
            this.tileY--;
        else if (bottomEdge)
            this.tileY++;
        this.topEdge = topEdge;
        if (rightEdge || leftEdge || topEdge || bottomEdge) {
            this.room.entities.push(new fishingSpot_1.FishingSpot(this.room, this.room.game, this.x, this.y));
        }
    }
}
exports.Pool = Pool;


/***/ }),

/***/ "./src/tile/spawnfloor.ts":
/*!********************************!*\
  !*** ./src/tile/spawnfloor.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SpawnFloor = void 0;
const game_1 = __webpack_require__(/*! ../game */ "./src/game.ts");
const tile_1 = __webpack_require__(/*! ./tile */ "./src/tile/tile.ts");
const random_1 = __webpack_require__(/*! ../utility/random */ "./src/utility/random.ts");
class SpawnFloor extends tile_1.Tile {
    constructor(room, x, y) {
        super(room, x, y);
        this.draw = (delta) => {
            game_1.Game.drawTile(this.variation, this.skin, 1, 1, this.x, this.y, 1, 1, this.room.shadeColor, this.shadeAmount());
        };
        this.variation = 1;
        if (this.skin == tile_1.SkinType.DUNGEON)
            this.variation = game_1.Game.randTable([1, 1, 1, 1, 1, 1, 8, 8, 8, 9, 10, 10, 10, 10, 10, 12], random_1.Random.rand);
        if (this.skin == tile_1.SkinType.CAVE)
            //this.variation = Game.randTable([1, 1, 1, 1, 8, 9, 10, 12], Random.rand);
            this.variation = game_1.Game.randTable([1, 1, 1, 1, 1, 1, 8, 8, 8, 9, 10, 10, 10, 10, 10, 12], random_1.Random.rand);
    }
}
exports.SpawnFloor = SpawnFloor;


/***/ }),

/***/ "./src/tile/spiketrap.ts":
/*!*******************************!*\
  !*** ./src/tile/spiketrap.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SpikeTrap = void 0;
const game_1 = __webpack_require__(/*! ../game */ "./src/game.ts");
const tile_1 = __webpack_require__(/*! ./tile */ "./src/tile/tile.ts");
const crate_1 = __webpack_require__(/*! ../entity/object/crate */ "./src/entity/object/crate.ts");
const barrel_1 = __webpack_require__(/*! ../entity/object/barrel */ "./src/entity/object/barrel.ts");
const hitWarning_1 = __webpack_require__(/*! ../drawable/hitWarning */ "./src/drawable/hitWarning.ts");
class SpikeTrap extends tile_1.Tile {
    constructor(room, x, y, tickCount) {
        super(room, x, y);
        this.tick = () => {
            this.tickCount++;
            if (this.tickCount >= 4)
                this.tickCount = 0;
            this.on = this.tickCount === 0;
            if (this.on) {
                for (const i in this.room.game.players) {
                    if (this.room ===
                        this.room.game.rooms[this.room.game.players[i].levelID] &&
                        this.room.game.players[i].x === this.x &&
                        this.room.game.players[i].y === this.y)
                        this.room.game.players[i].hurt(0.5, "spike trap");
                }
            }
            if (this.tickCount === 3)
                this.room.hitwarnings.push(new hitWarning_1.HitWarning(this.room.game, this.x, this.y, this.x, this.y, false));
        };
        this.tickEnd = () => {
            if (this.on) {
                for (const e of this.room.entities) {
                    if (e.x === this.x && e.y === this.y) {
                        e.hurt(null, 1);
                    }
                }
            }
        };
        this.onCollideEnemy = (enemy) => {
            if (this.on && !(enemy instanceof crate_1.Crate || enemy instanceof barrel_1.Barrel))
                enemy.hurt(null, 1);
        };
        this.draw = (delta) => {
            this.drawableY = this.y - 0.01;
            game_1.Game.drawTile(1, this.skin, 1, 1, this.x, this.y, 1, 1, this.room.shadeColor, this.shadeAmount());
            let rumbleOffsetX = 0;
            this.t += delta;
            if (!this.on && this.tickCount === 3) {
                if (Math.floor(this.t) % 4 === 1)
                    rumbleOffsetX = 0.0325;
                if (Math.floor(this.t) % 4 === 3)
                    rumbleOffsetX = -0.0325;
            }
            let frames = [0, 1, 2, 3, 3, 4, 2, 0];
            let f = 6 + frames[Math.floor(this.frame)];
            if (this.tickCount === 1 ||
                (this.tickCount === 0 && frames[Math.floor(this.frame)] === 0)) {
                f = 5;
            }
            game_1.Game.drawObj(f, 0, 1, 2, this.x + rumbleOffsetX, this.y - 1, 1, 2, this.room.shadeColor, this.shadeAmount());
            if (this.on && this.frame < frames.length - 1) {
                if (frames[Math.floor(this.frame)] < 3)
                    this.frame += 0.4 * delta;
                else
                    this.frame += 0.2 * delta;
            }
            if (!this.on)
                this.frame = 0;
        };
        if (tickCount)
            this.tickCount = tickCount;
        else
            this.tickCount = 0;
        this.on = false;
        this.frame = 0;
        this.t = 0;
        this.name = "spike trap";
    }
}
exports.SpikeTrap = SpikeTrap;


/***/ }),

/***/ "./src/tile/tile.ts":
/*!**************************!*\
  !*** ./src/tile/tile.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Tile = exports.SkinType = void 0;
const drawable_1 = __webpack_require__(/*! ../drawable/drawable */ "./src/drawable/drawable.ts");
const gameConstants_1 = __webpack_require__(/*! ../game/gameConstants */ "./src/game/gameConstants.ts");
const IdGenerator_1 = __webpack_require__(/*! ../globalStateManager/IdGenerator */ "./src/globalStateManager/IdGenerator.ts");
var SkinType;
(function (SkinType) {
    SkinType[SkinType["DUNGEON"] = 0] = "DUNGEON";
    SkinType[SkinType["CAVE"] = 1] = "CAVE";
    SkinType[SkinType["FOREST"] = 2] = "FOREST";
    SkinType[SkinType["CASTLE"] = 3] = "CASTLE";
    SkinType[SkinType["GLACIER"] = 4] = "GLACIER";
    SkinType[SkinType["SWAMP"] = 5] = "SWAMP";
})(SkinType = exports.SkinType || (exports.SkinType = {}));
class Tile extends drawable_1.Drawable {
    constructor(room, x, y) {
        super();
        this.name = "";
        this.getName = () => {
            return this.name;
        };
        this.hasPlayer = (player) => {
            if (player.x === this.x && player.y === this.y)
                return true;
            else
                return false;
        };
        this.shadeAmount = (offsetX = 0, offsetY = 0) => {
            if (gameConstants_1.GameConstants.SMOOTH_LIGHTING)
                return 0;
            return this.room.softVis[this.x + offsetX][this.y + offsetY];
        };
        this.isSolid = () => {
            return false;
        };
        this.canCrushEnemy = () => {
            return false;
        };
        this.isOpaque = () => {
            return false;
        };
        this.onCollide = (player) => { };
        this.onCollideEnemy = (enemy) => { };
        this.tick = () => { };
        this.tickEnd = () => { };
        this.draw = (delta) => { };
        this.drawUnderPlayer = (delta) => { };
        this.drawAbovePlayer = (delta) => { };
        this.drawAboveShading = (delta) => { };
        this.globalId = IdGenerator_1.IdGenerator.generate("T");
        this.skin = room.skin;
        this.room = room;
        this.x = x;
        this.y = y;
        this.drawableY = y;
        this.isDoor = false;
        this.opacity = 1;
    }
}
exports.Tile = Tile;


/***/ }),

/***/ "./src/tile/trapdoor.ts":
/*!******************************!*\
  !*** ./src/tile/trapdoor.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Trapdoor = void 0;
const game_1 = __webpack_require__(/*! ../game */ "./src/game.ts");
const tile_1 = __webpack_require__(/*! ./tile */ "./src/tile/tile.ts");
class Trapdoor extends tile_1.Tile {
    constructor(room, game, x, y) {
        super(room, x, y);
        this.draw = (delta) => {
            game_1.Game.drawTile(13, this.skin, 1, 1, this.x, this.y, 1, 1, this.room.shadeColor, this.shadeAmount());
        };
        this.onCollide = (player) => {
            // TODO
        };
        this.game = game;
    }
}
exports.Trapdoor = Trapdoor;


/***/ }),

/***/ "./src/tile/upLadder.ts":
/*!******************************!*\
  !*** ./src/tile/upLadder.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UpLadder = void 0;
const game_1 = __webpack_require__(/*! ../game */ "./src/game.ts");
const sound_1 = __webpack_require__(/*! ../sound/sound */ "./src/sound/sound.ts");
const lockable_1 = __webpack_require__(/*! ./lockable */ "./src/tile/lockable.ts");
const passageway_1 = __webpack_require__(/*! ./passageway */ "./src/tile/passageway.ts");
class UpLadder extends passageway_1.Passageway {
    constructor(room, game, x, y, lockType = lockable_1.LockType.NONE) {
        super(room, game, x, y);
        this.isRope = false;
        this.onCollide = (player) => {
            if (!this.game) {
                console.error("Game instance is undefined in UpLadder:", this);
                return;
            }
            // Check if locked
            if (this.lockable.isLocked()) {
                if (this.lockable.canUnlock(player)) {
                    this.lockable.unlock(player);
                }
                return;
            }
            try {
                if (!this.linkedRoom) {
                    this.linkRoom();
                }
                this.game.changeLevelThroughLadder(player, this);
                sound_1.Sound.forestMusic.pause();
                sound_1.Sound.caveMusic.pause();
            }
            catch (error) {
                console.error("Error during changeLevelThroughLadder:", error);
            }
        };
        this.getName = () => {
            return this.isRope ? "rope up" : "staircase up";
        };
        this.linkRoom = () => {
            this.linkedRoom = this.game.levels[this.depth - 1].exitRoom;
        };
        this.draw = (delta) => {
            let xx = 29;
            let yy = 0;
            if (this.isRope) {
                xx = 16;
                yy = 1;
            }
            game_1.Game.drawTile(1, this.skin, 1, 1, this.x, this.y, 1, 1, this.room.shadeColor, this.shadeAmount());
            if (!this.isRope) {
                game_1.Game.drawTile(xx, yy, 1, 1, this.x, this.y - 1, 1, 1, this.room.shadeColor, this.shadeAmount());
            }
            else {
                game_1.Game.drawTile(xx, yy + 0, 1, 2, this.x, this.y - 1, 1, 2, this.room.shadeColor, this.shadeAmount());
            }
            game_1.Game.drawTile(xx, yy + 1, 1, 1, this.x, this.y, 1, 1, this.room.shadeColor, this.shadeAmount());
        };
        this.drawAboveShading = (delta) => {
            // Update lockable animation
            this.lockable.update(delta);
            // Draw lock icon
            this.lockable.drawIcon(this.x, this.y, delta);
            // Original floating animation
            if (this.frame > 100)
                this.frame = 0;
            this.frame += 1 * delta;
            let multiplier = 0.125;
            game_1.Game.drawFX(2, 2, 1, 1, this.x, this.y - 1.25 + multiplier * Math.sin((this.frame * Math.PI) / 50), 1, 1);
        };
        this.drawAbovePlayer = (delta) => {
            if (this.isRope)
                game_1.Game.drawTile(16, 1, 1, 1, this.x, this.y - 1, 1, 1, this.room.shadeColor, this.shadeAmount());
        };
        this.depth = room.depth;
        // Initialize lockable with default config
        this.lockable = new lockable_1.Lockable(game, {
            lockType: lockType,
            isTopDoor: true,
        });
    }
    isLocked() {
        return this.lockable.isLocked();
    }
}
exports.UpLadder = UpLadder;


/***/ }),

/***/ "./src/tile/wall.ts":
/*!**************************!*\
  !*** ./src/tile/wall.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Wall = void 0;
const game_1 = __webpack_require__(/*! ../game */ "./src/game.ts");
const tile_1 = __webpack_require__(/*! ./tile */ "./src/tile/tile.ts");
class Wall extends tile_1.Tile {
    constructor(room, x, y, wallDirections) {
        super(room, x, y);
        this.isSolid = () => {
            return true;
        };
        this.canCrushEnemy = () => {
            return true;
        };
        this.isOpaque = () => {
            const wallInfo = this.wallInfo();
            if (!wallInfo)
                return false;
            return ((!wallInfo.isTopWall && !wallInfo.isInnerWall) ||
                wallInfo.isLeftWall ||
                wallInfo.isRightWall);
        };
        this.isInnerWall = () => {
            const wallInfo = this.wallInfo();
            return wallInfo?.isInnerWall || false;
        };
        this.wallInfo = () => {
            return this.room.wallInfo.get(`${this.x},${this.y}`);
        };
        this.draw = (delta) => {
            this.drawWall(delta);
        };
        this.drawWall = (delta) => {
            const wallInfo = this.room.wallInfo.get(`${this.x},${this.y}`);
            if (!wallInfo)
                return;
            // Set tileYOffset based on inner wall type
            this.tileXOffset =
                wallInfo.innerWallType === "bottomInner" ||
                    wallInfo.innerWallType === "surroundedInner"
                    ? 0
                    : 26;
            // Only draw the bottom part of the wall if it's not at the bottom edge of the room
            if (wallInfo.isDoorWall ||
                wallInfo.isBelowDoorWall ||
                (wallInfo.isTopWall && !wallInfo.isLeftWall && !wallInfo.isRightWall) ||
                wallInfo.isInnerWall)
                game_1.Game.drawTile(0, this.skin, 1, 1, this.x, this.y, 1, 1, this.room.shadeColor, this.shadeAmount());
            game_1.Game.drawTile(2 + this.tileXOffset, this.skin, 1, 1, this.x, this.y - 1, 1, 1, this.room.shadeColor, this.shadeAmount());
        };
        this.drawTopLayer = (delta) => {
            const wallInfo = this.room.wallInfo.get(`${this.x},${this.y}`);
            if (!wallInfo)
                return;
            if (wallInfo.isBottomWall ||
                wallInfo.isBelowDoorWall ||
                wallInfo.isAboveDoorWall) {
                game_1.Game.drawTile(2 + this.tileXOffset, this.skin, 1, 1, this.x, this.y - 1, 1, 1, this.room.shadeColor, this.shadeAmount());
            }
        };
        this.isDoor = false;
        this.tileXOffset = 6;
        this.wallDirections = wallDirections || [];
        this.opacity = 1;
    }
    get direction() {
        let directions = [];
        if (this.room.roomArray[this.x - 1][this.y] == null)
            directions.push(game_1.Direction.LEFT);
        if (this.room.roomArray[this.x + 1][this.y] == null)
            directions.push(game_1.Direction.RIGHT);
        if (this.room.roomArray[this.x][this.y - 1] == null)
            directions.push(game_1.Direction.DOWN);
        if (this.room.roomArray[this.x][this.y + 1] == null)
            directions.push(game_1.Direction.UP);
        if (directions.length == 1)
            return directions[0];
        if (directions.includes(game_1.Direction.UP) &&
            directions.includes(game_1.Direction.LEFT)) {
            this.opacity = 0.5;
            return game_1.Direction.UP_LEFT;
        }
        if (directions.includes(game_1.Direction.UP) &&
            directions.includes(game_1.Direction.RIGHT)) {
            this.opacity = 0.5;
            return game_1.Direction.UP_RIGHT;
        }
        if (directions.includes(game_1.Direction.DOWN) &&
            directions.includes(game_1.Direction.LEFT)) {
            this.opacity = 0.5;
            return game_1.Direction.DOWN_LEFT;
        }
        return game_1.Direction.DOWN_RIGHT;
    }
}
exports.Wall = Wall;


/***/ }),

/***/ "./src/tile/wallTorch.ts":
/*!*******************************!*\
  !*** ./src/tile/wallTorch.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WallTorch = void 0;
const game_1 = __webpack_require__(/*! ../game */ "./src/game.ts");
const lightSource_1 = __webpack_require__(/*! ../lighting/lightSource */ "./src/lighting/lightSource.ts");
const levelConstants_1 = __webpack_require__(/*! ../level/levelConstants */ "./src/level/levelConstants.ts");
const wall_1 = __webpack_require__(/*! ./wall */ "./src/tile/wall.ts");
const random_1 = __webpack_require__(/*! ../utility/random */ "./src/utility/random.ts");
class WallTorch extends wall_1.Wall {
    constructor(room, x, y, isBottomWall) {
        super(room, x, y);
        this.isSolid = () => {
            return true;
        };
        this.canCrushEnemy = () => {
            return true;
        };
        this.isOpaque = () => {
            const wallInfo = this.room.wallInfo.get(`${this.x},${this.y}`);
            if (!wallInfo)
                return true;
            return ((!wallInfo.isTopWall && !wallInfo.isInnerWall) ||
                wallInfo.isLeftWall ||
                wallInfo.isRightWall);
        };
        this.draw = (delta) => {
            this.drawWall(delta);
            const wallInfo = this.room.wallInfo.get(`${this.x},${this.y}`);
            if (!wallInfo)
                this.tileYOffset = 6;
            this.frame += 0.3 * delta;
            if (this.frame >= 12)
                this.frame = 0;
            this.tileYOffset =
                wallInfo.innerWallType === "bottomInner" ||
                    wallInfo.innerWallType === "surroundedInner"
                    ? 0
                    : 6;
            if (!this.isBottomWall) {
                game_1.Game.drawTile(0, this.skin, 1, 1, this.x, this.y, 1, 1, this.room.shadeColor, this.shadeAmount());
            }
            game_1.Game.drawFX(Math.floor(this.frame), 32, 1, 2, this.x, this.y - 1 - this.torchOffset, 1, 2);
            if (this.isBottomWall) {
                game_1.Game.drawTile(0, this.skin, 1, 1, this.x, this.y - 0.6, 1, 1, this.room.shadeColor, this.shadeAmount());
            }
        };
        this.isBottomWall = isBottomWall;
        this.torchOffset = isBottomWall ? 1 : 0;
        this.room.lightSources.push(new lightSource_1.LightSource(this.x + 0.5, this.y + 0.5 - this.torchOffset, 5, levelConstants_1.LevelConstants.TORCH_LIGHT_COLOR, 1.5));
        this.frame = random_1.Random.rand() * 12;
        this.tileYOffset = 6;
        this.hasBloom = true;
        this.bloomColor = "#FFA500";
        this.bloomAlpha = 1;
        this.softBloomAlpha = 0;
    }
}
exports.WallTorch = WallTorch;


/***/ }),

/***/ "./src/tips.ts":
/*!*********************!*\
  !*** ./src/tips.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Tips = void 0;
const random_1 = __webpack_require__(/*! ./utility/random */ "./src/utility/random.ts");
const tips = [
    "Too dark? Equip a light source to light up the area around you.",
    "Red X's show dangerous tiles, stay off of them to avoid taking damage.",
    "If you kill an enemy, it can't hit you on the next turn.",
    "Use weapon fragments on your weapon to repair broken weapons.",
    "A yellow box around an item means it can be used on another item.",
    "Lanterns can be refueled with coal.",
    "Some objects can be pushed and kill enemies by crushing them.",
    "Reapers spawn other enemies. Target them first to avoid being overrun.",
    "Occultists apply a purple occult shield to enemies, giving them an extra health.",
    "Killing an Occultist also removes the shields of each shielded enemy.",
    "Some enemies have helmets, giving them extra health.",
    "The shield absorbs one damage, and regenerates within 15 turns.",
    "Explore alternate pathways like caves to gather resources to prepare for tough battles.",
    "Vending machine sell useful items in exchange for coins.",
    "Different enemies have different movement and attack patterns.",
    "Frogs can only deal half damage, but can attack two tiles away in any direction.",
    "Sometimes you will need to switch weapons mid-fight to use the best one for the situation.",
    "Once you reach the end of a level you can get back to the beginning easily through tunnel doors.",
    "Dual daggers give you an extra turn. After attacking you can attack or move again.",
    "The Warhammer does two damage for taking out enemies with more than one health.",
    "The spear has an attack range of two, so you can hit enemies from a safe distance.",
    "Bombs can be placed to blow up enemies, just be sure to avoid blowing yourself up.",
    "Mushrooms heal one half health.",
    "Weapon blood can be applied to your weapon, giving it a powerful bleed effect upon attacking.",
    "Weapon poison can be applied to your weapon poisoning enemies upon attacking.",
    "The spellbook can attack multiple enemies from long range, great for getting out of tough situations.",
    "Bishops can move diagonally and might sneak up on you if you aren't careful.",
    "Rooks can move every turn and attack from any direction.",
    "Queens can move any direction and have two health, but retreat when hit.",
    "Dark? Equip light source.",
    "Red X = danger. Avoid.",
    "Kill enemy = safe next turn.",
    "Use fragments to repair weapons.",
    "Yellow box = usable on items.",
    "Coal refuels lanterns.",
    "Push objects to crush enemies.",
    "Kill reapers first - they spawn enemies.",
    "Occultists give enemies purple shields.",
    "Kill occultist = remove all shields.",
    "Helmets = extra enemy health.",
    "Shield: 1 damage, regens in 15 turns.",
    "Explore caves for resources.",
    "Vending machines: coins for items.",
    "Enemies have unique patterns.",
    "Frogs: half damage, 2-tile range.",
    "Switch weapons mid-fight.",
    "Tunnel doors = quick return to start.",
    "Dual daggers = extra turn after attack.",
    "Warhammer: 2 damage vs multi-health.",
    "Spear: 2-tile range.",
    "Bombs blow up enemies (not you).",
    "Mushrooms: heal 0.5 health.",
    "Weapon blood = bleed effect.",
    "Weapon poison = poison effect.",
    "Spellbook: multi-enemy, long range.",
    "Bishops: diagonal movement.",
    "Rooks: move every turn, any direction.",
    "Queens: 2 health, retreat when hit.",
];
class Tips {
    static getRandomTip() {
        return tips[Math.floor(random_1.Random.rand() * tips.length)];
    }
}
exports.Tips = Tips;


/***/ }),

/***/ "./src/utility/astarclass.ts":
/*!***********************************!*\
  !*** ./src/utility/astarclass.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.astar = void 0;
const game_1 = __webpack_require__(/*! ../game */ "./src/game.ts");
const downLadder_1 = __webpack_require__(/*! ../tile/downLadder */ "./src/tile/downLadder.ts");
const random_1 = __webpack_require__(/*! ./random */ "./src/utility/random.ts");
var astar;
(function (astar_1) {
    //================== start graph js
    /*
    graph.js http://github.com/bgrins/javascript-astar
    MIT License
    Creates a Graph class used in the astar search algorithm.
    Includes Binary Heap (with modifications) from Marijn Haverbeke
        URL: http://eloquentjavascript.net/appendix2.html
        License: http://creativecommons.org/licenses/by/3.0/
    */
    let GraphNodeType;
    (function (GraphNodeType) {
        GraphNodeType[GraphNodeType["WALL"] = 0] = "WALL";
        GraphNodeType[GraphNodeType["OPEN"] = 1] = "OPEN";
    })(GraphNodeType = astar_1.GraphNodeType || (astar_1.GraphNodeType = {}));
    let getTileCost = (tile) => {
        if (tile)
            return tile.isSolid() || tile.isDoor || tile instanceof downLadder_1.DownLadder
                ? 99999999
                : 300;
        else
            return 99999999;
    };
    class Graph {
        constructor(grid) {
            this.elements = grid;
            var nodes = [];
            var row, rowLength, len = grid.length;
            for (var x = 0; x < len; ++x) {
                row = grid[x];
                rowLength = row.length;
                nodes[x] = new Array(rowLength); // optimum array with size
                for (var y = 0; y < rowLength; ++y) {
                    nodes[x][y] = new GraphNode(x, y, row[y]);
                }
            }
            this.nodes = nodes;
        }
        toString() {
            var graphString = "\n";
            var nodes = this.nodes;
            var rowDebug, row, y, l;
            for (var x = 0, len = nodes.length; x < len;) {
                rowDebug = "";
                row = nodes[x++];
                for (y = 0, l = row.length; y < l;) {
                    rowDebug += row[y++].type + " ";
                }
                graphString = graphString + rowDebug + "\n";
            }
            return graphString;
        }
    }
    astar_1.Graph = Graph;
    class GraphNode {
        constructor(x, y, type) {
            this.data = {};
            this.x = x;
            this.y = y;
            this.pos = { x: x, y: y };
            this.type = type;
        }
        toString() {
            return "[" + this.x + " " + this.y + "]";
        }
        isWall() {
            return this.type == GraphNodeType.WALL;
        }
    }
    astar_1.GraphNode = GraphNode;
    class BinaryHeap {
        constructor(scoreFunction) {
            this.content = [];
            this.scoreFunction = scoreFunction;
        }
        push(node) {
            // Add the new node to the end of the array.
            this.content.push(node);
            // Allow it to sink down.
            this.sinkDown(this.content.length - 1);
        }
        pop() {
            // Store the first node so we can return it later.
            var result = this.content[0];
            // Get the node at the end of the array.
            var end = this.content.pop();
            // If there are any elements left, put the end node at the
            // start, and let it bubble up.
            if (this.content.length > 0) {
                this.content[0] = end;
                this.bubbleUp(0);
            }
            return result;
        }
        remove(node) {
            var i = this.content.indexOf(node);
            // When it is found, the process seen in 'pop' is repeated
            // to fill up the hole.
            var end = this.content.pop();
            if (i !== this.content.length - 1) {
                this.content[i] = end;
                if (this.scoreFunction(end) < this.scoreFunction(node))
                    this.sinkDown(i);
                else
                    this.bubbleUp(i);
            }
        }
        size() {
            return this.content.length;
        }
        rescoreElement(node) {
            this.sinkDown(this.content.indexOf(node));
        }
        sinkDown(n) {
            // Fetch the element that has to be sunk.
            var element = this.content[n];
            // When at 0, an element can not sink any further.
            while (n > 0) {
                // Compute the parent element's index, and fetch it.
                var parentN = ((n + 1) >> 1) - 1, parent = this.content[parentN];
                // Swap the elements if the parent is greater.
                if (this.scoreFunction(element) < this.scoreFunction(parent)) {
                    this.content[parentN] = element;
                    this.content[n] = parent;
                    // Update 'n' to continue at the new position.
                    n = parentN;
                }
                else {
                    // Found a parent that is less, no need to sink any further.
                    break;
                }
            }
        }
        bubbleUp(n) {
            // Look up the target element and its score.
            var length = this.content.length, element = this.content[n], elemScore = this.scoreFunction(element);
            while (true) {
                // Compute the indices of the child elements.
                var child2N = (n + 1) << 1, child1N = child2N - 1;
                // This is used to store the new position of the element,
                // if any.
                var swap = null;
                // If the first child exists (is inside the array)...
                if (child1N < length) {
                    // Look it up and compute its score.
                    var child1 = this.content[child1N], child1Score = this.scoreFunction(child1);
                    // If the score is less than our element's, we need to swap.
                    if (child1Score < elemScore)
                        swap = child1N;
                }
                // Do the same checks for the other child.
                if (child2N < length) {
                    var child2 = this.content[child2N], child2Score = this.scoreFunction(child2);
                    if (child2Score < (swap === null ? elemScore : child1Score))
                        swap = child2N;
                }
                // If the element needs to be moved, swap it, and continue.
                if (swap !== null) {
                    this.content[n] = this.content[swap];
                    this.content[swap] = element;
                    n = swap;
                }
                else {
                    // Otherwise, we are done.
                    break;
                }
            }
        }
    }
    astar_1.BinaryHeap = BinaryHeap;
    class AStar {
        constructor(grid, disablePoints, lastPlayerPosition, enableCost) {
            this.grid = [];
            for (var x = 0, xl = grid.length; x < xl; x++) {
                this.grid[x] = [];
                for (var y = 0, yl = grid[x].length; y < yl; y++) {
                    var cost = getTileCost(grid[x][y]);
                    this.grid[x][y] = {
                        org: grid[x][y],
                        f: 0,
                        g: 0,
                        h: 0,
                        cost: cost,
                        visited: false,
                        closed: false,
                        pos: {
                            x: x,
                            y: y,
                        },
                        parent: null,
                    };
                }
            }
            if (disablePoints !== undefined) {
                for (var i = 0; i < disablePoints.length; i++) {
                    if (disablePoints[i].x >= 0 &&
                        disablePoints[i].x < this.grid.length &&
                        disablePoints[i].y >= 0 &&
                        disablePoints[i].y < this.grid[0].length)
                        this.grid[disablePoints[i].x][disablePoints[i].y].cost = 99999999;
                }
            }
            if (lastPlayerPosition) {
                if (lastPlayerPosition.x >= 0 &&
                    lastPlayerPosition.x < this.grid.length &&
                    lastPlayerPosition.y >= 0 &&
                    lastPlayerPosition.y < this.grid[0].length)
                    this.grid[lastPlayerPosition.x][lastPlayerPosition.y].cost = 0.5;
            }
        }
        heap() {
            return new BinaryHeap(function (node) {
                return node.f;
            });
        }
        _find(org) {
            for (var x = 0; x < this.grid.length; x++)
                for (var y = 0; y < this.grid[x].length; y++)
                    if (this.grid[x][y].org == org)
                        return this.grid[x][y];
        }
        _search(start, end, diagonal, diagonalsOnly, turnCostsExtra, turnDirection, heuristic, diagonalsOmni, lastPlayerPosition) {
            heuristic = heuristic || this.manhattan;
            diagonal = !!diagonal;
            diagonalsOnly = !!diagonalsOnly;
            turnCostsExtra = !!turnCostsExtra;
            diagonalsOmni = !!diagonalsOmni;
            var openHeap = this.heap();
            var _start, _end;
            if (start.x !== undefined && start.y !== undefined)
                _start = this.grid[start.x][start.y];
            else
                _start = this._find(start);
            if (end.x !== undefined && end.y !== undefined)
                _end = this.grid[end.x][end.y];
            else
                _end = this._find(end);
            if (AStar.NO_CHECK_START_POINT == false && _start.cost <= 0)
                return [];
            openHeap.push(_start);
            while (openHeap.size() > 0) {
                // Grab the lowest f(x) to process next.  Heap keeps this sorted for us.
                var currentNode = openHeap.pop();
                // End case -- result has been found, return the traced path.
                if (currentNode === _end) {
                    var curr = currentNode;
                    var ret = [];
                    while (curr.parent) {
                        ret.push(curr);
                        curr = curr.parent;
                    }
                    return ret.reverse();
                }
                // Normal case -- move currentNode from open to closed, process each of its neighbors.
                currentNode.closed = true;
                // Find all neighbors for the current node. Optionally find diagonal neighbors as well (false by default).
                var neighbors = this.neighbors(currentNode, diagonal, diagonalsOnly, diagonalsOmni);
                for (var i = 0, il = neighbors.length; i < il; i++) {
                    var neighbor = neighbors[i];
                    if (neighbor.closed || neighbor.cost <= 0) {
                        // Not a valid node to process, skip to next neighbor.
                        continue;
                    }
                    // The g score is the shortest distance from start to current node.
                    // We need to check if the path we have arrived at this neighbor is the shortest one we have seen yet.
                    var gScore = currentNode.g + neighbor.cost;
                    if (turnCostsExtra) {
                        var isTurn = false;
                        if (currentNode.parent)
                            isTurn = !((currentNode.parent.pos.x === currentNode.pos.x &&
                                currentNode.pos.x === neighbor.pos.x) ||
                                (currentNode.parent.pos.y === currentNode.pos.y &&
                                    currentNode.pos.y === neighbor.pos.y));
                        else {
                            // initial step
                            isTurn = true;
                            if (neighbor.pos.x - currentNode.pos.x === 0 &&
                                neighbor.pos.y - currentNode.pos.y === -1 &&
                                turnDirection === game_1.Direction.UP)
                                isTurn = false;
                            if (neighbor.pos.x - currentNode.pos.x === 0 &&
                                neighbor.pos.y - currentNode.pos.y === 1 &&
                                turnDirection === game_1.Direction.DOWN)
                                isTurn = false;
                            if (neighbor.pos.x - currentNode.pos.x === 1 &&
                                neighbor.pos.y - currentNode.pos.y === 0 &&
                                turnDirection === game_1.Direction.RIGHT)
                                isTurn = false;
                            if (neighbor.pos.x - currentNode.pos.x === -1 &&
                                neighbor.pos.y - currentNode.pos.y === 0 &&
                                turnDirection === game_1.Direction.LEFT)
                                isTurn = false;
                        }
                        if (isTurn)
                            gScore++;
                    }
                    var beenVisited = neighbor.visited;
                    if (!beenVisited || gScore < neighbor.g) {
                        // Found an optimal (so far) path to this node.  Take score for node to see how good it is.
                        neighbor.visited = true;
                        neighbor.parent = currentNode;
                        neighbor.h =
                            neighbor.h ||
                                heuristic(neighbor.pos, _end.pos, lastPlayerPosition);
                        neighbor.g = gScore;
                        neighbor.f = neighbor.g + neighbor.h;
                        if (!beenVisited) {
                            // Pushing to heap will put it in proper place based on the 'f' value.
                            openHeap.push(neighbor);
                        }
                        else {
                            // Already seen the node, but since it has been rescored we need to reorder it in the heap
                            openHeap.rescoreElement(neighbor);
                        }
                    }
                }
            }
            // No result was found - empty array signifies failure to find path.
            return [];
        }
        static search(grid, start, end, disablePoints, diagonal, diagonalsOnly, turnCostsExtra, turnDirection, heuristic, diagonalsOmni, lastPlayerPosition) {
            var astar = new AStar(grid, disablePoints, lastPlayerPosition);
            return astar._search(start, end, diagonal, diagonalsOnly, turnCostsExtra, turnDirection, heuristic, diagonalsOmni);
        }
        manhattan(pos0, pos1) {
            var d1 = Math.abs(pos1.x - pos0.x);
            var d2 = Math.abs(pos1.y - pos0.y);
            var heuristic = d1 + d2;
            return heuristic;
        }
        neighbors(node, diagonals, diagonalsOnly, diagonalsOmni) {
            var grid = this.grid;
            var ret = [];
            var x = node.pos.x;
            var y = node.pos.y;
            if (!diagonalsOnly) {
                // West
                if (grid[x - 1] && grid[x - 1][y]) {
                    ret.push(grid[x - 1][y]);
                }
                // East
                if (grid[x + 1] && grid[x + 1][y]) {
                    ret.push(grid[x + 1][y]);
                }
                // South
                if (grid[x] && grid[x][y - 1]) {
                    ret.push(grid[x][y - 1]);
                }
                // North
                if (grid[x] && grid[x][y + 1]) {
                    ret.push(grid[x][y + 1]);
                }
            }
            if (diagonals) {
                // Southwest
                if (grid[x - 1] && grid[x - 1][y - 1]) {
                    ret.push(grid[x - 1][y - 1]);
                }
                // Southeast
                if (grid[x + 1] && grid[x + 1][y - 1]) {
                    ret.push(grid[x + 1][y - 1]);
                }
                // Northwest
                if (grid[x - 1] && grid[x - 1][y + 1]) {
                    ret.push(grid[x - 1][y + 1]);
                }
                // Northeast
                if (grid[x + 1] && grid[x + 1][y + 1]) {
                    ret.push(grid[x + 1][y + 1]);
                }
            }
            function getRandomBoolean() {
                return random_1.Random.rand() < 0.5;
            }
            if (diagonalsOmni) {
                const randomBool = getRandomBoolean();
                // West
                if (grid[x - 1] && grid[x - 1][y]) {
                    // Instead of pushing West, choose between Southwest and Northwest
                    if (randomBool == true) {
                        ret.push(grid[x - 1][y - 1]);
                        return;
                    }
                    else {
                        ret.push(grid[x - 1][y + 1]);
                        return;
                    }
                }
                // East
                if (grid[x + 1] && grid[x + 1][y]) {
                    if (randomBool == true) {
                        ret.push(grid[x + 1][y - 1]);
                        return;
                    }
                    else {
                        ret.push(grid[x + 1][y + 1]);
                        return;
                    }
                }
                // South
                if (grid[x] && grid[x][y - 1]) {
                    if (randomBool == true) {
                        ret.push(grid[x - 1][y - 1]);
                        return;
                    }
                    else {
                        ret.push(grid[x + 1][y - 1]);
                        return;
                    }
                }
                // North
                if (grid[x] && grid[x][y + 1]) {
                    if (randomBool == true) {
                        ret.push(grid[x - 1][y + 1]);
                        return;
                    }
                    else {
                        ret.push(grid[x + 1][y + 1]);
                        return;
                    }
                }
                else {
                    return;
                }
            }
            return ret;
        }
    }
    AStar.NO_CHECK_START_POINT = false;
    astar_1.AStar = AStar;
})(astar = exports.astar || (exports.astar = {}));


/***/ }),

/***/ "./src/utility/random.ts":
/*!*******************************!*\
  !*** ./src/utility/random.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Random = void 0;
class Random {
}
exports.Random = Random;
Random.setState = (state) => {
    Random.state = state;
};
/**
 * Generates a pseudorandom floating-point number using a xorshift algorithm.
 *
 * This method implements a 32-bit xorshift PRNG that modifies the internal state
 * using three XOR operations with bit shifts (21 left, 35 right, 4 left).
 * The algorithm is fast and suitable for games but should not be used for
 * cryptographic purposes.
 *
 * @returns {number} A pseudorandom floating-point number in the range [0, 1).
 *                   The value is uniformly distributed across this range.
 *
 * @example
 * Random.setState(12345); // Set initial seed
 * const randomValue = Random.rand(); // Returns something like 0.7234567891
 *
 * @see https://en.wikipedia.org/wiki/Xorshift for algorithm details
 */
Random.rand = () => {
    Random.state ^= Random.state << 21;
    Random.state ^= Random.state >>> 35;
    Random.state ^= Random.state << 4;
    return (Random.state >>> 0) / 4294967296;
};
// copy and paste into browser console
// let state;
// let rand = () => { state ^= (state << 21); state ^= (state >>> 35); state ^= (state << 4); return (state >>> 0) / 4294967296; }


/***/ }),

/***/ "./src/utility/utils.ts":
/*!******************************!*\
  !*** ./src/utility/utils.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Utils = void 0;
const game_1 = __webpack_require__(/*! ../game */ "./src/game.ts");
const random_1 = __webpack_require__(/*! ./random */ "./src/utility/random.ts");
class Utils {
}
exports.Utils = Utils;
Utils.distance = (startX, startY, endX, endY) => {
    return Math.sqrt((endX - startX) ** 2 + (endY - startY) ** 2);
};
Utils.calculateExponentialFalloff = (distance, falloffRate) => {
    return Math.exp(-falloffRate * distance);
};
// Corrected HSV to HEX conversion
Utils.hsvToHex = (h, s, v) => {
    let c = v * s;
    let x = c * (1 - Math.abs(((h / 60) % 2) - 1));
    let m = v - c;
    let r = 0, g = 0, b = 0;
    if (h >= 0 && h < 60) {
        r = c;
        g = x;
        b = 0;
    }
    else if (h >= 60 && h < 120) {
        r = x;
        g = c;
        b = 0;
    }
    else if (h >= 120 && h < 180) {
        r = 0;
        g = c;
        b = x;
    }
    else if (h >= 180 && h < 240) {
        r = 0;
        g = x;
        b = c;
    }
    else if (h >= 240 && h < 300) {
        r = x;
        g = 0;
        b = c;
    }
    else {
        r = c;
        g = 0;
        b = x;
    }
    // Convert to RGB values
    const rFinal = Math.round((r + m) * 255);
    const gFinal = Math.round((g + m) * 255);
    const bFinal = Math.round((b + m) * 255);
    return Utils.rgbToHex(rFinal, gFinal, bFinal);
};
// RGB to HEX conversion
Utils.rgbToHex = (r, g, b) => {
    const toHex = (val) => {
        const hex = val.toString(16);
        return hex.length === 1 ? "0" + hex : hex;
    };
    return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
};
/**
 * Generates a random integer using a modified cosine distribution that approximates a normal distribution.
 *
 * @param min - The minimum value (inclusive) of the range
 * @param max - The maximum value (inclusive) of the range
 * @param options - Optional parameters to modify the distribution
 * @param options.median - The value to skew the distribution towards (must be between min and max).
 *                        Default is the middle of the range. This acts as the peak of the distribution curve.
 * @returns A random integer between min and max (inclusive) following the specified distribution
 *
 * @example
 * // Normal bell curve distribution between 0 and 10 (centered at 5)
 * randomSineInt(0, 10)
 *
 * @example
 * // Distribution skewed towards 7
 * randomSineInt(0, 10, { median: 7 })
 */
Utils.randomSineInt = (min, max, options = {}) => {
    const roundedMax = Math.ceil(max);
    const roundedMin = Math.floor(min);
    const range = roundedMax - roundedMin + 1;
    const { median = roundedMin + (range - 1) / 2 } = options;
    // Validate median is within range
    const clampedMedian = Math.min(Math.max(median, roundedMin), roundedMax);
    // Generate two random numbers for a more normal-like distribution
    const x1 = random_1.Random.rand() * 2 * Math.PI;
    const x2 = random_1.Random.rand() * 2 * Math.PI;
    // Average two cosines to create smoother bell curve, normalized to [0,1]
    const value = (Math.cos(x1) + Math.cos(x2) + 2) / 4;
    // Calculate the relative median position in [0,1] range
    const medianPosition = (clampedMedian - roundedMin) / (range - 1);
    // Apply skewing by using a weighted average
    const weight = 0.7; // How strong the skewing effect should be
    const skewedValue = value * (1 - weight) +
        (value < 0.5
            ? value * (medianPosition / 0.5)
            : medianPosition + (value - 0.5) * 2 * (1 - medianPosition)) *
            weight;
    // Ensure we stay within bounds while avoiding edge cases
    const epsilon = 0.001;
    const boundedValue = Math.min(Math.max(skewedValue, epsilon), 1 - epsilon);
    // Map to integer range
    const result = Math.floor(boundedValue * range) + roundedMin;
    return Math.min(Math.max(result, roundedMin), roundedMax);
};
Utils.randTableWeighted = (table) => {
    // If table is empty, return null
    if (!table || table.length === 0)
        return null;
    // Check if items have weight property
    const hasWeights = table.some((item) => item && typeof item.weight === "number");
    if (!hasWeights) {
        // Fallback to equal probability selection
        return table[game_1.Game.rand(0, table.length - 1, random_1.Random.rand)];
    }
    // Calculate total weight
    const totalWeight = table.reduce((sum, item) => {
        return sum + (item && typeof item.weight === "number" ? item.weight : 0);
    }, 0);
    if (totalWeight <= 0) {
        // If no valid weights, fallback to equal probability
        return table[game_1.Game.rand(0, table.length - 1, random_1.Random.rand)];
    }
    // Generate random number between 0 and totalWeight
    let randomValue = random_1.Random.rand() * totalWeight;
    // Find the item that corresponds to this random value
    for (const item of table) {
        if (item && typeof item.weight === "number") {
            randomValue -= item.weight;
            if (randomValue <= 0) {
                return item;
            }
        }
    }
    // Fallback (should rarely happen due to floating point precision)
    return table[table.length - 1];
};
/**
 * Generates a random integer using a real normal distribution.
 *
 * @param min - The value that represents -2 standard deviations from the mean
 * @param max - The value that represents +2 standard deviations from the mean
 * @param options - Optional parameters to modify the distribution
 * @param options.median - The mean of the distribution (center point).
 *                        Default is the middle of the range.
 * @returns A random integer following a normal distribution, with negative values clamped to 0
 *
 * @example
 * // Normal distribution centered at 5, with min/max representing ±2 std devs
 * randomNormalInt(0, 10)
 *
 * @example
 * // Normal distribution centered at 7
 * randomNormalInt(0, 10, { median: 7 })
 */
Utils.randomNormalInt = (min, max, options = {}) => {
    const { median = min + (max - min) / 2 } = options;
    // Calculate standard deviation: (max - min) / 4 since min/max are ±2 std devs
    const standardDeviation = (max - min) / 5;
    // Box-Muller transform to generate normal distribution
    // Generate two uniform random numbers
    let u1 = random_1.Random.rand();
    let u2 = random_1.Random.rand();
    // Ensure u1 is not 0 to avoid log(0)
    while (u1 === 0) {
        u1 = random_1.Random.rand();
    }
    // Box-Muller transformation
    const z0 = Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
    // Scale and shift to desired mean and standard deviation
    const normalValue = z0 * standardDeviation + median;
    // Clamp negative values to 0
    const clampedValue = Math.max(0, normalValue);
    // Round to integer
    return Math.round(clampedValue);
};


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./src/game.ts");
/******/ 	
/******/ })()
;
//# sourceMappingURL=bundle.js.map