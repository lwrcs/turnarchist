/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/astarclass.ts":
/*!***************************!*\
  !*** ./src/astarclass.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.astar = void 0;
const game_1 = __webpack_require__(/*! ./game */ "./src/game.ts");
var astar;
(function (astar_1) {
    //================== start graph js
    /*
    graph.js http://github.com/bgrins/javascript-astar
    MIT License
    Creates a Graph class used in the astar search algorithm.
    Includes Binary Heap (with modifications) from Marijn Haverbeke
        URL: http://eloquentjavascript.net/appendix2.html
        License: http://creativecommons.org/licenses/by/3.0/
    */
    let GraphNodeType;
    (function (GraphNodeType) {
        GraphNodeType[GraphNodeType["WALL"] = 0] = "WALL";
        GraphNodeType[GraphNodeType["OPEN"] = 1] = "OPEN";
    })(GraphNodeType = astar_1.GraphNodeType || (astar_1.GraphNodeType = {}));
    let getTileCost = (tile) => {
        if (tile)
            return tile.isSolid() || tile.isDoor ? 99999999 : 300;
        else
            return 99999999;
    };
    class Graph {
        constructor(grid) {
            this.elements = grid;
            var nodes = [];
            var row, rowLength, len = grid.length;
            for (var x = 0; x < len; ++x) {
                row = grid[x];
                rowLength = row.length;
                nodes[x] = new Array(rowLength); // optimum array with size
                for (var y = 0; y < rowLength; ++y) {
                    nodes[x][y] = new GraphNode(x, y, row[y]);
                }
            }
            this.nodes = nodes;
        }
        toString() {
            var graphString = "\n";
            var nodes = this.nodes;
            var rowDebug, row, y, l;
            for (var x = 0, len = nodes.length; x < len;) {
                rowDebug = "";
                row = nodes[x++];
                for (y = 0, l = row.length; y < l;) {
                    rowDebug += row[y++].type + " ";
                }
                graphString = graphString + rowDebug + "\n";
            }
            return graphString;
        }
    }
    astar_1.Graph = Graph;
    class GraphNode {
        constructor(x, y, type) {
            this.data = {};
            this.x = x;
            this.y = y;
            this.pos = { x: x, y: y };
            this.type = type;
        }
        toString() {
            return "[" + this.x + " " + this.y + "]";
        }
        isWall() {
            return this.type == GraphNodeType.WALL;
        }
    }
    astar_1.GraphNode = GraphNode;
    class BinaryHeap {
        constructor(scoreFunction) {
            this.content = [];
            this.scoreFunction = scoreFunction;
        }
        push(node) {
            // Add the new node to the end of the array.
            this.content.push(node);
            // Allow it to sink down.
            this.sinkDown(this.content.length - 1);
        }
        pop() {
            // Store the first node so we can return it later.
            var result = this.content[0];
            // Get the node at the end of the array.
            var end = this.content.pop();
            // If there are any elements left, put the end node at the
            // start, and let it bubble up.
            if (this.content.length > 0) {
                this.content[0] = end;
                this.bubbleUp(0);
            }
            return result;
        }
        remove(node) {
            var i = this.content.indexOf(node);
            // When it is found, the process seen in 'pop' is repeated
            // to fill up the hole.
            var end = this.content.pop();
            if (i !== this.content.length - 1) {
                this.content[i] = end;
                if (this.scoreFunction(end) < this.scoreFunction(node))
                    this.sinkDown(i);
                else
                    this.bubbleUp(i);
            }
        }
        size() {
            return this.content.length;
        }
        rescoreElement(node) {
            this.sinkDown(this.content.indexOf(node));
        }
        sinkDown(n) {
            // Fetch the element that has to be sunk.
            var element = this.content[n];
            // When at 0, an element can not sink any further.
            while (n > 0) {
                // Compute the parent element's index, and fetch it.
                var parentN = ((n + 1) >> 1) - 1, parent = this.content[parentN];
                // Swap the elements if the parent is greater.
                if (this.scoreFunction(element) < this.scoreFunction(parent)) {
                    this.content[parentN] = element;
                    this.content[n] = parent;
                    // Update 'n' to continue at the new position.
                    n = parentN;
                }
                else {
                    // Found a parent that is less, no need to sink any further.
                    break;
                }
            }
        }
        bubbleUp(n) {
            // Look up the target element and its score.
            var length = this.content.length, element = this.content[n], elemScore = this.scoreFunction(element);
            while (true) {
                // Compute the indices of the child elements.
                var child2N = (n + 1) << 1, child1N = child2N - 1;
                // This is used to store the new position of the element,
                // if any.
                var swap = null;
                // If the first child exists (is inside the array)...
                if (child1N < length) {
                    // Look it up and compute its score.
                    var child1 = this.content[child1N], child1Score = this.scoreFunction(child1);
                    // If the score is less than our element's, we need to swap.
                    if (child1Score < elemScore)
                        swap = child1N;
                }
                // Do the same checks for the other child.
                if (child2N < length) {
                    var child2 = this.content[child2N], child2Score = this.scoreFunction(child2);
                    if (child2Score < (swap === null ? elemScore : child1Score))
                        swap = child2N;
                }
                // If the element needs to be moved, swap it, and continue.
                if (swap !== null) {
                    this.content[n] = this.content[swap];
                    this.content[swap] = element;
                    n = swap;
                }
                else {
                    // Otherwise, we are done.
                    break;
                }
            }
        }
    }
    astar_1.BinaryHeap = BinaryHeap;
    class AStar {
        constructor(grid, disablePoints, lastPlayerPosition, enableCost) {
            this.grid = [];
            for (var x = 0, xl = grid.length; x < xl; x++) {
                this.grid[x] = [];
                for (var y = 0, yl = grid[x].length; y < yl; y++) {
                    var cost = getTileCost(grid[x][y]);
                    this.grid[x][y] = {
                        org: grid[x][y],
                        f: 0,
                        g: 0,
                        h: 0,
                        cost: cost,
                        visited: false,
                        closed: false,
                        pos: {
                            x: x,
                            y: y,
                        },
                        parent: null,
                    };
                }
            }
            if (disablePoints !== undefined) {
                for (var i = 0; i < disablePoints.length; i++) {
                    if (disablePoints[i].x >= 0 &&
                        disablePoints[i].x < this.grid.length &&
                        disablePoints[i].y >= 0 &&
                        disablePoints[i].y < this.grid[0].length)
                        this.grid[disablePoints[i].x][disablePoints[i].y].cost = 99999999;
                }
            }
            if (lastPlayerPosition) {
                if (lastPlayerPosition.x >= 0 &&
                    lastPlayerPosition.x < this.grid.length &&
                    lastPlayerPosition.y >= 0 &&
                    lastPlayerPosition.y < this.grid[0].length)
                    this.grid[lastPlayerPosition.x][lastPlayerPosition.y].cost = 0.5;
            }
        }
        heap() {
            return new BinaryHeap(function (node) {
                return node.f;
            });
        }
        _find(org) {
            for (var x = 0; x < this.grid.length; x++)
                for (var y = 0; y < this.grid[x].length; y++)
                    if (this.grid[x][y].org == org)
                        return this.grid[x][y];
        }
        _search(start, end, diagonal, diagonalsOnly, turnCostsExtra, turnDirection, heuristic, diagonalsOmni, lastPlayerPosition) {
            heuristic = heuristic || this.manhattan;
            diagonal = !!diagonal;
            diagonalsOnly = !!diagonalsOnly;
            turnCostsExtra = !!turnCostsExtra;
            diagonalsOmni = !!diagonalsOmni;
            var openHeap = this.heap();
            var _start, _end;
            if (start.x !== undefined && start.y !== undefined)
                _start = this.grid[start.x][start.y];
            else
                _start = this._find(start);
            if (end.x !== undefined && end.y !== undefined)
                _end = this.grid[end.x][end.y];
            else
                _end = this._find(end);
            if (AStar.NO_CHECK_START_POINT == false && _start.cost <= 0)
                return [];
            openHeap.push(_start);
            while (openHeap.size() > 0) {
                // Grab the lowest f(x) to process next.  Heap keeps this sorted for us.
                var currentNode = openHeap.pop();
                // End case -- result has been found, return the traced path.
                if (currentNode === _end) {
                    var curr = currentNode;
                    var ret = [];
                    while (curr.parent) {
                        ret.push(curr);
                        curr = curr.parent;
                    }
                    return ret.reverse();
                }
                // Normal case -- move currentNode from open to closed, process each of its neighbors.
                currentNode.closed = true;
                // Find all neighbors for the current node. Optionally find diagonal neighbors as well (false by default).
                var neighbors = this.neighbors(currentNode, diagonal, diagonalsOnly, diagonalsOmni);
                for (var i = 0, il = neighbors.length; i < il; i++) {
                    var neighbor = neighbors[i];
                    if (neighbor.closed || neighbor.cost <= 0) {
                        // Not a valid node to process, skip to next neighbor.
                        continue;
                    }
                    // The g score is the shortest distance from start to current node.
                    // We need to check if the path we have arrived at this neighbor is the shortest one we have seen yet.
                    var gScore = currentNode.g + neighbor.cost;
                    if (turnCostsExtra) {
                        var isTurn = false;
                        if (currentNode.parent)
                            isTurn = !((currentNode.parent.pos.x === currentNode.pos.x &&
                                currentNode.pos.x === neighbor.pos.x) ||
                                (currentNode.parent.pos.y === currentNode.pos.y &&
                                    currentNode.pos.y === neighbor.pos.y));
                        else {
                            // initial step
                            isTurn = true;
                            if (neighbor.pos.x - currentNode.pos.x === 0 &&
                                neighbor.pos.y - currentNode.pos.y === -1 &&
                                turnDirection === game_1.Direction.UP)
                                isTurn = false;
                            if (neighbor.pos.x - currentNode.pos.x === 0 &&
                                neighbor.pos.y - currentNode.pos.y === 1 &&
                                turnDirection === game_1.Direction.DOWN)
                                isTurn = false;
                            if (neighbor.pos.x - currentNode.pos.x === 1 &&
                                neighbor.pos.y - currentNode.pos.y === 0 &&
                                turnDirection === game_1.Direction.RIGHT)
                                isTurn = false;
                            if (neighbor.pos.x - currentNode.pos.x === -1 &&
                                neighbor.pos.y - currentNode.pos.y === 0 &&
                                turnDirection === game_1.Direction.LEFT)
                                isTurn = false;
                        }
                        if (isTurn)
                            gScore++;
                    }
                    var beenVisited = neighbor.visited;
                    if (!beenVisited || gScore < neighbor.g) {
                        // Found an optimal (so far) path to this node.  Take score for node to see how good it is.
                        neighbor.visited = true;
                        neighbor.parent = currentNode;
                        neighbor.h =
                            neighbor.h ||
                                heuristic(neighbor.pos, _end.pos, lastPlayerPosition);
                        neighbor.g = gScore;
                        neighbor.f = neighbor.g + neighbor.h;
                        if (!beenVisited) {
                            // Pushing to heap will put it in proper place based on the 'f' value.
                            openHeap.push(neighbor);
                        }
                        else {
                            // Already seen the node, but since it has been rescored we need to reorder it in the heap
                            openHeap.rescoreElement(neighbor);
                        }
                    }
                }
            }
            // No result was found - empty array signifies failure to find path.
            return [];
        }
        static search(grid, start, end, disablePoints, diagonal, diagonalsOnly, turnCostsExtra, turnDirection, heuristic, diagonalsOmni, lastPlayerPosition) {
            var astar = new AStar(grid, disablePoints, lastPlayerPosition);
            return astar._search(start, end, diagonal, diagonalsOnly, turnCostsExtra, turnDirection, heuristic, diagonalsOmni);
        }
        manhattan(pos0, pos1) {
            var d1 = Math.abs(pos1.x - pos0.x);
            var d2 = Math.abs(pos1.y - pos0.y);
            var heuristic = d1 + d2;
            return heuristic;
        }
        neighbors(node, diagonals, diagonalsOnly, diagonalsOmni) {
            var grid = this.grid;
            var ret = [];
            var x = node.pos.x;
            var y = node.pos.y;
            if (!diagonalsOnly) {
                // West
                if (grid[x - 1] && grid[x - 1][y]) {
                    ret.push(grid[x - 1][y]);
                }
                // East
                if (grid[x + 1] && grid[x + 1][y]) {
                    ret.push(grid[x + 1][y]);
                }
                // South
                if (grid[x] && grid[x][y - 1]) {
                    ret.push(grid[x][y - 1]);
                }
                // North
                if (grid[x] && grid[x][y + 1]) {
                    ret.push(grid[x][y + 1]);
                }
            }
            if (diagonals) {
                // Southwest
                if (grid[x - 1] && grid[x - 1][y - 1]) {
                    ret.push(grid[x - 1][y - 1]);
                }
                // Southeast
                if (grid[x + 1] && grid[x + 1][y - 1]) {
                    ret.push(grid[x + 1][y - 1]);
                }
                // Northwest
                if (grid[x - 1] && grid[x - 1][y + 1]) {
                    ret.push(grid[x - 1][y + 1]);
                }
                // Northeast
                if (grid[x + 1] && grid[x + 1][y + 1]) {
                    ret.push(grid[x + 1][y + 1]);
                }
            }
            function getRandomBoolean() {
                return Math.random() < 0.5;
            }
            if (diagonalsOmni) {
                const randomBool = getRandomBoolean();
                // West
                if (grid[x - 1] && grid[x - 1][y]) {
                    // Instead of pushing West, choose between Southwest and Northwest
                    if (randomBool == true) {
                        ret.push(grid[x - 1][y - 1]);
                        return;
                    }
                    else {
                        ret.push(grid[x - 1][y + 1]);
                        return;
                    }
                }
                // East
                if (grid[x + 1] && grid[x + 1][y]) {
                    if (randomBool == true) {
                        ret.push(grid[x + 1][y - 1]);
                        return;
                    }
                    else {
                        ret.push(grid[x + 1][y + 1]);
                        return;
                    }
                }
                // South
                if (grid[x] && grid[x][y - 1]) {
                    if (randomBool == true) {
                        ret.push(grid[x - 1][y - 1]);
                        return;
                    }
                    else {
                        ret.push(grid[x + 1][y - 1]);
                        return;
                    }
                }
                // North
                if (grid[x] && grid[x][y + 1]) {
                    if (randomBool == true) {
                        ret.push(grid[x - 1][y + 1]);
                        return;
                    }
                    else {
                        ret.push(grid[x + 1][y + 1]);
                        return;
                    }
                }
                else {
                    return;
                }
            }
            return ret;
        }
    }
    AStar.NO_CHECK_START_POINT = false;
    astar_1.AStar = AStar;
})(astar = exports.astar || (exports.astar = {}));


/***/ }),

/***/ "./src/beamEffect.ts":
/*!***************************!*\
  !*** ./src/beamEffect.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BeamEffect = void 0;
const game_1 = __webpack_require__(/*! ./game */ "./src/game.ts");
const gameConstants_1 = __webpack_require__(/*! ./gameConstants */ "./src/gameConstants.ts");
const projectile_1 = __webpack_require__(/*! ./projectile/projectile */ "./src/projectile/projectile.ts");
class BeamEffect extends projectile_1.Projectile {
    constructor(x1, y1, x2, y2, parent) {
        super(parent, x1, y1);
        this.active = true;
        this.time = 0;
        this.alpha = 1;
        this.gravity = BeamEffect.GRAVITY;
        this.motionInfluence = BeamEffect.MOTION_INFLUENCE;
        this.turbulence = BeamEffect.TURBULENCE;
        this.velocityDecay = BeamEffect.VELOCITY_DECAY;
        this.angleChange = BeamEffect.ANGLE_CHANGE;
        this.maxVelocity = BeamEffect.MAX_VELOCITY;
        this.damping = BeamEffect.DAMPING;
        this.springStiffness = BeamEffect.SPRING_STIFFNESS;
        this.springDamping = BeamEffect.SPRING_DAMPING;
        this.iterations = BeamEffect.ITERATIONS;
        this.segments = BeamEffect.SEGMENTS;
        this.tick = () => {
            if (this.parent.dead) {
                this.destroy();
            }
        };
        this.draw = (delta) => {
            this.drawableY = this.y - 0.01;
            this.render(this.targetX, this.targetY, this.x, this.y, this.color, 2, delta, this.compositeOperation);
        };
        const startX = x1 * gameConstants_1.GameConstants.TILESIZE + 0.5 * gameConstants_1.GameConstants.TILESIZE;
        const startY = y1 * gameConstants_1.GameConstants.TILESIZE + 0.5 * gameConstants_1.GameConstants.TILESIZE;
        const endX = x2 * gameConstants_1.GameConstants.TILESIZE + 0.5 * gameConstants_1.GameConstants.TILESIZE;
        const endY = y2 * gameConstants_1.GameConstants.TILESIZE + 0.5 * gameConstants_1.GameConstants.TILESIZE;
        this.x = x1;
        this.y = y1;
        this.targetX = x2;
        this.targetY = y2;
        this.points = this.initializePoints(startX, startY, endX, endY);
        this.prevStartX = startX;
        this.prevStartY = startY;
        this.prevEndX = endX;
        this.prevEndY = endY;
        this.color = "cyan";
        this.compositeOperation = "source-over";
    }
    /**
     * Sets the physics properties for the beam effect.
     *
     * @param {number} [gravity] - The gravitational force applied to the beam. Default: 2
     * @param {number} [motionInfluence] - The influence of motion on the beam. Default: 1
     * @param {number} [turbulence] - The turbulence applied to the beam. Default: 0.5
     * @param {number} [velocityDecay] - The rate at which velocity decays. Default: 0.1
     * @param {number} [angleChange] - The change in angle of the beam. Default: 0.01
     * @param {number} [maxVelocity] - The maximum velocity of the beam.
     * @param {number} [damping] - The damping factor for the beam's motion.
     * @param {number} [springStiffness] - The stiffness of the spring effect.
     * @param {number} [springDamping] - The damping of the spring effect.
     * @param {number} [iterations] - The number of iterations for the physics simulation.
     * @param {number} [segments] - The number of segments for the beam.
     */
    setPhysics(gravity, motionInfluence, turbulence, velocityDecay, angleChange, maxVelocity, damping, springStiffness, springDamping, iterations, segments) {
        this.gravity = gravity ?? BeamEffect.GRAVITY;
        this.motionInfluence = motionInfluence ?? BeamEffect.MOTION_INFLUENCE;
        this.turbulence = turbulence ?? BeamEffect.TURBULENCE;
        this.velocityDecay = velocityDecay ?? BeamEffect.VELOCITY_DECAY;
        this.angleChange = angleChange ?? BeamEffect.ANGLE_CHANGE;
        this.maxVelocity = maxVelocity ?? BeamEffect.MAX_VELOCITY;
        this.damping = damping ?? BeamEffect.DAMPING;
        this.springStiffness = springStiffness ?? BeamEffect.SPRING_STIFFNESS;
        this.springDamping = springDamping ?? BeamEffect.SPRING_DAMPING;
        this.iterations = iterations ?? BeamEffect.ITERATIONS;
        this.segments = segments ?? BeamEffect.SEGMENTS;
    }
    setTarget(x, y, x2, y2) {
        this.x = x;
        this.y = y;
        this.targetX = x2;
        this.targetY = y2;
    }
    render(x1, y1, x2, y2, color = this.color, lineWidth = 2, delta = 1 / 60, compositeOperation = this.compositeOperation) {
        const startX = this.x * gameConstants_1.GameConstants.TILESIZE + 0.5 * gameConstants_1.GameConstants.TILESIZE;
        const startY = this.y * gameConstants_1.GameConstants.TILESIZE + 0.5 * gameConstants_1.GameConstants.TILESIZE;
        const endX = this.targetX * gameConstants_1.GameConstants.TILESIZE + 0.5 * gameConstants_1.GameConstants.TILESIZE;
        const endY = this.targetY * gameConstants_1.GameConstants.TILESIZE + 0.5 * gameConstants_1.GameConstants.TILESIZE;
        const startForceX = (startX - this.prevStartX) * this.motionInfluence * delta;
        const startForceY = (startY - this.prevStartY) * this.motionInfluence * delta;
        const endForceX = (endX - this.prevEndX) * this.motionInfluence * delta;
        const endForceY = (endY - this.prevEndY) * this.motionInfluence * delta;
        for (let i = 1; i < 4; i++) {
            const influence = 1 - i / 4;
            this.points[i].x += startForceX * influence;
            this.points[i].y += startForceY * influence;
        }
        for (let i = this.points.length - 4; i < this.points.length - 1; i++) {
            const influence = 1 - (this.points.length - i) / 4;
            this.points[i].x += endForceX * influence;
            this.points[i].y += endForceY * influence;
        }
        this.simulateRope(startX, startY, endX, endY, delta);
        const ctx = game_1.Game.ctx;
        ctx.save();
        game_1.Game.ctx.globalCompositeOperation =
            compositeOperation;
        for (let i = 0; i < this.points.length - 1; i++) {
            const p1 = this.points[i];
            const p2 = this.points[i + 1];
            const dx = p2.x - p1.x;
            const dy = p2.y - p1.y;
            const steps = Math.max(Math.abs(dx), Math.abs(dy));
            const xIncrement = dx / steps;
            const yIncrement = dy / steps;
            let x = p1.x;
            let y = p1.y;
            for (let step = 0; step <= steps; step++) {
                for (let w = 0; w < lineWidth; w++) {
                    for (let h = 0; h < lineWidth; h++) {
                        ctx.fillStyle = color;
                        ctx.fillRect(Math.round(x + w), Math.round(y + h), 1, 1);
                    }
                }
                x += xIncrement;
                y += yIncrement;
            }
        }
        ctx.restore();
        this.prevStartX = startX;
        this.prevStartY = startY;
        this.prevEndX = endX;
        this.prevEndY = endY;
    }
    initializePoints(startX, startY, endX, endY) {
        const points = [];
        for (let i = 0; i < this.segments; i++) {
            const t = i / (this.segments - 1);
            points.push({
                x: startX + (endX - startX) * t,
                y: startY + (endY - startY) * t,
                oldX: startX + (endX - startX) * t,
                oldY: startY + (endY - startY) * t,
                velocityX: 0,
                velocityY: 0,
                angle: Math.random() * Math.PI * 2,
            });
        }
        return points;
    }
    applyTurbulence(point, index) {
        point.angle += Math.sin(this.time * 0.1 + index * 0.5) * this.angleChange;
        const turbulenceX = Math.cos(point.angle) * this.turbulence;
        const turbulenceY = Math.sin(point.angle) * this.turbulence;
        point.velocityX += turbulenceX;
        point.velocityY += turbulenceY;
        point.velocityX = Math.min(Math.max(point.velocityX, -this.maxVelocity), this.maxVelocity);
        point.velocityY = Math.min(Math.max(point.velocityY, -this.maxVelocity), this.maxVelocity);
    }
    simulateRope(startX, startY, endX, endY, delta) {
        const iterationsThisFrame = Math.ceil(this.iterations * delta);
        for (let iteration = 0; iteration < iterationsThisFrame; iteration++) {
            for (let i = 1; i < this.points.length - 1; i++) {
                const point = this.points[i];
                const prevPoint = this.points[i - 1];
                const nextPoint = this.points[i + 1];
                const springForceXPrev = (prevPoint.x - point.x) * this.springStiffness;
                const springForceYPrev = (prevPoint.y - point.y) * this.springStiffness;
                const springForceXNext = (nextPoint.x - point.x) * this.springStiffness;
                const springForceYNext = (nextPoint.y - point.y) * this.springStiffness;
                this.applyTurbulence(point, i);
                point.velocityX =
                    (point.velocityX + springForceXPrev + springForceXNext) *
                        this.damping;
                point.velocityY =
                    (point.velocityY + springForceYPrev + springForceYNext) *
                        this.damping;
                const relativeVXPrev = prevPoint.velocityX - point.velocityX;
                const relativeVYPrev = prevPoint.velocityY - point.velocityY;
                const relativeVXNext = nextPoint.velocityX - point.velocityX;
                const relativeVYNext = nextPoint.velocityY - point.velocityY;
                point.velocityX +=
                    (relativeVXPrev + relativeVXNext) * this.springDamping;
                point.velocityY +=
                    (relativeVYPrev + relativeVYNext) * this.springDamping;
                point.oldX = point.x;
                point.oldY = point.y;
                point.x += point.velocityX;
                point.y += point.velocityY + this.gravity;
            }
            const segmentLength = Math.sqrt(Math.pow(endX - startX, 2) + Math.pow(endY - startY, 2)) /
                (this.segments - 1);
            for (let constraintIteration = 0; constraintIteration < 2; constraintIteration++) {
                for (let i = 0; i < this.points.length - 1; i++) {
                    const p1 = this.points[i];
                    const p2 = this.points[i + 1];
                    const dx = p2.x - p1.x;
                    const dy = p2.y - p1.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    const difference = segmentLength - distance;
                    const percent = difference / distance / 2;
                    const offsetX = dx * percent;
                    const offsetY = dy * percent;
                    if (i > 0) {
                        p1.x -= offsetX * 1.5;
                        p1.y -= offsetY * 1.5;
                    }
                    if (i < this.points.length - 2) {
                        p2.x += offsetX * 1.5;
                        p2.y += offsetY * 1.5;
                    }
                }
            }
        }
        this.points[0].x = startX;
        this.points[0].y = startY;
        this.points[0].oldX = startX;
        this.points[0].oldY = startY;
        this.points[this.points.length - 1].x = endX;
        this.points[this.points.length - 1].y = endY;
        this.points[this.points.length - 1].oldX = endX;
        this.points[this.points.length - 1].oldY = endY;
    }
    static renderBeam(x1, y1, x2, y2, color = "cyan", lineWidth = 2, alpha = 1) {
        const ctx = game_1.Game.ctx;
        ctx.globalAlpha = alpha;
        const startX = x1 * gameConstants_1.GameConstants.TILESIZE + 0.5 * gameConstants_1.GameConstants.TILESIZE;
        const startY = y1 * gameConstants_1.GameConstants.TILESIZE + 0.5 * gameConstants_1.GameConstants.TILESIZE;
        const endX = x2 * gameConstants_1.GameConstants.TILESIZE + 0.5 * gameConstants_1.GameConstants.TILESIZE;
        const endY = y2 * gameConstants_1.GameConstants.TILESIZE + 0.5 * gameConstants_1.GameConstants.TILESIZE;
        ctx.save();
        ctx.beginPath();
        ctx.moveTo(startX, startY);
        ctx.lineTo(endX, endY);
        ctx.lineWidth = lineWidth;
        ctx.strokeStyle = color;
        ctx.stroke();
        ctx.restore();
    }
    destroy() {
        this.active = false;
        this.points = [];
        this.dead = true;
    }
    isActive() {
        return this.active;
    }
}
exports.BeamEffect = BeamEffect;
// Number of points that make up the beam (higher = smoother but more expensive)
// Range: 10-100, recommended: 30
BeamEffect.SEGMENTS = 30;
// Downward force applied to each point (0 = no gravity)
// Range: 0-10, recommended: 2
BeamEffect.GRAVITY = 2;
// Physics simulation steps per frame (higher = more accurate but more expensive)
// Range: 1-10, recommended: 1
BeamEffect.ITERATIONS = 5;
// How much the beam reacts to movement of start/end points
// Range: 0-5, recommended: 1
BeamEffect.MOTION_INFLUENCE = 1;
// Amount of random movement applied to points (0 = straight beam)
// Range: 0-1, recommended: 0.5
BeamEffect.TURBULENCE = 0.5;
// How quickly velocity decreases over time
// Range: 0-1, recommended: 0.5
BeamEffect.VELOCITY_DECAY = 0.1;
// How quickly the turbulence angle changes
// Range: 0-2, recommended: 0.9
BeamEffect.ANGLE_CHANGE = 0.01; // for turbulence specifically
// Maximum speed any point can move per frame
// Range: 10-1000, recommended: 100
BeamEffect.MAX_VELOCITY = 100;
// General movement resistance (1 = no damping, 0 = full stop)
// Range: 0.9-0.999, recommended: 0.8
BeamEffect.DAMPING = 0.8;
// How strongly points pull toward their neighbors
// Range: 0.01-1, recommended: 0.01
BeamEffect.SPRING_STIFFNESS = 0.01;
// How quickly spring oscillations settle
// Range: 0.001-0.1, recommended: 0.1
BeamEffect.SPRING_DAMPING = 0.1;


/***/ }),

/***/ "./src/bestiary.ts":
/*!*************************!*\
  !*** ./src/bestiary.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Bestiary = void 0;
const game_1 = __webpack_require__(/*! ./game */ "./src/game.ts");
const levelConstants_1 = __webpack_require__(/*! ./levelConstants */ "./src/levelConstants.ts");
const gameConstants_1 = __webpack_require__(/*! ./gameConstants */ "./src/gameConstants.ts");
const crabEnemy_1 = __webpack_require__(/*! ./entity/enemy/crabEnemy */ "./src/entity/enemy/crabEnemy.ts");
const frogEnemy_1 = __webpack_require__(/*! ./entity/enemy/frogEnemy */ "./src/entity/enemy/frogEnemy.ts");
const zombieEnemy_1 = __webpack_require__(/*! ./entity/enemy/zombieEnemy */ "./src/entity/enemy/zombieEnemy.ts");
const skullEnemy_1 = __webpack_require__(/*! ./entity/enemy/skullEnemy */ "./src/entity/enemy/skullEnemy.ts");
const energyWizard_1 = __webpack_require__(/*! ./entity/enemy/energyWizard */ "./src/entity/enemy/energyWizard.ts");
const chargeEnemy_1 = __webpack_require__(/*! ./entity/enemy/chargeEnemy */ "./src/entity/enemy/chargeEnemy.ts");
const rookEnemy_1 = __webpack_require__(/*! ./entity/enemy/rookEnemy */ "./src/entity/enemy/rookEnemy.ts");
const bishopEnemy_1 = __webpack_require__(/*! ./entity/enemy/bishopEnemy */ "./src/entity/enemy/bishopEnemy.ts");
const armoredzombieEnemy_1 = __webpack_require__(/*! ./entity/enemy/armoredzombieEnemy */ "./src/entity/enemy/armoredzombieEnemy.ts");
const bigSkullEnemy_1 = __webpack_require__(/*! ./entity/enemy/bigSkullEnemy */ "./src/entity/enemy/bigSkullEnemy.ts");
const queenEnemy_1 = __webpack_require__(/*! ./entity/enemy/queenEnemy */ "./src/entity/enemy/queenEnemy.ts");
const knightEnemy_1 = __webpack_require__(/*! ./entity/enemy/knightEnemy */ "./src/entity/enemy/knightEnemy.ts");
const bigKnightEnemy_1 = __webpack_require__(/*! ./entity/enemy/bigKnightEnemy */ "./src/entity/enemy/bigKnightEnemy.ts");
const fireWizard_1 = __webpack_require__(/*! ./entity/enemy/fireWizard */ "./src/entity/enemy/fireWizard.ts");
const spawner_1 = __webpack_require__(/*! ./entity/enemy/spawner */ "./src/entity/enemy/spawner.ts");
const occultistEnemy_1 = __webpack_require__(/*! ./entity/enemy/occultistEnemy */ "./src/entity/enemy/occultistEnemy.ts");
//enemy typeof to class map
const enemyClassMap = {
    CrabEnemy: crabEnemy_1.CrabEnemy,
    FrogEnemy: frogEnemy_1.FrogEnemy,
    ZombieEnemy: zombieEnemy_1.ZombieEnemy,
    SkullEnemy: skullEnemy_1.SkullEnemy,
    EnergyWizardEnemy: energyWizard_1.EnergyWizardEnemy,
    ChargeEnemy: chargeEnemy_1.ChargeEnemy,
    RookEnemy: rookEnemy_1.RookEnemy,
    BishopEnemy: bishopEnemy_1.BishopEnemy,
    ArmoredzombieEnemy: armoredzombieEnemy_1.ArmoredzombieEnemy,
    BigSkullEnemy: bigSkullEnemy_1.BigSkullEnemy,
    QueenEnemy: queenEnemy_1.QueenEnemy,
    KnightEnemy: knightEnemy_1.KnightEnemy,
    BigKnightEnemy: bigKnightEnemy_1.BigKnightEnemy,
    FireWizardEnemy: fireWizard_1.FireWizardEnemy,
    Spawner: spawner_1.Spawner,
    OccultistEnemy: occultistEnemy_1.OccultistEnemy,
};
class Bestiary {
    constructor(game, player) {
        this.isOpen = false;
        this.openTime = Date.now();
        this.frame = 0;
        this.activeEntryIndex = 0;
        /**
         * Opens the logbook window.
         */
        this.open = () => {
            if (this.seenEnemies.size === 0)
                this.seenEnemies = this.game.tutorialListener.seenEnemies;
            this.isOpen = true;
            this.openTime = Date.now();
        };
        /**
         * Closes the logbook window.
         */
        this.close = () => {
            this.isOpen = false;
        };
        this.entryUp = () => {
            this.activeEntryIndex =
                (this.activeEntryIndex - 1 + this.entries.length) % this.entries.length;
        };
        this.entryDown = () => {
            this.activeEntryIndex = (this.activeEntryIndex + 1) % this.entries.length;
        };
        /**
         * Toggles the logbook window's open state.
         */
        this.toggleOpen = () => {
            this.isOpen ? this.close() : this.open();
        };
        /**
         * Adds a new entry to the logbook.
         * @param enemy The enemy to add.
         */
        this.addEntry = (enemy) => {
            const enemyClass = enemyClassMap[enemy.name];
            this.entries.push({
                name: enemy.name,
                description: enemyClass.prototype.description,
                tileX: enemyClass.prototype.tileX,
                tileY: enemyClass.prototype.tileY,
            });
        };
        /**
         * Draws the logbook interface.
         * @param delta The time delta since the last frame.
         */
        this.draw = (delta) => {
            if (!this.isOpen)
                return;
            game_1.Game.ctx.save();
            // Draw semi-transparent background
            game_1.Game.ctx.fillStyle = "rgba(0, 0, 0, 0.8)";
            game_1.Game.ctx.fillRect(0, 0, gameConstants_1.GameConstants.WIDTH, gameConstants_1.GameConstants.HEIGHT);
            // Define dimensions similar to Inventory
            const s = Math.min(18, (18 * (Date.now() - this.openTime)) / 100); // example scaling
            const b = 2; // border
            const g = -2; // gap
            const ob = 1; // outer border
            const width = 5 * (s + 2 * b + g) - g; // assuming 5 columns
            const height = 4 * (s + 2 * b + g) - g; // assuming 4 rows
            const startX = Math.round(0.5 * gameConstants_1.GameConstants.WIDTH - 0.5 * width) - ob;
            const startY = Math.round(0.5 * gameConstants_1.GameConstants.HEIGHT - 0.5 * height) - ob;
            // Draw main logbook background
            game_1.Game.ctx.fillStyle = "white";
            game_1.Game.ctx.fillRect(startX, startY, width + 2 * ob, height + 2 * ob);
            // Draw logbook entries
            game_1.Game.ctx.fillStyle = "black";
            const padding = 10;
            if (this.entries.length === 0) {
                game_1.Game.fillText("No enemies seen yet", startX + padding, startY + padding);
            }
            else {
                this.entries.forEach((entry, index) => {
                    game_1.Game.fillText(entry.name, startX + padding, startY + padding + index * 20);
                });
                this.drawEnemySprite(this.entries[this.activeEntryIndex].tileX, this.entries[this.activeEntryIndex].tileY, delta);
            }
            // Draw logbook button
            this.drawLogbookButton(delta);
            game_1.Game.ctx.restore();
        };
        this.drawEnemySprite = (tileX, tileY, delta) => {
            this.frame += Math.round(0.1 * delta * 10) / 10;
            if (this.frame >= 4)
                this.frame = 0;
            game_1.Game.drawMob(tileX, tileY, 1, 1, 1, 1, 1, 1, "Black", 0);
        };
        /**
         * Draws the logbook button on the screen.
         * @param delta The time delta since the last frame.
         */
        this.drawLogbookButton = (delta) => {
            game_1.Game.ctx.save();
            this.buttonX = levelConstants_1.LevelConstants.SCREEN_W - 2;
            this.buttonY = levelConstants_1.LevelConstants.SCREEN_H - 2.25;
            game_1.Game.drawFX(0, 0, 2, 2, this.buttonX, this.buttonY, 2, 2);
            game_1.Game.ctx.restore();
        };
        /**
         * Handles mouse down events.
         * @param x The x-coordinate of the mouse.
         * @param y The y-coordinate of the mouse.
         * @param button The mouse button pressed.
         */
        this.handleMouseDown = (x, y, button) => {
            if (button !== 0)
                return; // Only respond to left click
            if (this.isPointInLogbookButton(x, y)) {
                this.toggleOpen();
            }
        };
        /**
         * Handles mouse up events.
         * @param x The x-coordinate of the mouse.
         * @param y The y-coordinate of the mouse.
         * @param button The mouse button released.
         */
        this.handleMouseUp = (x, y, button) => {
            // Implement if needed
        };
        /**
         * Handles hold detection.
         */
        this.onHoldDetected = () => {
            // Implement if needed
        };
        /**
         * Checks if a point is within the logbook button bounds.
         * @param x The x-coordinate to check.
         * @param y The y-coordinate to check.
         * @returns True if the point is within the button bounds, else false.
         */
        this.isPointInLogbookButton = (x, y) => {
            const tX = x / gameConstants_1.GameConstants.TILESIZE;
            const tY = y / gameConstants_1.GameConstants.TILESIZE;
            return (tX >= this.buttonX &&
                tX <= this.buttonX + 2 &&
                tY >= this.buttonY &&
                tY <= this.buttonY + 2);
        };
        /**
         * Updates the logbook state each game tick.
         */
        this.tick = () => {
            if (this.isOpen) {
                // Update logbook-related logic here
            }
        };
        this.game = game;
        this.player = player;
        this.entries = [];
        this.activeEntryIndex = 0;
        this.buttonX = Math.round((Math.round(gameConstants_1.GameConstants.WIDTH / 2) + 3) / gameConstants_1.GameConstants.TILESIZE);
        this.buttonY = Math.round(10);
        this.seenEnemies = new Set();
    }
}
exports.Bestiary = Bestiary;


/***/ }),

/***/ "./src/drawable.ts":
/*!*************************!*\
  !*** ./src/drawable.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Drawable = void 0;
class Drawable {
    constructor() {
        this.drawableY = 0;
        this.draw = (delta) => { };
        this.hasBloom = false;
        this.bloomColor = "#FFFFFF";
        this.bloomAlpha = 1;
        this.softBloomAlpha = 0;
        this.updateBloom = (delta) => {
            if (this.hasBloom) {
                let diff = this.softBloomAlpha - this.bloomAlpha;
                if (Math.abs(diff) > 0.001) {
                    this.softBloomAlpha = this.softBloomAlpha - diff * 0.1 * delta;
                }
                else {
                    this.softBloomAlpha = this.bloomAlpha;
                }
            }
            else {
                this.softBloomAlpha = 0;
            }
        };
    }
}
exports.Drawable = Drawable;


/***/ }),

/***/ "./src/entity/enemy/armoredSkullEnemy.ts":
/*!***********************************************!*\
  !*** ./src/entity/enemy/armoredSkullEnemy.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ArmoredSkullEnemy = void 0;
const game_1 = __webpack_require__(/*! ../../game */ "./src/game.ts");
const astarclass_1 = __webpack_require__(/*! ../../astarclass */ "./src/astarclass.ts");
const spiketrap_1 = __webpack_require__(/*! ../../tile/spiketrap */ "./src/tile/spiketrap.ts");
const imageParticle_1 = __webpack_require__(/*! ../../particle/imageParticle */ "./src/particle/imageParticle.ts");
const enemy_1 = __webpack_require__(/*! ./enemy */ "./src/entity/enemy/enemy.ts");
class ArmoredSkullEnemy extends enemy_1.Enemy {
    constructor(room, game, x, y, drop) {
        super(room, game, x, y);
        this.REGEN_TICKS = 5;
        this.hit = () => {
            return 1;
        };
        this.hurt = (playerHitBy, damage, type = "none") => {
            this.handleEnemyCase(playerHitBy);
            let hitShield = false;
            let shieldHealth = 0;
            if (this.shielded) {
                shieldHealth = this.shield.health;
                if (shieldHealth > 0) {
                    this.shield.hurt(damage);
                    hitShield = true;
                }
            }
            this.ticksSinceFirstHit = 0;
            if (this.health == 2)
                this.unconscious = false;
            this.health -= damage;
            this.maxHealth -= shieldHealth;
            this.startHurting();
            this.healthBar.hurt();
            this.createDamageNumber(damage, type);
            this.playHitSound();
            if (this.health === 1) {
                this.unconscious = true;
                imageParticle_1.ImageParticle.spawnCluster(this.room, this.x + 0.5, this.y + 0.5, 3, 28);
            }
            else if (this.health === 2) {
                imageParticle_1.ImageParticle.spawnCluster(this.room, this.x + 0.5, this.y + 0.5, 6, 26);
            }
            else
                this.healthBar.hurt();
            if (this.health <= 0) {
                imageParticle_1.ImageParticle.spawnCluster(this.room, this.x + 0.5, this.y + 0.5, 0, 24);
                this.kill();
            }
            else
                this.hurtCallback();
        };
        this.behavior = () => {
            this.lastX = this.x;
            this.lastY = this.y;
            if (!this.dead) {
                if (this.skipNextTurns > 0) {
                    this.skipNextTurns--;
                    this.ticks++;
                    return;
                }
                if (this.health <= 1) {
                    this.unconscious = true;
                    this.ticksSinceFirstHit++;
                    if (this.ticksSinceFirstHit >= this.REGEN_TICKS) {
                        this.healthBar.hurt();
                        this.health = 2;
                        this.unconscious = false;
                    }
                    this.ticks++;
                    return;
                }
                this.ticks++;
                if (!this.seenPlayer) {
                    this.lookForPlayer();
                }
                else if (this.seenPlayer) {
                    if (this.room.playerTicked === this.targetPlayer) {
                        this.alertTicks = Math.max(0, this.alertTicks - 1);
                        let oldX = this.x;
                        let oldY = this.y;
                        let disablePositions = Array();
                        for (const e of this.room.entities) {
                            if (e !== this) {
                                disablePositions.push({ x: e.x, y: e.y });
                            }
                        }
                        for (let xx = this.x - 1; xx <= this.x + 1; xx++) {
                            for (let yy = this.y - 1; yy <= this.y + 1; yy++) {
                                if (this.room.roomArray[xx][yy] instanceof spiketrap_1.SpikeTrap &&
                                    this.room.roomArray[xx][yy].on) {
                                    disablePositions.push({ x: xx, y: yy });
                                }
                            }
                        }
                        let grid = [];
                        for (let x = 0; x < this.room.roomX + this.room.width; x++) {
                            grid[x] = [];
                            for (let y = 0; y < this.room.roomY + this.room.height; y++) {
                                if (this.room.roomArray[x] && this.room.roomArray[x][y])
                                    grid[x][y] = this.room.roomArray[x][y];
                                else
                                    grid[x][y] = false;
                            }
                        }
                        let moves = astarclass_1.astar.AStar.search(grid, this, this.targetPlayer, disablePositions, false, false, true, this.direction, undefined, undefined);
                        if (moves.length > 0) {
                            let moveX = moves[0].pos.x;
                            let moveY = moves[0].pos.y;
                            let oldDir = this.direction;
                            let player = this.targetPlayer;
                            this.facePlayer(player);
                            if (moveX > oldX)
                                this.direction = game_1.Direction.RIGHT;
                            else if (moveX < oldX)
                                this.direction = game_1.Direction.LEFT;
                            else if (moveY > oldY)
                                this.direction = game_1.Direction.DOWN;
                            else if (moveY < oldY)
                                this.direction = game_1.Direction.UP;
                            if (oldDir == this.direction) {
                                let hitPlayer = false;
                                for (const i in this.game.players) {
                                    if (this.game.rooms[this.game.players[i].levelID] === this.room &&
                                        this.game.players[i].x === moveX &&
                                        this.game.players[i].y === moveY) {
                                        this.game.players[i].hurt(this.hit(), this.name);
                                        this.drawX = 0.5 * (this.x - this.game.players[i].x);
                                        this.drawY = 0.5 * (this.y - this.game.players[i].y);
                                        if (this.game.players[i] ===
                                            this.game.players[this.game.localPlayerID])
                                            this.game.shakeScreen(10 * this.drawX, 10 * this.drawY);
                                    }
                                }
                                if (!hitPlayer) {
                                    this.tryMove(moveX, moveY);
                                    this.setDrawXY(oldX, oldY);
                                    if (this.x > oldX)
                                        this.direction = game_1.Direction.RIGHT;
                                    else if (this.x < oldX)
                                        this.direction = game_1.Direction.LEFT;
                                    else if (this.y > oldY)
                                        this.direction = game_1.Direction.DOWN;
                                    else if (this.y < oldY)
                                        this.direction = game_1.Direction.UP;
                                }
                            }
                        }
                        if (this.direction == game_1.Direction.LEFT) {
                            disablePositions.push({
                                x: this.x,
                                y: this.y + 1,
                            });
                            disablePositions.push({
                                x: this.x,
                                y: this.y - 1,
                            });
                        }
                        if (this.direction == game_1.Direction.RIGHT) {
                            disablePositions.push({
                                x: this.x,
                                y: this.y + 1,
                            });
                            disablePositions.push({
                                x: this.x,
                                y: this.y - 1,
                            });
                        }
                        if (this.direction == game_1.Direction.DOWN) {
                            disablePositions.push({
                                x: this.x + 1,
                                y: this.y,
                            });
                            disablePositions.push({
                                x: this.x - 1,
                                y: this.y,
                            });
                        }
                        if (this.direction == game_1.Direction.UP) {
                            disablePositions.push({
                                x: this.x + 1,
                                y: this.y,
                            });
                            disablePositions.push({
                                x: this.x - 1,
                                y: this.y,
                            });
                        }
                        this.makeHitWarnings();
                    }
                    let targetPlayerOffline = Object.values(this.game.offlinePlayers).indexOf(this.targetPlayer) !==
                        -1;
                    if (!this.aggro || targetPlayerOffline) {
                        let p = this.nearestPlayer();
                        if (p !== false) {
                            let [distance, player] = p;
                            if (distance <= 4 &&
                                (targetPlayerOffline ||
                                    distance < this.playerDistance(this.targetPlayer))) {
                                if (player !== this.targetPlayer) {
                                    this.targetPlayer = player;
                                    this.facePlayer(player);
                                    if (player === this.game.players[this.game.localPlayerID])
                                        this.alertTicks = 1;
                                    this.makeHitWarnings();
                                }
                            }
                        }
                    }
                }
            }
        };
        this.draw = (delta) => {
            if (this.dead)
                return;
            game_1.Game.ctx.save();
            game_1.Game.ctx.globalAlpha = this.alpha;
            if (!this.dead) {
                this.updateDrawXY(delta);
                this.tileX = 27;
                this.tileY = 16;
                if (this.health <= 2) {
                    this.tileX = 5;
                    this.tileY = 8;
                }
                if (this.health <= 1 || this.dying) {
                    this.tileX = 3;
                    this.tileY = 0;
                    if (this.ticksSinceFirstHit >= 3) {
                        this.flashingFrame += 0.1 * delta;
                        if (Math.floor(this.flashingFrame) % 2 === 0) {
                            this.tileX = 2;
                        }
                    }
                }
                this.frame += 0.1 * delta;
                if (this.frame >= 4)
                    this.frame = 0;
                if (this.hasShadow)
                    game_1.Game.drawMob(0, 0, 1, 1, this.x - this.drawX, this.y - this.drawY, 1, 1, this.room.shadeColor, this.shadeAmount());
                game_1.Game.drawMob(this.tileX +
                    (this.tileX % 5 && !this.unconscious && !this.dying
                        ? Math.floor(this.frame)
                        : 0), this.tileY + this.direction * 2, 1, 2, this.x - this.drawX, this.y - this.drawYOffset - this.drawY - this.jumpY, 1, 2, this.softShadeColor, this.shadeAmount());
            }
            if (!this.cloned) {
                if (!this.seenPlayer) {
                    this.drawSleepingZs(delta);
                }
                if (this.alertTicks > 0) {
                    this.drawExclamation(delta);
                }
            }
            game_1.Game.ctx.restore();
        };
        this.ticks = 0;
        this.frame = 0;
        this.health = 3;
        this.maxHealth = 3;
        this.tileX = 17;
        this.tileY = 16;
        this.seenPlayer = false;
        this.aggro = false;
        this.ticksSinceFirstHit = 0;
        this.flashingFrame = 0;
        this.deathParticleColor = "#ffffff";
        this.name = "armored skeleton";
        this.forwardOnlyAttack = true;
        if (drop)
            this.drop = drop;
        if (Math.random() < this.dropChance) {
            this.getDrop(["weapon", "consumable", "gem", "tool", "coin"]);
        }
    }
}
exports.ArmoredSkullEnemy = ArmoredSkullEnemy;
ArmoredSkullEnemy.difficulty = 2;
ArmoredSkullEnemy.tileX = 5;
ArmoredSkullEnemy.tileY = 8;


/***/ }),

/***/ "./src/entity/enemy/armoredzombieEnemy.ts":
/*!************************************************!*\
  !*** ./src/entity/enemy/armoredzombieEnemy.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ArmoredzombieEnemy = void 0;
// src/entity/enemy/armoredzombieEnemy.ts
const game_1 = __webpack_require__(/*! ../../game */ "./src/game.ts");
const enemy_1 = __webpack_require__(/*! ./enemy */ "./src/entity/enemy/enemy.ts");
const astarclass_1 = __webpack_require__(/*! ../../astarclass */ "./src/astarclass.ts");
const spiketrap_1 = __webpack_require__(/*! ../../tile/spiketrap */ "./src/tile/spiketrap.ts");
class ArmoredzombieEnemy extends enemy_1.Enemy {
    constructor(room, game, x, y, drop) {
        super(room, game, x, y);
        this.hit = () => {
            return 1;
        };
        this.behavior = () => {
            this.lastX = this.x;
            this.lastY = this.y;
            if (!this.dead) {
                if (this.skipNextTurns > 0) {
                    this.skipNextTurns--;
                    return;
                }
                this.ticks++;
                if (!this.seenPlayer)
                    this.lookForPlayer();
                else if (this.seenPlayer) {
                    if (this.room.playerTicked === this.targetPlayer) {
                        this.alertTicks = Math.max(0, this.alertTicks - 1);
                        let oldX = this.x;
                        let oldY = this.y;
                        let disablePositions = Array();
                        for (const e of this.room.entities) {
                            if (e !== this) {
                                disablePositions.push({ x: e.x, y: e.y });
                            }
                        }
                        for (let xx = this.x - 1; xx <= this.x + 1; xx++) {
                            for (let yy = this.y - 1; yy <= this.y + 1; yy++) {
                                if (this.room.roomArray[xx][yy] instanceof spiketrap_1.SpikeTrap &&
                                    this.room.roomArray[xx][yy].on) {
                                    // don't walk on active spiketraps
                                    disablePositions.push({ x: xx, y: yy });
                                }
                            }
                        }
                        let grid = [];
                        for (let x = 0; x < this.room.roomX + this.room.width; x++) {
                            grid[x] = [];
                            for (let y = 0; y < this.room.roomY + this.room.height; y++) {
                                if (this.room.roomArray[x] && this.room.roomArray[x][y])
                                    grid[x][y] = this.room.roomArray[x][y];
                                else
                                    grid[x][y] = false;
                            }
                        }
                        let moves = astarclass_1.astar.AStar.search(grid, this, this.targetPlayer, disablePositions, false, false, true, this.direction);
                        if (moves.length > 0) {
                            let moveX = moves[0].pos.x;
                            let moveY = moves[0].pos.y;
                            let oldDir = this.direction;
                            let player = this.targetPlayer;
                            this.facePlayer(player);
                            if (moveX > oldX)
                                this.direction = game_1.Direction.RIGHT;
                            else if (moveX < oldX)
                                this.direction = game_1.Direction.LEFT;
                            else if (moveY > oldY)
                                this.direction = game_1.Direction.DOWN;
                            else if (moveY < oldY)
                                this.direction = game_1.Direction.UP;
                            if (oldDir == this.direction) {
                                let hitPlayer = false;
                                for (const i in this.game.players) {
                                    if (this.game.rooms[this.game.players[i].levelID] === this.room &&
                                        this.game.players[i].x === moveX &&
                                        this.game.players[i].y === moveY &&
                                        oldDir == this.direction) {
                                        this.game.players[i].hurt(this.hit(), this.name);
                                        this.drawX = 0.5 * (this.x - this.game.players[i].x);
                                        this.drawY = 0.5 * (this.y - this.game.players[i].y);
                                        if (this.game.players[i] ===
                                            this.game.players[this.game.localPlayerID])
                                            this.game.shakeScreen(10 * this.drawX, 10 * this.drawY);
                                    }
                                }
                                if (!hitPlayer) {
                                    this.tryMove(moveX, moveY);
                                    this.setDrawXY(oldX, oldY);
                                    if (this.x > oldX)
                                        this.direction = game_1.Direction.RIGHT;
                                    else if (this.x < oldX)
                                        this.direction = game_1.Direction.LEFT;
                                    else if (this.y > oldY)
                                        this.direction = game_1.Direction.DOWN;
                                    else if (this.y < oldY)
                                        this.direction = game_1.Direction.UP;
                                }
                            }
                        }
                        if (this.direction == game_1.Direction.LEFT) {
                            disablePositions.push({
                                x: this.x,
                                y: this.y + 1,
                            });
                            disablePositions.push({
                                x: this.x,
                                y: this.y - 1,
                            });
                        }
                        if (this.direction == game_1.Direction.RIGHT) {
                            disablePositions.push({
                                x: this.x,
                                y: this.y + 1,
                            });
                            disablePositions.push({
                                x: this.x,
                                y: this.y - 1,
                            });
                        }
                        if (this.direction == game_1.Direction.DOWN) {
                            disablePositions.push({
                                x: this.x + 1,
                                y: this.y,
                            });
                            disablePositions.push({
                                x: this.x - 1,
                                y: this.y,
                            });
                        }
                        if (this.direction == game_1.Direction.UP) {
                            disablePositions.push({
                                x: this.x + 1,
                                y: this.y,
                            });
                            disablePositions.push({
                                x: this.x - 1,
                                y: this.y,
                            });
                        }
                        this.makeHitWarnings();
                    }
                    let targetPlayerOffline = Object.values(this.game.offlinePlayers).indexOf(this.targetPlayer) !==
                        -1;
                    if (!this.aggro || targetPlayerOffline) {
                        let p = this.nearestPlayer();
                        if (p !== false) {
                            let [distance, player] = p;
                            if (distance <= 4 &&
                                (targetPlayerOffline ||
                                    distance < this.playerDistance(this.targetPlayer))) {
                                if (player !== this.targetPlayer) {
                                    this.targetPlayer = player;
                                    this.facePlayer(player);
                                    if (player === this.game.players[this.game.localPlayerID])
                                        this.alertTicks = 1;
                                    this.makeHitWarnings();
                                }
                            }
                        }
                    }
                }
            }
        };
        this.draw = (delta) => {
            if (this.dead)
                return;
            game_1.Game.ctx.save();
            game_1.Game.ctx.globalAlpha = this.alpha;
            if (!this.dead) {
                this.updateDrawXY(delta);
                this.tileX = 27;
                this.tileY = 8;
                if (this.health <= 1 || this.dying) {
                    this.tileX = 17;
                    this.tileY = 8;
                }
                this.frame += 0.1 * delta;
                if (this.frame >= 4)
                    this.frame = 0;
                if (this.hasShadow)
                    game_1.Game.drawMob(0, 0, 1, 1, this.x - this.drawX, this.y - this.drawY, 1, 1, this.room.shadeColor, this.shadeAmount());
                game_1.Game.drawMob(this.tileX + (this.tileX === 5 ? Math.floor(this.frame) : 0), this.tileY + this.direction * 2, 1, 2, this.x - this.drawX, this.y - this.drawYOffset - this.drawY, 1, 2, this.softShadeColor, this.shadeAmount());
            }
            if (!this.cloned) {
                if (!this.seenPlayer) {
                    this.drawSleepingZs(delta);
                }
                if (this.alertTicks > 0) {
                    this.drawExclamation(delta);
                }
            }
            game_1.Game.ctx.restore();
        };
        this.ticks = 0;
        this.frame = 0;
        this.health = 2;
        this.maxHealth = 1;
        this.tileX = 17;
        this.tileY = 8;
        this.seenPlayer = false;
        this.aggro = false;
        this.deathParticleColor = "#ffffff";
        this.name = "armored zombie";
        this.forwardOnlyAttack = true;
        if (drop)
            this.drop = drop;
        if (Math.random() < this.dropChance) {
            this.getDrop([
                "weapon",
                "equipment",
                "consumable",
                "gem",
                "tool",
                "coin",
            ]);
        }
    }
}
exports.ArmoredzombieEnemy = ArmoredzombieEnemy;
ArmoredzombieEnemy.difficulty = 2;
ArmoredzombieEnemy.tileX = 17;
ArmoredzombieEnemy.tileY = 8;


/***/ }),

/***/ "./src/entity/enemy/bigKnightEnemy.ts":
/*!********************************************!*\
  !*** ./src/entity/enemy/bigKnightEnemy.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BigKnightEnemy = void 0;
const game_1 = __webpack_require__(/*! ../../game */ "./src/game.ts");
const hitWarning_1 = __webpack_require__(/*! ../../hitWarning */ "./src/hitWarning.ts");
const coin_1 = __webpack_require__(/*! ../../item/coin */ "./src/item/coin.ts");
const redgem_1 = __webpack_require__(/*! ../../item/redgem */ "./src/item/redgem.ts");
const spear_1 = __webpack_require__(/*! ../../weapon/spear */ "./src/weapon/spear.ts");
const gameConstants_1 = __webpack_require__(/*! ../../gameConstants */ "./src/gameConstants.ts");
const enemy_1 = __webpack_require__(/*! ./enemy */ "./src/entity/enemy/enemy.ts");
const random_1 = __webpack_require__(/*! ../../random */ "./src/random.ts");
class BigKnightEnemy extends enemy_1.Enemy {
    constructor(room, game, x, y, drop) {
        super(room, game, x, y);
        this.REGEN_TICKS = 5;
        this.addHitWarnings = () => {
            this.room.hitwarnings.push(new hitWarning_1.HitWarning(this.game, this.x - 1, this.y, this.x, this.y));
            this.room.hitwarnings.push(new hitWarning_1.HitWarning(this.game, this.x - 1, this.y + 1, this.x, this.y));
            this.room.hitwarnings.push(new hitWarning_1.HitWarning(this.game, this.x + 2, this.y, this.x, this.y));
            this.room.hitwarnings.push(new hitWarning_1.HitWarning(this.game, this.x + 2, this.y + 1, this.x, this.y));
            this.room.hitwarnings.push(new hitWarning_1.HitWarning(this.game, this.x, this.y - 1, this.x, this.y));
            this.room.hitwarnings.push(new hitWarning_1.HitWarning(this.game, this.x + 1, this.y - 1, this.x, this.y));
            this.room.hitwarnings.push(new hitWarning_1.HitWarning(this.game, this.x, this.y + 2, this.x, this.y));
            this.room.hitwarnings.push(new hitWarning_1.HitWarning(this.game, this.x + 1, this.y + 2, this.x, this.y));
        };
        this.hit = () => {
            return 1;
        };
        this.behavior = () => {
            this.lastX = this.x;
            this.lastY = this.y;
            if (!this.dead) {
                if (this.skipNextTurns > 0) {
                    this.skipNextTurns--;
                    return;
                }
                if (this.health == 1) {
                    this.ticksSinceFirstHit++;
                    if (this.ticksSinceFirstHit >= this.REGEN_TICKS) {
                        this.health++;
                        this.ticksSinceFirstHit = 0;
                    }
                }
                else {
                    this.ticks++;
                    if (!this.seenPlayer) {
                        let p = this.nearestPlayer();
                        if (p !== false) {
                            let [distance, player] = p;
                            if (distance <= 4) {
                                this.targetPlayer = player;
                                this.facePlayer(player);
                                this.seenPlayer = true;
                                if (player === this.game.players[this.game.localPlayerID])
                                    this.alertTicks = 1;
                                if (this.health >= 3)
                                    this.addHitWarnings();
                            }
                        }
                    }
                    else if (this.seenPlayer) {
                        if (this.room.playerTicked === this.targetPlayer) {
                            this.alertTicks = Math.max(0, this.alertTicks - 1);
                            let oldX = this.x;
                            let oldY = this.y;
                            let moveX = this.x;
                            let moveY = this.y;
                            if (this.ticks % 2 === 0) {
                                // horizontal preference
                                if (this.targetPlayer.x >= this.x + this.w)
                                    moveX++;
                                else if (this.targetPlayer.x < this.x)
                                    moveX--;
                                else if (this.targetPlayer.y >= this.y + this.h)
                                    moveY++;
                                else if (this.targetPlayer.y < this.y)
                                    moveY--;
                            }
                            else {
                                // vertical preference
                                if (this.targetPlayer.y >= this.y + this.h)
                                    moveY++;
                                else if (this.targetPlayer.y < this.y)
                                    moveY--;
                                else if (this.targetPlayer.x >= this.x + this.w)
                                    moveX++;
                                else if (this.targetPlayer.x < this.x)
                                    moveX--;
                            }
                            let hitPlayer = false;
                            if (this.health >= 3) {
                                let wouldHit = (player, moveX, moveY) => {
                                    return (player.x >= moveX &&
                                        player.x < moveX + this.w &&
                                        player.y >= moveY &&
                                        player.y < moveY + this.h);
                                };
                                for (const i in this.game.players) {
                                    if (this.game.rooms[this.game.players[i].levelID] === this.room &&
                                        wouldHit(this.game.players[i], moveX, moveY)) {
                                        this.game.players[i].hurt(this.hit(), this.name);
                                        this.drawX = 0.5 * (this.x - this.game.players[i].x);
                                        this.drawY = 0.5 * (this.y - this.game.players[i].y);
                                        if (this.game.players[i] ===
                                            this.game.players[this.game.localPlayerID])
                                            this.game.shakeScreen(10 * this.drawX, 10 * this.drawY);
                                    }
                                }
                            }
                            if (!hitPlayer) {
                                this.tryMove(moveX, moveY);
                                this.drawX = this.x - oldX;
                                this.drawY = this.y - oldY;
                                if (this.x > oldX)
                                    this.direction = game_1.Direction.RIGHT;
                                else if (this.x < oldX)
                                    this.direction = game_1.Direction.LEFT;
                                else if (this.y > oldY)
                                    this.direction = game_1.Direction.DOWN;
                                else if (this.y < oldY)
                                    this.direction = game_1.Direction.UP;
                            }
                            if (this.health < this.maxHealth) {
                                this.ticksSinceFirstHit++;
                                if (this.ticksSinceFirstHit >= this.REGEN_TICKS) {
                                    this.health++;
                                    this.ticksSinceFirstHit = 0;
                                }
                            }
                            if (this.health >= 3)
                                this.addHitWarnings();
                        }
                        let targetPlayerOffline = Object.values(this.game.offlinePlayers).indexOf(this.targetPlayer) !== -1;
                        if (!this.aggro || targetPlayerOffline) {
                            let p = this.nearestPlayer();
                            if (p !== false) {
                                let [distance, player] = p;
                                if (distance <= 4 &&
                                    (targetPlayerOffline ||
                                        distance < this.playerDistance(this.targetPlayer))) {
                                    if (player !== this.targetPlayer) {
                                        this.targetPlayer = player;
                                        this.facePlayer(player);
                                        if (player === this.game.players[this.game.localPlayerID])
                                            this.alertTicks = 1;
                                        if (this.health >= 3)
                                            this.addHitWarnings();
                                    }
                                }
                            }
                        }
                    }
                }
            }
        };
        this.draw = (delta) => {
            if (this.dead)
                return;
            game_1.Game.ctx.save();
            game_1.Game.ctx.globalAlpha = this.alpha;
            if (!this.dead) {
                this.updateDrawXY(delta);
                this.frame += 0.1 * delta;
                if (this.frame >= 4)
                    this.frame = 0;
                if (this.hasShadow)
                    game_1.Game.drawMob(18, 0, 2, 2, this.x - this.drawX, this.y - this.drawY, 2, 2, this.room.shadeColor, this.shadeAmount());
                game_1.Game.drawMob(2 * Math.floor((this.tileX + this.frame) / 2) + 1, this.tileY, 2, 4, this.x - this.drawX, this.y - 2.5 - this.drawY, 2, 4, this.softShadeColor, this.shadeAmount());
                if (!this.cloned) {
                    if (!this.seenPlayer) {
                        this.drawSleepingZs(delta, gameConstants_1.GameConstants.TILESIZE * 0.5, gameConstants_1.GameConstants.TILESIZE * -1);
                    }
                    if (this.alertTicks > 0) {
                        this.drawExclamation(delta, gameConstants_1.GameConstants.TILESIZE * 0.5, gameConstants_1.GameConstants.TILESIZE * -1);
                    }
                }
            }
            game_1.Game.ctx.restore();
        };
        this.drawTopLayer = (delta) => {
            this.drawableY = this.y;
            this.healthBar.draw(delta, this.health, this.maxHealth, this.x + 0.5, this.y, true);
        };
        this.dropLoot = () => {
            let dropOffsets = [
                { x: 0, y: 0 },
                { x: 1, y: 0 },
                { x: 0, y: 1 },
                { x: 1, y: 1 },
            ];
            for (let i = 0; i < this.drops.length; i++) {
                this.drops[i].level = this.room;
                this.drops[i].x = this.x + dropOffsets[i].x;
                this.drops[i].y = this.y + dropOffsets[i].y;
                this.room.items.push(this.drops[i]);
            }
        };
        this.w = 2;
        this.h = 2;
        this.ticks = 0;
        this.frame = 0;
        this.health = 4;
        this.maxHealth = 4;
        this.tileX = 29;
        this.tileY = 0;
        this.seenPlayer = false;
        this.aggro = false;
        this.ticksSinceFirstHit = 0;
        this.flashingFrame = 0;
        this.deathParticleColor = "#ffffff";
        this.chainPushable = false;
        this.name = "giant knight";
        this.drops = [];
        if (drop)
            this.drops.push(drop);
        while (this.drops.length < 4) {
            let dropProb = random_1.Random.rand();
            if (dropProb < 0.005)
                this.drops.push(new spear_1.Spear(this.room, this.x, this.y));
            else if (dropProb < 0.04)
                this.drops.push(new redgem_1.RedGem(this.room, this.x, this.y));
            else if (dropProb < 0.075)
                this.drops.push(new redgem_1.RedGem(this.room, this.x, this.y));
            else if (dropProb < 0.1)
                this.drops.push(new redgem_1.RedGem(this.room, this.x, this.y));
            else
                this.drops.push(new coin_1.Coin(this.room, this.x, this.y));
        }
    }
}
exports.BigKnightEnemy = BigKnightEnemy;
BigKnightEnemy.difficulty = 4;
BigKnightEnemy.tileX = 29;
BigKnightEnemy.tileY = 0;


/***/ }),

/***/ "./src/entity/enemy/bigSkullEnemy.ts":
/*!*******************************************!*\
  !*** ./src/entity/enemy/bigSkullEnemy.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BigSkullEnemy = void 0;
const game_1 = __webpack_require__(/*! ../../game */ "./src/game.ts");
const hitWarning_1 = __webpack_require__(/*! ../../hitWarning */ "./src/hitWarning.ts");
const coin_1 = __webpack_require__(/*! ../../item/coin */ "./src/item/coin.ts");
const redgem_1 = __webpack_require__(/*! ../../item/redgem */ "./src/item/redgem.ts");
const spear_1 = __webpack_require__(/*! ../../weapon/spear */ "./src/weapon/spear.ts");
const gameConstants_1 = __webpack_require__(/*! ../../gameConstants */ "./src/gameConstants.ts");
const enemy_1 = __webpack_require__(/*! ./enemy */ "./src/entity/enemy/enemy.ts");
const random_1 = __webpack_require__(/*! ../../random */ "./src/random.ts");
class BigSkullEnemy extends enemy_1.Enemy {
    constructor(room, game, x, y, drop) {
        super(room, game, x, y);
        this.REGEN_TICKS = 5;
        this.addHitWarnings = () => {
            this.room.hitwarnings.push(new hitWarning_1.HitWarning(this.game, this.x - 1, this.y, this.x, this.y));
            this.room.hitwarnings.push(new hitWarning_1.HitWarning(this.game, this.x - 1, this.y + 1, this.x, this.y));
            this.room.hitwarnings.push(new hitWarning_1.HitWarning(this.game, this.x + 2, this.y, this.x, this.y));
            this.room.hitwarnings.push(new hitWarning_1.HitWarning(this.game, this.x + 2, this.y + 1, this.x, this.y));
            this.room.hitwarnings.push(new hitWarning_1.HitWarning(this.game, this.x, this.y - 1, this.x, this.y));
            this.room.hitwarnings.push(new hitWarning_1.HitWarning(this.game, this.x + 1, this.y - 1, this.x, this.y));
            this.room.hitwarnings.push(new hitWarning_1.HitWarning(this.game, this.x, this.y + 2, this.x, this.y));
            this.room.hitwarnings.push(new hitWarning_1.HitWarning(this.game, this.x + 1, this.y + 2, this.x, this.y));
        };
        this.hit = () => {
            return 1;
        };
        this.behavior = () => {
            this.lastX = this.x;
            this.lastY = this.y;
            if (!this.dead) {
                if (this.skipNextTurns > 0) {
                    this.skipNextTurns--;
                    return;
                }
                if (this.health <= 2) {
                    this.ticksSinceFirstHit++;
                    if (this.ticksSinceFirstHit >= this.REGEN_TICKS) {
                        this.health++;
                        this.ticksSinceFirstHit = 0;
                    }
                    this.ticks++;
                }
                else {
                    this.ticks++;
                    if (!this.seenPlayer) {
                        let p = this.nearestPlayer();
                        if (p !== false) {
                            let [distance, player] = p;
                            if (distance <= 4) {
                                this.targetPlayer = player;
                                this.facePlayer(player);
                                this.seenPlayer = true;
                                if (player === this.game.players[this.game.localPlayerID])
                                    this.alertTicks = 1;
                                if (this.health >= 3)
                                    this.addHitWarnings();
                            }
                        }
                    }
                    else if (this.seenPlayer) {
                        if (this.room.playerTicked === this.targetPlayer) {
                            this.alertTicks = Math.max(0, this.alertTicks - 1);
                            let oldX = this.x;
                            let oldY = this.y;
                            let moveX = this.x;
                            let moveY = this.y;
                            if (this.ticks % 2 === 0) {
                                // horizontal preference
                                if (this.targetPlayer.x >= this.x + this.w)
                                    moveX++;
                                else if (this.targetPlayer.x < this.x)
                                    moveX--;
                                else if (this.targetPlayer.y >= this.y + this.h)
                                    moveY++;
                                else if (this.targetPlayer.y < this.y)
                                    moveY--;
                            }
                            else {
                                // vertical preference
                                if (this.targetPlayer.y >= this.y + this.h)
                                    moveY++;
                                else if (this.targetPlayer.y < this.y)
                                    moveY--;
                                else if (this.targetPlayer.x >= this.x + this.w)
                                    moveX++;
                                else if (this.targetPlayer.x < this.x)
                                    moveX--;
                            }
                            let hitPlayer = false;
                            if (this.health >= 2.5) {
                                let wouldHit = (player, moveX, moveY) => {
                                    return (player.x >= moveX &&
                                        player.x < moveX + this.w &&
                                        player.y >= moveY &&
                                        player.y < moveY + this.h);
                                };
                                for (const i in this.game.players) {
                                    if (this.game.rooms[this.game.players[i].levelID] === this.room &&
                                        wouldHit(this.game.players[i], moveX, moveY)) {
                                        this.game.players[i].hurt(this.hit(), this.name);
                                        this.drawX = 0.5 * (this.x - this.game.players[i].x);
                                        this.drawY = 0.5 * (this.y - this.game.players[i].y);
                                        if (this.game.players[i] ===
                                            this.game.players[this.game.localPlayerID])
                                            this.game.shakeScreen(10 * this.drawX, 10 * this.drawY);
                                    }
                                }
                            }
                            if (!hitPlayer) {
                                this.tryMove(moveX, moveY);
                                this.drawX = this.x - oldX;
                                this.drawY = this.y - oldY;
                                if (this.x > oldX)
                                    this.direction = game_1.Direction.RIGHT;
                                else if (this.x < oldX)
                                    this.direction = game_1.Direction.LEFT;
                                else if (this.y > oldY)
                                    this.direction = game_1.Direction.DOWN;
                                else if (this.y < oldY)
                                    this.direction = game_1.Direction.UP;
                            }
                            if (this.health < this.maxHealth) {
                                this.ticksSinceFirstHit++;
                                if (this.ticksSinceFirstHit >= this.REGEN_TICKS) {
                                    this.health++;
                                    this.ticksSinceFirstHit = 0;
                                }
                            }
                            if (this.health >= 2.5)
                                this.addHitWarnings();
                        }
                        let targetPlayerOffline = Object.values(this.game.offlinePlayers).indexOf(this.targetPlayer) !== -1;
                        if (!this.aggro || targetPlayerOffline) {
                            let p = this.nearestPlayer();
                            if (p !== false) {
                                let [distance, player] = p;
                                if (distance <= 4 &&
                                    (targetPlayerOffline ||
                                        distance < this.playerDistance(this.targetPlayer))) {
                                    if (player !== this.targetPlayer) {
                                        this.targetPlayer = player;
                                        this.facePlayer(player);
                                        if (player === this.game.players[this.game.localPlayerID])
                                            this.alertTicks = 1;
                                        if (this.health >= 3)
                                            this.addHitWarnings();
                                    }
                                }
                            }
                        }
                    }
                }
            }
        };
        this.draw = (delta) => {
            if (this.dead)
                return;
            game_1.Game.ctx.save();
            game_1.Game.ctx.globalAlpha = this.alpha;
            if (!this.dead) {
                this.updateDrawXY(delta);
                this.tileX = 21;
                this.tileY = 0;
                if (this.health === 3) {
                    this.tileX = 21;
                    this.tileY = 4;
                    if (this.ticksSinceFirstHit >= 3) {
                        this.flashingFrame += 0.1 * delta;
                        if (Math.floor(this.flashingFrame) % 2 === 0) {
                            this.tileY = 0;
                        }
                    }
                }
                else if (this.health === 2) {
                    this.tileX = 21;
                    this.tileY = 8;
                    if (this.ticksSinceFirstHit >= 3) {
                        this.flashingFrame += 0.1 * delta;
                        if (Math.floor(this.flashingFrame) % 2 === 0) {
                            this.tileY = 4;
                        }
                    }
                }
                else if (this.health === 1) {
                    this.tileX = 21;
                    this.tileY = 12;
                    if (this.ticksSinceFirstHit >= 3) {
                        this.flashingFrame += 0.1 * delta;
                        if (Math.floor(this.flashingFrame) % 2 === 0) {
                            this.tileY = 8;
                        }
                    }
                }
                this.frame += 0.1 * delta;
                if (this.frame >= 4)
                    this.frame = 0;
                if (this.hasShadow)
                    game_1.Game.drawMob(18, 0, 2, 2, this.x - this.drawX, this.y - this.drawY, 2, 2, this.room.shadeColor, this.shadeAmount());
                game_1.Game.drawMob(this.tileX + (this.tileX === 20 ? Math.floor(this.frame) * 2 : 0), this.tileY, 2, 4, this.x - this.drawX, this.y - 2.5 - this.drawY, 2, 4, this.softShadeColor, this.shadeAmount());
                if (!this.cloned) {
                    if (!this.seenPlayer) {
                        this.drawSleepingZs(delta, gameConstants_1.GameConstants.TILESIZE * 0.5, gameConstants_1.GameConstants.TILESIZE * -1);
                    }
                    if (this.alertTicks > 0) {
                        this.drawExclamation(delta, gameConstants_1.GameConstants.TILESIZE * 0.5, gameConstants_1.GameConstants.TILESIZE * -1);
                    }
                }
            }
            game_1.Game.ctx.restore();
        };
        this.drawTopLayer = (delta) => {
            this.drawableY = this.y;
            this.healthBar.draw(delta, this.health, this.maxHealth, this.x + 0.5, this.y, true);
        };
        this.dropLoot = () => {
            let dropOffsets = [
                { x: 0, y: 0 },
                { x: 1, y: 0 },
                { x: 0, y: 1 },
                { x: 1, y: 1 },
            ];
            for (let i = 0; i < this.drops.length; i++) {
                this.drops[i].level = this.room;
                this.drops[i].x = this.x + dropOffsets[i].x;
                this.drops[i].y = this.y + dropOffsets[i].y;
                this.room.items.push(this.drops[i]);
            }
        };
        this.w = 2;
        this.h = 2;
        this.ticks = 0;
        this.frame = 0;
        this.health = 4;
        this.maxHealth = 4;
        this.tileX = 21;
        this.tileY = 0;
        this.seenPlayer = false;
        this.aggro = false;
        this.ticksSinceFirstHit = 0;
        this.flashingFrame = 0;
        this.deathParticleColor = "#ffffff";
        this.chainPushable = false;
        this.name = "giant skeleton";
        this.drops = [];
        if (drop)
            this.drops.push(drop);
        while (this.drops.length < 4) {
            let dropProb = random_1.Random.rand();
            if (dropProb < 0.005)
                this.drops.push(new spear_1.Spear(this.room, this.x, this.y));
            else if (dropProb < 0.04)
                this.drops.push(new redgem_1.RedGem(this.room, this.x, this.y));
            else if (dropProb < 0.075)
                this.drops.push(new redgem_1.RedGem(this.room, this.x, this.y));
            else if (dropProb < 0.1)
                this.drops.push(new redgem_1.RedGem(this.room, this.x, this.y));
            else
                this.drops.push(new coin_1.Coin(this.room, this.x, this.y));
        }
    }
}
exports.BigSkullEnemy = BigSkullEnemy;
BigSkullEnemy.difficulty = 4;
BigSkullEnemy.tileX = 21;
BigSkullEnemy.tileY = 0;


/***/ }),

/***/ "./src/entity/enemy/bishopEnemy.ts":
/*!*****************************************!*\
  !*** ./src/entity/enemy/bishopEnemy.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BishopEnemy = void 0;
const game_1 = __webpack_require__(/*! ../../game */ "./src/game.ts");
const astarclass_1 = __webpack_require__(/*! ../../astarclass */ "./src/astarclass.ts");
const spiketrap_1 = __webpack_require__(/*! ../../tile/spiketrap */ "./src/tile/spiketrap.ts");
const door_1 = __webpack_require__(/*! ../../tile/door */ "./src/tile/door.ts");
const enemy_1 = __webpack_require__(/*! ./enemy */ "./src/entity/enemy/enemy.ts");
class BishopEnemy extends enemy_1.Enemy {
    constructor(room, game, x, y, drop) {
        super(room, game, x, y);
        this.tryMove = (x, y) => {
            let pointWouldBeIn = (someX, someY) => {
                return (someX >= x && someX < x + this.w && someY >= y && someY < y + this.h);
            };
            let enemyCollide = (enemy) => {
                if (enemy.x >= x + this.w || enemy.x + enemy.w <= x)
                    return false;
                if (enemy.y >= y + this.h || enemy.y + enemy.h <= y)
                    return false;
                return true;
            };
            for (const e of this.room.entities) {
                if (e !== this && enemyCollide(e)) {
                    return;
                }
            }
            for (const i in this.game.players) {
                if (pointWouldBeIn(this.game.players[i].x, this.game.players[i].y)) {
                    return;
                }
            }
            let tiles = [];
            for (let xx = 0; xx < this.w; xx++) {
                for (let yy = 0; yy < this.h; yy++) {
                    if (!this.room.roomArray[x + xx][y + yy].isSolid()) {
                        tiles.push(this.room.roomArray[x + xx][y + yy]);
                    }
                    else {
                        return;
                    }
                }
            }
            for (let tile of tiles) {
                tile.onCollideEnemy(this);
            }
            this.x = x;
            this.y = y;
        };
        this.hit = () => {
            return 1;
        };
        this.jump = (delta) => {
            let j = Math.max(Math.abs(this.drawX), Math.abs(this.drawY));
            let jumpY = Math.abs(Math.sin(j * Math.PI)) * this.jumpHeight;
            if (jumpY < 0.01)
                jumpY = 0;
            if (jumpY > this.jumpHeight)
                jumpY = this.jumpHeight;
            this.jumpY = jumpY;
        };
        this.behavior = () => {
            if (!this.dead) {
                if (this.skipNextTurns > 0) {
                    this.skipNextTurns--;
                    return;
                }
                this.ticks++;
                if (!this.seenPlayer)
                    this.lookForPlayer();
                else if (this.seenPlayer) {
                    if (this.room.playerTicked === this.targetPlayer) {
                        this.alertTicks = Math.max(0, this.alertTicks - 1);
                        let oldX = this.x;
                        let oldY = this.y;
                        let disablePositions = Array();
                        for (const e of this.room.entities) {
                            if (e !== this) {
                                disablePositions.push({ x: e.x, y: e.y });
                            }
                        }
                        for (let xx = this.x - 1; xx <= this.x + 1; xx++) {
                            for (let yy = this.y - 1; yy <= this.y + 1; yy++) {
                                if (this.room.roomArray[xx][yy] instanceof spiketrap_1.SpikeTrap &&
                                    this.room.roomArray[xx][yy].on) {
                                    // don't walk on active spiketraps
                                    disablePositions.push({ x: xx, y: yy });
                                }
                                if (this.room.roomArray[xx][yy] instanceof door_1.Door) {
                                    // don't walk into doorways (normally wouldn't be an issue without diagonals)
                                    disablePositions.push({ x: xx, y: yy });
                                }
                            }
                        }
                        let grid = [];
                        for (let x = 0; x < this.room.roomX + this.room.width; x++) {
                            grid[x] = [];
                            for (let y = 0; y < this.room.roomY + this.room.height; y++) {
                                if (this.room.roomArray[x] && this.room.roomArray[x][y])
                                    grid[x][y] = this.room.roomArray[x][y];
                                else
                                    grid[x][y] = false;
                            }
                        }
                        disablePositions.push({ x: this.x + 1, y: this.y });
                        disablePositions.push({ x: this.x - 1, y: this.y });
                        disablePositions.push({ x: this.x, y: this.y + 1 });
                        disablePositions.push({ x: this.x, y: this.y - 1 });
                        disablePositions.push({ x: this.x, y: this.y });
                        let moves = astarclass_1.astar.AStar.search(grid, this, this.targetPlayer, disablePositions, true);
                        moves = moves.filter((move) => {
                            const dx = Math.abs(move.pos.x - this.x);
                            const dy = Math.abs(move.pos.y - this.y);
                            return dx === 1 && dy === 1;
                        });
                        if (moves.length > 0) {
                            let moveX = moves[0].pos.x;
                            let moveY = moves[0].pos.y;
                            let hitPlayer = false;
                            for (const i in this.game.players) {
                                if (this.game.rooms[this.game.players[i].levelID] === this.room &&
                                    this.game.players[i].x === moveX &&
                                    this.game.players[i].y === moveY) {
                                    this.game.players[i].hurt(this.hit(), this.name);
                                    this.drawX = 0.5 * (this.x - this.game.players[i].x);
                                    this.drawY = 0.5 * (this.y - this.game.players[i].y);
                                    hitPlayer = true;
                                    if (this.game.players[i] ===
                                        this.game.players[this.game.localPlayerID])
                                        this.game.shakeScreen(10 * this.drawX, 10 * this.drawY);
                                }
                            }
                            if (!hitPlayer) {
                                this.tryMove(moveX, moveY);
                                this.setDrawXY(oldX, oldY);
                            }
                        }
                        this.makeHitWarnings();
                    }
                    let targetPlayerOffline = Object.values(this.game.offlinePlayers).indexOf(this.targetPlayer) !==
                        -1;
                    if (!this.aggro || targetPlayerOffline) {
                        let p = this.nearestPlayer();
                        if (p !== false) {
                            let [distance, player] = p;
                            if (distance <= 4 &&
                                (targetPlayerOffline ||
                                    distance < this.playerDistance(this.targetPlayer))) {
                                if (player !== this.targetPlayer) {
                                    this.targetPlayer = player;
                                    this.facePlayer(player);
                                    if (player === this.game.players[this.game.localPlayerID])
                                        this.alertTicks = 1;
                                    this.makeHitWarnings();
                                }
                            }
                        }
                    }
                }
            }
        };
        this.draw = (delta) => {
            if (this.dead)
                return;
            game_1.Game.ctx.save();
            game_1.Game.ctx.globalAlpha = this.alpha;
            if (!this.dead) {
                this.updateDrawXY(delta);
                this.frame += 0.1 * delta;
                if (this.frame >= 4)
                    this.frame = 0;
                if (this.hasShadow)
                    game_1.Game.drawMob(0, 0, 1, 1, this.x - this.drawX, this.y - this.drawY, 1, 1, this.room.shadeColor, this.shadeAmount());
                game_1.Game.drawMob(this.tileX + Math.floor(this.frame), this.tileY, 1, 2, this.x - this.drawX, this.y - this.drawYOffset - this.drawY - this.jumpY, 1, 2, this.softShadeColor, this.shadeAmount() * (1 + this.jumpY / 3));
            }
            if (!this.cloned) {
                if (!this.seenPlayer) {
                    this.drawSleepingZs(delta);
                }
                if (this.alertTicks > 0) {
                    this.drawExclamation(delta);
                }
            }
            game_1.Game.ctx.restore();
        };
        this.ticks = 0;
        this.frame = 0;
        this.health = 1;
        this.maxHealth = 1;
        this.tileX = 31;
        this.tileY = 8;
        this.seenPlayer = false;
        this.aggro = false;
        this.name = "bishop";
        this.jumpHeight = 1;
        this.drawMoveSpeed = 0.2;
        this.diagonalAttackRange = 1;
        this.diagonalAttack = true;
        this.orthogonalAttack = false;
        this.imageParticleX = 0;
        this.imageParticleY = 26;
        if (drop)
            this.drop = drop;
        if (Math.random() < this.dropChance) {
            this.getDrop([
                "weapon",
                "equipment",
                "consumable",
                "gem",
                "tool",
                "coin",
            ]);
        }
    }
}
exports.BishopEnemy = BishopEnemy;
BishopEnemy.difficulty = 2;
BishopEnemy.tileX = 31;
BishopEnemy.tileY = 8;


/***/ }),

/***/ "./src/entity/enemy/chargeEnemy.ts":
/*!*****************************************!*\
  !*** ./src/entity/enemy/chargeEnemy.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ChargeEnemy = exports.ChargeEnemyState = void 0;
const game_1 = __webpack_require__(/*! ../../game */ "./src/game.ts");
const hitWarning_1 = __webpack_require__(/*! ../../hitWarning */ "./src/hitWarning.ts");
const door_1 = __webpack_require__(/*! ../../tile/door */ "./src/tile/door.ts");
const genericParticle_1 = __webpack_require__(/*! ../../particle/genericParticle */ "./src/particle/genericParticle.ts");
const gameConstants_1 = __webpack_require__(/*! ../../gameConstants */ "./src/gameConstants.ts");
const enemy_1 = __webpack_require__(/*! ./enemy */ "./src/entity/enemy/enemy.ts");
var ChargeEnemyState;
(function (ChargeEnemyState) {
    ChargeEnemyState[ChargeEnemyState["IDLE"] = 0] = "IDLE";
    ChargeEnemyState[ChargeEnemyState["ALERTED"] = 1] = "ALERTED";
    ChargeEnemyState[ChargeEnemyState["CHARGING"] = 2] = "CHARGING";
})(ChargeEnemyState = exports.ChargeEnemyState || (exports.ChargeEnemyState = {}));
class ChargeEnemy extends enemy_1.Enemy {
    constructor(room, game, x, y, drop) {
        super(room, game, x, y);
        this.hit = () => {
            return 1;
        };
        this.canMoveOver = (x, y) => {
            for (const e of this.room.entities) {
                if (e !== this && x === e.x && y === e.y)
                    return false;
            }
            let t = this.room.roomArray[x][y];
            return !(t.isSolid() || t instanceof door_1.Door);
        };
        this.behavior = () => {
            this.lastX = this.x;
            this.lastY = this.y;
            if (!this.dead) {
                if (this.skipNextTurns > 0) {
                    this.skipNextTurns--;
                    return;
                }
                this.ticks++;
                if (this.state === ChargeEnemyState.IDLE) {
                    let blocked = false;
                    let dx = 0;
                    let dy = 0;
                    for (const i in this.game.players) {
                        if (this.x === this.game.players[i].x) {
                            if (this.y < this.game.players[i].y)
                                dy = 1;
                            else
                                dy = -1;
                            for (let yy = this.y; yy !== this.game.players[i].y; yy += dy) {
                                if (!this.canMoveOver(this.x, yy))
                                    blocked = true;
                            }
                        }
                        else if (this.y === this.game.players[i].y) {
                            if (this.x < this.game.players[i].x)
                                dx = 1;
                            else
                                dx = -1;
                            for (let xx = this.x; xx !== this.game.players[i].x; xx += dx) {
                                if (!this.canMoveOver(xx, this.y))
                                    blocked = true;
                            }
                        }
                        if ((dx !== 0 || dy !== 0) && !blocked) {
                            this.state = ChargeEnemyState.ALERTED;
                            this.targetX = this.x;
                            this.targetY = this.y;
                            while (this.canMoveOver(this.targetX + dx, this.targetY + dy)) {
                                this.targetX += dx;
                                this.targetY += dy;
                                if ((this.targetX === this.game.players[i].x &&
                                    this.targetY === this.game.players[i].y) ||
                                    (this.targetX === this.game.players[i].x - 1 &&
                                        this.targetY === this.game.players[i].y) ||
                                    (this.targetX === this.game.players[i].x + 1 &&
                                        this.targetY === this.game.players[i].y) ||
                                    (this.targetX === this.game.players[i].x &&
                                        this.targetY === this.game.players[i].y - 1) ||
                                    (this.targetX === this.game.players[i].x &&
                                        this.targetY === this.game.players[i].y + 1))
                                    this.room.hitwarnings.push(new hitWarning_1.HitWarning(this.game, this.targetX, this.targetY, this.x, this.y));
                            }
                            this.visualTargetX = this.targetX + 0.5 * dx;
                            this.visualTargetY = this.targetY + 0.5 * dy;
                            if (dy === 1)
                                this.visualTargetY += 0.65;
                            if (dx > 0)
                                this.direction = game_1.Direction.RIGHT;
                            else if (dx < 0)
                                this.direction = game_1.Direction.LEFT;
                            else if (dy < 0)
                                this.direction = game_1.Direction.UP;
                            else if (dy > 0)
                                this.direction = game_1.Direction.DOWN;
                            break;
                        }
                    }
                }
                else if (this.state === ChargeEnemyState.ALERTED) {
                    this.state = ChargeEnemyState.CHARGING;
                    this.trailFrame = 0;
                    for (const i in this.game.players) {
                        if ((this.y === this.game.players[i].y &&
                            ((this.x < this.game.players[i].x &&
                                this.game.players[i].x <= this.targetX) ||
                                (this.targetX <= this.game.players[i].x &&
                                    this.game.players[i].x < this.x))) ||
                            (this.x === this.game.players[i].x &&
                                ((this.y < this.game.players[i].y &&
                                    this.game.players[i].y <= this.targetY) ||
                                    (this.targetY <= this.game.players[i].y &&
                                        this.game.players[i].y < this.y)))) {
                            this.game.players[i].hurt(this.hit(), this.name);
                        }
                    }
                    this.startX = this.x;
                    this.startY = this.y;
                    this.drawX = this.targetX - this.x;
                    this.drawY = this.targetY - this.y;
                    this.x = this.targetX;
                    this.y = this.targetY;
                }
                else if (this.state === ChargeEnemyState.CHARGING) {
                    this.state = ChargeEnemyState.IDLE;
                }
            }
        };
        this.draw = (delta) => {
            if (this.dead)
                return;
            game_1.Game.ctx.save();
            game_1.Game.ctx.globalAlpha = this.alpha;
            if (!this.dead) {
                this.updateDrawXY(delta);
                this.frame += 0.1 * delta;
                if (this.frame >= 4)
                    this.frame = 0;
                if ((this.state === ChargeEnemyState.CHARGING &&
                    Math.abs(this.drawX) > 0.1) ||
                    Math.abs(this.drawY) > 0.1) {
                    genericParticle_1.GenericParticle.spawnCluster(this.room, this.x - this.drawX + 0.5, this.y - this.drawY + 0.5, "black");
                    genericParticle_1.GenericParticle.spawnCluster(this.room, this.x - this.drawX + 0.5, this.y - this.drawY + 0.5, "white");
                }
                if (this.state === ChargeEnemyState.CHARGING) {
                    this.trailFrame += 0.01 * delta;
                    let t = this.trailFrame;
                    if (t >= 0 && t <= 1) {
                        game_1.Game.ctx.strokeStyle = "white";
                        if (gameConstants_1.GameConstants.ALPHA_ENABLED)
                            game_1.Game.ctx.globalAlpha = 1 - t;
                        game_1.Game.ctx.lineWidth = gameConstants_1.GameConstants.TILESIZE * 0.25;
                        game_1.Game.ctx.beginPath();
                        game_1.Game.ctx.moveTo((this.startX + 0.5) * gameConstants_1.GameConstants.TILESIZE, (this.startY + 0.5) * gameConstants_1.GameConstants.TILESIZE);
                        game_1.Game.ctx.lineCap = "round";
                        game_1.Game.ctx.lineTo((this.x - this.drawX + 0.5) * gameConstants_1.GameConstants.TILESIZE, (this.y - this.drawY + 0.5) * gameConstants_1.GameConstants.TILESIZE);
                        game_1.Game.ctx.stroke();
                        game_1.Game.ctx.globalAlpha = 1;
                    }
                }
                if (this.hasShadow)
                    game_1.Game.drawMob(0, 0, 1, 1, this.x - this.drawX, this.y - this.drawY, 1, 1, this.room.shadeColor, this.shadeAmount());
                game_1.Game.drawMob(this.tileX + Math.floor(this.frame), this.tileY + this.direction * 2, 1, 2, this.x - this.drawX, this.y - this.drawYOffset - this.drawY, 1, 2, this.softShadeColor, this.shadeAmount());
                if (!this.cloned) {
                    if (this.state === ChargeEnemyState.IDLE) {
                        this.drawSleepingZs(delta);
                    }
                    else if (this.state === ChargeEnemyState.ALERTED) {
                        this.drawExclamation(delta);
                    }
                }
            }
            game_1.Game.ctx.restore();
        };
        this.drawTopLayer = (delta) => {
            if (this.dying)
                return;
            this.drawableY = this.y;
            this.healthBar.draw(delta, this.health, this.maxHealth, this.x, this.y, true);
            this.drawX += -0.1 * this.drawX;
            this.drawY += -0.1 * this.drawY;
            if (this.state === ChargeEnemyState.ALERTED) {
                this.trailFrame += 0.4 * delta;
                if (Math.floor(this.trailFrame) % 2 === 0) {
                    let startX = (this.x + 0.5) * gameConstants_1.GameConstants.TILESIZE;
                    let startY = (this.y - 0.25) * gameConstants_1.GameConstants.TILESIZE;
                    if (this.direction === game_1.Direction.LEFT)
                        startX -= 3;
                    else if (this.direction === game_1.Direction.RIGHT)
                        startX += 3;
                    else if (this.direction === game_1.Direction.DOWN)
                        startY += 2;
                    else if (this.direction === game_1.Direction.UP)
                        startY -= 8;
                    game_1.Game.ctx.strokeStyle = "white";
                    game_1.Game.ctx.lineWidth = gameConstants_1.GameConstants.TILESIZE * 0.25;
                    game_1.Game.ctx.beginPath();
                    game_1.Game.ctx.moveTo(Math.round(startX), Math.round(startY));
                    game_1.Game.ctx.lineCap = "round";
                    game_1.Game.ctx.lineTo(Math.round((this.visualTargetX + 0.5) * gameConstants_1.GameConstants.TILESIZE), Math.round((this.visualTargetY - 0.25) * gameConstants_1.GameConstants.TILESIZE));
                    game_1.Game.ctx.stroke();
                    game_1.Game.ctx.globalAlpha = 1;
                }
            }
        };
        this.ticks = 0;
        this.frame = 0;
        this.health = 1;
        this.maxHealth = 1;
        this.tileX = 13;
        this.tileY = 8;
        this.trailFrame = 0;
        this.alertTicks = 0;
        this.deathParticleColor = "#ffffff";
        this.lastX = this.x;
        this.lastY = this.y;
        this.name = "charge knight";
        this.state = ChargeEnemyState.IDLE;
        if (drop)
            this.drop = drop;
        if (Math.random() < this.dropChance) {
            this.getDrop([
                "weapon",
                "equipment",
                "consumable",
                "gem",
                "tool",
                "coin",
            ]);
        }
    }
}
exports.ChargeEnemy = ChargeEnemy;
ChargeEnemy.difficulty = 3;
ChargeEnemy.tileX = 13;
ChargeEnemy.tileY = 8;


/***/ }),

/***/ "./src/entity/enemy/crabEnemy.ts":
/*!***************************************!*\
  !*** ./src/entity/enemy/crabEnemy.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CrabEnemy = void 0;
const game_1 = __webpack_require__(/*! ../../game */ "./src/game.ts");
const astarclass_1 = __webpack_require__(/*! ../../astarclass */ "./src/astarclass.ts");
const spiketrap_1 = __webpack_require__(/*! ../../tile/spiketrap */ "./src/tile/spiketrap.ts");
const gameConstants_1 = __webpack_require__(/*! ../../gameConstants */ "./src/gameConstants.ts");
const enemy_1 = __webpack_require__(/*! ./enemy */ "./src/entity/enemy/enemy.ts");
class CrabEnemy extends enemy_1.Enemy {
    constructor(room, game, x, y, drop) {
        super(room, game, x, y);
        this.hit = () => {
            return 0.5;
        };
        this.behavior = () => {
            this.lastX = this.x;
            this.lastY = this.y;
            if (!this.dead) {
                if (this.skipNextTurns > 0) {
                    this.skipNextTurns--;
                    return;
                }
                if (!this.seenPlayer)
                    this.lookForPlayer();
                else if (this.seenPlayer) {
                    if (this.room.playerTicked === this.targetPlayer) {
                        this.alertTicks = Math.max(0, this.alertTicks - 1);
                        this.ticks++;
                        if (this.ticks % 2 === 1) {
                            this.rumbling = true;
                            let oldX = this.x;
                            let oldY = this.y;
                            let disablePositions = Array();
                            for (const e of this.room.entities) {
                                if (e !== this) {
                                    disablePositions.push({ x: e.x, y: e.y });
                                }
                            }
                            for (let xx = this.x - 1; xx <= this.x + 1; xx++) {
                                for (let yy = this.y - 1; yy <= this.y + 1; yy++) {
                                    if (this.room.roomArray[xx][yy] instanceof spiketrap_1.SpikeTrap &&
                                        this.room.roomArray[xx][yy].on) {
                                        // don't walk on active spiketraps
                                        disablePositions.push({ x: xx, y: yy });
                                    }
                                }
                            }
                            let grid = [];
                            for (let x = 0; x < this.room.roomX + this.room.width; x++) {
                                grid[x] = [];
                                for (let y = 0; y < this.room.roomY + this.room.height; y++) {
                                    if (this.room.roomArray[x] && this.room.roomArray[x][y])
                                        grid[x][y] = this.room.roomArray[x][y];
                                    else
                                        grid[x][y] = false;
                                }
                            }
                            this.target =
                                this.getAverageLuminance() > 0 // 0.8
                                    ? this.targetPlayer
                                    : this.room.getExtremeLuminanceFromPoint(this.x, this.y)
                                        .darkest;
                            let moves = astarclass_1.astar.AStar.search(grid, this, this.target, disablePositions, undefined, undefined, undefined, undefined, undefined, undefined, this.lastPlayerPos);
                            if (moves.length > 0) {
                                let hitPlayer = false;
                                for (const i in this.game.players) {
                                    if (this.game.rooms[this.game.players[i].levelID] === this.room &&
                                        this.game.players[i].x === moves[0].pos.x &&
                                        this.game.players[i].y === moves[0].pos.y) {
                                        this.game.players[i].hurt(this.hit(), this.name);
                                        this.drawX = 0.5 * (this.x - this.game.players[i].x);
                                        this.drawY = 0.5 * (this.y - this.game.players[i].y);
                                        if (this.game.players[i] ===
                                            this.game.players[this.game.localPlayerID])
                                            this.game.shakeScreen(10 * this.drawX, 10 * this.drawY);
                                        hitPlayer = true;
                                    }
                                }
                                if (!hitPlayer) {
                                    this.tryMove(moves[0].pos.x, moves[0].pos.y);
                                    this.setDrawXY(oldX, oldY);
                                    if (this.x > oldX)
                                        this.direction = game_1.Direction.RIGHT;
                                    else if (this.x < oldX)
                                        this.direction = game_1.Direction.LEFT;
                                    else if (this.y > oldY)
                                        this.direction = game_1.Direction.DOWN;
                                    else if (this.y < oldY)
                                        this.direction = game_1.Direction.UP;
                                }
                            }
                            this.rumbling = false;
                        }
                        else {
                            this.rumbling = true;
                            /*
                            if (
                              (this.target.x === this.targetPlayer.x &&
                                this.target.y === this.targetPlayer.y) ||
                              Utils.distance(
                                this.targetPlayer.x,
                                this.targetPlayer.y,
                                this.x,
                                this.y,
                              ) <= 2
                            )
                              */ {
                                this.makeHitWarnings();
                            }
                        }
                    }
                    let targetPlayerOffline = Object.values(this.game.offlinePlayers).indexOf(this.targetPlayer) !==
                        -1;
                    if (!this.aggro || targetPlayerOffline) {
                        let p = this.nearestPlayer();
                        if (p !== false) {
                            let [distance, player] = p;
                            if (distance <= 4 &&
                                (targetPlayerOffline ||
                                    distance < this.playerDistance(this.targetPlayer))) {
                                if (player !== this.targetPlayer) {
                                    this.targetPlayer = player;
                                    this.facePlayer(player);
                                    if (player === this.game.players[this.game.localPlayerID])
                                        this.alertTicks = 1;
                                    if (this.ticks % 2 === 0) {
                                        /*
                                        if (
                                          (this.target.x === this.targetPlayer.x &&
                                            this.target.y === this.targetPlayer.y) ||
                                          Utils.distance(
                                            this.targetPlayer.x,
                                            this.targetPlayer.y,
                                            this.x,
                                            this.y,
                                          ) <= 2
                                        ) */ {
                                            this.makeHitWarnings();
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        };
        this.draw = (delta) => {
            if (this.dead)
                return;
            game_1.Game.ctx.save();
            game_1.Game.ctx.globalAlpha = this.alpha;
            if (!this.dead) {
                this.updateDrawXY(delta);
                if (this.ticks % 2 === 0) {
                    this.tileX = 9;
                    this.tileY = 4;
                }
                else {
                    this.tileX = 8;
                    this.tileY = 4;
                }
                let rumbleX = this.rumble(this.rumbling, this.frame, this.direction).x;
                let rumbleY = this.rumble(this.rumbling, this.frame, this.direction).y;
                this.frame += 0.1 * delta;
                if (this.frame >= 4)
                    this.frame = 0;
                if (this.hasShadow)
                    game_1.Game.drawMob(0, 0, 1, 1, this.x - this.drawX, this.y - 0.25 - this.drawY, 1, 1, this.room.shadeColor, this.shadeAmount());
                game_1.Game.drawMob(this.tileX, this.tileY + this.direction, 1, 1, this.x - this.drawX + rumbleX, this.y - this.drawYOffset - this.drawY + rumbleY, 1 * this.crushX, 1 * this.crushY, this.softShadeColor, this.shadeAmount());
                if (this.crushed) {
                    this.crushAnim(delta);
                }
            }
            if (!this.cloned) {
                if (!this.seenPlayer) {
                    this.drawSleepingZs(delta, 0, 0.75 * gameConstants_1.GameConstants.TILESIZE);
                }
                if (this.alertTicks > 0) {
                    this.drawExclamation(delta, 0, 0.75 * gameConstants_1.GameConstants.TILESIZE);
                }
            }
            game_1.Game.ctx.restore();
        };
        this.ticks = 0;
        this.frame = 0;
        this.health = 1;
        this.maxHealth = 1;
        this.tileX = 8;
        this.tileY = 4;
        this.seenPlayer = false;
        this.aggro = false;
        this.name = "crab";
        this.orthogonalAttack = true;
        this.imageParticleX = 3;
        this.imageParticleY = 24;
        //if (drop) this.drop = drop;
        this.drawYOffset = 0.175;
        if (Math.random() < this.dropChance) {
            this.getDrop([
                "weapon",
                "equipment",
                "consumable",
                "gem",
                "tool",
                "coin",
            ]);
        }
    }
    get alertText() {
        return `New Enemy Spotted: Crab 
    Health: ${this.health}
    Attack Pattern: Omnidirectional
    Moves every other turn`;
    }
}
exports.CrabEnemy = CrabEnemy;
CrabEnemy.difficulty = 1;
CrabEnemy.tileX = 8;
CrabEnemy.tileY = 4;


/***/ }),

/***/ "./src/entity/enemy/enemy.ts":
/*!***********************************!*\
  !*** ./src/entity/enemy/enemy.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Enemy = void 0;
const entity_1 = __webpack_require__(/*! ../entity */ "./src/entity/entity.ts");
const game_1 = __webpack_require__(/*! ../../game */ "./src/game.ts");
const astarclass_1 = __webpack_require__(/*! ../../astarclass */ "./src/astarclass.ts");
const spiketrap_1 = __webpack_require__(/*! ../../tile/spiketrap */ "./src/tile/spiketrap.ts");
const entity_2 = __webpack_require__(/*! ../entity */ "./src/entity/entity.ts");
const eventBus_1 = __webpack_require__(/*! ../../eventBus */ "./src/eventBus.ts");
var EnemyState;
(function (EnemyState) {
    EnemyState[EnemyState["SLEEP"] = 0] = "SLEEP";
    EnemyState[EnemyState["AGGRO"] = 1] = "AGGRO";
    EnemyState[EnemyState["ATTACK"] = 2] = "ATTACK";
    EnemyState[EnemyState["DEAD"] = 3] = "DEAD";
    EnemyState[EnemyState["IDLE"] = 4] = "IDLE";
})(EnemyState || (EnemyState = {}));
class Enemy extends entity_1.Entity {
    constructor(room, game, x, y) {
        super(room, game, x, y);
        this.tryMove = (x, y, collide = true) => {
            let pointWouldBeIn = (someX, someY) => {
                return (someX >= x && someX < x + this.w && someY >= y && someY < y + this.h);
            };
            let entityCollide = (entity) => {
                if (entity.x >= x + this.w || entity.x + entity.w <= x)
                    return false;
                if (entity.y >= y + this.h || entity.y + entity.h <= y)
                    return false;
                return true;
            };
            for (const e of this.room.entities) {
                if (e !== this && entityCollide(e) && collide) {
                    return;
                }
            }
            for (const i in this.game.players) {
                if (pointWouldBeIn(this.game.players[i].x, this.game.players[i].y)) {
                    return;
                }
            }
            let tiles = [];
            for (let xx = 0; xx < this.w; xx++) {
                for (let yy = 0; yy < this.h; yy++) {
                    if (!this.room.roomArray[x + xx][y + yy].isSolid()) {
                        tiles.push(this.room.roomArray[x + xx][y + yy]);
                    }
                    else {
                        return;
                    }
                }
            }
            for (let tile of tiles) {
                tile.onCollideEnemy(this);
            }
            this.x = x;
            this.y = y;
        };
        this.hit = () => {
            return 1;
        };
        this.handleEnemyCase = (playerHitBy) => {
            if (!playerHitBy)
                return;
            if (playerHitBy) {
                this.aggro = true;
                this.targetPlayer = playerHitBy;
                //this.facePlayer(playerHitBy);
                if (playerHitBy === this.game.players[this.game.localPlayerID])
                    this.alertTicks = 2; // this is really 1 tick, it will be decremented immediately in tick()
            }
        };
        this.poison = () => {
            if (!this.status.poison.active) {
                this.status.poison = {
                    active: true,
                    hitCount: 0,
                    startTick: this.ticks,
                    effectTick: this.ticks % 3,
                };
                this.shadeColor = "#00FF00";
            }
        };
        this.bleed = () => {
            if (!this.status.bleed.active) {
                this.status.bleed = {
                    active: true,
                    hitCount: 0,
                    startTick: this.ticks,
                    effectTick: this.ticks % 1,
                };
            }
        };
        this.tickPoison = () => {
            if (this.status.poison.active && this.targetPlayer) {
                if (this.ticks % 3 === this.status.poison.effectTick &&
                    this.ticks !== this.status.poison.startTick &&
                    this.health >= 1) {
                    this.hurt(this.targetPlayer, 1, "poison");
                    this.shadeColor = "#00FF00";
                    //this.status.poison.hitCount++;
                    /*
                    if (this.status.poison.hitCount >= 2) {
                      this.status.poison = {
                        active: false,
                        hitCount: 0,
                        startTick: 0,
                        effectTick: 0,
                      };
                    }
                    */
                }
            }
        };
        this.tickBleed = () => {
            if (this.status.bleed.active && this.targetPlayer) {
                if (this.ticks % 1 === this.status.bleed.effectTick &&
                    this.ticks !== this.status.bleed.startTick) {
                    this.hurt(this.targetPlayer, 0.5, "blood");
                    //this.targetPlayer.heal(0.5);
                    this.shadeColor = "#FF0000";
                    this.status.bleed.hitCount++;
                    if (this.status.bleed.hitCount >= 4) {
                        this.status.bleed = {
                            active: false,
                            hitCount: 0,
                            startTick: 0,
                            effectTick: 0,
                        };
                    }
                }
            }
        };
        this.tick = () => {
            console.log(this.name, this.ticks);
            this.tickPoison();
            this.tickBleed();
            this.behavior();
            if (this.x !== this.lastX || this.y !== this.lastY) {
                this.emitEntityData();
            }
            if (this.shielded)
                this.shield.updateLightSourcePos();
        };
        this.lookForPlayer = (face = true) => {
            if (this.seenPlayer)
                return;
            let p = this.nearestPlayer();
            if (p !== false) {
                let [distance, player] = p;
                if (distance <= 4) {
                    this.targetPlayer = player;
                    if (face)
                        this.facePlayer(player);
                    this.seenPlayer = true;
                    let type = this.constructor;
                    eventBus_1.globalEventBus.emit("EnemySeenPlayer", {
                        enemyType: this.constructor.name,
                        enemyName: this.name,
                    });
                    if (player === this.game.players[this.game.localPlayerID])
                        this.alertTicks = 1;
                    this.makeHitWarnings();
                }
            }
        };
        this.getDisablePositions = () => {
            let disablePositions = Array();
            for (const e of this.room.entities) {
                if (e !== this) {
                    disablePositions.push({ x: e.x, y: e.y });
                }
            }
            for (let xx = this.x - 1; xx <= this.x + 1; xx++) {
                for (let yy = this.y - 1; yy <= this.y + 1; yy++) {
                    if (this.room.roomArray[xx][yy] instanceof spiketrap_1.SpikeTrap &&
                        this.room.roomArray[xx][yy].on) {
                        // Don't walk on active spike traps
                        disablePositions.push({ x: xx, y: yy });
                    }
                }
            }
            return disablePositions;
        };
        this.findPath = () => {
            let disablePositions = Array();
            for (const e of this.room.entities) {
                if (e !== this) {
                    disablePositions.push({ x: e.x, y: e.y });
                }
            }
            for (let xx = this.x - 1; xx <= this.x + 1; xx++) {
                for (let yy = this.y - 1; yy <= this.y + 1; yy++) {
                    if (this.room.roomArray[xx][yy] instanceof spiketrap_1.SpikeTrap &&
                        this.room.roomArray[xx][yy].on) {
                        // Don't walk on active spike traps
                        disablePositions.push({ x: xx, y: yy });
                    }
                }
            }
            // Create a grid of the room
            let grid = [];
            for (let x = 0; x < this.room.roomX + this.room.width; x++) {
                grid[x] = [];
                for (let y = 0; y < this.room.roomY + this.room.height; y++) {
                    if (this.room.roomArray[x] && this.room.roomArray[x][y])
                        grid[x][y] = this.room.roomArray[x][y];
                    else
                        grid[x][y] = false;
                }
            }
            // Find a path to the target player
            let moves = astarclass_1.astar.AStar.search(grid, this, this.targetPlayer, disablePositions, false, false, true, this.direction);
        };
        this.behavior = () => {
            // Store the current position
            this.lastX = this.x;
            this.lastY = this.y;
            // If the enemy is not dead
            if (!this.dead) {
                // Skip turns if necessary
                if (this.skipNextTurns > 0) {
                    this.skipNextTurns--;
                    return;
                }
                // Increment the tick counter
                this.ticks++;
                // If the enemy has not seen the player yet
                if (!this.seenPlayer)
                    this.lookForPlayer();
                else if (this.seenPlayer) {
                    // If the target player has taken their turn
                    if (this.room.playerTicked === this.targetPlayer) {
                        // Decrement alert ticks
                        this.alertTicks = Math.max(0, this.alertTicks - 1);
                        // Store the old position
                        let oldX = this.x;
                        let oldY = this.y;
                        // Create a list of positions to avoid
                        let disablePositions = Array();
                        for (const e of this.room.entities) {
                            if (e !== this) {
                                disablePositions.push({ x: e.x, y: e.y });
                            }
                        }
                        for (let xx = this.x - 1; xx <= this.x + 1; xx++) {
                            for (let yy = this.y - 1; yy <= this.y + 1; yy++) {
                                if (this.room.roomArray[xx][yy] instanceof spiketrap_1.SpikeTrap &&
                                    this.room.roomArray[xx][yy].on) {
                                    // Don't walk on active spike traps
                                    disablePositions.push({ x: xx, y: yy });
                                }
                            }
                        }
                        // Create a grid of the room
                        let grid = [];
                        for (let x = 0; x < this.room.roomX + this.room.width; x++) {
                            grid[x] = [];
                            for (let y = 0; y < this.room.roomY + this.room.height; y++) {
                                if (this.room.roomArray[x] && this.room.roomArray[x][y])
                                    grid[x][y] = this.room.roomArray[x][y];
                                else
                                    grid[x][y] = false;
                            }
                        }
                        // Find a path to the target player
                        let moves = astarclass_1.astar.AStar.search(grid, this, this.targetPlayer, disablePositions, false, false, true, this.direction);
                        // If there are moves available
                        if (moves.length > 0) {
                            let moveX = moves[0].pos.x;
                            let moveY = moves[0].pos.y;
                            let oldDir = this.direction;
                            let player = this.targetPlayer;
                            // Face the target player
                            this.facePlayer(player);
                            // Determine the new direction based on the move
                            if (moveX > oldX)
                                this.direction = game_1.Direction.RIGHT;
                            else if (moveX < oldX)
                                this.direction = game_1.Direction.LEFT;
                            else if (moveY > oldY)
                                this.direction = game_1.Direction.DOWN;
                            else if (moveY < oldY)
                                this.direction = game_1.Direction.UP;
                            // If the direction hasn't changed, attempt to move or attack
                            if (oldDir == this.direction) {
                                let hitPlayer = false;
                                for (const i in this.game.players) {
                                    if (this.game.rooms[this.game.players[i].levelID] === this.room &&
                                        this.game.players[i].x === moveX &&
                                        this.game.players[i].y === moveY) {
                                        // Attack the player if they are in the way
                                        this.game.players[i].hurt(this.hit(), this.name);
                                        this.drawX = 0.5 * (this.x - this.game.players[i].x);
                                        this.drawY = 0.5 * (this.y - this.game.players[i].y);
                                        if (this.game.players[i] ===
                                            this.game.players[this.game.localPlayerID])
                                            this.game.shakeScreen(10 * this.drawX, 10 * this.drawY);
                                    }
                                }
                                if (!hitPlayer) {
                                    // Move to the new position
                                    this.tryMove(moveX, moveY);
                                    this.setDrawXY(moveX, moveY);
                                    if (this.x > moveX)
                                        this.direction = game_1.Direction.RIGHT;
                                    else if (this.x < moveX)
                                        this.direction = game_1.Direction.LEFT;
                                    else if (this.y > moveY)
                                        this.direction = game_1.Direction.DOWN;
                                    else if (this.y < moveY)
                                        this.direction = game_1.Direction.UP;
                                }
                            }
                        }
                        // Add positions to avoid based on the current direction
                        if (this.direction == game_1.Direction.LEFT) {
                            disablePositions.push({
                                x: this.x,
                                y: this.y + 1,
                            });
                            disablePositions.push({
                                x: this.x,
                                y: this.y - 1,
                            });
                        }
                        if (this.direction == game_1.Direction.RIGHT) {
                            disablePositions.push({
                                x: this.x,
                                y: this.y + 1,
                            });
                            disablePositions.push({
                                x: this.x,
                                y: this.y - 1,
                            });
                        }
                        if (this.direction == game_1.Direction.DOWN) {
                            disablePositions.push({
                                x: this.x + 1,
                                y: this.y,
                            });
                            disablePositions.push({
                                x: this.x - 1,
                                y: this.y,
                            });
                        }
                        if (this.direction == game_1.Direction.UP) {
                            disablePositions.push({
                                x: this.x + 1,
                                y: this.y,
                            });
                            disablePositions.push({
                                x: this.x - 1,
                                y: this.y,
                            });
                        }
                        // Make hit warnings
                        this.makeHitWarnings();
                    }
                    // Check if the target player is offline
                    let targetPlayerOffline = Object.values(this.game.offlinePlayers).indexOf(this.targetPlayer) !==
                        -1;
                    // If the enemy is not aggro or the target player is offline, find a new target player
                    if (!this.aggro || targetPlayerOffline) {
                        let p = this.nearestPlayer();
                        if (p !== false) {
                            let [distance, player] = p;
                            if (distance <= 4 &&
                                (targetPlayerOffline ||
                                    distance < this.playerDistance(this.targetPlayer))) {
                                if (player !== this.targetPlayer) {
                                    this.targetPlayer = player;
                                    this.facePlayer(player);
                                    if (player === this.game.players[this.game.localPlayerID])
                                        this.alertTicks = 1;
                                    this.makeHitWarnings();
                                }
                            }
                        }
                    }
                }
            }
        };
        this.jump = (delta) => {
            let j = Math.max(Math.abs(this.drawX), Math.abs(this.drawY));
            this.jumpY = Math.abs(Math.sin(j * Math.PI)) * this.jumpHeight;
            if (this.jumpY < 0.01)
                this.jumpY = 0;
            if (this.jumpY > this.jumpHeight)
                this.jumpY = this.jumpHeight;
        };
        this.updateDrawXY = (delta) => {
            //putting this here bc i'm lazy
            this.updateHurtFrame(delta);
            this.animateDying(delta);
            if (!this.doneMoving()) {
                this.drawX *= 0.85 ** delta;
                this.drawY *= 0.85 ** delta;
                this.drawX = Math.abs(this.drawX) < 0.01 ? 0 : this.drawX;
                this.drawY = Math.abs(this.drawY) < 0.01 ? 0 : this.drawY;
                this.jump(delta);
            }
            this.updateShadeColor(delta);
        };
        this.setDrawXY = (x, y) => {
            this.drawX += this.x - x;
            this.drawY += this.y - y;
        };
        this.draw = (delta) => {
            if (!this.dead) {
                this.updateDrawXY(delta);
                this.frame += 0.1 * delta;
                if (this.frame >= 4)
                    this.frame = 0;
                if (this.hasShadow)
                    game_1.Game.drawMob(0, 0, 1, 1, this.x - this.drawX, this.y - this.drawY, 1, 1, this.room.shadeColor, this.shadeAmount());
                game_1.Game.drawMob(this.tileX + Math.floor(this.frame), this.tileY + this.direction * 2, 1, 2, this.x - this.drawX, this.y - this.drawYOffset - this.drawY - this.jumpY, 1, 2, this.softShadeColor, this.shadeAmount());
            }
            if (!this.dying) {
                if (!this.seenPlayer) {
                    this.drawSleepingZs(delta);
                }
                if (this.alertTicks > 0) {
                    this.drawExclamation(delta);
                }
            }
        };
        this.drawYOffset = 1.5;
        this.name = "";
        this.seenPlayer = false;
        this.heardPlayer = false;
        this.ticks = 0;
        this.frame = 0;
        this.health = 1;
        this.maxHealth = 1;
        this.tileX = 17;
        this.tileY = 8;
        this.aggro = false;
        this.jumpY = 0;
        this.jumpHeight = 0.3;
        //this.dir = Direction.South;
        this.name = "generic enemy";
        this.dropChance = 0.1;
        this.status = {
            poison: { active: false, hitCount: 0, startTick: 0, effectTick: 0 },
            bleed: { active: false, hitCount: 0, startTick: 0, effectTick: 0 },
        };
        this.effectStartTick = 1;
        this.startTick = 1;
        this.isEnemy = true;
        this.poisonHitCount = 0;
        this.bleedHitCount = 0;
        //this.getDrop(["weapon", "equipment", "consumable", "gem", "tool", "coin"]);
    }
    get lastPlayerPos() {
        return {
            x: this.targetPlayer.lastX,
            y: this.targetPlayer.lastY,
        };
    }
    get type() {
        return entity_2.EntityType.ENEMY;
    }
}
exports.Enemy = Enemy;
Enemy.difficulty = 1;


/***/ }),

/***/ "./src/entity/enemy/energyWizard.ts":
/*!******************************************!*\
  !*** ./src/entity/enemy/energyWizard.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EnergyWizardEnemy = exports.WizardState = void 0;
const game_1 = __webpack_require__(/*! ../../game */ "./src/game.ts");
const wizardEnemy_1 = __webpack_require__(/*! ./wizardEnemy */ "./src/entity/enemy/wizardEnemy.ts");
var WizardState;
(function (WizardState) {
    WizardState[WizardState["idle"] = 0] = "idle";
    WizardState[WizardState["attack"] = 1] = "attack";
    WizardState[WizardState["justAttacked"] = 2] = "justAttacked";
    WizardState[WizardState["teleport"] = 3] = "teleport";
})(WizardState = exports.WizardState || (exports.WizardState = {}));
class EnergyWizardEnemy extends wizardEnemy_1.WizardEnemy {
    constructor(room, game, x, y, drop) {
        super(room, game, x, y);
        this.draw = (delta) => {
            if (this.dead)
                return;
            game_1.Game.ctx.save();
            game_1.Game.ctx.globalAlpha = this.alpha;
            if (!this.dead) {
                this.updateDrawXY(delta);
                if (this.state === WizardState.attack)
                    this.tileX = 7;
                else
                    this.tileX = 6;
                if (this.hasShadow)
                    game_1.Game.drawMob(0, 0, 1, 1, this.x - this.drawX, this.y - this.drawY, 1, 1, this.room.shadeColor, this.shadeAmount());
                if (this.frame >= 0) {
                    game_1.Game.drawMob(Math.floor(this.frame) + 6, 2, 1, 2, this.x, this.y - 1.5, 1, 2, this.softShadeColor, this.shadeAmount());
                    this.frame += 0.4 * delta;
                    if (this.frame > 11)
                        this.frame = -1;
                }
                else {
                    game_1.Game.drawMob(this.tileX, this.tileY, 1, 2, this.x - this.drawX, this.y - 1.3 - this.drawY, 1, 2, this.softShadeColor, this.shadeAmount());
                }
                if (!this.cloned) {
                    if (!this.seenPlayer) {
                        this.drawSleepingZs(delta);
                    }
                    if (this.alertTicks > 0) {
                        this.drawExclamation(delta);
                    }
                }
            }
            game_1.Game.ctx.restore();
        };
        this.ticks = 0;
        this.health = 1;
        this.tileX = 6;
        this.tileY = 0;
        this.frame = 0;
        this.state = WizardState.attack;
        this.seenPlayer = false;
        this.alertTicks = 0;
        this.name = "wizard bomber";
        this.projectileColor = [0, 50, 150];
        if (drop)
            this.drop = drop;
        if (Math.random() < this.dropChance) {
            this.getDrop([
                "weapon",
                "equipment",
                "consumable",
                "gem",
                "tool",
                "coin",
            ]);
        }
    }
}
exports.EnergyWizardEnemy = EnergyWizardEnemy;
EnergyWizardEnemy.difficulty = 3;
EnergyWizardEnemy.tileX = 6;
EnergyWizardEnemy.tileY = 0;


/***/ }),

/***/ "./src/entity/enemy/fireWizard.ts":
/*!****************************************!*\
  !*** ./src/entity/enemy/fireWizard.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FireWizardEnemy = exports.WizardState = void 0;
const game_1 = __webpack_require__(/*! ../../game */ "./src/game.ts");
const floor_1 = __webpack_require__(/*! ../../tile/floor */ "./src/tile/floor.ts");
const bones_1 = __webpack_require__(/*! ../../tile/bones */ "./src/tile/bones.ts");
const deathParticle_1 = __webpack_require__(/*! ../../particle/deathParticle */ "./src/particle/deathParticle.ts");
const wizardTeleportParticle_1 = __webpack_require__(/*! ../../particle/wizardTeleportParticle */ "./src/particle/wizardTeleportParticle.ts");
const wizardFireball_1 = __webpack_require__(/*! ../../projectile/wizardFireball */ "./src/projectile/wizardFireball.ts");
const random_1 = __webpack_require__(/*! ../../random */ "./src/random.ts");
const wizardEnemy_1 = __webpack_require__(/*! ./wizardEnemy */ "./src/entity/enemy/wizardEnemy.ts");
var WizardState;
(function (WizardState) {
    WizardState[WizardState["idle"] = 0] = "idle";
    WizardState[WizardState["attack"] = 1] = "attack";
    WizardState[WizardState["justAttacked"] = 2] = "justAttacked";
    WizardState[WizardState["teleport"] = 3] = "teleport";
})(WizardState = exports.WizardState || (exports.WizardState = {}));
class FireWizardEnemy extends wizardEnemy_1.WizardEnemy {
    constructor(room, game, x, y, drop) {
        super(room, game, x, y);
        this.ATTACK_RADIUS = 5;
        this.hit = () => {
            return 1;
        };
        this.withinAttackingRangeOfPlayer = () => {
            let withinRange = false;
            for (const i in this.game.players) {
                if ((this.x - this.game.players[i].x) ** 2 +
                    (this.y - this.game.players[i].y) ** 2 <=
                    this.ATTACK_RADIUS ** 2) {
                    withinRange = true;
                }
            }
            return withinRange;
        };
        this.shuffle = (a) => {
            let j, x, i;
            for (i = a.length - 1; i > 0; i--) {
                j = Math.floor(random_1.Random.rand() * (i + 1));
                x = a[i];
                a[i] = a[j];
                a[j] = x;
            }
            return a;
        };
        this.behavior = () => {
            this.lastX = this.x;
            this.lastY = this.y;
            if (!this.dead) {
                if (this.skipNextTurns > 0) {
                    this.skipNextTurns--;
                    return;
                }
                if (!this.seenPlayer)
                    this.lookForPlayer();
                else if (this.seenPlayer) {
                    this.alertTicks = Math.max(0, this.alertTicks - 1);
                    switch (this.state) {
                        case WizardState.attack:
                            const nearestPlayerInfo = this.nearestPlayer();
                            if (nearestPlayerInfo !== false) {
                                const [distance, targetPlayer] = nearestPlayerInfo;
                                const attackLength = 20;
                                const offsets = this.calculateProjectileOffsets(targetPlayer.x, targetPlayer.y, 10);
                                this.attemptProjectilePlacement([
                                    { x: -1, y: 0 },
                                    { x: -1, y: -1 },
                                    { x: 1, y: 0 },
                                    { x: 1, y: 1 },
                                    { x: 0, y: -1 },
                                    { x: 1, y: -1 },
                                    { x: 0, y: 1 },
                                    { x: -1, y: 1 },
                                ], wizardFireball_1.WizardFireball, false);
                            }
                            this.state = WizardState.justAttacked;
                            break;
                        case WizardState.justAttacked:
                            this.state = WizardState.idle;
                            break;
                        case WizardState.teleport:
                            let oldX = this.x;
                            let oldY = this.y;
                            let min = 100000;
                            let bestPos;
                            let emptyTiles = this.shuffle(this.room.getEmptyTiles());
                            emptyTiles = emptyTiles.filter((tile) => !this.room.projectiles.some((projectile) => projectile.x === tile.x && projectile.y === tile.y));
                            let optimalDist = game_1.Game.randTable([2, 2, 3, 3, 3, 3, 3], random_1.Random.rand);
                            // pick a random player to target
                            let player_ids = [];
                            for (const i in this.game.players)
                                player_ids.push(i);
                            let target_player_id = game_1.Game.randTable(player_ids, random_1.Random.rand);
                            for (let t of emptyTiles) {
                                let newPos = t;
                                let dist = Math.abs(newPos.x - this.game.players[target_player_id].x) +
                                    Math.abs(newPos.y - this.game.players[target_player_id].y);
                                if (Math.abs(dist - optimalDist) < Math.abs(min - optimalDist)) {
                                    min = dist;
                                    bestPos = newPos;
                                }
                            }
                            this.tryMove(bestPos.x, bestPos.y);
                            this.drawX = this.x - oldX;
                            this.drawY = this.y - oldY;
                            this.frame = 0; // trigger teleport animation
                            this.room.particles.push(new wizardTeleportParticle_1.WizardTeleportParticle(oldX, oldY));
                            if (this.withinAttackingRangeOfPlayer()) {
                                this.state = WizardState.attack;
                            }
                            else {
                                this.state = WizardState.idle;
                            }
                            break;
                        case WizardState.idle:
                            this.state = WizardState.teleport;
                            break;
                    }
                }
            }
        };
        this.draw = (delta) => {
            this.frame += 0.1 * delta;
            if (this.frame >= 4)
                this.frame = 0;
            if (!this.dead) {
                this.updateDrawXY(delta);
                if (this.hasShadow)
                    game_1.Game.drawMob(0, 0, 1, 1, this.x - this.drawX, this.y - this.drawY, 1, 1, this.room.shadeColor, this.shadeAmount());
                if (this.frame >= 0) {
                    game_1.Game.drawMob(this.tileX + Math.floor(this.frame), this.tileY, 1, 2, this.x, this.y - 1.3, 1, 2, this.softShadeColor, this.shadeAmount());
                }
                else {
                    game_1.Game.drawMob(this.tileX, this.tileY, 1, 2, this.x - this.drawX, this.y - 1.3 - this.drawY, 1, 2, this.softShadeColor, this.shadeAmount());
                }
                if (!this.seenPlayer) {
                    this.drawSleepingZs(delta);
                }
                if (this.alertTicks > 0) {
                    this.drawExclamation(delta);
                }
            }
        };
        this.kill = () => {
            if (this.room.roomArray[this.x][this.y] instanceof floor_1.Floor) {
                let b = new bones_1.Bones(this.room, this.x, this.y);
                b.skin = this.room.roomArray[this.x][this.y].skin;
                this.room.roomArray[this.x][this.y] = b;
            }
            this.dead = true;
            this.room.particles.push(new deathParticle_1.DeathParticle(this.x, this.y));
            this.dropLoot();
        };
        this.ticks = 0;
        this.health = 1;
        this.tileX = 35;
        this.tileY = 8;
        this.frame = 0;
        this.state = WizardState.attack;
        this.seenPlayer = false;
        this.alertTicks = 0;
        this.name = "fire wizard";
        this.projectileColor = [200, 20, 0];
        if (drop)
            this.drop = drop;
        if (Math.random() < this.dropChance) {
            this.getDrop([
                "weapon",
                "equipment",
                "consumable",
                "gem",
                "tool",
                "coin",
            ]);
        }
    }
}
exports.FireWizardEnemy = FireWizardEnemy;
FireWizardEnemy.difficulty = 3;
FireWizardEnemy.tileX = 35;
FireWizardEnemy.tileY = 8;


/***/ }),

/***/ "./src/entity/enemy/frogEnemy.ts":
/*!***************************************!*\
  !*** ./src/entity/enemy/frogEnemy.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FrogEnemy = void 0;
const game_1 = __webpack_require__(/*! ../../game */ "./src/game.ts");
const astarclass_1 = __webpack_require__(/*! ../../astarclass */ "./src/astarclass.ts");
const hitWarning_1 = __webpack_require__(/*! ../../hitWarning */ "./src/hitWarning.ts");
const spiketrap_1 = __webpack_require__(/*! ../../tile/spiketrap */ "./src/tile/spiketrap.ts");
const coin_1 = __webpack_require__(/*! ../../item/coin */ "./src/item/coin.ts");
const enemy_1 = __webpack_require__(/*! ./enemy */ "./src/entity/enemy/enemy.ts");
const utils_1 = __webpack_require__(/*! ../../utils */ "./src/utils.ts");
class FrogEnemy extends enemy_1.Enemy {
    constructor(room, game, x, y, drop) {
        super(room, game, x, y);
        this.hit = () => {
            return 0.5;
        };
        this.behavior = () => {
            this.lastX = this.x;
            this.lastY = this.y;
            this.tileX = 1;
            this.frameLength = 3;
            this.animationSpeed = 0.1;
            if (!this.dead) {
                if (this.skipNextTurns > 0) {
                    this.skipNextTurns--;
                    return;
                }
                if (!this.seenPlayer) {
                    this.tileX = 12;
                    this.lookForPlayer();
                }
                else if (this.seenPlayer) {
                    this.tileX = 1;
                    if (this.room.playerTicked === this.targetPlayer) {
                        this.alertTicks = Math.max(0, this.alertTicks - 1);
                        this.ticks++;
                        if (this.ticks % 2 === 1) {
                            this.rumbling = true;
                            let oldX = this.x;
                            let oldY = this.y;
                            let disablePositions = Array();
                            for (const e of this.room.entities) {
                                if (e !== this) {
                                    disablePositions.push({ x: e.x, y: e.y });
                                }
                            }
                            for (let xx = this.x - 1; xx <= this.x + 1; xx++) {
                                for (let yy = this.y - 1; yy <= this.y + 1; yy++) {
                                    if (this.room.roomArray[xx][yy] instanceof spiketrap_1.SpikeTrap &&
                                        this.room.roomArray[xx][yy].on) {
                                        // don't walk on active spiketraps
                                        disablePositions.push({ x: xx, y: yy });
                                    }
                                }
                            }
                            let grid = [];
                            for (let x = 0; x < this.room.roomX + this.room.width; x++) {
                                grid[x] = [];
                                for (let y = 0; y < this.room.roomY + this.room.height; y++) {
                                    if (this.room.roomArray[x] && this.room.roomArray[x][y])
                                        grid[x][y] = this.room.roomArray[x][y];
                                    else
                                        grid[x][y] = false;
                                }
                            }
                            let targetPosition = {
                                x: this.targetPlayer.x,
                                y: this.targetPlayer.y,
                            };
                            let dx = this.targetPlayer.x - this.x;
                            let dy = this.targetPlayer.y - this.y;
                            if ((dx === 0 && dy <= 1) ||
                                (dx <= 1 && dy === 0) ||
                                (dx === 0 && dy >= -1) ||
                                (dx >= -1 && dy === 0)) {
                                let jumpOverX = this.targetPlayer.x + dx;
                                let jumpOverY = this.targetPlayer.y + dy;
                                if (this.room.roomArray[jumpOverX] &&
                                    this.room.roomArray[jumpOverX][jumpOverY]) {
                                    if (!this.room.roomArray[jumpOverX][jumpOverY].isSolid()) {
                                        targetPosition = {
                                            x: jumpOverX,
                                            y: jumpOverY,
                                        };
                                    }
                                }
                            }
                            let moves = astarclass_1.astar.AStar.search(grid, this, targetPosition, disablePositions, false, false, false, undefined, undefined, false, this.lastPlayerPos);
                            //console.log(moves); //DON'T REMOVE THIS
                            if (moves[1]) {
                                let hitPlayer = false;
                                for (const i in this.game.players) {
                                    if (this.game.rooms[this.game.players[i].levelID] === this.room &&
                                        this.game.players[i].x === moves[1].pos.x &&
                                        this.game.players[i].y === moves[1].pos.y) {
                                        this.game.players[i].hurt(this.hit(), this.name);
                                        this.drawX += 1.5 * (this.x - this.game.players[i].x);
                                        this.drawY += 1.5 * (this.y - this.game.players[i].y);
                                        if (this.game.players[i] ===
                                            this.game.players[this.game.localPlayerID])
                                            this.game.shakeScreen(5 * this.drawX, 5 * this.drawY);
                                        hitPlayer = true;
                                    }
                                }
                                if (!hitPlayer) {
                                    if (moves.length > 1) {
                                        let moveX = moves[1].pos.x;
                                        let moveY = moves[1].pos.y;
                                        this.tryMove(moveX, moveY);
                                        this.setDrawXY(this.lastX, this.lastY);
                                        if (this.jumping) {
                                            this.frame = 8;
                                            this.animationSpeed = 1;
                                        }
                                        if (this.x > moveX)
                                            this.direction = game_1.Direction.RIGHT;
                                        else if (this.x < moveX)
                                            this.direction = game_1.Direction.LEFT;
                                        else if (this.y > moveY)
                                            this.direction = game_1.Direction.DOWN;
                                        else if (this.y < moveY)
                                            this.direction = game_1.Direction.UP;
                                    }
                                }
                            }
                            this.rumbling = false;
                        }
                        else {
                            this.makeHitWarnings();
                            this.rumbling = true;
                            this.tileX = 3;
                            this.frame = 0;
                            this.frameLength = 2;
                            this.animationSpeed = 0.2;
                        }
                    }
                    let targetPlayerOffline = Object.values(this.game.offlinePlayers).indexOf(this.targetPlayer) !==
                        -1;
                    if (!this.aggro || targetPlayerOffline) {
                        let p = this.nearestPlayer();
                        if (p !== false) {
                            let [distance, player] = p;
                            if (distance <= 4 &&
                                (targetPlayerOffline ||
                                    distance < this.playerDistance(this.targetPlayer))) {
                                if (player !== this.targetPlayer) {
                                    this.targetPlayer = player;
                                    this.facePlayer(player);
                                    if (player === this.game.players[this.game.localPlayerID])
                                        this.alertTicks = 1;
                                    if (this.ticks % 2 === 0) {
                                        this.makeHitWarnings();
                                    }
                                }
                            }
                        }
                    }
                }
            }
        };
        this.jump = (delta) => {
            //console.log(`this.drawX, this.drawY: ${this.drawX}, ${this.drawY}`);
            if (this.jumping) {
                let j = Math.max(Math.abs(this.drawX), Math.abs(this.drawY));
                if (j > 1) {
                    this.jumpDistance = 2;
                    this.drawMoveSpeed = 0.2;
                }
                this.jumpY =
                    Math.sin((j / this.jumpDistance) * Math.PI) * this.jumpHeight;
                if (this.jumpY < 0.01 && this.jumpY > -0.01) {
                    this.jumpY = 0;
                    this.jumpDistance = 1;
                    this.drawMoveSpeed = 0.2;
                }
                if (this.jumpY > this.jumpHeight)
                    this.jumpY = this.jumpHeight;
            }
        };
        this.makeHitWarnings = () => {
            const cullFactor = 0.25;
            const player = this.getPlayer();
            const orthogonal = this.orthogonalAttack;
            const diagonal = this.diagonalAttack;
            const forwardOnly = this.forwardOnlyAttack;
            const direction = this.direction;
            const orthoRange = this.attackRange;
            const diagRange = this.diagonalAttackRange;
            const generateOffsets = (isOrthogonal, range) => {
                const baseOffsets = isOrthogonal
                    ? [
                        [-2, 0],
                        [2, 0],
                        [0, -2],
                        [0, 2],
                    ]
                    : [
                        [-1, -1],
                        [1, 1],
                        [1, -1],
                        [-1, 1],
                    ];
                return baseOffsets.flatMap(([dx, dy]) => Array.from({ length: range }, (_, i) => [(i + 1) * dx, (i + 1) * dy]));
            };
            const directionOffsets = {
                [game_1.Direction.LEFT]: [-1, 0],
                [game_1.Direction.RIGHT]: [1, 0],
                [game_1.Direction.UP]: [0, -1],
                [game_1.Direction.DOWN]: [0, 1],
            };
            let offsets = [];
            if (forwardOnly) {
                const [dx, dy] = directionOffsets[direction];
                offsets = Array.from({ length: orthoRange }, (_, i) => [
                    (i + 1) * dx,
                    (i + 1) * dy,
                ]);
            }
            else {
                if (orthogonal)
                    offsets.push(...generateOffsets(true, orthoRange));
                if (diagonal)
                    offsets.push(...generateOffsets(false, diagRange));
            }
            const warningCoordinates = offsets
                .map(([dx, dy]) => ({
                x: dx,
                y: dy,
                distance: utils_1.Utils.distance(dx, dy, player.x - this.x, player.y - this.y),
            }))
                .sort((a, b) => a.distance - b.distance);
            const keepCount = Math.ceil(warningCoordinates.length * (1 - cullFactor));
            const culledWarnings = warningCoordinates.slice(0, keepCount);
            culledWarnings.forEach(({ x, y }) => {
                const targetX = this.x + x;
                const targetY = this.y + y;
                if (this.isWithinRoomBounds(targetX, targetY)) {
                    const hitWarning = new hitWarning_1.HitWarning(this.game, targetX, targetY, this.x, this.y, true, false, this);
                    this.room.hitwarnings.push(hitWarning);
                    //this.hitWarnings.push(hitWarning);
                }
            });
        };
        this.draw = (delta) => {
            if (this.dead)
                return;
            game_1.Game.ctx.save();
            game_1.Game.ctx.globalAlpha = this.alpha;
            if (!this.dead) {
                this.updateDrawXY(delta);
                this.frame += this.animationSpeed * delta;
                if (this.frame >= this.frameLength) {
                    this.frame = 0;
                }
                let rumbleX = this.rumble(this.rumbling, this.frame).x;
                let rumbleY = this.rumble(this.rumbling, this.frame).y;
                if (this.drawX !== 0 || this.drawY !== 0) {
                    this.jumping = true;
                }
                else {
                    this.jumping = false;
                }
                if (this.jumping) {
                    this.frameLength = 10;
                    this.animationSpeed = 0.4;
                }
                else {
                    this.frameLength = 3;
                    this.animationSpeed = 0.1;
                }
                if (this.hasShadow)
                    game_1.Game.drawMob(0, 0, 1, 1, this.x - this.drawX, this.y - this.drawY, 1, 1, this.room.shadeColor, this.shadeAmount());
                game_1.Game.drawMob(this.tileX +
                    (this.tileX !== 12 && !this.rumbling ? Math.floor(this.frame) : 0), this.tileY /*+ this.direction * 2,*/, 1, 2, this.x + rumbleX - this.drawX, this.y - this.drawYOffset - this.drawY - this.jumpY, 1, 2, this.softShadeColor, this.shadeAmount());
            }
            if (!this.cloned) {
                if (!this.seenPlayer) {
                    this.drawSleepingZs(delta);
                }
                if (this.alertTicks > 0) {
                    this.drawExclamation(delta);
                }
            }
            game_1.Game.ctx.restore();
        };
        this.ticks = 0;
        this.frame = 0;
        this.health = 1;
        this.maxHealth = 1;
        this.tileX = 12;
        this.tileY = 16;
        this.seenPlayer = false;
        this.aggro = false;
        this.deathParticleColor = "#ffffff";
        this.frameLength = 3;
        this.startFrame = 0;
        this.animationSpeed = 0.1;
        this.tickCount = 0;
        this.jumping = false;
        this.jumpDistance = 1;
        this.drop = drop ? drop : new coin_1.Coin(this.room, this.x, this.y);
        this.name = "frog";
        this.orthogonalAttack = true;
        this.diagonalAttack = true;
        this.jumpHeight = 1;
        this.drawMoveSpeed = 0.2;
        this.imageParticleX = 3;
        this.imageParticleY = 30;
        if (drop)
            this.drop = drop;
        if (Math.random() < this.dropChance) {
            this.getDrop(["weapon", "consumable", "gem", "tool", "coin", "poison"]);
        }
    }
}
exports.FrogEnemy = FrogEnemy;
FrogEnemy.difficulty = 1;
FrogEnemy.tileX = 12;
FrogEnemy.tileY = 16;


/***/ }),

/***/ "./src/entity/enemy/knightEnemy.ts":
/*!*****************************************!*\
  !*** ./src/entity/enemy/knightEnemy.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.KnightEnemy = void 0;
const game_1 = __webpack_require__(/*! ../../game */ "./src/game.ts");
const astarclass_1 = __webpack_require__(/*! ../../astarclass */ "./src/astarclass.ts");
const spiketrap_1 = __webpack_require__(/*! ../../tile/spiketrap */ "./src/tile/spiketrap.ts");
const enemy_1 = __webpack_require__(/*! ./enemy */ "./src/entity/enemy/enemy.ts");
class KnightEnemy extends enemy_1.Enemy {
    constructor(room, game, x, y, drop) {
        super(room, game, x, y);
        this.hit = () => {
            return 1;
        };
        this.behavior = () => {
            this.lastX = this.x;
            this.lastY = this.y;
            if (!this.dead) {
                if (this.skipNextTurns > 0) {
                    this.skipNextTurns--;
                    return;
                }
                if (!this.seenPlayer) {
                    const result = this.nearestPlayer();
                    if (result !== false) {
                        let [distance, p] = result;
                        if (distance < 4) {
                            this.rumbling = true;
                            this.seenPlayer = true;
                            this.targetPlayer = p;
                            this.facePlayer(p);
                            if (p === this.game.players[this.game.localPlayerID])
                                this.alertTicks = 1;
                            this.makeHitWarnings();
                        }
                    }
                }
                else if (this.seenPlayer) {
                    if (this.room.playerTicked === this.targetPlayer) {
                        this.alertTicks = Math.max(0, this.alertTicks - 1);
                        this.ticks++;
                        if (this.ticks % 2 === 1) {
                            this.rumbling = true;
                            let oldX = this.x;
                            let oldY = this.y;
                            let disablePositions = Array();
                            for (const e of this.room.entities) {
                                if (e !== this) {
                                    disablePositions.push({ x: e.x, y: e.y });
                                }
                            }
                            for (let xx = this.x - 1; xx <= this.x + 1; xx++) {
                                for (let yy = this.y - 1; yy <= this.y + 1; yy++) {
                                    if (this.room.roomArray[xx][yy] instanceof spiketrap_1.SpikeTrap &&
                                        this.room.roomArray[xx][yy].on) {
                                        // don't walk on active spiketraps
                                        disablePositions.push({ x: xx, y: yy });
                                    }
                                }
                            }
                            let grid = [];
                            for (let x = 0; x < this.room.roomX + this.room.width; x++) {
                                grid[x] = [];
                                for (let y = 0; y < this.room.roomY + this.room.height; y++) {
                                    if (this.room.roomArray[x] && this.room.roomArray[x][y])
                                        grid[x][y] = this.room.roomArray[x][y];
                                    else
                                        grid[x][y] = false;
                                }
                            }
                            let moves = astarclass_1.astar.AStar.search(grid, this, this.targetPlayer, disablePositions, undefined, undefined, undefined, undefined, undefined, undefined, this.lastPlayerPos);
                            if (moves.length > 0) {
                                let hitPlayer = false;
                                for (const i in this.game.players) {
                                    if (this.game.rooms[this.game.players[i].levelID] === this.room &&
                                        this.game.players[i].x === moves[0].pos.x &&
                                        this.game.players[i].y === moves[0].pos.y) {
                                        this.game.players[i].hurt(this.hit(), this.name);
                                        this.drawX = 0.5 * (this.x - this.game.players[i].x);
                                        this.drawY = 0.5 * (this.y - this.game.players[i].y);
                                        if (this.game.players[i] ===
                                            this.game.players[this.game.localPlayerID])
                                            this.game.shakeScreen(10 * this.drawX, 10 * this.drawY);
                                        hitPlayer = true;
                                    }
                                }
                                if (!hitPlayer) {
                                    this.tryMove(moves[0].pos.x, moves[0].pos.y);
                                    this.setDrawXY(oldX, oldY);
                                    if (this.x > oldX)
                                        this.direction = game_1.Direction.RIGHT;
                                    else if (this.x < oldX)
                                        this.direction = game_1.Direction.LEFT;
                                    else if (this.y > oldY)
                                        this.direction = game_1.Direction.DOWN;
                                    else if (this.y < oldY)
                                        this.direction = game_1.Direction.UP;
                                }
                            }
                            this.rumbling = false;
                        }
                        else {
                            this.rumbling = true;
                            this.makeHitWarnings();
                        }
                    }
                    let targetPlayerOffline = Object.values(this.game.offlinePlayers).indexOf(this.targetPlayer) !==
                        -1;
                    if (!this.aggro || targetPlayerOffline) {
                        let p = this.nearestPlayer();
                        if (p !== false) {
                            let [distance, player] = p;
                            if (distance <= 4 &&
                                (targetPlayerOffline ||
                                    distance < this.playerDistance(this.targetPlayer))) {
                                if (player !== this.targetPlayer) {
                                    this.targetPlayer = player;
                                    this.facePlayer(player);
                                    if (player === this.game.players[this.game.localPlayerID])
                                        this.alertTicks = 1;
                                    if (this.ticks % 2 === 0) {
                                        this.rumbling = true;
                                        this.makeHitWarnings();
                                    }
                                }
                            }
                        }
                    }
                }
            }
        };
        this.draw = (delta) => {
            if (this.dead)
                return;
            game_1.Game.ctx.save();
            game_1.Game.ctx.globalAlpha = this.alpha;
            let rumbleX = this.rumble(this.rumbling, this.frame).x;
            let rumbleY = this.rumble(this.rumbling, this.frame, this.direction).y;
            if (!this.dead) {
                this.updateDrawXY(delta);
                if (this.ticks % 2 === 0) {
                    this.tileX = 9;
                    this.tileY = 8;
                }
                else {
                    this.tileX = 4;
                    this.tileY = 0;
                }
                this.frame += 0.1 * delta;
                if (this.frame >= 4)
                    this.frame = 0;
                if (this.hasShadow)
                    game_1.Game.drawMob(0, 0, 1, 1, this.x - this.drawX, this.y - this.drawY, 1, 1, this.room.shadeColor, this.shadeAmount());
                game_1.Game.drawMob(this.tileX + (this.tileX === 4 ? 0 : Math.floor(this.frame)), this.tileY + this.direction * 2, 1, 2, this.x - this.drawX + rumbleX, this.y -
                    this.drawYOffset -
                    this.drawY +
                    (this.tileX === 4 ? 0.1875 : 0), 1, 2, this.softShadeColor, this.shadeAmount());
            }
            if (!this.cloned) {
                if (!this.seenPlayer) {
                    this.drawSleepingZs(delta);
                }
                if (this.alertTicks > 0) {
                    this.drawExclamation(delta);
                }
            }
            game_1.Game.ctx.restore();
        };
        this.ticks = 0;
        this.frame = 0;
        this.health = 2;
        this.maxHealth = 2;
        this.tileX = 9;
        this.tileY = 8;
        this.seenPlayer = false;
        this.aggro = false;
        this.deathParticleColor = "#ffffff";
        this.lastX = this.x;
        this.lastY = this.y;
        this.name = "burrow knight";
        this.orthogonalAttack = true;
        this.imageParticleX = 3;
        this.imageParticleY = 29;
        if (drop)
            this.drop = drop;
        if (Math.random() < this.dropChance) {
            this.getDrop([
                "weapon",
                "equipment",
                "consumable",
                "gem",
                "tool",
                "coin",
            ]);
        }
    }
}
exports.KnightEnemy = KnightEnemy;
KnightEnemy.difficulty = 2;
KnightEnemy.tileX = 9;
KnightEnemy.tileY = 8;


/***/ }),

/***/ "./src/entity/enemy/mummyEnemy.ts":
/*!****************************************!*\
  !*** ./src/entity/enemy/mummyEnemy.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MummyEnemy = void 0;
const game_1 = __webpack_require__(/*! ../../game */ "./src/game.ts");
const astarclass_1 = __webpack_require__(/*! ../../astarclass */ "./src/astarclass.ts");
const spiketrap_1 = __webpack_require__(/*! ../../tile/spiketrap */ "./src/tile/spiketrap.ts");
const enemy_1 = __webpack_require__(/*! ./enemy */ "./src/entity/enemy/enemy.ts");
class MummyEnemy extends enemy_1.Enemy {
    constructor(room, game, x, y, drop) {
        super(room, game, x, y);
        this.hit = () => {
            return 1;
        };
        this.behavior = () => {
            // Store the current position
            this.lastX = this.x;
            this.lastY = this.y;
            // If the enemy is not dead
            if (!this.dead) {
                // Skip turns if necessary
                if (this.skipNextTurns > 0) {
                    this.skipNextTurns--;
                    return;
                }
                // Increment the tick counter
                this.ticks++;
                // If the enemy has not seen the player yet
                if (!this.seenPlayer)
                    this.lookForPlayer();
                else if (this.seenPlayer) {
                    // If the target player has taken their turn
                    if (this.room.playerTicked === this.targetPlayer) {
                        // Decrement alert ticks
                        this.alertTicks = Math.max(0, this.alertTicks - 1);
                        // Store the old position
                        let oldX = this.x;
                        let oldY = this.y;
                        // Create a list of positions to avoid
                        let disablePositions = Array();
                        for (const e of this.room.entities) {
                            if (e !== this) {
                                disablePositions.push({ x: e.x, y: e.y });
                            }
                        }
                        for (let xx = this.x - 1; xx <= this.x + 1; xx++) {
                            for (let yy = this.y - 1; yy <= this.y + 1; yy++) {
                                if (this.room.roomArray[xx][yy] instanceof spiketrap_1.SpikeTrap &&
                                    this.room.roomArray[xx][yy].on) {
                                    // Don't walk on active spike traps
                                    disablePositions.push({ x: xx, y: yy });
                                }
                            }
                        }
                        // Create a grid of the room
                        let grid = [];
                        for (let x = 0; x < this.room.roomX + this.room.width; x++) {
                            grid[x] = [];
                            for (let y = 0; y < this.room.roomY + this.room.height; y++) {
                                if (this.room.roomArray[x] && this.room.roomArray[x][y])
                                    grid[x][y] = this.room.roomArray[x][y];
                                else
                                    grid[x][y] = false;
                            }
                        }
                        // Find a path to the target player
                        let moves = astarclass_1.astar.AStar.search(grid, this, this.targetPlayer, disablePositions, false, false, true, this.direction);
                        // If there are moves available
                        if (moves.length > 0) {
                            let moveX = moves[0].pos.x;
                            let moveY = moves[0].pos.y;
                            let oldDir = this.direction;
                            let player = this.targetPlayer;
                            // Face the target player
                            this.facePlayer(player);
                            // Determine the new direction based on the move
                            if (moveX > oldX)
                                this.direction = game_1.Direction.RIGHT;
                            else if (moveX < oldX)
                                this.direction = game_1.Direction.LEFT;
                            else if (moveY > oldY)
                                this.direction = game_1.Direction.DOWN;
                            else if (moveY < oldY)
                                this.direction = game_1.Direction.UP;
                            // If the direction hasn't changed, attempt to move or attack
                            if (oldDir == this.direction) {
                                let hitPlayer = false;
                                for (const i in this.game.players) {
                                    if (this.game.rooms[this.game.players[i].levelID] === this.room &&
                                        this.game.players[i].x === moveX &&
                                        this.game.players[i].y === moveY) {
                                        // Attack the player if they are in the way
                                        this.game.players[i].hurt(this.hit(), this.name);
                                        this.drawX = 0.5 * (this.x - this.game.players[i].x);
                                        this.drawY = 0.5 * (this.y - this.game.players[i].y);
                                        if (this.game.players[i] ===
                                            this.game.players[this.game.localPlayerID])
                                            this.game.shakeScreen(10 * this.drawX, 10 * this.drawY);
                                    }
                                }
                                if (!hitPlayer) {
                                    // Move to the new position
                                    this.tryMove(moveX, moveY);
                                    this.setDrawXY(oldX, oldY);
                                    if (this.x > oldX)
                                        this.direction = game_1.Direction.RIGHT;
                                    else if (this.x < oldX)
                                        this.direction = game_1.Direction.LEFT;
                                    else if (this.y > oldY)
                                        this.direction = game_1.Direction.DOWN;
                                    else if (this.y < oldY)
                                        this.direction = game_1.Direction.UP;
                                }
                            }
                        }
                        // Add positions to avoid based on the current direction
                        if (this.direction == game_1.Direction.LEFT) {
                            disablePositions.push({
                                x: this.x,
                                y: this.y + 1,
                            });
                            disablePositions.push({
                                x: this.x,
                                y: this.y - 1,
                            });
                        }
                        if (this.direction == game_1.Direction.RIGHT) {
                            disablePositions.push({
                                x: this.x,
                                y: this.y + 1,
                            });
                            disablePositions.push({
                                x: this.x,
                                y: this.y - 1,
                            });
                        }
                        if (this.direction == game_1.Direction.DOWN) {
                            disablePositions.push({
                                x: this.x + 1,
                                y: this.y,
                            });
                            disablePositions.push({
                                x: this.x - 1,
                                y: this.y,
                            });
                        }
                        if (this.direction == game_1.Direction.UP) {
                            disablePositions.push({
                                x: this.x + 1,
                                y: this.y,
                            });
                            disablePositions.push({
                                x: this.x - 1,
                                y: this.y,
                            });
                        }
                        // Make hit warnings
                        this.makeHitWarnings();
                    }
                    // Check if the target player is offline
                    let targetPlayerOffline = Object.values(this.game.offlinePlayers).indexOf(this.targetPlayer) !==
                        -1;
                    // If the enemy is not aggro or the target player is offline, find a new target player
                    if (!this.aggro || targetPlayerOffline) {
                        let p = this.nearestPlayer();
                        if (p !== false) {
                            let [distance, player] = p;
                            if (distance <= 4 &&
                                (targetPlayerOffline ||
                                    distance < this.playerDistance(this.targetPlayer))) {
                                if (player !== this.targetPlayer) {
                                    this.targetPlayer = player;
                                    this.facePlayer(player);
                                    if (player === this.game.players[this.game.localPlayerID])
                                        this.alertTicks = 1;
                                    this.makeHitWarnings();
                                }
                            }
                        }
                    }
                }
            }
        };
        this.draw = (delta) => {
            if (this.dead)
                return;
            //this.updateShadeColor(delta);
            game_1.Game.ctx.globalAlpha = this.alpha;
            this.updateDrawXY(delta);
            this.frame += 0.1 * delta;
            if (this.frame >= 4)
                this.frame = 0;
            if (this.hasShadow)
                game_1.Game.drawMob(0, 0, 1, 1, this.x - this.drawX, this.y - this.drawY, 1, 1, this.shadeColor, this.shadeAmount());
            game_1.Game.drawMob(this.tileX + Math.floor(this.frame), this.tileY + this.direction * 2, 1, 2, this.x - this.drawX, this.y - this.drawYOffset - this.drawY - this.jumpY, 1, 2, this.softShadeColor, this.shadeAmount());
            if (!this.cloned) {
                if (!this.seenPlayer) {
                    this.drawSleepingZs(delta);
                }
                if (this.alertTicks > 0) {
                    this.drawExclamation(delta);
                }
            }
            game_1.Game.ctx.globalAlpha = 1;
        };
        this.ticks = 0;
        this.frame = 0;
        this.health = 1;
        this.maxHealth = 1;
        this.tileX = 17;
        this.tileY = 16;
        this.seenPlayer = false;
        this.aggro = false;
        this.dir = game_1.Direction.DOWN;
        this.name = "mummy";
        this.forwardOnlyAttack = true;
        this.drawMoveSpeed = 0.2;
        this.jumpHeight = 0.35;
        if (drop)
            this.drop = drop;
        if (Math.random() < this.dropChance) {
            this.getDrop(["consumable", "gem", "tool", "coin"]);
        }
    }
}
exports.MummyEnemy = MummyEnemy;
MummyEnemy.difficulty = 1;
MummyEnemy.tileX = 17;
MummyEnemy.tileY = 8;


/***/ }),

/***/ "./src/entity/enemy/occultistEnemy.ts":
/*!********************************************!*\
  !*** ./src/entity/enemy/occultistEnemy.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.OccultistEnemy = void 0;
const game_1 = __webpack_require__(/*! ../../game */ "./src/game.ts");
const enemy_1 = __webpack_require__(/*! ./enemy */ "./src/entity/enemy/enemy.ts");
const utils_1 = __webpack_require__(/*! ../../utils */ "./src/utils.ts");
const beamEffect_1 = __webpack_require__(/*! ../../beamEffect */ "./src/beamEffect.ts");
const lighting_1 = __webpack_require__(/*! ../../lighting */ "./src/lighting.ts");
class OccultistEnemy extends enemy_1.Enemy {
    constructor(room, game, x, y) {
        super(room, game, x, y);
        this.hit = () => {
            return 1;
        };
        this.uniqueKillBehavior = () => {
            this.unshieldEnemies();
            this.removeLightSource(this.lightSource);
            this.lightSource = null;
        };
        this.behavior = () => {
            this.lastX = this.x;
            this.lastY = this.y;
            let enemiesToShield = this.room.entities.filter((entity) => entity instanceof enemy_1.Enemy &&
                utils_1.Utils.distance(this.x, this.y, entity.x, entity.y) <= this.range &&
                !entity.shielded &&
                !entity.dead &&
                entity !== this &&
                !entity.shieldedBefore);
            if (!this.dead) {
                if (this.skipNextTurns > 0) {
                    this.skipNextTurns--;
                    return;
                }
                this.ticks++;
                if (this.ticks % 2 === 0) {
                    if (enemiesToShield.length > 0) {
                        enemiesToShield.forEach((enemy) => {
                            const distance = utils_1.Utils.distance(this.x, this.y, enemy.x, enemy.y);
                            if (Math.random() * 10 > distance) {
                                this.applyShieldTo(enemy);
                            }
                        });
                        //this.createBeam(this.shieldedEnemies);
                    }
                }
                this.shieldedEnemies.forEach((enemy) => {
                    if (enemy.dead) {
                        this.shieldedEnemies = this.shieldedEnemies.filter((e) => e !== enemy);
                    }
                });
            }
            if (this.shieldedEnemies.length > 0) {
                this.shadeColor = "#2E0854";
            }
            else {
                this.shadeColor = "#000000";
            }
        };
        this.unshieldEnemies = () => {
            if (this.shieldedEnemies.length > 0) {
                for (let enemy of this.shieldedEnemies) {
                    if (!enemy.cloned) {
                        enemy.removeShield();
                        console.log("unshielded enemy:", enemy.name);
                    }
                }
                this.shieldedEnemies = [];
            }
        };
        this.applyShieldTo = (enemy) => {
            //this.shadeColor = "#2E0854";
            this.shadeMultiplier = 1.5;
            enemy.applyShield();
            this.shieldedEnemies.push(enemy);
            if (enemy.shielded && enemy.shield) {
                let beam = new beamEffect_1.BeamEffect(enemy.x, enemy.y, this.x, this.y, enemy);
                beam.compositeOperation = "source-over";
                beam.color = "#2E0854";
                beam.turbulence = 0.4;
                beam.gravity = 0.1;
                beam.iterations = 1;
                beam.segments = 100;
                beam.angleChange = 0.001;
                beam.springDamping = 0.01;
                beam.drawableY = enemy.drawableY;
                this.room.projectiles.push(beam);
                console.log("beam created");
            }
        };
        this.createBeam = (enemies) => {
            for (let enemy of enemies) {
                if (enemy.shielded && enemy.shield) {
                    let beam = new beamEffect_1.BeamEffect(enemy.x, enemy.y, this.x, this.y, enemy);
                    beam.compositeOperation = "source-over";
                    beam.color = "#2E0854";
                    beam.turbulence = 0.5;
                    beam.gravity = 0.1;
                    beam.iterations = 1;
                    beam.segments = 30;
                    beam.angleChange = 0.01;
                    beam.springDamping = 0.1;
                    beam.drawableY = enemy.drawableY;
                    this.room.projectiles.push(beam);
                    console.log("beam created");
                }
            }
        };
        this.updateBeam = (delta) => {
            for (let beam of this.room.projectiles) {
                if (beam instanceof beamEffect_1.BeamEffect) {
                    beam.setTarget(this.x - this.drawX, this.y - this.drawY, beam.parent.x - beam.parent.drawX, beam.parent.y - beam.parent.drawY);
                    beam.drawableY = beam.parent.drawableY;
                    switch (Math.floor(this.frame)) {
                        case 0:
                            beam.color = "#2e0854";
                            break;
                        case 1:
                            beam.color = "#331988";
                            break;
                        case 2:
                            beam.color = "#4729db";
                            break;
                        case 3:
                            beam.color = "#331988";
                            break;
                    }
                }
            }
        };
        this.draw = (delta) => {
            if (this.dead)
                return;
            game_1.Game.ctx.save();
            game_1.Game.ctx.globalAlpha = this.alpha;
            this.drawableY = this.y;
            if (!this.dead) {
                this.updateDrawXY(delta);
                this.updateBeam(delta);
                this.frame += 0.1 * delta;
                if (this.frame >= 4)
                    this.frame = 0;
                if (this.hasShadow)
                    game_1.Game.drawMob(0, 0, 1, 1, this.x - this.drawX, this.y - this.drawY, 1, 1, this.room.shadeColor, this.shadeAmount());
                game_1.Game.drawMob(this.tileX + Math.floor(this.frame), this.tileY, 1, 2, this.x - this.drawX, this.y - this.drawYOffset - this.drawY, 1, 2, this.softShadeColor, this.shadeAmount());
            }
            game_1.Game.ctx.restore();
        };
        this.ticks = 0;
        this.health = 6;
        this.maxHealth = 6;
        this.tileX = 55;
        this.tileY = 8;
        this.seenPlayer = true;
        this.name = "occultist";
        this.range = 6;
        this.aggro = false;
        this.frame = 0;
        this.hasShadow = true;
        this.shieldedBefore = false;
        this.shieldedEnemies = [];
        this.shadeColor = "#000000";
        this.lightSource = lighting_1.Lighting.newLightSource(this.x + 0.5, this.y + 0.5, [20, 0, 40], 3.5, 20);
        this.addLightSource(this.lightSource);
        this.room.updateLighting();
        this.hasBloom = true;
        this.bloomColor = "#2E0854";
        this.bloomAlpha = 1;
        this.softBloomAlpha = 0;
    }
}
exports.OccultistEnemy = OccultistEnemy;
OccultistEnemy.tileX = 55;
OccultistEnemy.tileY = 8;


/***/ }),

/***/ "./src/entity/enemy/queenEnemy.ts":
/*!****************************************!*\
  !*** ./src/entity/enemy/queenEnemy.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.QueenEnemy = void 0;
const game_1 = __webpack_require__(/*! ../../game */ "./src/game.ts");
const astarclass_1 = __webpack_require__(/*! ../../astarclass */ "./src/astarclass.ts");
const spiketrap_1 = __webpack_require__(/*! ../../tile/spiketrap */ "./src/tile/spiketrap.ts");
const enemy_1 = __webpack_require__(/*! ./enemy */ "./src/entity/enemy/enemy.ts");
class QueenEnemy extends enemy_1.Enemy {
    constructor(room, game, x, y, drop) {
        super(room, game, x, y);
        this.hit = () => {
            return 1;
        };
        this.behavior = () => {
            this.lastX = this.x;
            this.lastY = this.y;
            if (this.health <= 1)
                this.imageParticleY = 29; //no crown particle
            if (!this.dead) {
                if (this.skipNextTurns > 0) {
                    this.skipNextTurns--;
                    return;
                }
                this.ticks++;
                if (!this.seenPlayer) {
                    let p = this.nearestPlayer();
                    if (p !== false) {
                        let [distance, player] = p;
                        if (distance <= 4) {
                            this.targetPlayer = player;
                            this.facePlayer(player);
                            this.seenPlayer = true;
                            if (player === this.game.players[this.game.localPlayerID])
                                this.alertTicks = 1;
                            this.makeHitWarnings();
                        }
                    }
                }
                else if (this.seenPlayer) {
                    if (this.room.playerTicked === this.targetPlayer) {
                        this.alertTicks = Math.max(0, this.alertTicks - 1);
                        let oldX = this.x;
                        let oldY = this.y;
                        let disablePositions = Array();
                        for (const e of this.room.entities) {
                            if (e !== this) {
                                disablePositions.push({ x: e.x, y: e.y });
                            }
                        }
                        for (let xx = this.x - 1; xx <= this.x + 1; xx++) {
                            for (let yy = this.y - 1; yy <= this.y + 1; yy++) {
                                if (this.room.roomArray[xx][yy] instanceof spiketrap_1.SpikeTrap &&
                                    this.room.roomArray[xx][yy].on) {
                                    // don't walk on active spiketraps
                                    disablePositions.push({ x: xx, y: yy });
                                }
                            }
                        }
                        let grid = [];
                        for (let x = 0; x < this.room.roomX + this.room.width; x++) {
                            grid[x] = [];
                            for (let y = 0; y < this.room.roomY + this.room.height; y++) {
                                if (this.room.roomArray[x] && this.room.roomArray[x][y])
                                    grid[x][y] = this.room.roomArray[x][y];
                                else
                                    grid[x][y] = false;
                            }
                        }
                        let moves = astarclass_1.astar.AStar.search(grid, this, this.targetPlayer, disablePositions, true, //diagonals
                        false, //diagonalsOnly
                        undefined, undefined, undefined, false);
                        if (moves.length > 0) {
                            disablePositions.push({ x: oldX + 1, y: oldY });
                            disablePositions.push({ x: oldX - 1, y: oldY });
                            disablePositions.push({ x: oldX, y: oldY + 1 });
                            disablePositions.push({ x: oldX, y: oldY - 1 });
                            let moveX = moves[0].pos.x;
                            let moveY = moves[0].pos.y;
                            let hitPlayer = false;
                            for (const i in this.game.players) {
                                if (this.game.rooms[this.game.players[i].levelID] === this.room &&
                                    this.game.players[i].x === moveX &&
                                    this.game.players[i].y === moveY) {
                                    this.game.players[i].hurt(this.hit(), this.name);
                                    this.drawX = 0.5 * (this.x - this.game.players[i].x);
                                    this.drawY = 0.5 * (this.y - this.game.players[i].y);
                                    if (this.game.players[i] ===
                                        this.game.players[this.game.localPlayerID])
                                        this.game.shakeScreen(10 * this.drawX, 10 * this.drawY);
                                }
                            }
                            if (!hitPlayer) {
                                //if ()
                                this.tryMove(moveX, moveY);
                                this.setDrawXY(oldX, oldY);
                            }
                        }
                        this.makeHitWarnings();
                    }
                    let targetPlayerOffline = Object.values(this.game.offlinePlayers).indexOf(this.targetPlayer) !==
                        -1;
                    if (!this.aggro || targetPlayerOffline) {
                        let p = this.nearestPlayer();
                        if (p !== false) {
                            let [distance, player] = p;
                            if (distance <= 4 &&
                                (targetPlayerOffline ||
                                    distance < this.playerDistance(this.targetPlayer))) {
                                if (player !== this.targetPlayer) {
                                    this.targetPlayer = player;
                                    this.facePlayer(player);
                                    if (player === this.game.players[this.game.localPlayerID])
                                        this.alertTicks = 1;
                                    this.makeHitWarnings();
                                }
                            }
                        }
                    }
                }
            }
        };
        this.jump = (delta) => {
            let j = Math.max(Math.abs(this.drawX), Math.abs(this.drawY));
            let jumpY = Math.abs(Math.sin(j * Math.PI)) * this.jumpHeight;
            if (jumpY < 0.01)
                jumpY = 0;
            if (jumpY > this.jumpHeight)
                jumpY = this.jumpHeight;
            this.jumpY = jumpY;
        };
        this.draw = (delta) => {
            const offsetTileY = this.health <= 1 ? 0 : -2;
            if (this.dead)
                return;
            game_1.Game.ctx.save();
            game_1.Game.ctx.globalAlpha = this.alpha;
            if (!this.dead) {
                this.updateDrawXY(delta);
                this.frame += 0.1 * delta;
                if (this.frame >= 4)
                    this.frame = 0;
                if (this.hasShadow)
                    game_1.Game.drawMob(0, 0, 1, 1, this.x - this.drawX, this.y - this.drawY, 1, 1, this.room.shadeColor, this.shadeAmount());
                game_1.Game.drawMob(this.tileX + Math.floor(this.frame), this.tileY + offsetTileY, 1, 2, this.x - this.drawX, this.y - this.drawYOffset - this.drawY - this.jumpY, 1, 2, this.softShadeColor, this.shadeAmount() * (1 + this.jumpY / 3));
            }
            if (!this.cloned) {
                if (!this.seenPlayer) {
                    this.drawSleepingZs(delta);
                }
                if (this.alertTicks > 0) {
                    this.drawExclamation(delta);
                }
            }
            game_1.Game.ctx.restore();
        };
        this.ticks = 0;
        this.frame = 0;
        this.health = 2;
        this.maxHealth = 2;
        this.tileX = 23;
        this.tileY = 10;
        this.seenPlayer = false;
        this.aggro = false;
        this.name = "queen";
        this.orthogonalAttack = true;
        this.diagonalAttack = true;
        this.jumpHeight = 1;
        this.imageParticleX = 6;
        this.imageParticleY = 28; //includes crown particle
        if (drop)
            this.drop = drop;
        if (Math.random() < this.dropChance) {
            this.getDrop([
                "weapon",
                "equipment",
                "consumable",
                "gem",
                "tool",
                "coin",
            ]);
        }
    }
}
exports.QueenEnemy = QueenEnemy;
QueenEnemy.difficulty = 4;
QueenEnemy.tileX = 23;
QueenEnemy.tileY = 8;


/***/ }),

/***/ "./src/entity/enemy/rookEnemy.ts":
/*!***************************************!*\
  !*** ./src/entity/enemy/rookEnemy.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RookEnemy = void 0;
const game_1 = __webpack_require__(/*! ../../game */ "./src/game.ts");
const astarclass_1 = __webpack_require__(/*! ../../astarclass */ "./src/astarclass.ts");
const spiketrap_1 = __webpack_require__(/*! ../../tile/spiketrap */ "./src/tile/spiketrap.ts");
const enemy_1 = __webpack_require__(/*! ./enemy */ "./src/entity/enemy/enemy.ts");
class RookEnemy extends enemy_1.Enemy {
    constructor(room, game, x, y, drop) {
        super(room, game, x, y);
        this.hit = () => {
            return 1;
        };
        this.behavior = () => {
            this.lastX = this.x;
            this.lastY = this.y;
            if (!this.dead) {
                if (this.skipNextTurns > 0) {
                    this.skipNextTurns--;
                    return;
                }
                this.ticks++;
                if (!this.seenPlayer) {
                    let p = this.nearestPlayer();
                    if (p !== false) {
                        let [distance, player] = p;
                        if (distance <= 4) {
                            this.targetPlayer = player;
                            this.facePlayer(player);
                            this.seenPlayer = true;
                            if (player === this.game.players[this.game.localPlayerID])
                                this.alertTicks = 1;
                            this.makeHitWarnings();
                        }
                    }
                }
                else if (this.seenPlayer) {
                    if (this.room.playerTicked === this.targetPlayer) {
                        this.alertTicks = Math.max(0, this.alertTicks - 1);
                        let oldX = this.x;
                        let oldY = this.y;
                        let disablePositions = Array();
                        for (const e of this.room.entities) {
                            if (e !== this) {
                                disablePositions.push({ x: e.x, y: e.y });
                            }
                        }
                        for (let xx = this.x - 1; xx <= this.x + 1; xx++) {
                            for (let yy = this.y - 1; yy <= this.y + 1; yy++) {
                                if (this.room.roomArray[xx][yy] instanceof spiketrap_1.SpikeTrap &&
                                    this.room.roomArray[xx][yy].on) {
                                    // don't walk on active spiketraps
                                    disablePositions.push({ x: xx, y: yy });
                                }
                            }
                        }
                        let grid = [];
                        for (let x = 0; x < this.room.roomX + this.room.width; x++) {
                            grid[x] = [];
                            for (let y = 0; y < this.room.roomY + this.room.height; y++) {
                                if (this.room.roomArray[x] && this.room.roomArray[x][y])
                                    grid[x][y] = this.room.roomArray[x][y];
                                else
                                    grid[x][y] = false;
                            }
                        }
                        let moves = astarclass_1.astar.AStar.search(grid, this, this.targetPlayer, disablePositions, false, //diagonals
                        false, //diagonalsOnly
                        undefined, undefined, undefined, false, //diagonalsOmni
                        this.lastPlayerPos);
                        if (moves.length > 0) {
                            let moveX = moves[0].pos.x;
                            let moveY = moves[0].pos.y;
                            let hitPlayer = false;
                            for (const i in this.game.players) {
                                if (this.game.rooms[this.game.players[i].levelID] === this.room &&
                                    this.game.players[i].x === moveX &&
                                    this.game.players[i].y === moveY) {
                                    this.game.players[i].hurt(this.hit(), this.name);
                                    this.drawX = 0.5 * (this.x - this.game.players[i].x);
                                    this.drawY = 0.5 * (this.y - this.game.players[i].y);
                                    if (this.game.players[i] ===
                                        this.game.players[this.game.localPlayerID])
                                        this.game.shakeScreen(10 * this.drawX, 10 * this.drawY);
                                }
                            }
                            if (!hitPlayer) {
                                this.tryMove(moveX, moveY);
                                this.setDrawXY(oldX, oldY);
                            }
                        }
                        this.makeHitWarnings();
                    }
                    let targetPlayerOffline = Object.values(this.game.offlinePlayers).indexOf(this.targetPlayer) !==
                        -1;
                    if (!this.aggro || targetPlayerOffline) {
                        let p = this.nearestPlayer();
                        if (p !== false) {
                            let [distance, player] = p;
                            if (distance <= 4 &&
                                (targetPlayerOffline ||
                                    distance < this.playerDistance(this.targetPlayer))) {
                                if (player !== this.targetPlayer) {
                                    this.targetPlayer = player;
                                    this.facePlayer(player);
                                    if (player === this.game.players[this.game.localPlayerID])
                                        this.alertTicks = 1;
                                    this.makeHitWarnings();
                                }
                            }
                        }
                    }
                }
            }
        };
        this.draw = (delta) => {
            if (this.dead)
                return;
            game_1.Game.ctx.save();
            game_1.Game.ctx.globalAlpha = this.alpha;
            if (!this.dead) {
                this.updateDrawXY(delta);
                this.frame += 0.1 * delta;
                if (this.frame >= 4)
                    this.frame = 0;
                if (this.hasShadow)
                    game_1.Game.drawMob(0, 0, 1, 1, this.x - this.drawX, this.y - this.drawY, 1, 1, this.room.shadeColor, this.shadeAmount());
                game_1.Game.drawMob(this.tileX + Math.floor(this.frame), this.tileY, 1, 2, this.x - this.drawX, this.y - this.drawYOffset - this.drawY - this.jumpY, 1, 2, this.softShadeColor, this.shadeAmount());
            }
            if (!this.cloned) {
                if (!this.seenPlayer) {
                    this.drawSleepingZs(delta);
                }
                if (this.alertTicks > 0) {
                    this.drawExclamation(delta);
                }
            }
            game_1.Game.ctx.restore();
        };
        this.ticks = 0;
        this.frame = 0;
        this.health = 1;
        this.maxHealth = 1;
        this.tileX = 23 + 28;
        this.tileY = 8;
        this.seenPlayer = false;
        this.aggro = false;
        this.name = "rook";
        this.orthogonalAttack = true;
        this.diagonalAttack = false;
        this.jumpHeight = 0.5;
        if (drop)
            this.drop = drop;
        if (Math.random() < this.dropChance) {
            this.getDrop([
                "weapon",
                "equipment",
                "consumable",
                "gem",
                "tool",
                "coin",
            ]);
        }
    }
}
exports.RookEnemy = RookEnemy;
RookEnemy.difficulty = 4;
RookEnemy.tileX = 23 + 28;
RookEnemy.tileY = 8;


/***/ }),

/***/ "./src/entity/enemy/skullEnemy.ts":
/*!****************************************!*\
  !*** ./src/entity/enemy/skullEnemy.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SkullEnemy = void 0;
const game_1 = __webpack_require__(/*! ../../game */ "./src/game.ts");
const astarclass_1 = __webpack_require__(/*! ../../astarclass */ "./src/astarclass.ts");
const spiketrap_1 = __webpack_require__(/*! ../../tile/spiketrap */ "./src/tile/spiketrap.ts");
const imageParticle_1 = __webpack_require__(/*! ../../particle/imageParticle */ "./src/particle/imageParticle.ts");
const enemy_1 = __webpack_require__(/*! ./enemy */ "./src/entity/enemy/enemy.ts");
class SkullEnemy extends enemy_1.Enemy {
    constructor(room, game, x, y, drop) {
        super(room, game, x, y);
        this.REGEN_TICKS = 5;
        this.hit = () => {
            return 1;
        };
        this.hurt = (playerHitBy, damage, type = "none") => {
            this.handleEnemyCase(playerHitBy);
            let hitShield = false;
            let shieldHealth = 0;
            if (this.shielded) {
                shieldHealth = this.shield.health;
                if (shieldHealth > 0) {
                    this.shield.hurt(damage);
                    hitShield = true;
                }
            }
            this.ticksSinceFirstHit = 0;
            if (this.health == 2)
                this.unconscious = false;
            this.health -= damage;
            this.maxHealth -= shieldHealth;
            this.startHurting();
            this.healthBar.hurt();
            this.createDamageNumber(damage, type);
            this.playHitSound();
            if (this.health == 1) {
                this.unconscious = true;
                imageParticle_1.ImageParticle.spawnCluster(this.room, this.x + 0.5, this.y + 0.5, 3, 28);
            }
            else {
                this.healthBar.hurt();
            }
            if (this.health <= 0) {
                imageParticle_1.ImageParticle.spawnCluster(this.room, this.x + 0.5, this.y + 0.5, 0, 24);
                this.kill();
            }
            else
                this.hurtCallback();
        };
        this.behavior = () => {
            this.lastX = this.x;
            this.lastY = this.y;
            if (!this.dead) {
                if (this.skipNextTurns > 0) {
                    this.skipNextTurns--;
                    this.ticks++;
                    return;
                }
                if (this.health <= 1) {
                    this.unconscious = true;
                    this.ticksSinceFirstHit++;
                    if (this.ticksSinceFirstHit >= this.REGEN_TICKS) {
                        this.healthBar.hurt();
                        this.health = 2;
                        this.unconscious = false;
                    }
                    this.ticks++;
                    return;
                }
                this.ticks++;
                if (!this.seenPlayer) {
                    this.lookForPlayer();
                }
                else if (this.seenPlayer) {
                    if (this.room.playerTicked === this.targetPlayer) {
                        this.alertTicks = Math.max(0, this.alertTicks - 1);
                        let oldX = this.x;
                        let oldY = this.y;
                        let disablePositions = Array();
                        for (const e of this.room.entities) {
                            if (e !== this) {
                                disablePositions.push({ x: e.x, y: e.y });
                            }
                        }
                        for (let xx = this.x - 1; xx <= this.x + 1; xx++) {
                            for (let yy = this.y - 1; yy <= this.y + 1; yy++) {
                                if (this.room.roomArray[xx][yy] instanceof spiketrap_1.SpikeTrap &&
                                    this.room.roomArray[xx][yy].on) {
                                    disablePositions.push({ x: xx, y: yy });
                                }
                            }
                        }
                        let grid = [];
                        for (let x = 0; x < this.room.roomX + this.room.width; x++) {
                            grid[x] = [];
                            for (let y = 0; y < this.room.roomY + this.room.height; y++) {
                                if (this.room.roomArray[x] && this.room.roomArray[x][y])
                                    grid[x][y] = this.room.roomArray[x][y];
                                else
                                    grid[x][y] = false;
                            }
                        }
                        let moves = astarclass_1.astar.AStar.search(grid, this, this.targetPlayer, disablePositions, false, false, true, this.direction, undefined, undefined);
                        if (moves.length > 0) {
                            let moveX = moves[0].pos.x;
                            let moveY = moves[0].pos.y;
                            let oldDir = this.direction;
                            let player = this.targetPlayer;
                            this.facePlayer(player);
                            if (moveX > oldX)
                                this.direction = game_1.Direction.RIGHT;
                            else if (moveX < oldX)
                                this.direction = game_1.Direction.LEFT;
                            else if (moveY > oldY)
                                this.direction = game_1.Direction.DOWN;
                            else if (moveY < oldY)
                                this.direction = game_1.Direction.UP;
                            if (oldDir == this.direction) {
                                let hitPlayer = false;
                                for (const i in this.game.players) {
                                    if (this.game.rooms[this.game.players[i].levelID] === this.room &&
                                        this.game.players[i].x === moveX &&
                                        this.game.players[i].y === moveY) {
                                        this.game.players[i].hurt(this.hit(), this.name);
                                        this.drawX = 0.5 * (this.x - this.game.players[i].x);
                                        this.drawY = 0.5 * (this.y - this.game.players[i].y);
                                        if (this.game.players[i] ===
                                            this.game.players[this.game.localPlayerID])
                                            this.game.shakeScreen(10 * this.drawX, 10 * this.drawY);
                                    }
                                }
                                if (!hitPlayer) {
                                    this.tryMove(moveX, moveY);
                                    this.setDrawXY(oldX, oldY);
                                    if (this.x > oldX)
                                        this.direction = game_1.Direction.RIGHT;
                                    else if (this.x < oldX)
                                        this.direction = game_1.Direction.LEFT;
                                    else if (this.y > oldY)
                                        this.direction = game_1.Direction.DOWN;
                                    else if (this.y < oldY)
                                        this.direction = game_1.Direction.UP;
                                }
                            }
                        }
                        if (this.direction == game_1.Direction.LEFT) {
                            disablePositions.push({
                                x: this.x,
                                y: this.y + 1,
                            });
                            disablePositions.push({
                                x: this.x,
                                y: this.y - 1,
                            });
                        }
                        if (this.direction == game_1.Direction.RIGHT) {
                            disablePositions.push({
                                x: this.x,
                                y: this.y + 1,
                            });
                            disablePositions.push({
                                x: this.x,
                                y: this.y - 1,
                            });
                        }
                        if (this.direction == game_1.Direction.DOWN) {
                            disablePositions.push({
                                x: this.x + 1,
                                y: this.y,
                            });
                            disablePositions.push({
                                x: this.x - 1,
                                y: this.y,
                            });
                        }
                        if (this.direction == game_1.Direction.UP) {
                            disablePositions.push({
                                x: this.x + 1,
                                y: this.y,
                            });
                            disablePositions.push({
                                x: this.x - 1,
                                y: this.y,
                            });
                        }
                        this.makeHitWarnings();
                    }
                    let targetPlayerOffline = Object.values(this.game.offlinePlayers).indexOf(this.targetPlayer) !==
                        -1;
                    if (!this.aggro || targetPlayerOffline) {
                        let p = this.nearestPlayer();
                        if (p !== false) {
                            let [distance, player] = p;
                            if (distance <= 4 &&
                                (targetPlayerOffline ||
                                    distance < this.playerDistance(this.targetPlayer))) {
                                if (player !== this.targetPlayer) {
                                    this.targetPlayer = player;
                                    this.facePlayer(player);
                                    if (player === this.game.players[this.game.localPlayerID])
                                        this.alertTicks = 1;
                                    this.makeHitWarnings();
                                }
                            }
                        }
                    }
                }
            }
        };
        this.draw = (delta) => {
            if (this.dead)
                return;
            game_1.Game.ctx.save();
            game_1.Game.ctx.globalAlpha = this.alpha;
            if (!this.dead) {
                this.updateDrawXY(delta);
                this.tileX = 5;
                this.tileY = 8;
                if (this.health <= 1 || this.dying) {
                    this.tileX = 3;
                    this.tileY = 0;
                    if (this.ticksSinceFirstHit >= 3) {
                        this.flashingFrame += 0.1 * delta;
                        if (Math.floor(this.flashingFrame) % 2 === 0) {
                            this.tileX = 2;
                        }
                    }
                }
                this.frame += 0.1 * delta;
                if (this.frame >= 4)
                    this.frame = 0;
                if (this.hasShadow)
                    game_1.Game.drawMob(0, 0, 1, 1, this.x - this.drawX, this.y - this.drawY, 1, 1, this.room.shadeColor, this.shadeAmount());
                game_1.Game.drawMob(this.tileX + (this.tileX === 5 ? Math.floor(this.frame) : 0), this.tileY + this.direction * 2, 1, 2, this.x - this.drawX, this.y - this.drawYOffset - this.drawY - this.jumpY, 1, 2, this.softShadeColor, this.shadeAmount());
            }
            if (!this.cloned) {
                if (!this.seenPlayer) {
                    this.drawSleepingZs(delta);
                }
                if (this.alertTicks > 0) {
                    this.drawExclamation(delta);
                }
            }
            game_1.Game.ctx.restore();
        };
        this.ticks = 0;
        this.frame = 0;
        this.health = 2;
        this.maxHealth = 2;
        this.tileX = 5;
        this.tileY = 8;
        this.seenPlayer = false;
        this.aggro = false;
        this.ticksSinceFirstHit = 0;
        this.flashingFrame = 0;
        this.deathParticleColor = "#ffffff";
        this.name = "skeleton";
        this.forwardOnlyAttack = true;
        if (drop)
            this.drop = drop;
        if (Math.random() < this.dropChance) {
            this.getDrop(["weapon", "consumable", "gem", "tool", "coin"]);
        }
    }
}
exports.SkullEnemy = SkullEnemy;
SkullEnemy.difficulty = 2;
SkullEnemy.tileX = 5;
SkullEnemy.tileY = 8;


/***/ }),

/***/ "./src/entity/enemy/spawner.ts":
/*!*************************************!*\
  !*** ./src/entity/enemy/spawner.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Spawner = void 0;
const game_1 = __webpack_require__(/*! ../../game */ "./src/game.ts");
const floor_1 = __webpack_require__(/*! ../../tile/floor */ "./src/tile/floor.ts");
const hitWarning_1 = __webpack_require__(/*! ../../hitWarning */ "./src/hitWarning.ts");
const skullEnemy_1 = __webpack_require__(/*! ./skullEnemy */ "./src/entity/enemy/skullEnemy.ts");
const enemySpawnAnimation_1 = __webpack_require__(/*! ../../projectile/enemySpawnAnimation */ "./src/projectile/enemySpawnAnimation.ts");
const knightEnemy_1 = __webpack_require__(/*! ./knightEnemy */ "./src/entity/enemy/knightEnemy.ts");
const enemy_1 = __webpack_require__(/*! ./enemy */ "./src/entity/enemy/enemy.ts");
const random_1 = __webpack_require__(/*! ../../random */ "./src/random.ts");
const energyWizard_1 = __webpack_require__(/*! ./energyWizard */ "./src/entity/enemy/energyWizard.ts");
const zombieEnemy_1 = __webpack_require__(/*! ./zombieEnemy */ "./src/entity/enemy/zombieEnemy.ts");
const bishopEnemy_1 = __webpack_require__(/*! ./bishopEnemy */ "./src/entity/enemy/bishopEnemy.ts");
const crabEnemy_1 = __webpack_require__(/*! ./crabEnemy */ "./src/entity/enemy/crabEnemy.ts");
const chargeEnemy_1 = __webpack_require__(/*! ./chargeEnemy */ "./src/entity/enemy/chargeEnemy.ts");
const bigKnightEnemy_1 = __webpack_require__(/*! ./bigKnightEnemy */ "./src/entity/enemy/bigKnightEnemy.ts");
const bigSkullEnemy_1 = __webpack_require__(/*! ./bigSkullEnemy */ "./src/entity/enemy/bigSkullEnemy.ts");
const frogEnemy_1 = __webpack_require__(/*! ./frogEnemy */ "./src/entity/enemy/frogEnemy.ts");
const fireWizard_1 = __webpack_require__(/*! ./fireWizard */ "./src/entity/enemy/fireWizard.ts");
const queenEnemy_1 = __webpack_require__(/*! ./queenEnemy */ "./src/entity/enemy/queenEnemy.ts");
const armoredzombieEnemy_1 = __webpack_require__(/*! ./armoredzombieEnemy */ "./src/entity/enemy/armoredzombieEnemy.ts");
const rookEnemy_1 = __webpack_require__(/*! ./rookEnemy */ "./src/entity/enemy/rookEnemy.ts");
const room_1 = __webpack_require__(/*! ../../room/room */ "./src/room/room.ts");
const armoredSkullEnemy_1 = __webpack_require__(/*! ./armoredSkullEnemy */ "./src/entity/enemy/armoredSkullEnemy.ts");
class Spawner extends enemy_1.Enemy {
    constructor(room, game, x, y, enemyTable = [0, 1, 2, 3, 4, 5, 6, 8, 9, 10, 11, 12, 13, 14, 16]) {
        super(room, game, x, y);
        this.hit = () => {
            return 1;
        };
        this.setSpawnFrequency = () => {
            this.spawnFrequency = Math.min(12, 4 * this.room.currentSpawnerCount);
            const spawners = this.room.entities.filter((e) => e instanceof Spawner);
            this.spawnOffset = (spawners.indexOf(this) + 1) * 4;
        };
        this.behavior = () => {
            this.setSpawnFrequency();
            let shouldSpawn = true;
            this.lastX = this.x;
            this.lastY = this.y;
            if (!this.dead) {
                if (this.skipNextTurns > 0) {
                    this.skipNextTurns--;
                    return;
                }
                this.tileX = 6;
                if ((this.ticks + this.spawnOffset) % this.spawnFrequency === 0) {
                    let positions = this.room
                        .getEmptyTiles()
                        .filter((t) => Math.abs(t.x - this.x) <= 1 && Math.abs(t.y - this.y) <= 1);
                    if (this.enemySpawnType === 8) {
                        const offLimits = [
                            { x: this.x, y: this.y },
                            { x: this.x + 1, y: this.y + 1 },
                            { x: this.x - 1, y: this.y - 1 },
                            { x: this.x + 1, y: this.y - 1 },
                            { x: this.x - 1, y: this.y + 1 },
                        ];
                        positions = positions.filter((t) => !offLimits.some((o) => o.x === t.x && o.y === t.y));
                    }
                    if (positions.length > 0) {
                        this.tileX = 7;
                        const position = game_1.Game.randTable(positions, random_1.Random.rand);
                        let spawned;
                        switch (this.enemySpawnType) {
                            case 1:
                                spawned = new crabEnemy_1.CrabEnemy(this.room, this.game, position.x, position.y);
                                break;
                            case 2:
                                spawned = new frogEnemy_1.FrogEnemy(this.room, this.game, position.x, position.y);
                                break;
                            case 3:
                                spawned = new zombieEnemy_1.ZombieEnemy(this.room, this.game, position.x, position.y);
                                break;
                            case 4:
                                spawned = new skullEnemy_1.SkullEnemy(this.room, this.game, position.x, position.y);
                                break;
                            case 5:
                                spawned = new energyWizard_1.EnergyWizardEnemy(this.room, this.game, position.x, position.y);
                                break;
                            case 6:
                                spawned = new chargeEnemy_1.ChargeEnemy(this.room, this.game, position.x, position.y);
                                break;
                            case 7:
                                spawned = new rookEnemy_1.RookEnemy(this.room, this.game, position.x, position.y);
                                break;
                            case 8:
                                spawned = new bishopEnemy_1.BishopEnemy(this.room, this.game, position.x, position.y);
                                break;
                            case 9:
                                spawned = new armoredzombieEnemy_1.ArmoredzombieEnemy(this.room, this.game, position.x, position.y);
                                break;
                            case 10:
                                if (this.room.type !== room_1.RoomType.BIGDUNGEON) {
                                    spawned = new skullEnemy_1.SkullEnemy(this.room, this.game, position.x, position.y);
                                    break;
                                }
                                spawned = new bigSkullEnemy_1.BigSkullEnemy(this.room, this.game, position.x, position.y);
                                for (let xx = 0; xx < 2; xx++) {
                                    for (let yy = 0; yy < 2; yy++) {
                                        this.room.roomArray[position.x + xx][position.y + yy] =
                                            new floor_1.Floor(this.room, position.x + xx, position.y + yy); // remove any walls
                                    }
                                }
                                break;
                            case 11:
                                spawned = new queenEnemy_1.QueenEnemy(this.room, this.game, position.x, position.y);
                                break;
                            case 12:
                                spawned = new knightEnemy_1.KnightEnemy(this.room, this.game, position.x, position.y);
                                break;
                            case 13:
                                if (this.room.type !== room_1.RoomType.BIGDUNGEON) {
                                    spawned = new knightEnemy_1.KnightEnemy(this.room, this.game, position.x, position.y);
                                    break;
                                }
                                spawned = new bigKnightEnemy_1.BigKnightEnemy(this.room, this.game, position.x, position.y);
                                for (let xx = 0; xx < 2; xx++) {
                                    for (let yy = 0; yy < 2; yy++) {
                                        this.room.roomArray[position.x + xx][position.y + yy] =
                                            new floor_1.Floor(this.room, position.x + xx, position.y + yy); // remove any walls
                                    }
                                }
                                break;
                            case 14:
                                spawned = new zombieEnemy_1.ZombieEnemy(this.room, this.game, position.x, position.y);
                                break;
                            case 15:
                                spawned = new fireWizard_1.FireWizardEnemy(this.room, this.game, position.x, position.y);
                                break;
                            case 16:
                                spawned = new armoredSkullEnemy_1.ArmoredSkullEnemy(this.room, this.game, position.x, position.y);
                                break;
                        }
                        if (shouldSpawn) {
                            this.room.projectiles.push(new enemySpawnAnimation_1.EnemySpawnAnimation(this.room, spawned, position.x, position.y));
                            this.room.hitwarnings.push(new hitWarning_1.HitWarning(this.game, position.x, position.y, this.x, this.y));
                        }
                    }
                }
                this.ticks++;
            }
        };
        this.uniqueKillBehavior = () => {
            this.room.currentSpawnerCount--;
        };
        this.draw = (delta) => {
            game_1.Game.ctx.save();
            game_1.Game.ctx.globalAlpha = this.alpha;
            if (!this.dead) {
                this.updateDrawXY(delta);
                this.frame += 0.1 * delta;
                if (this.frame >= 4)
                    this.frame = 0;
                if (this.hasShadow)
                    game_1.Game.drawMob(0, 0, 1, 1, this.x - this.drawX, this.y - this.drawY, 1, 1, this.room.shadeColor, this.shadeAmount());
                game_1.Game.drawMob(this.tileX, this.tileY, 1, 2, this.x - this.drawX, this.y - this.drawYOffset - this.drawY, 1, 2, this.softShadeColor, this.shadeAmount());
            }
            if (!this.dying) {
                if (!this.seenPlayer) {
                    this.drawSleepingZs(delta);
                }
                if (this.alertTicks > 0) {
                    this.drawExclamation(delta);
                }
            }
            game_1.Game.ctx.restore();
        };
        this.ticks = 0;
        this.health = 4;
        this.maxHealth = 4;
        this.tileX = 6;
        this.tileY = 4;
        this.seenPlayer = true;
        this.spawnFrequency = 4;
        this.room.currentSpawnerCount++;
        this.enemyTable = enemyTable.filter((t) => t !== 7);
        const randSpawnType = game_1.Game.randTable(this.enemyTable, random_1.Random.rand);
        this.enemySpawnType = randSpawnType;
        this.spawnOffset = 0;
        if (Math.random() < 0.15) {
            switch (this.enemySpawnType) {
                case 0:
                    this.getDrop(["consumable"]);
                    break;
                case 1:
                    this.getDrop(["gem"]);
                    break;
                case 2:
                    this.getDrop(["consumable"]);
                    break;
                case 3:
                    this.getDrop(["gem"]);
                    break;
                case 4:
                    this.getDrop(["gem"]);
                    break;
                case 5:
                    this.getDrop(["consumable"]);
                    break;
                case 6:
                    this.getDrop(["gem"]);
                    break;
                case 7:
                    this.getDrop(["gem"]);
                    break;
                case 8:
                    this.getDrop(["gem"]);
                    break;
                case 9:
                    this.getDrop(["equipment", "weapon", "tool"]);
                    break;
                case 10:
                    this.getDrop(["weapon"]);
                    break;
                case 11:
                    this.getDrop(["weapon"]);
                    break;
                case 12:
                    this.getDrop(["weapon"]);
                    break;
                case 13:
                    this.getDrop(["weapon"]);
                    break;
                case 14:
                    this.getDrop(["weapon"]);
                    break;
                case 16:
                    this.getDrop(["weapon", "equipment"]);
                    break;
            }
        }
        else {
            this.getDrop(["consumable", "tool"]);
        }
        this.name = "reaper";
    }
}
exports.Spawner = Spawner;
Spawner.tileX = 6;
Spawner.tileY = 4;


/***/ }),

/***/ "./src/entity/enemy/spiderEnemy.ts":
/*!*****************************************!*\
  !*** ./src/entity/enemy/spiderEnemy.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SpiderEnemy = void 0;
const game_1 = __webpack_require__(/*! ../../game */ "./src/game.ts");
const astarclass_1 = __webpack_require__(/*! ../../astarclass */ "./src/astarclass.ts");
const spiketrap_1 = __webpack_require__(/*! ../../tile/spiketrap */ "./src/tile/spiketrap.ts");
const gameConstants_1 = __webpack_require__(/*! ../../gameConstants */ "./src/gameConstants.ts");
const enemy_1 = __webpack_require__(/*! ./enemy */ "./src/entity/enemy/enemy.ts");
var SpiderState;
(function (SpiderState) {
    SpiderState[SpiderState["VISIBLE"] = 0] = "VISIBLE";
    SpiderState[SpiderState["HIDING"] = 1] = "HIDING";
    SpiderState[SpiderState["HIDDEN"] = 2] = "HIDDEN";
})(SpiderState || (SpiderState = {}));
class SpiderEnemy extends enemy_1.Enemy {
    constructor(room, game, x, y, drop) {
        super(room, game, x, y);
        this.hit = () => {
            return 1;
        };
        this.toggleReveal = () => {
            let ticksSince = this.ticks - this.revealTick;
            if (this.state === SpiderState.HIDDEN && ticksSince > 8)
                this.state = SpiderState.HIDING;
            this.revealTick = this.ticks;
        };
        this.behavior = () => {
            this.lastX = this.x;
            this.lastY = this.y;
            if (!this.dead) {
                if (this.skipNextTurns > 0) {
                    this.skipNextTurns--;
                    return;
                }
                if (!this.seenPlayer)
                    this.lookForPlayer();
                else if (this.seenPlayer) {
                    if (this.room.playerTicked === this.targetPlayer) {
                        this.alertTicks = Math.max(0, this.alertTicks - 1);
                        this.ticks++;
                        if (this.ticks % 2 === 1) {
                            this.rumbling = true;
                            let oldX = this.x;
                            let oldY = this.y;
                            let disablePositions = Array();
                            for (const e of this.room.entities) {
                                if (e !== this) {
                                    disablePositions.push({ x: e.x, y: e.y });
                                }
                            }
                            for (let xx = this.x - 1; xx <= this.x + 1; xx++) {
                                for (let yy = this.y - 1; yy <= this.y + 1; yy++) {
                                    if (this.room.roomArray[xx][yy] instanceof spiketrap_1.SpikeTrap &&
                                        this.room.roomArray[xx][yy].on) {
                                        // don't walk on active spiketraps
                                        disablePositions.push({ x: xx, y: yy });
                                    }
                                }
                            }
                            let grid = [];
                            for (let x = 0; x < this.room.roomX + this.room.width; x++) {
                                grid[x] = [];
                                for (let y = 0; y < this.room.roomY + this.room.height; y++) {
                                    if (this.room.roomArray[x] && this.room.roomArray[x][y])
                                        grid[x][y] = this.room.roomArray[x][y];
                                    else
                                        grid[x][y] = false;
                                }
                            }
                            this.target =
                                this.getAverageLuminance() > 0 // 0.8
                                    ? this.targetPlayer
                                    : this.room.getExtremeLuminanceFromPoint(this.x, this.y)
                                        .darkest;
                            let moves = astarclass_1.astar.AStar.search(grid, this, this.target, disablePositions, undefined, undefined, undefined, undefined, undefined, undefined, this.lastPlayerPos);
                            if (moves.length > 0) {
                                let hitPlayer = false;
                                for (const i in this.game.players) {
                                    if (this.game.rooms[this.game.players[i].levelID] === this.room &&
                                        this.game.players[i].x === moves[0].pos.x &&
                                        this.game.players[i].y === moves[0].pos.y) {
                                        this.game.players[i].hurt(this.hit(), this.name);
                                        this.drawX = 0.5 * (this.x - this.game.players[i].x);
                                        this.drawY = 0.5 * (this.y - this.game.players[i].y);
                                        if (this.game.players[i] ===
                                            this.game.players[this.game.localPlayerID])
                                            this.game.shakeScreen(10 * this.drawX, 10 * this.drawY);
                                        hitPlayer = true;
                                    }
                                }
                                if (!hitPlayer) {
                                    this.tryMove(moves[0].pos.x, moves[0].pos.y);
                                    this.setDrawXY(oldX, oldY);
                                    if (this.x > oldX)
                                        this.direction = game_1.Direction.RIGHT;
                                    else if (this.x < oldX)
                                        this.direction = game_1.Direction.LEFT;
                                    else if (this.y > oldY)
                                        this.direction = game_1.Direction.DOWN;
                                    else if (this.y < oldY)
                                        this.direction = game_1.Direction.UP;
                                }
                            }
                            this.rumbling = false;
                        }
                        else {
                            this.rumbling = true;
                            /*
                            if (
                              (this.target.x === this.targetPlayer.x &&
                                this.target.y === this.targetPlayer.y) ||
                              Utils.distance(
                                this.targetPlayer.x,
                                this.targetPlayer.y,
                                this.x,
                                this.y,
                              ) <= 2
                            )
                              */ {
                                this.makeHitWarnings();
                            }
                        }
                    }
                    let targetPlayerOffline = Object.values(this.game.offlinePlayers).indexOf(this.targetPlayer) !==
                        -1;
                    if (!this.aggro || targetPlayerOffline) {
                        let p = this.nearestPlayer();
                        if (p !== false) {
                            let [distance, player] = p;
                            if (distance <= 4 &&
                                (targetPlayerOffline ||
                                    distance < this.playerDistance(this.targetPlayer))) {
                                if (player !== this.targetPlayer) {
                                    this.targetPlayer = player;
                                    this.facePlayer(player);
                                    if (player === this.game.players[this.game.localPlayerID])
                                        this.alertTicks = 1;
                                    if (this.ticks % 2 === 0) {
                                        /*
                                        if (
                                          (this.target.x === this.targetPlayer.x &&
                                            this.target.y === this.targetPlayer.y) ||
                                          Utils.distance(
                                            this.targetPlayer.x,
                                            this.targetPlayer.y,
                                            this.x,
                                            this.y,
                                          ) <= 2
                                        ) */ {
                                            this.makeHitWarnings();
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        };
        this.draw = (delta) => {
            if (this.dead)
                return;
            game_1.Game.ctx.save();
            game_1.Game.ctx.globalAlpha = this.alpha;
            if (!this.dead) {
                this.updateDrawXY(delta);
                if (this.ticks % 2 === 0) {
                    this.tileX = 9;
                    this.tileY = 4;
                }
                else {
                    this.tileX = 8;
                    this.tileY = 4;
                }
                let rumbleX = this.rumble(this.rumbling, this.frame, this.direction).x;
                let rumbleY = this.rumble(this.rumbling, this.frame, this.direction).y;
                this.frame += 0.1 * delta;
                if (this.frame >= 4)
                    this.frame = 0;
                if (this.hasShadow)
                    game_1.Game.drawMob(0, 0, 1, 1, this.x - this.drawX, this.y - 0.25 - this.drawY, 1, 1, this.room.shadeColor, this.shadeAmount());
                if ((this.state = SpiderState.VISIBLE)) {
                    //only draw when visible
                    game_1.Game.drawMob(this.tileX, this.tileY + this.direction, 1, 1, this.x - this.drawX + rumbleX, this.y - this.drawYOffset - this.drawY + rumbleY, 1 * this.crushX, 1 * this.crushY, this.softShadeColor, this.shadeAmount());
                }
                if (this.crushed) {
                    this.crushAnim(delta);
                }
            }
            if (!this.cloned) {
                if (!this.seenPlayer) {
                    this.drawSleepingZs(delta, 0, 0.75 * gameConstants_1.GameConstants.TILESIZE);
                }
                if (this.alertTicks > 0) {
                    this.drawExclamation(delta, 0, 0.75 * gameConstants_1.GameConstants.TILESIZE);
                }
            }
            game_1.Game.ctx.restore();
        };
        this.ticks = 0;
        this.frame = 0;
        this.health = 1;
        this.maxHealth = 1;
        this.tileX = 8;
        this.tileY = 4;
        this.seenPlayer = false;
        this.aggro = false;
        this.name = "spider";
        this.orthogonalAttack = true;
        this.imageParticleX = 3;
        this.imageParticleY = 24;
        this.state = SpiderState.HIDDEN;
        //if (drop) this.drop = drop;
        this.drawYOffset = 0.175;
        this.revealTick = 0;
        if (Math.random() < this.dropChance) {
            this.getDrop([
                "weapon",
                "equipment",
                "consumable",
                "gem",
                "tool",
                "coin",
            ]);
        }
    }
    get alertText() {
        return `New Enemy Spotted: Spider 
    Health: ${this.health}
    Attack Pattern: Omnidirectional
    Moves every other turn`;
    }
}
exports.SpiderEnemy = SpiderEnemy;
SpiderEnemy.difficulty = 1;
SpiderEnemy.tileX = 8;
SpiderEnemy.tileY = 4;


/***/ }),

/***/ "./src/entity/enemy/wizardEnemy.ts":
/*!*****************************************!*\
  !*** ./src/entity/enemy/wizardEnemy.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WizardEnemy = exports.WizardState = void 0;
const game_1 = __webpack_require__(/*! ../../game */ "./src/game.ts");
const wizardTeleportParticle_1 = __webpack_require__(/*! ../../particle/wizardTeleportParticle */ "./src/particle/wizardTeleportParticle.ts");
const wizardFireball_1 = __webpack_require__(/*! ../../projectile/wizardFireball */ "./src/projectile/wizardFireball.ts");
const random_1 = __webpack_require__(/*! ../../random */ "./src/random.ts");
const enemy_1 = __webpack_require__(/*! ./enemy */ "./src/entity/enemy/enemy.ts");
const lightSource_1 = __webpack_require__(/*! ../../lightSource */ "./src/lightSource.ts");
var WizardState;
(function (WizardState) {
    WizardState[WizardState["idle"] = 0] = "idle";
    WizardState[WizardState["attack"] = 1] = "attack";
    WizardState[WizardState["justAttacked"] = 2] = "justAttacked";
    WizardState[WizardState["teleport"] = 3] = "teleport";
})(WizardState = exports.WizardState || (exports.WizardState = {}));
class WizardEnemy extends enemy_1.Enemy {
    constructor(room, game, x, y, drop) {
        super(room, game, x, y);
        this.ATTACK_RADIUS = 5;
        this.newLightSource = (x, y, radius, color, brightness) => {
            this.lightSource = new lightSource_1.LightSource(x, y, radius, color, brightness);
        };
        this.addLightSource = (lightSource) => {
            this.room.lightSources.push(lightSource);
        };
        this.removeLightSource = (lightSource) => {
            this.room.lightSources = this.room.lightSources.filter((ls) => ls !== lightSource);
        };
        this.hit = () => {
            return 1;
        };
        this.withinAttackingRangeOfPlayer = () => {
            let withinRange = false;
            for (const i in this.game.players) {
                if ((this.x - this.game.players[i].x) ** 2 +
                    (this.y - this.game.players[i].y) ** 2 <=
                    this.ATTACK_RADIUS ** 2) {
                    withinRange = true;
                }
            }
            return withinRange;
        };
        this.shuffle = (a) => {
            let j, x, i;
            for (i = a.length - 1; i > 0; i--) {
                j = Math.floor(random_1.Random.rand() * (i + 1));
                x = a[i];
                a[i] = a[j];
                a[j] = x;
            }
            return a;
        };
        this.behavior = () => {
            this.lastX = this.x;
            this.lastY = this.y;
            if (!this.dead) {
                if (this.skipNextTurns > 0) {
                    this.skipNextTurns--;
                    return;
                }
                if (!this.seenPlayer)
                    this.lookForPlayer();
                else if (this.seenPlayer) {
                    this.alertTicks = Math.max(0, this.alertTicks - 1);
                    switch (this.state) {
                        case WizardState.attack:
                            const nearestPlayerInfo = this.nearestPlayer();
                            if (nearestPlayerInfo !== false) {
                                const [distance, targetPlayer] = nearestPlayerInfo;
                                const attackLength = 20;
                                const offsets = this.calculateProjectileOffsets(targetPlayer.x, targetPlayer.y, 10);
                                this.attemptProjectilePlacement([
                                    { x: -1, y: 0 },
                                    { x: -2, y: 0 },
                                    { x: 1, y: 0 },
                                    { x: 2, y: 0 },
                                    { x: 0, y: -1 },
                                    { x: 0, y: -2 },
                                    { x: 0, y: 1 },
                                    { x: 0, y: 2 },
                                ], wizardFireball_1.WizardFireball, false);
                            }
                            this.state = WizardState.justAttacked;
                            break;
                        case WizardState.justAttacked:
                            this.state = WizardState.idle;
                            break;
                        case WizardState.teleport:
                            let oldX = this.x;
                            let oldY = this.y;
                            let min = 100000;
                            let bestPos;
                            let emptyTiles = this.shuffle(this.room.getEmptyTiles());
                            emptyTiles = emptyTiles.filter((tile) => !this.room.projectiles.some((projectile) => projectile.x === tile.x && projectile.y === tile.y));
                            let optimalDist = game_1.Game.randTable([2, 2, 3, 3, 3, 3, 3], random_1.Random.rand);
                            // pick a random player to target
                            let player_ids = [];
                            for (const i in this.game.players)
                                player_ids.push(i);
                            let target_player_id = game_1.Game.randTable(player_ids, random_1.Random.rand);
                            for (let t of emptyTiles) {
                                let newPos = t;
                                let dist = Math.abs(newPos.x - this.game.players[target_player_id].x) +
                                    Math.abs(newPos.y - this.game.players[target_player_id].y);
                                if (Math.abs(dist - optimalDist) < Math.abs(min - optimalDist)) {
                                    min = dist;
                                    bestPos = newPos;
                                }
                            }
                            if (bestPos) {
                                this.tryMove(bestPos.x, bestPos.y);
                                this.drawX = this.x - oldX;
                                this.drawY = this.y - oldY;
                                this.frame = 0; // trigger teleport animation
                                this.room.particles.push(new wizardTeleportParticle_1.WizardTeleportParticle(oldX, oldY));
                                if (this.withinAttackingRangeOfPlayer()) {
                                    this.state = WizardState.attack;
                                }
                                else {
                                    this.state = WizardState.idle;
                                }
                            }
                            break;
                        case WizardState.idle:
                            this.state = WizardState.teleport;
                            break;
                    }
                }
            }
        };
        this.draw = (delta) => {
            if (this.dead)
                return;
            game_1.Game.ctx.save();
            game_1.Game.ctx.globalAlpha = this.alpha;
            if (!this.dead) {
                this.updateDrawXY(delta);
                if (this.state === WizardState.attack)
                    this.tileX = 7;
                else
                    this.tileX = 6;
                if (this.hasShadow)
                    game_1.Game.drawMob(0, 0, 1, 1, this.x - this.drawX, this.y - this.drawY, 1, 1, this.room.shadeColor, this.shadeAmount());
                if (this.frame >= 0) {
                    game_1.Game.drawMob(Math.floor(this.frame) + 6, 2, 1, 2, this.x, this.y - 1.5, 1, 2, this.softShadeColor, this.shadeAmount());
                    this.frame += 0.2 * delta;
                    if (this.frame > 11)
                        this.frame = -1;
                }
                else {
                    game_1.Game.drawMob(this.tileX, this.tileY, 1, 2, this.x - this.drawX, this.y - 1.3 - this.drawY, 1, 2, this.softShadeColor, this.shadeAmount());
                }
                if (!this.seenPlayer) {
                    this.drawSleepingZs(delta);
                }
                if (this.alertTicks > 0) {
                    this.drawExclamation(delta);
                }
            }
            game_1.Game.ctx.restore();
        };
        this.ticks = 0;
        this.health = 1;
        this.tileX = 6;
        this.tileY = 0;
        this.frame = 0;
        this.state = WizardState.attack;
        this.seenPlayer = false;
        this.alertTicks = 0;
        this.name = "wizard bomber";
        if (drop)
            this.drop = drop;
        if (Math.random() < this.dropChance) {
            this.getDrop([
                "weapon",
                "equipment",
                "consumable",
                "gem",
                "tool",
                "coin",
            ]);
        }
    }
}
exports.WizardEnemy = WizardEnemy;
WizardEnemy.difficulty = 3;
WizardEnemy.tileX = 6;
WizardEnemy.tileY = 0;


/***/ }),

/***/ "./src/entity/enemy/zombieEnemy.ts":
/*!*****************************************!*\
  !*** ./src/entity/enemy/zombieEnemy.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ZombieEnemy = void 0;
const game_1 = __webpack_require__(/*! ../../game */ "./src/game.ts");
const astarclass_1 = __webpack_require__(/*! ../../astarclass */ "./src/astarclass.ts");
const spiketrap_1 = __webpack_require__(/*! ../../tile/spiketrap */ "./src/tile/spiketrap.ts");
const enemy_1 = __webpack_require__(/*! ./enemy */ "./src/entity/enemy/enemy.ts");
class ZombieEnemy extends enemy_1.Enemy {
    constructor(room, game, x, y, drop) {
        super(room, game, x, y);
        this.hit = () => {
            return 1;
        };
        this.behavior = () => {
            // Store the current position
            this.lastX = this.x;
            this.lastY = this.y;
            // If the enemy is not dead
            if (!this.dead) {
                // Skip turns if necessary
                if (this.skipNextTurns > 0) {
                    this.skipNextTurns--;
                    return;
                }
                // Increment the tick counter
                this.ticks++;
                // If the enemy has not seen the player yet
                if (!this.seenPlayer)
                    this.lookForPlayer();
                else if (this.seenPlayer) {
                    // If the target player has taken their turn
                    if (this.room.playerTicked === this.targetPlayer) {
                        // Decrement alert ticks
                        this.alertTicks = Math.max(0, this.alertTicks - 1);
                        // Store the old position
                        let oldX = this.x;
                        let oldY = this.y;
                        // Create a list of positions to avoid
                        let disablePositions = Array();
                        for (const e of this.room.entities) {
                            if (e !== this) {
                                disablePositions.push({ x: e.x, y: e.y });
                            }
                        }
                        for (let xx = this.x - 1; xx <= this.x + 1; xx++) {
                            for (let yy = this.y - 1; yy <= this.y + 1; yy++) {
                                if (this.room.roomArray[xx][yy] instanceof spiketrap_1.SpikeTrap &&
                                    this.room.roomArray[xx][yy].on) {
                                    // Don't walk on active spike traps
                                    disablePositions.push({ x: xx, y: yy });
                                }
                            }
                        }
                        // Create a grid of the room
                        let grid = [];
                        for (let x = 0; x < this.room.roomX + this.room.width; x++) {
                            grid[x] = [];
                            for (let y = 0; y < this.room.roomY + this.room.height; y++) {
                                if (this.room.roomArray[x] && this.room.roomArray[x][y])
                                    grid[x][y] = this.room.roomArray[x][y];
                                else
                                    grid[x][y] = false;
                            }
                        }
                        // Find a path to the target player
                        let moves = astarclass_1.astar.AStar.search(grid, this, this.targetPlayer, disablePositions, false, false, true, this.direction);
                        // If there are moves available
                        if (moves.length > 0) {
                            let moveX = moves[0].pos.x;
                            let moveY = moves[0].pos.y;
                            let oldDir = this.direction;
                            let player = this.targetPlayer;
                            // Face the target player
                            this.facePlayer(player);
                            // Determine the new direction based on the move
                            if (moveX > oldX)
                                this.direction = game_1.Direction.RIGHT;
                            else if (moveX < oldX)
                                this.direction = game_1.Direction.LEFT;
                            else if (moveY > oldY)
                                this.direction = game_1.Direction.DOWN;
                            else if (moveY < oldY)
                                this.direction = game_1.Direction.UP;
                            // If the direction hasn't changed, attempt to move or attack
                            if (oldDir == this.direction) {
                                let hitPlayer = false;
                                for (const i in this.game.players) {
                                    if (this.game.rooms[this.game.players[i].levelID] === this.room &&
                                        this.game.players[i].x === moveX &&
                                        this.game.players[i].y === moveY) {
                                        // Attack the player if they are in the way
                                        this.game.players[i].hurt(this.hit(), this.name);
                                        this.drawX = 0.5 * (this.x - this.game.players[i].x);
                                        this.drawY = 0.5 * (this.y - this.game.players[i].y);
                                        if (this.game.players[i] ===
                                            this.game.players[this.game.localPlayerID])
                                            this.game.shakeScreen(10 * this.drawX, 10 * this.drawY);
                                    }
                                }
                                if (!hitPlayer) {
                                    // Move to the new position
                                    this.tryMove(moveX, moveY);
                                    this.setDrawXY(oldX, oldY);
                                    if (this.x > oldX)
                                        this.direction = game_1.Direction.RIGHT;
                                    else if (this.x < oldX)
                                        this.direction = game_1.Direction.LEFT;
                                    else if (this.y > oldY)
                                        this.direction = game_1.Direction.DOWN;
                                    else if (this.y < oldY)
                                        this.direction = game_1.Direction.UP;
                                }
                            }
                        }
                        // Add positions to avoid based on the current direction
                        if (this.direction == game_1.Direction.LEFT) {
                            disablePositions.push({
                                x: this.x,
                                y: this.y + 1,
                            });
                            disablePositions.push({
                                x: this.x,
                                y: this.y - 1,
                            });
                        }
                        if (this.direction == game_1.Direction.RIGHT) {
                            disablePositions.push({
                                x: this.x,
                                y: this.y + 1,
                            });
                            disablePositions.push({
                                x: this.x,
                                y: this.y - 1,
                            });
                        }
                        if (this.direction == game_1.Direction.DOWN) {
                            disablePositions.push({
                                x: this.x + 1,
                                y: this.y,
                            });
                            disablePositions.push({
                                x: this.x - 1,
                                y: this.y,
                            });
                        }
                        if (this.direction == game_1.Direction.UP) {
                            disablePositions.push({
                                x: this.x + 1,
                                y: this.y,
                            });
                            disablePositions.push({
                                x: this.x - 1,
                                y: this.y,
                            });
                        }
                        // Make hit warnings
                        this.makeHitWarnings();
                    }
                    // Check if the target player is offline
                    let targetPlayerOffline = Object.values(this.game.offlinePlayers).indexOf(this.targetPlayer) !==
                        -1;
                    // If the enemy is not aggro or the target player is offline, find a new target player
                    if (!this.aggro || targetPlayerOffline) {
                        let p = this.nearestPlayer();
                        if (p !== false) {
                            let [distance, player] = p;
                            if (distance <= 4 &&
                                (targetPlayerOffline ||
                                    distance < this.playerDistance(this.targetPlayer))) {
                                if (player !== this.targetPlayer) {
                                    this.targetPlayer = player;
                                    this.facePlayer(player);
                                    if (player === this.game.players[this.game.localPlayerID])
                                        this.alertTicks = 1;
                                    this.makeHitWarnings();
                                }
                            }
                        }
                    }
                }
            }
        };
        this.draw = (delta) => {
            if (this.dead)
                return;
            //this.updateShadeColor(delta);
            game_1.Game.ctx.globalAlpha = this.alpha;
            this.updateDrawXY(delta);
            this.frame += 0.1 * delta;
            if (this.frame >= 4)
                this.frame = 0;
            if (this.hasShadow)
                game_1.Game.drawMob(0, 0, 1, 1, this.x - this.drawX, this.y - this.drawY, 1, 1, this.shadeColor, this.shadeAmount());
            game_1.Game.drawMob(this.tileX + Math.floor(this.frame), this.tileY + this.direction * 2, 1, 2, this.x - this.drawX, this.y - this.drawYOffset - this.drawY - this.jumpY, 1, 2, this.softShadeColor, this.shadeAmount());
            if (!this.cloned) {
                if (!this.seenPlayer) {
                    this.drawSleepingZs(delta);
                }
                if (this.alertTicks > 0) {
                    this.drawExclamation(delta);
                }
            }
            game_1.Game.ctx.globalAlpha = 1;
        };
        this.ticks = 0;
        this.frame = 0;
        this.health = 1;
        this.maxHealth = 1;
        this.tileX = 17;
        this.tileY = 8;
        this.seenPlayer = false;
        this.aggro = false;
        this.dir = game_1.Direction.DOWN;
        this.name = "zombie";
        this.forwardOnlyAttack = true;
        this.drawMoveSpeed = 0.2;
        this.jumpHeight = 0.35;
        if (drop)
            this.drop = drop;
        if (Math.random() < this.dropChance) {
            this.getDrop(["consumable", "gem", "tool", "coin"]);
        }
    }
}
exports.ZombieEnemy = ZombieEnemy;
ZombieEnemy.difficulty = 1;
ZombieEnemy.tileX = 17;
ZombieEnemy.tileY = 8;


/***/ }),

/***/ "./src/entity/entity.ts":
/*!******************************!*\
  !*** ./src/entity/entity.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Entity = exports.EntityType = exports.EntityDirection = void 0;
const game_1 = __webpack_require__(/*! ../game */ "./src/game.ts");
const healthbar_1 = __webpack_require__(/*! ../healthbar */ "./src/healthbar.ts");
const drawable_1 = __webpack_require__(/*! ../drawable */ "./src/drawable.ts");
const gameConstants_1 = __webpack_require__(/*! ../gameConstants */ "./src/gameConstants.ts");
const hitWarning_1 = __webpack_require__(/*! ../hitWarning */ "./src/hitWarning.ts");
const utils_1 = __webpack_require__(/*! ../utils */ "./src/utils.ts");
const eventBus_1 = __webpack_require__(/*! ../eventBus */ "./src/eventBus.ts");
const events_1 = __webpack_require__(/*! ../events */ "./src/events.ts");
const damageNumber_1 = __webpack_require__(/*! ../particle/damageNumber */ "./src/particle/damageNumber.ts");
const downLadder_1 = __webpack_require__(/*! ../tile/downLadder */ "./src/tile/downLadder.ts");
const door_1 = __webpack_require__(/*! ../tile/door */ "./src/tile/door.ts");
const wall_1 = __webpack_require__(/*! ../tile/wall */ "./src/tile/wall.ts");
const dropTable_1 = __webpack_require__(/*! ../item/dropTable */ "./src/item/dropTable.ts");
const weapon_1 = __webpack_require__(/*! ../weapon/weapon */ "./src/weapon/weapon.ts");
const enemyShield_1 = __webpack_require__(/*! ../projectile/enemyShield */ "./src/projectile/enemyShield.ts");
const sound_1 = __webpack_require__(/*! ../sound */ "./src/sound.ts");
const imageParticle_1 = __webpack_require__(/*! ../particle/imageParticle */ "./src/particle/imageParticle.ts");
var EntityDirection;
(function (EntityDirection) {
    EntityDirection[EntityDirection["DOWN"] = 0] = "DOWN";
    EntityDirection[EntityDirection["UP"] = 1] = "UP";
    EntityDirection[EntityDirection["RIGHT"] = 2] = "RIGHT";
    EntityDirection[EntityDirection["LEFT"] = 3] = "LEFT";
})(EntityDirection = exports.EntityDirection || (exports.EntityDirection = {}));
var EntityType;
(function (EntityType) {
    EntityType[EntityType["ENEMY"] = 0] = "ENEMY";
    EntityType[EntityType["FRIENDLY"] = 1] = "FRIENDLY";
    EntityType[EntityType["RESOURCE"] = 2] = "RESOURCE";
    EntityType[EntityType["PROP"] = 3] = "PROP";
    EntityType[EntityType["CHEST"] = 4] = "CHEST";
})(EntityType = exports.EntityType || (exports.EntityType = {}));
class Entity extends drawable_1.Drawable {
    constructor(room, game, x, y) {
        super();
        this.sleepingZFrame = 0;
        this.imageParticleX = 0;
        this.imageParticleY = 26;
        this.dropChance = 0.02;
        //shadeColor: string;
        this.shadeMultiplier = 1;
        this.bloomColor = "#FFFFFF";
        this.bloomAlpha = 1;
        this.softBloomAlpha = 1;
        this.bloomSize = 1;
        this.bloomOffsetY = 0;
        this.applyShield = (shieldHealth = 1) => {
            if (!this.shieldedBefore) {
                this.shield = new enemyShield_1.EnemyShield(this, this.x, this.y, shieldHealth);
                this.shielded = true;
                this.shieldedBefore = true;
                this.health += shieldHealth;
                this.maxHealth += shieldHealth;
                this.shadeColor = "purple";
                this.shadeMultiplier = 0.5;
                this.hasBloom = true;
                this.bloomColor = "#2E0854";
                this.bloomAlpha = 1;
            }
        };
        this.removeShield = () => {
            if (this.shield) {
                this.health -= this.shield.health;
                this.maxHealth -= this.shield.health;
                this.shield.remove();
                this.shadeColor = this.room.shadeColor;
                this.shadeMultiplier = 1;
                this.hasBloom = false;
                this.bloomAlpha = 0;
            }
        };
        this.getDrop = (useCategory = [], force = false) => {
            dropTable_1.DropTable.getDrop(this, false, useCategory, force);
            //make monsters drop degraded weapons
            if (this.drop instanceof weapon_1.Weapon && this.type === EntityType.ENEMY) {
                this.drop.durability = Math.floor(Math.random() * 0.31 * this.drop.durabilityMax);
                this.drop.durabilityMax;
            }
        };
        this.addLightSource = (lightSource) => {
            this.room.lightSources.push(lightSource);
        };
        this.removeLightSource = (lightSource) => {
            this.room.lightSources = this.room.lightSources.filter((ls) => ls !== lightSource);
            this.lightSource = null;
            this.room.updateLighting();
        };
        this.behavior = () => { };
        this.hit = () => {
            return 0;
        };
        this.hurtCallback = () => { };
        this.pointIn = (x, y) => {
            return (x >= this.x && x < this.x + this.w && y >= this.y && y < this.y + this.h);
        };
        this.createDamageNumber = (damage, type = "none") => {
            let color = "red";
            let outlineColor = gameConstants_1.GameConstants.OUTLINE;
            if (type === "poison")
                color = "green";
            if (type === "blood") {
                color = "#8B0000";
                outlineColor = "red";
            }
            if (type === "heal") {
                color = "#B8A4FF";
                outlineColor = gameConstants_1.GameConstants.OUTLINE;
            }
            this.room.particles.push(new damageNumber_1.DamageNumber(this.room, this.x, this.y, damage, color, outlineColor));
        };
        this.updateDrawXY = (delta) => {
            //putting this here bc i'm lazy
            this.updateHurtFrame(delta);
            this.animateDying(delta);
            this.updateShadeColor(delta);
            //this.updateBloom(delta);
            if (!this.doneMoving()) {
                this.drawX *= 0.9 ** delta;
                this.drawY *= 0.9 ** delta;
                this.drawX = Math.abs(this.drawX) < 0.01 ? 0 : this.drawX;
                this.drawY = Math.abs(this.drawY) < 0.01 ? 0 : this.drawY;
            }
        };
        this.setDrawXY = (x, y) => {
            this.drawX += this.x - x;
            this.drawY += this.y - y;
        };
        this.getPlayer = () => {
            const maxDistance = 138291380921; // pulled this straight outta my ass
            let closestDistance = maxDistance;
            let closestPlayer = null;
            for (const i in this.game.players) {
                if (this.game.rooms[this.game.players[i].levelID] === this.room) {
                    let distance = this.playerDistance(this.game.players[i]);
                    if (distance < closestDistance) {
                        closestDistance = distance;
                        closestPlayer = this.game.players[i];
                    }
                }
            }
            if (closestDistance === maxDistance)
                return false;
            else
                return closestPlayer;
        };
        this.hurt = (playerHitBy, damage, type = "none") => {
            this.handleEnemyCase(playerHitBy);
            let hitShield = false;
            let shieldHealth = 0;
            if (this.shielded) {
                shieldHealth = this.shield.health;
                if (shieldHealth > 0) {
                    this.shield.hurt(damage);
                    hitShield = true;
                }
            }
            /*
            this.shadeColor = "red";
            setTimeout(() => {
              this.shadeColor = this.room.shadeColor;
            }, 100);
            */
            this.health -= damage;
            this.maxHealth -= shieldHealth;
            this.startHurting();
            this.createDamageNumber(damage, type);
            this.playHitSound();
            this.healthBar.hurt();
            if (type === "none" || this.health <= 0 || !this.isEnemy) {
                this.createHitParticles();
            }
            if (this.health <= 0) {
                this.kill();
                this.bloomAlpha = 0;
            }
            else
                this.hurtCallback();
        };
        this.startHurting = () => {
            this.hurting = true;
            this.hurtFrame += 15;
            this.shadeColor = "#FF0000";
            this.shadeMultiplier = 1.5;
        };
        this.stopHurting = () => {
            this.hurting = false;
            this.hurtFrame = 0;
            this.shadeColor = "#000000";
        };
        this.interact = (player) => { };
        this.handleEnemyCase = (playerHitBy) => { };
        this.playHitSound = () => {
            if (this.hitSound)
                sound_1.Sound.delayPlay(this.hitSound, 250);
        };
        this.createHitParticles = () => {
            imageParticle_1.ImageParticle.spawnCluster(this.room, this.x + 0.5, this.y + 0.5, this.imageParticleX, this.imageParticleY);
        };
        this.dropLoot = () => {
            let coordX;
            let coordY;
            if (this.crushed) {
                coordX = this.lastX;
                coordY = this.lastY;
            }
            else {
                coordX = this.x;
                coordY = this.y;
            }
            if (this.drop) {
                this.drop.level = this.room;
                if (!this.room.roomArray[coordX][coordY].isSolid()) {
                    this.drop.x = coordX;
                    this.drop.y = coordY;
                }
                this.room.items.push(this.drop);
                this.drop.onDrop();
            }
        };
        this.kill = (player) => {
            if (this.cloned)
                return;
            this.emitEnemyKilled();
            this.removeLightSource(this.lightSource);
            const deadEntity = this.clone();
            this.room.deadEntities.push(deadEntity);
            this.dead = true;
            //this.room.entities = this.room.entities.filter((e) => e !== this);
            this.dropLoot();
            this.uniqueKillBehavior();
        };
        this.uniqueKillBehavior = () => { };
        this.killNoBones = () => {
            this.dead = true;
            this.dropLoot();
        };
        this.updateHurtFrame = (delta) => {
            if (this.hurting) {
                this.hurtFrame -= delta;
                if (this.hurtFrame < 0) {
                    this.stopHurting();
                }
            }
        };
        this.shadeAmount = () => {
            let softVis = this.room.softVis[this.x][this.y] * 1;
            if (this.shadeMultiplier > 1)
                return Math.min(1, softVis * this.shadeMultiplier);
            return this.room.softVis[this.x][this.y];
        };
        this.updateShadeColor = (delta) => {
            if (this.shadeMultiplier > 1)
                this.shadeMultiplier -= 0.01 * delta;
            if (this.shadeMultiplier < 1)
                this.shadeMultiplier = 1;
            let updated = false;
            // Convert hex color to RGB
            const hexToRgb = (hex) => {
                const bigint = parseInt(hex.slice(1), 16);
                const r = (bigint >> 16) & 255;
                const g = (bigint >> 8) & 255;
                const b = bigint & 255;
                return [r, g, b];
            };
            // Convert RGB to hex color
            const rgbToHex = (rgb) => {
                const [r, g, b] = rgb;
                return ("#" +
                    ((1 << 24) + (r << 16) + (g << 8) + b)
                        .toString(16)
                        .slice(1)
                        .toUpperCase());
            };
            const [softR, softG, softB] = hexToRgb(this.softShadeColor);
            const [targetR, targetG, targetB] = hexToRgb(this.shadeColor);
            // Calculate differences
            let diffR = softR - targetR;
            let diffG = softG - targetG;
            let diffB = softB - targetB;
            let flagR = false;
            let flagG = false;
            let flagB = false;
            if (Math.abs(diffR) > 1)
                flagR = true;
            if (Math.abs(diffG) > 1)
                flagG = true;
            if (Math.abs(diffB) > 1)
                flagB = true;
            if (!flagR && !flagG && !flagB) {
                return this.softShadeColor;
            }
            let softShadeRgb = [softR, softG, softB];
            // Apply smoothing similar to fadeLighting
            if (flagR) {
                diffR *= 0.1 * delta;
                softShadeRgb[0] = this.room.clamp(Math.round(softR - diffR), 0, 255);
                updated = true;
            }
            if (flagG) {
                diffG *= 0.1 * delta;
                softShadeRgb[1] = this.room.clamp(Math.round(softG - diffG), 0, 255);
                updated = true;
            }
            if (flagB) {
                diffB *= 0.1 * delta;
                softShadeRgb[2] = this.room.clamp(Math.round(softB - diffB), 0, 255);
                updated = true;
            }
            if (updated) {
                this.softShadeColor = rgbToHex(softShadeRgb);
            }
            return this.softShadeColor;
        };
        this.emitEnemyKilled = () => {
            eventBus_1.globalEventBus.emit(events_1.EVENTS.ENEMY_KILLED, {
                enemyId: this.name,
            });
        };
        this.doneMoving = () => {
            let EPSILON = 0.01;
            return Math.abs(this.drawX) < EPSILON && Math.abs(this.drawY) < EPSILON;
        };
        this.nearestPlayer = () => {
            const maxDistance = 138291380921; // pulled this straight outta my ass
            let closestDistance = maxDistance;
            let closestPlayer = null;
            for (const i in this.game.players) {
                if (this.game.rooms[this.game.players[i].levelID] === this.room) {
                    let distance = this.playerDistance(this.game.players[i]);
                    if (distance < closestDistance) {
                        closestDistance = distance;
                        closestPlayer = this.game.players[i];
                    }
                }
            }
            if (closestDistance === maxDistance)
                return false;
            else
                return [closestDistance, closestPlayer];
        };
        this.playerDistance = (player) => {
            return Math.max(Math.abs(this.x - player.x), Math.abs(this.y - player.y));
        };
        this.facePlayer = (player) => {
            let dx = player.x - this.x;
            let dy = player.y - this.y;
            if (Math.abs(dx) === Math.abs(dy)) {
                // just moved, already facing player
            }
            else if (Math.abs(dx) > Math.abs(dy)) {
                if (dx > 0)
                    this.direction = game_1.Direction.RIGHT;
                if (dx < 0)
                    this.direction = game_1.Direction.LEFT;
            }
            else {
                if (dy > 0)
                    this.direction = game_1.Direction.DOWN;
                if (dy < 0)
                    this.direction = game_1.Direction.UP;
            }
        };
        this.animateDying = (delta) => {
            if (this.cloned) {
                //this.frame = 0;
                this.dyingFrame -= delta / 3;
                this.alpha = Math.max(0, this.alpha - delta / 50);
                if (this.dyingFrame <= 0) {
                    this.dead = true;
                    this.dying = false;
                    this.uniqueKillBehavior();
                    this.room.clearDeadStuff();
                }
            }
        };
        this.draw = (delta) => {
            if (!this.dead) {
                game_1.Game.ctx.globalAlpha = this.alpha;
                if (this.shielded)
                    if (this.hasShadow) {
                        game_1.Game.drawFX(0, 0, 1, 1, this.x - this.drawX, this.y - this.drawY, 1, 1, this.shadeColor, this.shadeAmount());
                    }
                game_1.Game.drawMob(0, 0, 1, 1, this.x - this.drawX, this.y - this.drawY, 1, 1, this.room.shadeColor, this.shadeAmount());
                game_1.Game.drawMob(this.tileX, this.tileY + this.direction * 2, 1, 2, this.x - this.drawX, this.y - this.drawYOffset - this.drawY, 1, 2, this.shadeColor, this.shadeAmount());
            }
            /*if (this.crushed) {
              this.crushAnim(delta);
            }*/
            game_1.Game.ctx.globalAlpha = 1;
        };
        this.tick = () => {
            this.behavior();
            if (this.shielded)
                this.shield.updateLightSourcePos();
        };
        this.emitEntityData = () => {
            eventBus_1.globalEventBus.emit("EntityData", {
                name: this.name,
                location: { x: this.x, y: this.y },
            });
        };
        this.drawTopLayer = (delta) => {
            //this.updateDrawXY(delta);
            this.drawableY = this.y - this.drawY;
            this.healthBar.draw(delta, this.health, this.maxHealth, this.x, this.y, true);
        };
        this.drawSleepingZs = (delta, offsetX = 0, offsetY = 0) => {
            this.sleepingZFrame += delta;
            let numZs = 2;
            let t = this.sleepingZFrame * 0.01; // 0 <= t < 1
            t -= Math.floor(t);
            //let whichway = Math.floor(this.sleepingZFrame * 0.02 / numZs) % 2;
            for (let off = numZs - 1; off >= 0; off--) {
                let yoff = (t + off) * 7;
                let alpha = Math.min(1 - (t + off) / numZs, (2 * (t + off)) / numZs);
                let xoff = 0;
                if (off === 0)
                    xoff = 1;
                if (t >= 0.33 && t < 0.66)
                    xoff = off;
                if (t >= 0.33 && t < 0.66)
                    xoff = off;
                let width = game_1.Game.measureText("Z").width;
                if (gameConstants_1.GameConstants.ALPHA_ENABLED)
                    game_1.Game.ctx.globalAlpha = alpha;
                game_1.Game.fillTextOutline("Z", (this.x + 0.5) * gameConstants_1.GameConstants.TILESIZE - width / 2 + xoff + offsetX, (this.y - 0.6) * gameConstants_1.GameConstants.TILESIZE - yoff + offsetY, gameConstants_1.GameConstants.OUTLINE, "white");
                game_1.Game.ctx.globalAlpha = 1;
            }
        };
        this.drawExclamation = (delta, offsetX = 0, offsetY = 0) => {
            this.exclamationFrame += delta;
            let yoff = 0;
            let yoffs = [0, -1, -2, -3, -5, -7, -4];
            if (this.exclamationFrame > yoffs.length)
                yoff = yoffs[yoffs.length - 1];
            else
                yoff = yoffs[this.exclamationFrame];
            let width = game_1.Game.measureText("!").width;
            game_1.Game.ctx.globalAlpha = 1;
            if (yoff !== false) {
                game_1.Game.fillTextOutline("!", (this.x + 0.5) * gameConstants_1.GameConstants.TILESIZE - width / 2 + offsetX, (this.y - 0.75) * gameConstants_1.GameConstants.TILESIZE + yoff + offsetY, gameConstants_1.GameConstants.OUTLINE, gameConstants_1.GameConstants.WARNING_RED);
            }
        };
        this.crush = () => {
            this.crushed = true;
            let player;
            for (let i in this.game.players) {
                player = this.game.players[i];
            }
            if (this.x == player.x) {
                this.crushVertical = true;
            }
            this.kill();
        };
        this.crushAnim = (delta) => {
            if (this.crushVertical && this.crushY >= 0) {
                this.crushY *= 0.95;
            }
            else if (this.crushX >= 0) {
                this.crushX *= 0.95;
            }
        };
        //set rumbling in the tick function for the enemies
        //create variables for the rumbling x and y offsets
        //return the rumbling x and y offsets
        //add the rumbling x and y offsets to the enemy's x and y in the draw function
        this.rumble = (rumbling, frame, direction) => {
            let rumbleOffset = { x: 0, y: 0 };
            if (rumbling) {
                const isOddFrame = Math.floor(frame) % 2 === 1;
                const offset = isOddFrame ? 0.0325 : 0;
                if (direction === game_1.Direction.LEFT || direction === game_1.Direction.RIGHT) {
                    rumbleOffset.y = offset;
                }
                else if (direction === game_1.Direction.UP ||
                    direction === game_1.Direction.DOWN ||
                    !direction) {
                    rumbleOffset.x = offset;
                }
                this.animationSpeed = 0.2;
            }
            return rumbleOffset;
        };
        this.attemptProjectilePlacement = (offsets, projectileClass, collide = false, clearPath = true, targetingPlayer = false) => {
            for (const offset of offsets) {
                const targetX = this.x + offset.x;
                const targetY = this.y + offset.y;
                if (!this.isValidProjectilePosition(targetX, targetY, collide, clearPath)) {
                    if (targetingPlayer)
                        break;
                    continue;
                }
                this.placeProjectile(projectileClass, targetX, targetY);
                if (targetingPlayer)
                    break;
            }
        };
        this.isValidProjectilePosition = (x, y, collide, clearPath) => {
            if (!this.isWithinRoomBounds(x, y))
                return false;
            if (clearPath && !this.isPathClear(this.x, this.y, x, y))
                return false;
            if (collide && this.isEntityColliding(x, y))
                return false;
            const targetTile = this.room.roomArray[x][y];
            return targetTile && !targetTile.isSolid() && !targetTile.isDoor;
        };
        this.isEntityColliding = (x, y) => {
            return this.room.entities.some((entity) => entity.x === x && entity.y === y);
        };
        this.placeProjectile = (projectileClass, x, y, color) => {
            this.room.projectiles.push(new projectileClass(this, x, y, color));
        };
        this.isPathClear = (startX, startY, endX, endY) => {
            const dx = Math.sign(endX - startX);
            const dy = Math.sign(endY - startY);
            let x = startX;
            let y = startY;
            while (x !== endX || y !== endY) {
                x += dx;
                y += dy;
                if (!this.isWithinRoomBounds(x, y) ||
                    this.room.roomArray[x][y]?.isSolid()) {
                    return false;
                }
            }
            return true;
        };
        this.getLuminance = () => {
            if (this.room.roomArray[this.x][this.y]) {
                return this.room.vis[this.x][this.y];
            }
            return null;
        };
        this.getAverageLuminance = () => {
            let total = 0;
            let count = 0;
            for (let x = this.x - 2; x <= this.x + 2; x++) {
                if (this.room.roomArray[x] && this.room.roomArray[x][this.y]) {
                    for (let y = this.y - 2; y <= this.y + 2; y++) {
                        if (this.room.vis[x][y]) {
                            total += this.room.vis[x][y];
                            count++;
                        }
                    }
                }
            }
            return total / count;
        };
        this.getOpenTile = () => {
            let x, y;
            do {
                x = Math.floor(Math.random() * 3 + this.x - 1);
                y = Math.floor(Math.random() * 3 + this.y - 1);
            } while ((x === this.x && y === this.y) ||
                this.room.roomArray[x][y].isSolid() ||
                this.room.roomArray[x][y] instanceof downLadder_1.DownLadder ||
                this.room.roomArray[x][y] instanceof door_1.Door ||
                this.room.roomArray[x][y] instanceof wall_1.Wall ||
                this.room.entities.some((e) => e.x === x && e.y === y));
            if (!x || !y)
                return { x: this.x, y: this.y };
            return { x, y };
        };
        this.makeHitWarnings = () => {
            const cullFactor = 0.45;
            const player = this.getPlayer();
            const orthogonal = this.orthogonalAttack;
            const diagonal = this.diagonalAttack;
            const forwardOnly = this.forwardOnlyAttack;
            const direction = this.direction;
            const orthoRange = this.attackRange;
            const diagRange = this.diagonalAttackRange;
            const generateOffsets = (isOrthogonal, range) => {
                const baseOffsets = isOrthogonal
                    ? [
                        [-1, 0],
                        [1, 0],
                        [0, -1],
                        [0, 1],
                    ]
                    : [
                        [-1, -1],
                        [1, 1],
                        [1, -1],
                        [-1, 1],
                    ];
                return baseOffsets.flatMap(([dx, dy]) => Array.from({ length: range }, (_, i) => [(i + 1) * dx, (i + 1) * dy]));
            };
            const directionOffsets = {
                [game_1.Direction.LEFT]: [-1, 0],
                [game_1.Direction.RIGHT]: [1, 0],
                [game_1.Direction.UP]: [0, -1],
                [game_1.Direction.DOWN]: [0, 1],
            };
            let offsets = [];
            if (forwardOnly) {
                const [dx, dy] = directionOffsets[direction];
                offsets = Array.from({ length: orthoRange }, (_, i) => [
                    (i + 1) * dx,
                    (i + 1) * dy,
                ]);
            }
            else {
                if (orthogonal)
                    offsets.push(...generateOffsets(true, orthoRange));
                if (diagonal)
                    offsets.push(...generateOffsets(false, diagRange));
            }
            const warningCoordinates = offsets
                .map(([dx, dy]) => ({
                x: dx,
                y: dy,
                distance: utils_1.Utils.distance(dx, dy, player.x - this.x, player.y - this.y),
            }))
                .sort((a, b) => a.distance - b.distance);
            const keepCount = Math.ceil(warningCoordinates.length * (1 - cullFactor));
            const culledWarnings = warningCoordinates.slice(0, keepCount);
            culledWarnings.forEach(({ x, y }) => {
                const targetX = this.x + x;
                const targetY = this.y + y;
                if (this.isWithinRoomBounds(targetX, targetY)) {
                    const hitWarning = new hitWarning_1.HitWarning(this.game, targetX, targetY, this.x, this.y, true, false, this);
                    this.room.hitwarnings.push(hitWarning);
                    //this.hitWarnings.push(hitWarning);
                }
            });
        };
        this.isWithinRoomBounds = (x, y) => {
            const xInBounds = x >= this.room.roomX && x < this.room.roomX + this.room.width;
            const yInBounds = y >= this.room.roomY && y < this.room.roomY + this.room.height;
            const tileExists = this.room.roomArray[x] && this.room.roomArray[x][y] !== undefined;
            return xInBounds && yInBounds && tileExists;
        };
        this.room = room;
        this.x = x;
        this.y = y;
        this.w = 1;
        this.h = 1;
        this.game = game;
        this.drawX = 0;
        this.drawY = 0;
        this.health = 1;
        this.maxHealth = 1;
        this.tileX = 0;
        this.tileY = 0;
        this.hasShadow = false;
        this.skipNextTurns = 0;
        this.direction = game_1.Direction.DOWN;
        this.destroyable = true;
        this.pushable = false;
        this.chainPushable = true;
        this.interactable = false;
        this.healthBar = new healthbar_1.HealthBar();
        this.alertTicks = 0;
        this.exclamationFrame = 0;
        this.lastX = x;
        this.lastY = y;
        this.hitBy = null;
        this.crushX = 1;
        this.crushY = 1;
        this.crushVertical = false;
        this.crushed = false;
        this.rumbling = false;
        this.animationSpeed = 0.1;
        this.drawYOffset = 1.175;
        this.hitWarnings = [];
        this.orthogonalAttack = false;
        this.diagonalAttack = false;
        this.forwardOnlyAttack = false;
        this.attackRange = 1;
        this.diagonalAttackRange = 1;
        this.drawMoveSpeed = 0.3;
        this.unconscious = false;
        this.dropChance = 0.02;
        this.isEnemy = false;
        this.shielded = false;
        this.shield = null;
        this.frame = 0;
        this.shieldedBefore = false;
        this._imageParticleTiles = { x: 0, y: 0 };
        this.hitSound = null;
        this.shadeColor = this.room.shadeColor;
        this.hurting = false;
        this.hurtFrame = 0;
        this.softShadeColor = "#000000";
        this.dying = false;
        this.dyingFrame = 30;
        this.alpha = 1;
        this.cloned = false;
        this.dead = false;
        this.hasBloom = false;
        this.bloomColor = "#FFFFFF";
        this.moving = false;
    }
    static add(room, game, x, y, ...rest) {
        room.entities.push(new this(room, game, x, y, ...rest));
    }
    static cloneEntity(original) {
        const { room, game, x, y } = original;
        // Create a new instance using the constructor
        const cloned = new original.constructor(room, game, x, y);
        // Assign other properties
        cloned.cloned = true;
        cloned.dead = false;
        cloned.dying = true;
        cloned.drawableY = original.drawableY;
        cloned.tileX = original.tileX;
        cloned.tileY = original.tileY;
        cloned.frame = original.frame;
        cloned.isEnemy = original.isEnemy;
        cloned.hasShadow = original.hasShadow;
        cloned.skipNextTurns = original.skipNextTurns;
        cloned.direction = original.direction;
        cloned.drawX = original.drawX;
        cloned.drawY = original.drawY;
        cloned.alpha = original.alpha;
        cloned.shadeColor = original.shadeColor;
        cloned.shadeMultiplier = original.shadeMultiplier;
        cloned.softShadeColor = original.softShadeColor;
        cloned.hasBloom = original.hasBloom;
        cloned.bloomColor = original.bloomColor;
        cloned.bloomAlpha = 1;
        cloned.softBloomAlpha = 1;
        cloned.removeLightSource(cloned.lightSource);
        cloned.room.updateLighting();
        // Add the cloned entity to deadEntities
        room.deadEntities.push(cloned);
        return cloned;
    }
    /**
     * Clones the current entity without adding it to deadEntities.
     */
    clone() {
        const cloned = Entity.cloneEntity(this);
        cloned.dead = false; // Explicitly set as not dead
        cloned.dying = true; // Ensure the clone is in a dying state
        return cloned;
    }
    get imageParticleTiles() {
        return this._imageParticleTiles;
    }
    get type() {
        return EntityType.ENEMY;
    }
    calculateProjectileOffsets(targetX, targetY, attackLength) {
        const dx = targetX - this.x;
        const dy = targetY - this.y;
        let offsets = [];
        // Normalize the direction
        const stepX = dx !== 0 ? Math.sign(dx) : 0;
        const stepY = dy !== 0 ? Math.sign(dy) : 0;
        // Generate offsets for the full attackLength
        for (let i = 1; i <= attackLength; i++) {
            offsets.push({ x: i * stepX, y: i * stepY });
        }
        return offsets;
    }
}
exports.Entity = Entity;


/***/ }),

/***/ "./src/entity/object/barrel.ts":
/*!*************************************!*\
  !*** ./src/entity/object/barrel.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Barrel = void 0;
const entity_1 = __webpack_require__(/*! ../entity */ "./src/entity/entity.ts");
const game_1 = __webpack_require__(/*! ../../game */ "./src/game.ts");
const entity_2 = __webpack_require__(/*! ../entity */ "./src/entity/entity.ts");
const weaponFragments_1 = __webpack_require__(/*! ../../item/weaponFragments */ "./src/item/weaponFragments.ts");
const coin_1 = __webpack_require__(/*! ../../item/coin */ "./src/item/coin.ts");
class Barrel extends entity_1.Entity {
    constructor(room, game, x, y) {
        super(room, game, x, y);
        this.killNoBones = () => {
            this.kill();
        };
        this.draw = (delta) => {
            if (this.dead)
                return;
            game_1.Game.ctx.save();
            //this.updateShadeColor(delta);
            game_1.Game.ctx.globalAlpha = this.alpha;
            if (!this.dead) {
                this.updateDrawXY(delta);
                game_1.Game.drawObj(this.tileX, this.tileY, 1, 2, this.x - this.drawX, this.y - this.drawYOffset - this.drawY, 1, 2, this.room.shadeColor, this.shadeAmount());
            }
            game_1.Game.ctx.restore();
        };
        this.drawTopLayer = (delta) => {
            this.drawableY = this.y;
        };
        this.room = room;
        this.health = 1;
        this.tileX = 1;
        this.tileY = 0;
        this.hasShadow = false;
        this.pushable = true;
        this.name = "barrel";
        this.imageParticleX = 3;
        this.imageParticleY = 25;
        if (Math.random() < 0.1) {
            this.drop = new weaponFragments_1.WeaponFragments(this.room, this.x, this.y);
        }
        else {
            this.drop = new coin_1.Coin(this.room, this.x, this.y);
        }
    }
    get type() {
        return entity_2.EntityType.PROP;
    }
}
exports.Barrel = Barrel;


/***/ }),

/***/ "./src/entity/object/block.ts":
/*!************************************!*\
  !*** ./src/entity/object/block.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Block = void 0;
const entity_1 = __webpack_require__(/*! ../entity */ "./src/entity/entity.ts");
const game_1 = __webpack_require__(/*! ../../game */ "./src/game.ts");
const entity_2 = __webpack_require__(/*! ../entity */ "./src/entity/entity.ts");
const imageParticle_1 = __webpack_require__(/*! ../../particle/imageParticle */ "./src/particle/imageParticle.ts");
const sound_1 = __webpack_require__(/*! ../../sound */ "./src/sound.ts");
class Block extends entity_1.Entity {
    constructor(room, game, x, y) {
        super(room, game, x, y);
        this.kill = () => {
            sound_1.Sound.breakRock();
            this.dead = true;
            imageParticle_1.ImageParticle.spawnCluster(this.room, this.x + 0.5, this.y + 0.5, this.imageParticleX, this.imageParticleY);
        };
        this.killNoBones = () => {
            this.kill();
        };
        this.draw = (delta) => {
            if (this.dead)
                return;
            game_1.Game.ctx.save();
            game_1.Game.ctx.globalAlpha = this.alpha;
            if (!this.dead) {
                this.updateDrawXY(delta);
                game_1.Game.drawObj(this.tileX, this.tileY, 1, 2, this.x - this.drawX, this.y - this.drawYOffset - this.drawY, 1, 2, this.room.shadeColor, this.shadeAmount());
            }
            game_1.Game.ctx.restore();
        };
        this.drawTopLayer = (delta) => {
            this.drawableY = this.y;
        };
        this.room = room;
        this.health = 1;
        this.tileX = 10;
        this.tileY = 2;
        this.hasShadow = false;
        this.chainPushable = true;
        this.pushable = true;
        this.name = "block";
        this.imageParticleX = 0;
        this.imageParticleY = 25;
    }
    get type() {
        return entity_2.EntityType.PROP;
    }
}
exports.Block = Block;


/***/ }),

/***/ "./src/entity/object/bomb.ts":
/*!***********************************!*\
  !*** ./src/entity/object/bomb.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Bomb = void 0;
const entity_1 = __webpack_require__(/*! ../entity */ "./src/entity/entity.ts");
const game_1 = __webpack_require__(/*! ../../game */ "./src/game.ts");
const genericParticle_1 = __webpack_require__(/*! ../../particle/genericParticle */ "./src/particle/genericParticle.ts");
const entity_2 = __webpack_require__(/*! ../entity */ "./src/entity/entity.ts");
const sound_1 = __webpack_require__(/*! ../../sound */ "./src/sound.ts");
const lightSource_1 = __webpack_require__(/*! ../../lightSource */ "./src/lightSource.ts");
const lighting_1 = __webpack_require__(/*! ../../lighting */ "./src/lighting.ts");
const explosion_1 = __webpack_require__(/*! ../../projectile/explosion */ "./src/projectile/explosion.ts");
const utils_1 = __webpack_require__(/*! ../../utils */ "./src/utils.ts");
class Bomb extends entity_1.Entity {
    constructor(room, game, x, y) {
        super(room, game, x, y);
        this.fuseLength = 4;
        this.lit = false;
        this.playerHitBy = null;
        this.soundPaused = false;
        this.killNoBones = () => {
            this.kill();
        };
        this.uniqueKillBehavior = () => {
            if (this.cloned)
                return;
            //this.room.addEntity(new Explosion(this.room, this.game, this.x, this.y));
        };
        this.tick = () => {
            if (this.lit) {
                this.fuseLength--;
                //if (this.fuseLength < 3 && this.fuseLength > 0)
                if (this.fuseLength <= 0) {
                    // Sound.playFuse();
                    this.fuseLength = 0;
                    sound_1.Sound.stopSound(this.fuseSound);
                    this.explode();
                    sound_1.Sound.playBomb();
                }
            }
        };
        this.createLightSource = () => {
            if (!this.lit)
                return;
            this.lightSource = new lightSource_1.LightSource(this.x + 0.5, this.y + 0.5, 3, [200, 200, 30], 0.75);
            this.addLightSource(this.lightSource);
            this.bloomAlpha = 1;
            this.hasBloom = true;
        };
        this.hurt = (playerHitBy, damage) => {
            if (!this.lit) {
                this.lit = true;
                this.createLightSource();
                this.playerHitBy = playerHitBy;
                sound_1.Sound.playFuse();
            }
        };
        this.explode = () => {
            sound_1.Sound.stopSound(this.fuseSound);
            for (let x = this.x - 2; x < this.x + 3; x++) {
                for (let y = this.y - 2; y < this.y + 3; y++) {
                    if (this.room.pointExists(x, y) &&
                        !this.room.roomArray[x][y].isSolid() &&
                        utils_1.Utils.distance(this.x, this.y, x, y) < 2.5) {
                        const explosion = new explosion_1.Explosion(this, x, y, this.playerHitBy);
                        this.room.projectiles.push(explosion);
                    }
                }
            }
            this.health = 0;
            lighting_1.Lighting.momentaryLight(this.room, this.x, this.y, 7, [200, 200, 50], 250, 50, 0);
            console.log("screen shake");
            genericParticle_1.GenericParticle.spawnCluster(this.room, this.x + 0.5, this.y + 0.5, "white");
            this.kill();
            setTimeout(() => {
                this.game.shakeScreen((Math.random() - 0.5) * 5, (Math.random() - 0.5) * 0, false);
            }, 100);
            this.game.shakeScreen(0, 20, false);
        };
        this.draw = (delta) => {
            if (this.dead)
                return;
            this.frame += delta;
            if (this.health === 0) {
                this.frame = 0;
            }
            if (this.frame > 20)
                this.frame = 0;
            this.bloomAlpha = (this.frame / 10) % 2 === 0 ? 1 : 0.5;
            game_1.Game.ctx.save();
            game_1.Game.ctx.globalAlpha = this.alpha;
            if (!this.dead) {
                this.updateDrawXY(delta);
                if (this.lit) {
                    game_1.Game.drawObj(this.tileX +
                        6 -
                        Math.min(3, this.fuseLength) * 2 +
                        (Math.floor(this.frame / 10) % 2), this.tileY, 1, 2, this.x - this.drawX, this.y - this.drawYOffset - this.drawY, 1, 2, this.room.shadeColor, this.shadeAmount());
                }
                else {
                    game_1.Game.drawObj(this.tileX - 1, this.tileY, 1, 2, this.x - this.drawX, this.y - this.drawYOffset - this.drawY, 1, 2, this.room.shadeColor, this.shadeAmount());
                }
            }
            game_1.Game.ctx.restore();
        };
        this.drawTopLayer = (delta) => {
            this.drawableY = this.y;
        };
        this.room = room;
        this.health = 1;
        this.tileX = 15;
        this.tileY = 4;
        this.hasShadow = false;
        this.chainPushable = false;
        this.name = "bomb";
        this.frame = 0;
        this.hasBloom = false;
        this.bloomColor = "yellow";
        this.bloomAlpha = 0;
        this.bloomSize = 1;
        this.bloomOffsetY = -1;
        this.health = 1;
        this.hitSound = sound_1.Sound.potSmash;
        this.imageParticleX = 0;
        this.imageParticleY = 29;
        this.createLightSource();
        this.playerHitBy = null;
        this.fuseSound = sound_1.Sound.fuseLoopSound;
        this.soundPaused = false;
    }
    get type() {
        return entity_2.EntityType.PROP;
    }
}
exports.Bomb = Bomb;


/***/ }),

/***/ "./src/entity/object/chest.ts":
/*!************************************!*\
  !*** ./src/entity/object/chest.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Chest = void 0;
const game_1 = __webpack_require__(/*! ../../game */ "./src/game.ts");
const entity_1 = __webpack_require__(/*! ../entity */ "./src/entity/entity.ts");
const entity_2 = __webpack_require__(/*! ../entity */ "./src/entity/entity.ts");
const random_1 = __webpack_require__(/*! ../../random */ "./src/random.ts");
const sound_1 = __webpack_require__(/*! ../../sound */ "./src/sound.ts");
class Chest extends entity_1.Entity {
    constructor(room, game, x, y) {
        super(room, game, x, y);
        this.interact = (playerHitBy) => {
            //this.healthBar.hurt();
            this.health -= 1;
            if (this.health === 2 && !this.opening)
                this.open();
            if (this.health === 1) {
                this.drop.onPickup(playerHitBy);
                this.destroyable = true;
            }
            if (this.health <= 0) {
                this.kill();
            }
            else
                this.hurtCallback();
        };
        this.open = () => {
            this.tileX = 0;
            this.tileY = 2;
            this.opening = true;
            sound_1.Sound.chest();
            if (this.drop === null)
                this.getDrop(["consumable", "gem", "coin"]);
            if (this.drop.name === "coin") {
                const stack = Math.ceil(Math.random() * 5);
                this.drop.stackCount = stack;
                this.drop.stack = stack;
            }
            this.dropLoot();
            this.drop.animateFromChest();
        };
        this.rollDrop = () => {
            return game_1.Game.randTable([1, 1, 1, 1, 1, 1, 1, 2, 3, 4, 5, 2, 2], random_1.Random.rand);
        };
        this.killNoBones = () => {
            this.kill();
        };
        this.draw = (delta) => {
            if (this.dead)
                return;
            game_1.Game.ctx.save();
            game_1.Game.ctx.globalAlpha = this.alpha;
            if (this.opening) {
                if (this.tileX <= 6) {
                    this.tileX += 0.15 * delta;
                }
                else {
                    this.opening = false;
                }
            }
            if (!this.dead) {
                this.updateDrawXY(delta);
                game_1.Game.drawObj(Math.floor(this.tileX), Math.floor(this.tileY), 1, 2, this.x - this.drawX, this.y - this.drawYOffset - this.drawY, 1, 2, this.room.shadeColor, this.shadeAmount());
            }
            game_1.Game.ctx.restore();
        };
        this.drawTopLayer = (delta) => {
            this.drawableY = this.y - 1;
        };
        this.tileX = 4;
        this.tileY = 0;
        this.health = 3;
        this.name = "chest";
        this.frame = 0;
        this.opening = false;
        this.dropX = 0;
        this.dropY = 0;
        this.drop = null;
        this.destroyable = false;
        this.pushable = false;
        this.chainPushable = false;
        this.interactable = true;
        this.imageParticleX = 3;
        this.imageParticleY = 26;
        /*
        this.layer = new ChestLayer(
          this.room,
          this.game,
          this.x,
          this.y,
        );
        this.room.entities.push(this.layer);
        */
    }
    get type() {
        return entity_2.EntityType.CHEST;
    }
}
exports.Chest = Chest;


/***/ }),

/***/ "./src/entity/object/crate.ts":
/*!************************************!*\
  !*** ./src/entity/object/crate.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Crate = void 0;
const entity_1 = __webpack_require__(/*! ../entity */ "./src/entity/entity.ts");
const game_1 = __webpack_require__(/*! ../../game */ "./src/game.ts");
const entity_2 = __webpack_require__(/*! ../entity */ "./src/entity/entity.ts");
const weaponFragments_1 = __webpack_require__(/*! ../../item/weaponFragments */ "./src/item/weaponFragments.ts");
const coin_1 = __webpack_require__(/*! ../../item/coin */ "./src/item/coin.ts");
class Crate extends entity_1.Entity {
    constructor(room, game, x, y) {
        super(room, game, x, y);
        this.killNoBones = () => {
            this.kill();
        };
        this.draw = (delta) => {
            if (this.dead)
                return;
            game_1.Game.ctx.save();
            game_1.Game.ctx.globalAlpha = this.alpha;
            if (!this.dead) {
                this.updateDrawXY(delta);
                game_1.Game.drawObj(this.tileX, this.tileY, 1, 2, this.x - this.drawX, this.y - this.drawYOffset - this.drawY, 1, 2, this.room.shadeColor, this.shadeAmount());
            }
            game_1.Game.ctx.restore();
        };
        this.drawTopLayer = (delta) => {
            this.drawableY = this.y;
        };
        this.room = room;
        this.health = 1;
        this.maxHealth = 1;
        this.tileX = 0;
        this.tileY = 0;
        this.hasShadow = false;
        this.pushable = true;
        this.name = "crate";
        this.imageParticleX = 3;
        this.imageParticleY = 26;
        if (Math.random() < 0.1) {
            this.drop = new weaponFragments_1.WeaponFragments(this.room, this.x, this.y, 10);
        }
        else {
            this.drop = new coin_1.Coin(this.room, this.x, this.y);
        }
    }
    get type() {
        return entity_2.EntityType.PROP;
    }
}
exports.Crate = Crate;


/***/ }),

/***/ "./src/entity/object/mushrooms.ts":
/*!****************************************!*\
  !*** ./src/entity/object/mushrooms.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Mushrooms = void 0;
const entity_1 = __webpack_require__(/*! ../entity */ "./src/entity/entity.ts");
const game_1 = __webpack_require__(/*! ../../game */ "./src/game.ts");
const entity_2 = __webpack_require__(/*! ../entity */ "./src/entity/entity.ts");
class Mushrooms extends entity_1.Entity {
    constructor(room, game, x, y) {
        super(room, game, x, y);
        this.killNoBones = () => {
            this.kill();
        };
        this.draw = (delta) => {
            if (this.dead)
                return;
            game_1.Game.ctx.save();
            game_1.Game.ctx.globalAlpha = this.alpha;
            if (!this.dead) {
                this.updateDrawXY(delta);
                game_1.Game.drawObj(this.tileX, this.tileY, 1, 2, this.x - this.drawX, this.y - this.drawYOffset - this.drawY, 1, 2, this.room.shadeColor, this.shadeAmount());
            }
            game_1.Game.ctx.restore();
        };
        this.drawTopLayer = (delta) => {
            this.drawableY = this.y;
        };
        this.room = room;
        this.health = 1;
        this.tileX = 9;
        this.tileY = 2;
        this.hasShadow = false;
        this.chainPushable = false;
        this.name = "mushrooms";
        this.imageParticleX = 0;
        this.imageParticleY = 30;
    }
    get type() {
        return entity_2.EntityType.PROP;
    }
}
exports.Mushrooms = Mushrooms;


/***/ }),

/***/ "./src/entity/object/pot.ts":
/*!**********************************!*\
  !*** ./src/entity/object/pot.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Pot = void 0;
const entity_1 = __webpack_require__(/*! ../entity */ "./src/entity/entity.ts");
const game_1 = __webpack_require__(/*! ../../game */ "./src/game.ts");
const heart_1 = __webpack_require__(/*! ../../item/heart */ "./src/item/heart.ts");
const entity_2 = __webpack_require__(/*! ../entity */ "./src/entity/entity.ts");
const random_1 = __webpack_require__(/*! ../../random */ "./src/random.ts");
const coin_1 = __webpack_require__(/*! ../../item/coin */ "./src/item/coin.ts");
const sound_1 = __webpack_require__(/*! ../../sound */ "./src/sound.ts");
class Pot extends entity_1.Entity {
    constructor(room, game, x, y) {
        super(room, game, x, y);
        this.killNoBones = () => {
            this.kill();
        };
        this.draw = (delta) => {
            if (this.dead)
                return;
            game_1.Game.ctx.save();
            game_1.Game.ctx.globalAlpha = this.alpha;
            if (!this.dead) {
                this.updateDrawXY(delta);
                game_1.Game.drawObj(this.tileX, this.tileY, 1, 2, this.x - this.drawX, this.y - this.drawYOffset - this.drawY, 1, 2, this.room.shadeColor, this.shadeAmount());
            }
            game_1.Game.ctx.restore();
        };
        this.drawTopLayer = (delta) => {
            this.drawableY = this.y;
        };
        this.room = room;
        this.health = 1;
        this.tileX = 11;
        this.tileY = 0;
        this.hasShadow = false;
        this.chainPushable = false;
        this.name = "pot";
        this.hitSound = sound_1.Sound.potSmash;
        this.imageParticleX = 0;
        this.imageParticleY = 29;
        let dropProb = random_1.Random.rand();
        if (dropProb < 0.025)
            this.drop = new heart_1.Heart(this.room, this.x, this.y);
        else
            this.drop = new coin_1.Coin(this.room, this.x, this.y);
    }
    get type() {
        return entity_2.EntityType.PROP;
    }
}
exports.Pot = Pot;


/***/ }),

/***/ "./src/entity/object/pottedPlant.ts":
/*!******************************************!*\
  !*** ./src/entity/object/pottedPlant.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PottedPlant = void 0;
const entity_1 = __webpack_require__(/*! ../entity */ "./src/entity/entity.ts");
const game_1 = __webpack_require__(/*! ../../game */ "./src/game.ts");
const heart_1 = __webpack_require__(/*! ../../item/heart */ "./src/item/heart.ts");
const coin_1 = __webpack_require__(/*! ../../item/coin */ "./src/item/coin.ts");
const entity_2 = __webpack_require__(/*! ../entity */ "./src/entity/entity.ts");
const imageParticle_1 = __webpack_require__(/*! ../../particle/imageParticle */ "./src/particle/imageParticle.ts");
const random_1 = __webpack_require__(/*! ../../random */ "./src/random.ts");
class PottedPlant extends entity_1.Entity {
    constructor(room, game, x, y, drop) {
        super(room, game, x, y);
        this.killNoBones = () => {
            this.dead = true;
        };
        this.uniqueKillBehavior = () => {
            imageParticle_1.ImageParticle.spawnCluster(this.room, this.x + 0.5, this.y + 0.5, 0, 29);
        };
        this.draw = (delta) => {
            if (this.dead)
                return;
            game_1.Game.ctx.save();
            game_1.Game.ctx.globalAlpha = this.alpha;
            if (!this.dead) {
                this.updateDrawXY(delta);
                if (this.health <= 1 || this.dying)
                    this.tileX = 2;
                game_1.Game.drawObj(this.tileX, this.tileY, 1, 2, this.x - this.drawX, this.y - this.drawYOffset - this.drawY, 1, 2, this.room.shadeColor, this.shadeAmount());
            }
            game_1.Game.ctx.restore();
        };
        this.drawTopLayer = (delta) => {
            this.drawableY = this.y;
        };
        this.dropLoot = () => {
            this.drop.level = this.room;
            this.drop.x = this.x;
            this.drop.y = this.y;
            this.room.items.push(this.drop);
        };
        this.room = room;
        this.health = 2;
        this.tileX = 3;
        this.tileY = 0;
        this.hasShadow = false;
        this.chainPushable = false;
        this.name = "plant";
        this.imageParticleX = 0;
        this.imageParticleY = 28;
        if (drop)
            this.drop = drop;
        else {
            let dropProb = random_1.Random.rand();
            if (dropProb < 0.025)
                this.drop = new heart_1.Heart(this.room, this.x, this.y);
            else
                this.drop = new coin_1.Coin(this.room, this.x, this.y);
        }
    }
    get type() {
        return entity_2.EntityType.PROP;
    }
}
exports.PottedPlant = PottedPlant;


/***/ }),

/***/ "./src/entity/object/pumpkin.ts":
/*!**************************************!*\
  !*** ./src/entity/object/pumpkin.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Pumpkin = void 0;
const entity_1 = __webpack_require__(/*! ../entity */ "./src/entity/entity.ts");
const game_1 = __webpack_require__(/*! ../../game */ "./src/game.ts");
const entity_2 = __webpack_require__(/*! ../entity */ "./src/entity/entity.ts");
const lightSource_1 = __webpack_require__(/*! ../../lightSource */ "./src/lightSource.ts");
const candle_1 = __webpack_require__(/*! ../../item/candle */ "./src/item/candle.ts");
class Pumpkin extends entity_1.Entity {
    constructor(room, game, x, y) {
        super(room, game, x, y);
        this.killNoBones = () => {
            this.kill();
        };
        this.uniqueKillBehavior = () => {
            this.removeLightSource(this.lightSource);
        };
        this.draw = (delta) => {
            if (this.dead)
                return;
            game_1.Game.ctx.save();
            game_1.Game.ctx.globalAlpha = this.alpha;
            if (!this.dead) {
                this.updateDrawXY(delta);
                game_1.Game.drawObj(this.tileX, this.tileY, 1, 2, this.x - this.drawX, this.y - this.drawYOffset - this.drawY, 1, 2, this.room.shadeColor, this.shadeAmount());
            }
            game_1.Game.ctx.restore();
        };
        this.drawTopLayer = (delta) => {
            this.drawableY = this.y;
        };
        this.room = room;
        this.health = 1;
        this.tileX = 15;
        this.tileY = 2;
        this.hasShadow = false;
        this.chainPushable = false;
        this.name = "pumpkin";
        this.drop = new candle_1.Candle(this.room, this.x, this.y);
        this.imageParticleX = 0;
        this.imageParticleY = 25;
        this.bloomColor = "#FFA500";
        this.hasBloom = true;
        this.bloomAlpha = 1;
        this.softBloomAlpha = 0;
        this.lightSource = new lightSource_1.LightSource(this.x + 0.5, this.y + 0.5, 5, [200, 30, 1], 3);
        this.addLightSource(this.lightSource);
    }
    get type() {
        return entity_2.EntityType.PROP;
    }
}
exports.Pumpkin = Pumpkin;


/***/ }),

/***/ "./src/entity/object/tombStone.ts":
/*!****************************************!*\
  !*** ./src/entity/object/tombStone.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TombStone = void 0;
const entity_1 = __webpack_require__(/*! ../entity */ "./src/entity/entity.ts");
const game_1 = __webpack_require__(/*! ../../game */ "./src/game.ts");
const entity_2 = __webpack_require__(/*! ../entity */ "./src/entity/entity.ts");
const skullEnemy_1 = __webpack_require__(/*! ../enemy/skullEnemy */ "./src/entity/enemy/skullEnemy.ts");
const random_1 = __webpack_require__(/*! ../../random */ "./src/random.ts");
const spellbook_1 = __webpack_require__(/*! ../../weapon/spellbook */ "./src/weapon/spellbook.ts");
const sound_1 = __webpack_require__(/*! ../../sound */ "./src/sound.ts");
const imageParticle_1 = __webpack_require__(/*! ../../particle/imageParticle */ "./src/particle/imageParticle.ts");
const lightSource_1 = __webpack_require__(/*! ../../lightSource */ "./src/lightSource.ts");
class TombStone extends entity_1.Entity {
    constructor(room, game, x, y, skinType, drop) {
        super(room, game, x, y);
        this.kill = () => {
            this.removeLightSource(this.lightSource);
            this.dead = true;
            this.dropLoot();
        };
        this.hurt = (playerHitBy, damage) => {
            this.healthBar.hurt();
            imageParticle_1.ImageParticle.spawnCluster(this.room, this.x + 0.5, this.y + 0.5, 0, 25);
            //Sound.delayPlay(Sound.hurt, 0);
            this.health -= 1;
            if (this.health === 1) {
                const positions = this.room
                    .getEmptyTiles()
                    .filter((t) => Math.abs(t.x - this.x) <= 1 && Math.abs(t.y - this.y) <= 1);
                if (positions.length > 0) {
                    for (let position of positions) {
                        for (const i in this.game.players) {
                            const playerX = this.game.players[i].x;
                            const playerY = this.game.players[i].y;
                            if ((playerX !== position.x && playerY === position.y) ||
                                (playerX === position.x && playerY !== position.y)) {
                                this.room.entities.push(new skullEnemy_1.SkullEnemy(this.room, this.game, position.x, position.y));
                            }
                        }
                    }
                    sound_1.Sound.delayPlay(sound_1.Sound.skeleSpawn, 50);
                }
                this.tileX += 2;
                //draw half broken tombstone based on skintype after it takes one damage
            }
            if (this.health <= 0) {
                this.kill();
                sound_1.Sound.delayPlay(sound_1.Sound.breakRock, 50);
            }
            else {
                this.hurtCallback();
                //Sound.delayPlay(Sound.hit, 0);
            }
        };
        this.draw = (delta) => {
            if (this.dead)
                return;
            game_1.Game.ctx.save();
            game_1.Game.ctx.globalAlpha = this.alpha;
            if (!this.dead) {
                game_1.Game.drawObj(this.tileX, this.tileY, 1, 2, this.x - this.drawX, this.y - this.drawYOffset - this.drawY, 1, 2, this.room.shadeColor, this.shadeAmount());
            }
            game_1.Game.ctx.restore();
        };
        this.drawTopLayer = (delta) => {
            this.drawableY = this.y;
            this.updateDrawXY(delta);
        };
        this.skinType = skinType;
        this.room = room;
        this.health = 2;
        this.maxHealth = 2;
        this.tileX = 11 + this.skinType;
        this.tileY = 2;
        this.hasShadow = false;
        this.pushable = false;
        this.destroyable = true;
        this.skinType = skinType;
        this.chainPushable = false;
        this.name = "tombstone";
        let dropProb = random_1.Random.rand();
        if (dropProb < 0.05)
            this.drop = new spellbook_1.Spellbook(this.room, this.x, this.y);
        this.hasBloom = true;
        this.bloomColor = "#05FF05";
        this.bloomAlpha = 1;
        this.softBloomAlpha = 0;
        this.lightSource = new lightSource_1.LightSource(this.x + 0.5, this.y + 0.5, 7, [5, 150, 5], 1);
        this.addLightSource(this.lightSource);
    }
    get type() {
        return entity_2.EntityType.PROP;
    }
}
exports.TombStone = TombStone;


/***/ }),

/***/ "./src/entity/object/vendingMachine.ts":
/*!*********************************************!*\
  !*** ./src/entity/object/vendingMachine.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.VendingMachine = void 0;
const game_1 = __webpack_require__(/*! ../../game */ "./src/game.ts");
const entity_1 = __webpack_require__(/*! ../entity */ "./src/entity/entity.ts");
const coin_1 = __webpack_require__(/*! ../../item/coin */ "./src/item/coin.ts");
const greengem_1 = __webpack_require__(/*! ../../item/greengem */ "./src/item/greengem.ts");
const gameConstants_1 = __webpack_require__(/*! ../../gameConstants */ "./src/gameConstants.ts");
const shotgun_1 = __webpack_require__(/*! ../../weapon/shotgun */ "./src/weapon/shotgun.ts");
const armor_1 = __webpack_require__(/*! ../../item/armor */ "./src/item/armor.ts");
const heart_1 = __webpack_require__(/*! ../../item/heart */ "./src/item/heart.ts");
const spear_1 = __webpack_require__(/*! ../../weapon/spear */ "./src/weapon/spear.ts");
const bluegem_1 = __webpack_require__(/*! ../../item/bluegem */ "./src/item/bluegem.ts");
const dualdagger_1 = __webpack_require__(/*! ../../weapon/dualdagger */ "./src/weapon/dualdagger.ts");
const lantern_1 = __webpack_require__(/*! ../../item/lantern */ "./src/item/lantern.ts");
const redgem_1 = __webpack_require__(/*! ../../item/redgem */ "./src/item/redgem.ts");
const entity_2 = __webpack_require__(/*! ../entity */ "./src/entity/entity.ts");
const random_1 = __webpack_require__(/*! ../../random */ "./src/random.ts");
const warhammer_1 = __webpack_require__(/*! ../../weapon/warhammer */ "./src/weapon/warhammer.ts");
const torch_1 = __webpack_require__(/*! ../../item/torch */ "./src/item/torch.ts");
const spellbook_1 = __webpack_require__(/*! ../../weapon/spellbook */ "./src/weapon/spellbook.ts");
let OPEN_TIME = 150;
let FILL_COLOR = "#5a595b";
let OUTLINE_COLOR = "#292c36";
let FULL_OUTLINE = "white";
class VendingMachine extends entity_1.Entity {
    constructor(room, game, x, y, item) {
        super(room, game, x, y);
        this.open = false;
        this.openTime = 0;
        this.isInf = false;
        this.quantity = 1;
        this.buyAnimAmount = 0;
        this.setCost = (value = 1, costItems, counts, quantity = 1) => {
            //value is arbitrary multiplies the stackcount to adapt to the item
            if (!costItems || !counts) {
                // Default behavior: randomly choose between gems and coins
                const possibleItems = [
                    new bluegem_1.BlueGem(this.room, 0, 0),
                    new greengem_1.GreenGem(this.room, 0, 0),
                    new redgem_1.RedGem(this.room, 0, 0),
                    new coin_1.Coin(this.room, 0, 0),
                ];
                const costItem = game_1.Game.randTable(possibleItems, random_1.Random.rand);
                if (costItem instanceof coin_1.Coin) {
                    costItem.stackCount = game_1.Game.randTable([20, 25, 30], random_1.Random.rand);
                }
                else {
                    costItem.stackCount = game_1.Game.randTable([1, 2, 3], random_1.Random.rand);
                }
                costItem.stackCount *= value;
                this.costItems = [costItem];
            }
            else {
                // Original behavior for custom costs
                const randCount = game_1.Game.randTable(counts, random_1.Random.rand);
                const costItem = game_1.Game.randTable(costItems, random_1.Random.rand);
                costItem.stackCount = randCount;
                //if (costItem instanceof Coin) {
                //costItem.stackCount *= Game.randTable([9, 10, 11], Random.rand);
                //}
                this.costItems = [costItem];
            }
            this.quantity = quantity;
        };
        this.interact = (player) => {
            if (this.isInf || this.quantity > 0) {
                if (this.open)
                    this.playerOpened.openVendingMachine = null;
                this.open = true;
                this.playerOpened = player;
                this.openTime = Date.now();
                if (this.playerOpened.openVendingMachine &&
                    this.playerOpened.openVendingMachine !== this)
                    this.playerOpened.openVendingMachine.close();
                this.playerOpened.openVendingMachine = this;
            }
        };
        this.close = () => {
            this.open = false;
            this.playerOpened.openVendingMachine = null;
        };
        this.space = () => {
            if (this.open) {
                // Check if player can pay
                for (const i of this.costItems) {
                    if (!this.playerOpened.inventory.hasItemCount(i)) {
                        let numOfItem = 0;
                        this.playerOpened.inventory.items.forEach((item) => {
                            if (item instanceof i.constructor)
                                numOfItem++;
                        });
                        const difference = this.costItems[0].stackCount - numOfItem;
                        const pluralLetter = this.costItems[0].stackCount > 1 ? "s" : "";
                        this.game.pushMessage(`You need ${difference} more ${this.costItems[0].constructor.itemName}${pluralLetter} to buy that. `);
                        return;
                    }
                }
                // Create the new item instance
                let newItem = new this.item.constructor(this.room, this.x, this.y);
                //     newItem = newItem.constructor(this.room, this.x, this.y);
                // **Attempt to add the item directly to the player's inventory**
                const addedSuccessfully = this.playerOpened.inventory.addItem(newItem);
                if (!addedSuccessfully) {
                    // If adding the item failed, refund the cost items
                    for (const i of this.costItems) {
                        this.playerOpened.inventory.addItem(i);
                    }
                    this.game.pushMessage("Your inventory is full. Cannot purchase the item.");
                    return;
                }
                // Subtract the cost items from player's inventory
                for (const i of this.costItems) {
                    this.playerOpened.inventory.subtractItemCount(i);
                }
                const cost = this.costItems[0].stackCount;
                const pluralLetter = cost > 1 ? "s" : "";
                // Decrement the quantity of items available in the vending machine, if not infinite
                if (!this.isInf) {
                    this.quantity--;
                    if (this.quantity <= 0)
                        this.close();
                }
                // Notify the player of the successful purchase
                this.game.pushMessage(`Purchased ${newItem.constructor.itemName} for ${cost} ${this.costItems[0].constructor.itemName}${pluralLetter}`);
                this.game.pushMessage(`${this.quantity} available to buy.`);
                // Handle visual feedback and screen shake
                this.buyAnimAmount = 0.99;
                if (this.playerOpened === this.game.players[this.game.localPlayerID])
                    this.game.shakeScreen(0, 4);
            }
        };
        this.draw = (delta) => {
            let tileX = 19;
            if (!this.isInf && this.quantity === 0)
                tileX = 20;
            game_1.Game.drawObj(tileX, 0, 1, 2, this.x, this.y - 1, 1, 2, this.room.shadeColor, this.shadeAmount());
        };
        this.drawTopLayer = (delta) => {
            if (this.open && this.playerOpened.inventory.isOpen) {
                this.close();
                return;
            }
            this.drawableY = this.y;
            if (this.open &&
                this.playerOpened === this.game.players[this.game.localPlayerID]) {
                let s = Math.min(18, (18 * (Date.now() - this.openTime)) / OPEN_TIME); // size of box
                let b = 2; // border
                let g = -2; // gap
                let hg = 3; // highlighted growth
                let ob = 1; // outer border
                let width = (this.costItems.length + 2) * (s + 2 * b + g) - g;
                let height = s + 2 * b + g - g;
                let cx = (this.x + 0.5) * gameConstants_1.GameConstants.TILESIZE;
                let cy = (this.y - 1.5) * gameConstants_1.GameConstants.TILESIZE;
                game_1.Game.ctx.fillStyle = FULL_OUTLINE;
                game_1.Game.ctx.fillRect(Math.round(cx - 0.5 * width) - ob, Math.round(cy - 0.5 * height) - ob, Math.round(width + 2 * ob), Math.round(height + 2 * ob));
                for (let x = 0; x < this.costItems.length + 2; x++) {
                    game_1.Game.ctx.fillStyle = OUTLINE_COLOR;
                    game_1.Game.ctx.fillRect(Math.round(cx - 0.5 * width + x * (s + 2 * b + g)), Math.round(cy - 0.5 * height), Math.round(s + 2 * b), Math.round(s + 2 * b));
                    if (x !== this.costItems.length) {
                        game_1.Game.ctx.fillStyle = FILL_COLOR;
                        game_1.Game.ctx.fillRect(Math.round(cx - 0.5 * width + x * (s + 2 * b + g) + b), Math.round(cy - 0.5 * height + b), Math.round(s), Math.round(s));
                    }
                }
                if (Date.now() - this.openTime >= OPEN_TIME) {
                    for (let i = 0; i < this.costItems.length + 2; i++) {
                        let drawX = Math.round(cx -
                            0.5 * width +
                            i * (s + 2 * b + g) +
                            b +
                            Math.floor(0.5 * s) -
                            0.5 * gameConstants_1.GameConstants.TILESIZE);
                        let drawY = Math.round(cy -
                            0.5 * height +
                            b +
                            Math.floor(0.5 * s) -
                            0.5 * gameConstants_1.GameConstants.TILESIZE);
                        let drawXScaled = drawX / gameConstants_1.GameConstants.TILESIZE;
                        let drawYScaled = drawY / gameConstants_1.GameConstants.TILESIZE;
                        if (i < this.costItems.length) {
                            let a = 1;
                            if (!this.playerOpened.inventory.hasItemCount(this.costItems[i]))
                                a = 0.15;
                            this.costItems[i].drawIcon(delta, drawXScaled, drawYScaled, a);
                        }
                        else if (i === this.costItems.length) {
                            game_1.Game.drawFX(2, 0, 1, 1, drawXScaled, drawYScaled, 1, 1);
                        }
                        else if (i === this.costItems.length + 1) {
                            this.item.drawIcon(delta, drawXScaled, drawYScaled, 1, this.quantity);
                        }
                    }
                }
                this.buyAnimAmount *= this.buyAnimAmount;
                if (gameConstants_1.GameConstants.ALPHA_ENABLED)
                    game_1.Game.ctx.globalAlpha = this.buyAnimAmount;
                game_1.Game.ctx.fillStyle = FULL_OUTLINE;
                game_1.Game.ctx.fillRect(Math.round(cx - 0.5 * width) - ob, Math.round(cy - 0.5 * height) - ob, Math.round(width + 2 * ob), Math.round(height + 2 * ob));
                game_1.Game.ctx.globalAlpha = 1.0;
            }
        };
        this.destroyable = false;
        this.pushable = false;
        this.chainPushable = false;
        this.interactable = true;
        this.costItems = [];
        this.item = item;
        this.name = "vending machine";
        if (this.item instanceof shotgun_1.Shotgun) {
            this.setCost(3);
        }
        else if (this.item instanceof heart_1.Heart) {
            this.setCost(1, [new coin_1.Coin(room, 0, 0)], [9, 10, 11], 3); // Uses default random cost
        }
        else if (this.item instanceof spear_1.Spear) {
            this.setCost(2); // Uses default random cost
        }
        else if (this.item instanceof armor_1.Armor) {
            this.setCost(2); // Uses default random cost
        }
        else if (this.item instanceof dualdagger_1.DualDagger) {
            this.setCost(3); // Uses default random cost
        }
        else if (this.item instanceof lantern_1.Lantern) {
            this.setCost(2); // Uses default random cost
        }
        else if (this.item instanceof warhammer_1.Warhammer) {
            this.setCost(2); // Uses default random cost
        }
        else if (this.item instanceof spellbook_1.Spellbook) {
            this.setCost(3); // Uses default random cost
        }
        else if (this.item instanceof torch_1.Torch) {
            this.setCost(2); // Uses default random cost
        }
    }
    get type() {
        return entity_2.EntityType.PROP;
    }
}
exports.VendingMachine = VendingMachine;
VendingMachine.isPointInVendingMachineBounds = (x, y, shop) => {
    // First check if this is the currently open vending machine
    if (!shop.open || shop !== shop.playerOpened?.openVendingMachine)
        return false;
    let w = gameConstants_1.GameConstants.WIDTH;
    let h = gameConstants_1.GameConstants.HEIGHT;
    return x >= w * 0.25 && x <= w * 0.75 && y >= h * 0.25 && y <= h * 0.5;
};


/***/ }),

/***/ "./src/entity/resource/coalResource.ts":
/*!*********************************************!*\
  !*** ./src/entity/resource/coalResource.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CoalResource = void 0;
const resource_1 = __webpack_require__(/*! ./resource */ "./src/entity/resource/resource.ts");
const coal_1 = __webpack_require__(/*! ../../item/coal */ "./src/item/coal.ts");
class CoalResource extends resource_1.Resource {
    constructor(room, game, x, y) {
        super(room, game, x, y);
        this.tileX = 12;
        this.tileY = 0;
        this.health = 1;
        this.name = "coal";
        this.drop = new coal_1.Coal(this.room, this.x, this.y);
    }
}
exports.CoalResource = CoalResource;


/***/ }),

/***/ "./src/entity/resource/emeraldResource.ts":
/*!************************************************!*\
  !*** ./src/entity/resource/emeraldResource.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EmeraldResource = void 0;
const greengem_1 = __webpack_require__(/*! ../../item/greengem */ "./src/item/greengem.ts");
const resource_1 = __webpack_require__(/*! ./resource */ "./src/entity/resource/resource.ts");
class EmeraldResource extends resource_1.Resource {
    constructor(room, game, x, y) {
        super(room, game, x, y);
        this.tileX = 14;
        this.tileY = 0;
        this.health = 3;
        this.name = "emerald";
        this.drop = new greengem_1.GreenGem(this.room, this.x, this.y);
    }
}
exports.EmeraldResource = EmeraldResource;


/***/ }),

/***/ "./src/entity/resource/goldResource.ts":
/*!*********************************************!*\
  !*** ./src/entity/resource/goldResource.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GoldResource = void 0;
const resource_1 = __webpack_require__(/*! ./resource */ "./src/entity/resource/resource.ts");
const gold_1 = __webpack_require__(/*! ../../item/gold */ "./src/item/gold.ts");
class GoldResource extends resource_1.Resource {
    constructor(room, game, x, y) {
        super(room, game, x, y);
        this.tileX = 13;
        this.tileY = 0;
        this.health = 2;
        this.name = "gold";
        this.drop = new gold_1.Gold(this.room, this.x, this.y);
    }
}
exports.GoldResource = GoldResource;


/***/ }),

/***/ "./src/entity/resource/resource.ts":
/*!*****************************************!*\
  !*** ./src/entity/resource/resource.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Resource = void 0;
const game_1 = __webpack_require__(/*! ../../game */ "./src/game.ts");
const entity_1 = __webpack_require__(/*! ../entity */ "./src/entity/entity.ts");
const entity_2 = __webpack_require__(/*! ../entity */ "./src/entity/entity.ts");
const sound_1 = __webpack_require__(/*! ../../sound */ "./src/sound.ts");
class Resource extends entity_1.Entity {
    constructor(room, game, x, y) {
        super(room, game, x, y);
        this.hurt = (playerHitBy, damage) => {
            this.healthBar.hurt();
            this.health -= damage;
            sound_1.Sound.mine();
            this.hurtCallback();
            this.createHitParticles();
            if (this.health <= 0) {
                this.kill(playerHitBy);
            }
        };
        this.kill = (player) => {
            sound_1.Sound.breakRock();
            this.dead = true;
            if ((player !== null && player.inventory.getWeapon().canMine === true) ||
                player === null) {
                this.dropLoot();
            }
            else {
                this.game.pushMessage("You break the rock, but fail to collect any material from it.");
            }
        };
        this.killNoBones = () => {
            this.kill();
        };
        this.draw = (delta) => {
            if (!this.dead) {
                game_1.Game.drawObj(this.tileX, this.tileY, 1, 2, this.x - this.drawX, this.y - 1 - this.drawY, 1, 2, this.room.shadeColor, this.shadeAmount());
            }
        };
        this.drawTopLayer = (delta) => {
            this.drawableY = this.y;
        };
        this.tileX = 12;
        this.tileY = 0;
        this.health = 1;
        this.chainPushable = false;
        this.name = "resource";
        this.imageParticleX = 0;
        this.imageParticleY = 25;
    }
    get type() {
        return entity_2.EntityType.RESOURCE;
    }
}
exports.Resource = Resource;


/***/ }),

/***/ "./src/entity/resource/rockResource.ts":
/*!*********************************************!*\
  !*** ./src/entity/resource/rockResource.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Rock = void 0;
const stone_1 = __webpack_require__(/*! ../../item/stone */ "./src/item/stone.ts");
const resource_1 = __webpack_require__(/*! ./resource */ "./src/entity/resource/resource.ts");
class Rock extends resource_1.Resource {
    constructor(room, game, x, y) {
        super(room, game, x, y);
        this.room = room;
        this.health = 2;
        this.tileX = 8;
        this.tileY = 2;
        this.hasShadow = false;
        this.chainPushable = false;
        this.name = "rock";
        this.drop = new stone_1.Stone(this.room, this.x, this.y);
    }
}
exports.Rock = Rock;


/***/ }),

/***/ "./src/environment.ts":
/*!****************************!*\
  !*** ./src/environment.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Environment = exports.EnvType = void 0;
var EnvType;
(function (EnvType) {
    EnvType[EnvType["DUNGEON"] = 0] = "DUNGEON";
    EnvType[EnvType["CAVE"] = 1] = "CAVE";
    EnvType[EnvType["FOREST"] = 2] = "FOREST";
    EnvType[EnvType["SWAMP"] = 3] = "SWAMP";
    EnvType[EnvType["GLACIER"] = 4] = "GLACIER";
    EnvType[EnvType["CASTLE"] = 5] = "CASTLE";
})(EnvType = exports.EnvType || (exports.EnvType = {}));
class Environment {
    constructor(type) {
        this.type = type;
        this.skin = this.type;
    }
}
exports.Environment = Environment;


/***/ }),

/***/ "./src/eventBus.ts":
/*!*************************!*\
  !*** ./src/eventBus.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.globalEventBus = void 0;
const eventEmitter_1 = __webpack_require__(/*! ./eventEmitter */ "./src/eventEmitter.ts");
class EventBus {
    constructor() {
        this.eventEmitter = new eventEmitter_1.EventEmitter();
    }
    static getInstance() {
        if (!EventBus.instance) {
            EventBus.instance = new EventBus();
        }
        return EventBus.instance;
    }
    emit(event, data) {
        this.eventEmitter.emit(event, data);
    }
    on(event, callback) {
        this.eventEmitter.on(event, callback);
    }
    off(event, callback) {
        this.eventEmitter.off(event, callback);
    }
}
exports.globalEventBus = EventBus.getInstance();


/***/ }),

/***/ "./src/eventEmitter.ts":
/*!*****************************!*\
  !*** ./src/eventEmitter.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EventEmitter = void 0;
class EventEmitter {
    constructor() {
        this.events = {};
    }
    on(event, listener) {
        if (!this.events[event]) {
            this.events[event] = [];
        }
        this.events[event].push(listener);
    }
    off(event, listener) {
        if (!this.events[event])
            return;
        this.events[event] = this.events[event].filter((l) => l !== listener);
    }
    emit(event, data) {
        if (!this.events[event])
            return;
        this.events[event].forEach((listener) => listener(data));
    }
    // New method to remove all listeners for an event
    removeAllListeners(event) {
        delete this.events[event];
    }
}
exports.EventEmitter = EventEmitter;


/***/ }),

/***/ "./src/events.ts":
/*!***********************!*\
  !*** ./src/events.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EVENTS = void 0;
exports.EVENTS = {
    KEY_DOWN: "KEY_DOWN",
    KEY_UP: "KEY_UP",
    MOUSE_LEFT_CLICK: "MOUSE_LEFT_CLICK",
    MOUSE_RIGHT_CLICK: "MOUSE_RIGHT_CLICK",
    MOUSE_MOVE: "MOUSE_MOVE",
    TOUCH_START: "TOUCH_START",
    TOUCH_MOVE: "TOUCH_MOVE",
    TOUCH_END: "TOUCH_END",
    TAP: "TAP",
    TAP_HOLD: "TAP_HOLD",
    MOUSE_DOWN: "MOUSE_DOWN",
    MOUSE_UP: "MOUSE_UP",
    // **Additional Custom Events:**
    CHAT_MESSAGE: "ChatMessage",
    ENEMY_SEEN_PLAYER: "EnemySeenPlayer",
    ENEMY_KILLED: "ENEMY_KILLED",
    DAMAGE_DONE: "DAMAGE_DONE",
    DAMAGE_TAKEN: "DAMAGE_TAKEN",
    TURN_PASSED: "TURN_PASSED",
    COIN_COLLECTED: "COIN_COLLECTED",
    ITEM_COLLECTED: "ITEM_COLLECTED",
    LEVEL_GENERATION_STARTED: "LEVEL_GENERATION_STARTED",
    LEVEL_GENERATION_COMPLETED: "LEVEL_GENERATION_COMPLETED",
    // Add other custom events as needed
};


/***/ }),

/***/ "./src/game.ts":
/*!*********************!*\
  !*** ./src/game.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.gs = exports.game = exports.Game = exports.ChatMessage = exports.Direction = exports.LevelState = void 0;
const gameConstants_1 = __webpack_require__(/*! ./gameConstants */ "./src/gameConstants.ts");
const door_1 = __webpack_require__(/*! ./tile/door */ "./src/tile/door.ts");
const sound_1 = __webpack_require__(/*! ./sound */ "./src/sound.ts");
const levelConstants_1 = __webpack_require__(/*! ./levelConstants */ "./src/levelConstants.ts");
const levelGenerator_1 = __webpack_require__(/*! ./levelGenerator */ "./src/levelGenerator.ts");
const input_1 = __webpack_require__(/*! ./input */ "./src/input.ts");
const downLadder_1 = __webpack_require__(/*! ./tile/downLadder */ "./src/tile/downLadder.ts");
const textbox_1 = __webpack_require__(/*! ./textbox */ "./src/textbox.ts");
const gameState_1 = __webpack_require__(/*! ./gameState */ "./src/gameState.ts");
const tutorialListener_1 = __webpack_require__(/*! ./tutorialListener */ "./src/tutorialListener.ts");
const mouseCursor_1 = __webpack_require__(/*! ./mouseCursor */ "./src/mouseCursor.ts");
const eventBus_1 = __webpack_require__(/*! ./eventBus */ "./src/eventBus.ts");
const reverb_1 = __webpack_require__(/*! ./reverb */ "./src/reverb.ts");
const stats_1 = __webpack_require__(/*! ./stats */ "./src/stats.ts");
const events_1 = __webpack_require__(/*! ./events */ "./src/events.ts");
const upLadder_1 = __webpack_require__(/*! ./tile/upLadder */ "./src/tile/upLadder.ts");
var LevelState;
(function (LevelState) {
    LevelState[LevelState["IN_LEVEL"] = 0] = "IN_LEVEL";
    LevelState[LevelState["TRANSITIONING"] = 1] = "TRANSITIONING";
    LevelState[LevelState["TRANSITIONING_LADDER"] = 2] = "TRANSITIONING_LADDER";
    LevelState[LevelState["LEVEL_GENERATION"] = 3] = "LEVEL_GENERATION";
})(LevelState = exports.LevelState || (exports.LevelState = {}));
var Direction;
(function (Direction) {
    Direction[Direction["DOWN"] = 0] = "DOWN";
    Direction[Direction["UP"] = 1] = "UP";
    Direction[Direction["RIGHT"] = 2] = "RIGHT";
    Direction[Direction["LEFT"] = 3] = "LEFT";
    Direction[Direction["DOWN_RIGHT"] = 4] = "DOWN_RIGHT";
    Direction[Direction["UP_LEFT"] = 5] = "UP_LEFT";
    Direction[Direction["UP_RIGHT"] = 6] = "UP_RIGHT";
    Direction[Direction["DOWN_LEFT"] = 7] = "DOWN_LEFT";
    Direction[Direction["CENTER"] = 8] = "CENTER";
})(Direction = exports.Direction || (exports.Direction = {}));
class ChatMessage {
    constructor(message) {
        this.message = message;
        this.timestamp = Date.now();
    }
}
exports.ChatMessage = ChatMessage;
let getShadeCanvasKey = (set, sX, sY, sW, sH, opacity, shadeColor) => {
    return (set.src +
        "," +
        sX +
        "," +
        sY +
        "," +
        sW +
        "," +
        sH +
        "," +
        opacity +
        "," +
        shadeColor);
};
// fps counter
const times = [];
let fps = 60;
class Game {
    constructor() {
        this.localPlayerID = "localplayer";
        this.loginMessage = "";
        this.startScreenAlpha = 1;
        this.focusTimeout = null;
        this.FOCUS_TIMEOUT_DURATION = 15000; // 5 seconds
        this.wasMuted = false;
        this.wasStarted = false;
        this.updateDepth = (depth) => {
            this.previousDepth = this.currentDepth;
            this.currentDepth = depth;
            this.players[this.localPlayerID].depth = depth;
        };
        this.updateLevel = () => {
            this.level = this.levels[this.currentDepth];
            if (this.level.rooms.length > 0)
                this.rooms = this.level.rooms;
        };
        this.setPlayer = () => {
            this.player = this.players[this.localPlayerID];
        };
        this.newGame = () => {
            stats_1.statsTracker.resetStats();
            this.currentDepth = 0;
            this.encounteredEnemies = [];
            this.levels = [];
            //gs = new GameState();
            exports.gs.seed = (Math.random() * 4294967296) >>> 0;
            exports.gs.randomState = (Math.random() * 4294967296) >>> 0;
            (0, gameState_1.loadGameState)(this, [this.localPlayerID], exports.gs, true);
            this.levelState = LevelState.LEVEL_GENERATION;
        };
        this.keyDownListener = (key) => {
            Game.inputReceived = true;
            if (!this.started) {
                this.startedFadeOut = true;
                return;
            }
            // Handle global keys
            if (!this.chatOpen) {
                switch (key.toUpperCase()) {
                    case "M":
                        sound_1.Sound.audioMuted = !sound_1.Sound.audioMuted;
                        this.pushMessage(sound_1.Sound.audioMuted ? "Audio muted" : "Audio unmuted");
                        return;
                    case "C":
                        this.chatOpen = true;
                        return;
                    case "/":
                        this.chatOpen = true;
                        this.chatTextBox.clear();
                        this.chatTextBox.handleKeyPress(key);
                        return;
                    case "1":
                        levelGenerator_1.LevelGenerator.ANIMATION_CONSTANT = 1;
                        return;
                    case "2":
                        levelGenerator_1.LevelGenerator.ANIMATION_CONSTANT = 2;
                        return;
                    case "3":
                        levelGenerator_1.LevelGenerator.ANIMATION_CONSTANT = 5;
                        return;
                    case "4":
                        levelGenerator_1.LevelGenerator.ANIMATION_CONSTANT = 10000;
                        return;
                    case "0":
                        levelGenerator_1.LevelGenerator.ANIMATION_CONSTANT = 0;
                        return;
                }
                // Forward all player input
                const player = this.players[this.localPlayerID];
                player.inputHandler.handleKeyboardKey(key);
            }
            else {
                this.chatTextBox.handleKeyPress(key);
            }
        };
        this.changeLevel = (player, newLevel) => {
            if (this.tutorialListener === null) {
                this.tutorialListener = new tutorialListener_1.TutorialListener(this);
            }
            player.levelID = this.levels[player.depth].rooms.indexOf(newLevel);
            if (this.players[this.localPlayerID] === player) {
                //this.level.exitLevel();
                this.room = newLevel;
            }
            this.level = this.room.level;
            newLevel.enterLevel(player);
        };
        this.changeLevelThroughLadder = (player, ladder) => {
            player.map.saveOldMap();
            if (ladder instanceof downLadder_1.DownLadder && !ladder.linkedLevel)
                ladder.generate();
            const newRoom = ladder.linkedLevel;
            if (this.players[this.localPlayerID] === player) {
                player.levelID = newRoom.id;
                if (ladder instanceof upLadder_1.UpLadder) {
                    this.players[this.localPlayerID].levelID =
                        newRoom.level.rooms.indexOf(newRoom);
                }
            }
            this.updateDepth(newRoom.depth);
            this.levelState = LevelState.TRANSITIONING_LADDER;
            this.transitionStartTime = Date.now();
            this.transitioningLadder = ladder;
        };
        this.changeLevelThroughDoor = (player, door, side) => {
            door.linkedDoor.room.entered = true;
            player.levelID = door.room.id;
            if (this.players[this.localPlayerID] === player) {
                this.levelState = LevelState.TRANSITIONING;
                this.transitionStartTime = Date.now();
                const hasDir = door.doorDir !== door.linkedDoor.doorDir;
                let oldX = this.players[this.localPlayerID].x;
                let oldY = this.players[this.localPlayerID].y;
                this.prevLevel = this.room;
                this.prevLevel.exitLevel();
                //this.level.exitLevel();
                this.room = door.room;
                door.room.enterLevelThroughDoor(player, door, side);
                this.transitionX =
                    (this.players[this.localPlayerID].x - oldX) * gameConstants_1.GameConstants.TILESIZE;
                this.transitionY =
                    (this.players[this.localPlayerID].y - oldY) * gameConstants_1.GameConstants.TILESIZE;
                this.upwardTransition = false;
                this.sideTransition = false;
                this.sideTransitionDirection = side;
                if (door instanceof door_1.Door &&
                    [Direction.RIGHT, Direction.LEFT].includes(door.doorDir) &&
                    hasDir)
                    this.sideTransition = true;
                else if (door instanceof door_1.Door &&
                    door.doorDir === Direction.DOWN &&
                    hasDir)
                    this.upwardTransition = true;
            }
            else {
                door.room.enterLevelThroughDoor(player, door, side);
            }
            player.map.saveMapData();
        };
        this.run = (timestamp) => {
            if (this.paused) {
                // Still request next frame even when paused to maintain loop
                window.requestAnimationFrame(this.run);
                return;
            }
            if (!this.previousFrameTimestamp) {
                this.previousFrameTimestamp = timestamp;
                window.requestAnimationFrame(this.run);
                return;
            }
            // Calculate elapsed time in milliseconds
            let elapsed = timestamp - this.previousFrameTimestamp;
            // Normalize delta to 60 FPS
            let delta = (elapsed * 60) / 1000.0;
            // Define minimum and maximum delta values
            const deltaMin = 1 / 10; // 600fps
            const deltaMax = 8; //7.5fps
            // Cap delta within [deltaMin, deltaMax]
            if (Game.delta)
                delta = Game.delta;
            if (delta < deltaMin) {
                delta = deltaMin;
            }
            else if (delta > deltaMax) {
                delta = deltaMax;
            }
            // Update FPS tracking
            while (times.length > 0 && times[0] <= timestamp - 1000) {
                times.shift();
            }
            times.push(timestamp);
            fps = times.length;
            // Update game logic
            if (Math.floor(timestamp / (1000 / 60)) >
                Math.floor(this.previousFrameTimestamp / (1000 / 60))) {
                this.update();
            }
            if (Math.floor(timestamp) >
                Math.floor(this.previousFrameTimestamp) + 1000) {
                this.refreshDimensions();
            }
            //delta = 0.1;
            // Render the frame with capped delta
            this.draw(delta * gameConstants_1.GameConstants.ANIMATION_SPEED * 1);
            // Request the next frame
            window.requestAnimationFrame(this.run);
            // Update the previous frame timestamp
            this.previousFrameTimestamp = timestamp;
        };
        this.update = () => {
            this.refreshDimensions();
            input_1.Input.checkIsTapHold();
            if (input_1.Input.lastPressTime !== 0 &&
                Date.now() - input_1.Input.lastPressTime > gameConstants_1.GameConstants.KEY_REPEAT_TIME) {
                input_1.Input.onKeydown({
                    repeat: false,
                    key: input_1.Input.lastPressKey,
                });
            }
            if (this.levelState === LevelState.TRANSITIONING) {
                if (Date.now() - this.transitionStartTime >=
                    levelConstants_1.LevelConstants.LEVEL_TRANSITION_TIME) {
                    this.levelState = LevelState.IN_LEVEL;
                }
            }
            if (this.levelState === LevelState.TRANSITIONING_LADDER) {
                if (Date.now() - this.transitionStartTime >=
                    levelConstants_1.LevelConstants.LEVEL_TRANSITION_TIME_LADDER) {
                    this.levelState = LevelState.IN_LEVEL;
                    this.players[this.localPlayerID].map.saveMapData();
                }
            }
            if (this.levelState !== LevelState.LEVEL_GENERATION) {
                for (const i in this.players) {
                    this.players[i].update();
                    this.levels[this.players[i].depth].rooms[this.players[i].levelID].update();
                    if (this.players[i].dead) {
                        for (const j in this.players) {
                            this.players[j].dead = true;
                        }
                    }
                }
            }
        };
        this.lerp = (a, b, t) => {
            return (1 - t) * a + t * b;
        };
        this.pushMessage = (message) => {
            this.chat.push(new ChatMessage(message));
        };
        this.commandHandler = (command) => {
            const player = this.room.game.players[0];
            command = command.toLowerCase();
            switch (command) {
                case "devmode":
                    gameConstants_1.GameConstants.DEVELOPER_MODE = !gameConstants_1.GameConstants.DEVELOPER_MODE;
                    console.log(`Developer mode is now ${gameConstants_1.GameConstants.DEVELOPER_MODE}`);
                    break;
                case "new":
                    this.newGame();
                    break;
                case "dev":
                    gameConstants_1.GameConstants.DEVELOPER_MODE = !gameConstants_1.GameConstants.DEVELOPER_MODE;
                    console.log(`Developer mode is now ${gameConstants_1.GameConstants.DEVELOPER_MODE}`);
                    this.newGame();
                    break;
                case "kill":
                    for (const i in this.players) {
                        this.players[i].dead = true;
                    }
                    break;
                case "killall":
                    for (const i in this.players) {
                        this.players[i].game.room.entities.forEach((e) => {
                            e.kill();
                        });
                    }
                    break;
                case "bomb":
                    this.room.addBombs(1, () => Math.random());
                    break;
                case "col":
                    gameConstants_1.GameConstants.SET_COLOR_LAYER_COMPOSITE_OPERATION(false);
                    break;
                case "scl":
                    gameConstants_1.GameConstants.SET_SCALE();
                    this.onResize();
                    break;
                case "shd":
                    gameConstants_1.GameConstants.SET_COLOR_LAYER_COMPOSITE_OPERATION(false, true);
                    break;
                case "smooth":
                    gameConstants_1.GameConstants.SMOOTH_LIGHTING = !gameConstants_1.GameConstants.SMOOTH_LIGHTING;
                    break;
                case "rooms":
                    gameConstants_1.GameConstants.drawOtherRooms = !gameConstants_1.GameConstants.drawOtherRooms;
                default:
                    if (command.startsWith("new ")) {
                        this.room.addNewEnemy(command.slice(4));
                    }
                    break;
            }
        };
        this.maxScale = () => {
            for (let i = gameConstants_1.GameConstants.MIN_SCALE; i <= gameConstants_1.GameConstants.MAX_SCALE; i++) {
                if (window.innerWidth / i < 130) {
                    return i;
                }
            }
            return gameConstants_1.GameConstants.MAX_SCALE;
        };
        this.increaseScale = () => {
            gameConstants_1.GameConstants.INCREASE_SCALE();
            this.onResize();
        };
        this.decreaseScale = () => {
            gameConstants_1.GameConstants.DECREASE_SCALE();
            this.onResize();
        };
        this.updateScale = (delta) => {
            if (gameConstants_1.GameConstants.SOFT_SCALE < gameConstants_1.GameConstants.SCALE &&
                Math.abs(gameConstants_1.GameConstants.SOFT_SCALE - gameConstants_1.GameConstants.SCALE) >= 0.1) {
                gameConstants_1.GameConstants.SOFT_SCALE +=
                    ((gameConstants_1.GameConstants.SCALE - gameConstants_1.GameConstants.SOFT_SCALE) * delta) / 10;
            }
            if (gameConstants_1.GameConstants.SOFT_SCALE > gameConstants_1.GameConstants.SCALE &&
                Math.abs(gameConstants_1.GameConstants.SOFT_SCALE - gameConstants_1.GameConstants.SCALE) >= 0.1) {
                gameConstants_1.GameConstants.SOFT_SCALE -=
                    ((gameConstants_1.GameConstants.SOFT_SCALE - gameConstants_1.GameConstants.SCALE) * delta) / 10;
            }
            if (gameConstants_1.GameConstants.SOFT_SCALE < gameConstants_1.GameConstants.SCALE &&
                Math.abs(gameConstants_1.GameConstants.SOFT_SCALE - gameConstants_1.GameConstants.SCALE) <= 0.1) {
                gameConstants_1.GameConstants.SOFT_SCALE += delta / 25;
            }
            if (gameConstants_1.GameConstants.SOFT_SCALE > gameConstants_1.GameConstants.SCALE &&
                Math.abs(gameConstants_1.GameConstants.SOFT_SCALE - gameConstants_1.GameConstants.SCALE) <= 0.1) {
                gameConstants_1.GameConstants.SOFT_SCALE -= delta / 25;
            }
            if (Math.abs(gameConstants_1.GameConstants.SOFT_SCALE - gameConstants_1.GameConstants.SCALE) <= 0.01) {
                gameConstants_1.GameConstants.SOFT_SCALE = gameConstants_1.GameConstants.SCALE;
            }
            this.onResize();
        };
        this.refreshDimensions = () => {
            Game.ctx.canvas.setAttribute("width", `${gameConstants_1.GameConstants.WIDTH}`);
            Game.ctx.canvas.setAttribute("height", `${gameConstants_1.GameConstants.HEIGHT}`);
        };
        this.onResize = () => {
            // Determine device pixel ratio
            const dpr = window.devicePixelRatio;
            // Define scale adjustment based on device pixel ratio
            let scaleOffset = 0;
            //if (dpr > 1.5) {
            // High DPI devices like MacBook Air
            //scaleOffset = 2;
            //} else {
            // Standard DPI devices
            //   scaleOffset = 0;
            //}
            // Calculate maximum possible scale based on window size
            let maxWidthScale = Math.floor(window.innerWidth / gameConstants_1.GameConstants.DEFAULTWIDTH);
            let maxHeightScale = Math.floor(window.innerHeight / gameConstants_1.GameConstants.DEFAULTHEIGHT);
            const zoomLevel = Math.round((window.outerWidth / window.innerWidth) * 20) / 20;
            this.isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
            if (this.isMobile) {
                if (!gameConstants_1.GameConstants.isMobile)
                    this.pushMessage("Mobile detected");
                gameConstants_1.GameConstants.SHADE_LEVELS = 35;
                gameConstants_1.GameConstants.isMobile = true;
                levelConstants_1.LevelConstants.LIGHTING_ANGLE_STEP = 2;
                levelConstants_1.LevelConstants.LIGHTING_MAX_DISTANCE = 7;
                // Use smaller scale for mobile devices based on screen size
                // Adjust max scale with scaleOffset
                const integerScale = gameConstants_1.GameConstants.MAX_SCALE + scaleOffset;
                Game.scale = Math.min(maxWidthScale, maxHeightScale, integerScale); // Cap at 3 + offset for mobile
            }
            else {
                gameConstants_1.GameConstants.isMobile = false;
                // For desktop, use standard scaling logic
                // Ensure GameConstants.SCALE is an integer. If not, round it.
                const integerScale = gameConstants_1.GameConstants.SOFT_SCALE + scaleOffset;
                Game.scale = Math.min(maxWidthScale, maxHeightScale, integerScale);
            }
            // Handle case where scale would be 0
            if (Game.scale === 0) {
                // Recalculate max scales without flooring to check for minimum scale
                maxWidthScale = window.innerWidth / gameConstants_1.GameConstants.DEFAULTWIDTH;
                maxHeightScale = window.innerHeight / gameConstants_1.GameConstants.DEFAULTHEIGHT;
                // Ensure Game.scale is at least 1 and an integer
                Game.scale = Math.max(1, Math.min(maxWidthScale, maxHeightScale, 1 + scaleOffset));
            }
            // Apply device pixel ratio negation by setting scale to compensate for DPI
            const NEGATE_DPR_FACTOR = 1;
            Game.scale *= NEGATE_DPR_FACTOR / window.devicePixelRatio;
            console.log(window.devicePixelRatio);
            //Game.scale = Math.ceil(Math.min(Game.scale, this.maxScale()));
            //GameConstants.SCALE = Game.scale;
            // Calculate screen width and height in tiles, ensuring integer values
            levelConstants_1.LevelConstants.SCREEN_W = Math.floor(window.innerWidth / Game.scale / gameConstants_1.GameConstants.TILESIZE);
            levelConstants_1.LevelConstants.SCREEN_H = Math.floor(window.innerHeight / Game.scale / gameConstants_1.GameConstants.TILESIZE);
            // Calculate canvas width and height in pixels
            gameConstants_1.GameConstants.WIDTH = Math.floor(window.innerWidth / Game.scale);
            gameConstants_1.GameConstants.HEIGHT = Math.floor(window.innerHeight / Game.scale);
            // Set canvas width and height attributes
            Game.ctx.canvas.setAttribute("width", `${gameConstants_1.GameConstants.WIDTH}`);
            Game.ctx.canvas.setAttribute("height", `${gameConstants_1.GameConstants.HEIGHT}`);
            // Set CSS styles for scaling, applying negated DPR factor
            Game.ctx.canvas.setAttribute("style", `width: ${gameConstants_1.GameConstants.WIDTH * Game.scale}px; height: ${gameConstants_1.GameConstants.HEIGHT * Game.scale}px;
      display: block;
      margin: 0 auto;
      image-rendering: optimizeSpeed; /* Older versions of FF */
      image-rendering: -moz-crisp-edges; /* FF 6.0+ */
      image-rendering: -webkit-optimize-contrast; /* Safari */
      image-rendering: -o-crisp-edges; /* OS X & Windows Opera (12.02+) */
      image-rendering: pixelated; /* Future-browsers */
      -ms-interpolation-mode: nearest-neighbor; /* IE */
      `);
            // Optional: Log the new scale and canvas size for debugging
        };
        this.shakeScreen = (shakeX, shakeY, clamp = false) => {
            let finalX = clamp ? Math.max(-3, Math.min(3, shakeX)) : shakeX;
            let finalY = clamp ? Math.max(-3, Math.min(3, shakeY)) : shakeY;
            this.screenShakeActive = true;
            this.screenShakeX += finalX;
            this.screenShakeY += finalY;
            this.shakeAmountX += Math.abs(finalX);
            this.shakeAmountY += Math.abs(finalY);
            if (finalX < 0 || finalY < 0)
                this.shakeFrame = (3 * Math.PI) / 2;
            if (finalX > 0 || finalY > 0)
                this.shakeFrame = Math.PI / 2;
            this.screenShakeCutoff = Date.now();
        };
        this.drawRooms = (delta, skipLocalPlayer = false) => {
            if (!gameConstants_1.GameConstants.drawOtherRooms) {
                this.room.draw(delta);
                this.room.drawEntities(delta, true);
            }
            else if (gameConstants_1.GameConstants.drawOtherRooms) {
                // Create a sorted copy of the rooms array based on roomY + height
                const sortedRooms = this.levels[this.currentDepth].rooms
                    .slice()
                    .sort((a, b) => {
                    const aPosition = a.roomY + a.height;
                    const bPosition = b.roomY + b.height;
                    return aPosition - bPosition; // Ascending order
                });
                for (const room of sortedRooms) {
                    if (room.active || (room.entered && room.onScreen)) {
                        room.draw(delta);
                        room.drawEntities(delta, skipLocalPlayer);
                        //room.drawShade(delta); // this used to come after the color layer
                    }
                }
            }
        };
        this.drawRoomShadeAndColor = (delta) => {
            for (const room of this.levels[this.currentDepth].rooms) {
                if (room.active || room.entered) {
                    room.drawShadeLayer();
                    room.drawColorLayer();
                    room.drawBloomLayer(delta);
                }
            }
            for (const room of this.levels[this.currentDepth].rooms) {
                if (room.active && room.entered) {
                    room.drawOverShade(delta);
                }
            }
        };
        this.drawStartScreen = (delta) => {
            let startString = "Welcome to Turnarchist";
            Game.ctx.globalAlpha = this.startScreenAlpha;
            if (!this.started && !this.startedFadeOut) {
                this.startScreenAlpha = 1;
                if (this.startScreenAlpha <= 0)
                    this.startScreenAlpha = 0;
            }
            else if (!this.started && this.startedFadeOut) {
                this.startScreenAlpha -= delta * 0.025;
                if (this.startScreenAlpha <= 0) {
                    this.startScreenAlpha = 0;
                    this.started = true;
                    sound_1.Sound.playAmbient();
                }
            }
            Game.ctx.fillStyle = "black";
            Game.ctx.fillRect(0, 0, gameConstants_1.GameConstants.WIDTH, gameConstants_1.GameConstants.HEIGHT);
            Game.ctx.fillStyle = levelConstants_1.LevelConstants.LEVEL_TEXT_COLOR;
            Game.fillText(startString, gameConstants_1.GameConstants.WIDTH / 2 - Game.measureText(startString).width / 2, gameConstants_1.GameConstants.HEIGHT / 2 - Game.letter_height + 2);
            let restartButton = "Press space or click to start";
            if (this.isMobile)
                restartButton = "Tap to start";
            Game.fillText(restartButton, gameConstants_1.GameConstants.WIDTH / 2 - Game.measureText(restartButton).width / 2, gameConstants_1.GameConstants.HEIGHT / 2 + Game.letter_height + 5);
            Game.ctx.globalAlpha = 1;
        };
        this.draw = (delta) => {
            if (gameConstants_1.GameConstants.SOFT_SCALE !== gameConstants_1.GameConstants.SCALE) {
                this.updateScale(delta);
            }
            //Game.ctx.canvas.setAttribute("role", "presentation");
            Game.ctx.clearRect(0, 0, gameConstants_1.GameConstants.WIDTH, gameConstants_1.GameConstants.HEIGHT);
            Game.ctx.save(); // Save the current canvas state
            // Reset transformations to ensure the black background covers the entire canvas
            Game.ctx.setTransform(1, 0, 0, 1, 0, 0);
            Game.ctx.globalAlpha = 1;
            Game.ctx.globalCompositeOperation = "source-over";
            Game.ctx.fillStyle = "black";
            Game.ctx.fillRect(0, 0, gameConstants_1.GameConstants.WIDTH, gameConstants_1.GameConstants.HEIGHT);
            //if (this.room) Game.ctx.fillStyle = this.room.shadeColor;
            //else Game.ctx.fillStyle = "black";
            //Game.ctx.fillRect(0, 0, GameConstants.WIDTH, GameConstants.HEIGHT);
            if (this.levelState === LevelState.TRANSITIONING) {
                this.screenShakeX = 0;
                this.screenShakeY = 0;
                this.screenShakeActive = false;
                let levelOffsetX = Math.floor(this.lerp((Date.now() - this.transitionStartTime) /
                    levelConstants_1.LevelConstants.LEVEL_TRANSITION_TIME, 0, -this.transitionX));
                let levelOffsetY = Math.floor(this.lerp((Date.now() - this.transitionStartTime) /
                    levelConstants_1.LevelConstants.LEVEL_TRANSITION_TIME, 0, -this.transitionY));
                let playerOffsetX = levelOffsetX - this.transitionX;
                let playerOffsetY = levelOffsetY - this.transitionY;
                let playerCX = (this.players[this.localPlayerID].x -
                    this.players[this.localPlayerID].drawX +
                    0.5) *
                    gameConstants_1.GameConstants.TILESIZE;
                let playerCY = (this.players[this.localPlayerID].y -
                    this.players[this.localPlayerID].drawY +
                    0.5) *
                    gameConstants_1.GameConstants.TILESIZE;
                Game.ctx.translate(-Math.round(playerCX + playerOffsetX - 0.5 * gameConstants_1.GameConstants.WIDTH), -Math.round(playerCY + playerOffsetY - 0.5 * gameConstants_1.GameConstants.HEIGHT));
                let extraTileLerp = Math.floor(this.lerp((Date.now() - this.transitionStartTime) /
                    levelConstants_1.LevelConstants.LEVEL_TRANSITION_TIME, 0, gameConstants_1.GameConstants.TILESIZE));
                let newLevelOffsetX = playerOffsetX;
                let newLevelOffsetY = playerOffsetY;
                if (this.sideTransition) {
                    if (this.sideTransitionDirection > 0) {
                        levelOffsetX += extraTileLerp;
                        newLevelOffsetX += extraTileLerp + gameConstants_1.GameConstants.TILESIZE;
                    }
                    else {
                        levelOffsetX -= extraTileLerp;
                        newLevelOffsetX -= extraTileLerp + gameConstants_1.GameConstants.TILESIZE;
                    }
                }
                else if (this.upwardTransition) {
                    levelOffsetY -= extraTileLerp;
                    newLevelOffsetY -= extraTileLerp + gameConstants_1.GameConstants.TILESIZE;
                }
                else {
                    levelOffsetY += extraTileLerp;
                    newLevelOffsetY += extraTileLerp + gameConstants_1.GameConstants.TILESIZE;
                }
                let ditherFrame = Math.floor((7 * (Date.now() - this.transitionStartTime)) /
                    levelConstants_1.LevelConstants.LEVEL_TRANSITION_TIME);
                Game.ctx.translate(levelOffsetX, levelOffsetY);
                if (!gameConstants_1.GameConstants.drawOtherRooms) {
                    this.prevLevel.draw(delta);
                    this.prevLevel.drawEntities(delta);
                    this.prevLevel.drawColorLayer();
                    this.prevLevel.drawShade(delta);
                    this.prevLevel.drawOverShade(delta);
                    /*
                    for (
                      let x = this.prevLevel.roomX - 1;
                      x <= this.prevLevel.roomX + this.prevLevel.width;
                      x++
                    ) {
                      for (
                        let y = this.prevLevel.roomY - 1;
                        y <= this.prevLevel.roomY + this.prevLevel.height;
                        y++
                      ) {
                        Game.drawFX(7 - ditherFrame, 10, 1, 1, x, y, 1, 1);
                      }
                    }
                  
                  */
                }
                Game.ctx.translate(-levelOffsetX, -levelOffsetY);
                Game.ctx.translate(newLevelOffsetX, newLevelOffsetY);
                if (gameConstants_1.GameConstants.drawOtherRooms) {
                    this.drawRooms(delta, true);
                    Game.ctx.translate(-newLevelOffsetX, -newLevelOffsetY);
                    Game.ctx.translate(playerOffsetX, playerOffsetY);
                    this.players[this.localPlayerID].draw(delta); // draw the translation
                    Game.ctx.translate(-playerOffsetX, -playerOffsetY);
                    Game.ctx.translate(newLevelOffsetX, newLevelOffsetY);
                    this.drawRoomShadeAndColor(delta);
                }
                for (let x = this.room.roomX - 1; x <= this.room.roomX + this.room.width; x++) {
                    for (let y = this.room.roomY - 1; y <= this.room.roomY + this.room.height; y++) {
                        //Game.drawFX(ditherFrame, 10, 1, 1, x, y, 1, 1);
                    }
                }
                //this.drawStuff(delta);
                Game.ctx.translate(-newLevelOffsetX, -newLevelOffsetY);
                Game.ctx.translate(Math.round(playerCX + playerOffsetX - 0.5 * gameConstants_1.GameConstants.WIDTH), Math.round(playerCY + playerOffsetY - 0.5 * gameConstants_1.GameConstants.HEIGHT));
                this.players[this.localPlayerID].drawGUI(delta);
                //for (const i in this.players) this.players[i].updateDrawXY(delta);
            }
            else if (this.levelState === LevelState.TRANSITIONING_LADDER) {
                let playerCX = (this.players[this.localPlayerID].x -
                    this.players[this.localPlayerID].drawX +
                    0.5) *
                    gameConstants_1.GameConstants.TILESIZE;
                let playerCY = (this.players[this.localPlayerID].y -
                    this.players[this.localPlayerID].drawY +
                    0.5) *
                    gameConstants_1.GameConstants.TILESIZE;
                Game.ctx.translate(-Math.round(playerCX - 0.5 * gameConstants_1.GameConstants.WIDTH), -Math.round(playerCY - 0.5 * gameConstants_1.GameConstants.HEIGHT));
                let deadFrames = 6;
                let ditherFrame = Math.floor(((7 * 2 + deadFrames) * (Date.now() - this.transitionStartTime)) /
                    levelConstants_1.LevelConstants.LEVEL_TRANSITION_TIME_LADDER);
                Game.ctx.translate(Math.round(playerCX - 0.5 * gameConstants_1.GameConstants.WIDTH), Math.round(playerCY - 0.5 * gameConstants_1.GameConstants.HEIGHT));
                if (ditherFrame < 7) {
                    this.drawRooms(delta);
                    this.drawRoomShadeAndColor(delta);
                    if (!gameConstants_1.GameConstants.drawOtherRooms) {
                        for (let x = this.room.roomX - 1; x <= this.room.roomX + this.room.width; x++) {
                            for (let y = this.room.roomY - 1; y <= this.room.roomY + this.room.height; y++) {
                                Game.drawFX(7 - ditherFrame, 10, 1, 1, x, y, 1, 1);
                            }
                        }
                    }
                }
                else if (ditherFrame >= 7 + deadFrames) {
                    if (this.transitioningLadder) {
                        this.prevLevel = this.room;
                        this.room.exitLevel();
                        this.room = this.transitioningLadder.linkedLevel;
                        //this.players[this.localPlayerID].levelID = this.room.id;
                        this.room.enterLevel(this.players[this.localPlayerID]);
                        this.transitioningLadder = null;
                    }
                    this.drawRooms(delta);
                    this.drawRoomShadeAndColor(delta);
                    //        this.room.draw(delta);
                    //        this.room.drawEntities(delta);
                    //        this.drawStuff(delta);
                    if (!gameConstants_1.GameConstants.drawOtherRooms) {
                        for (let x = this.room.roomX - 1; x <= this.room.roomX + this.room.width; x++) {
                            for (let y = this.room.roomY - 1; y <= this.room.roomY + this.room.height; y++) {
                                Game.drawFX(ditherFrame - (7 + deadFrames), 10, 1, 1, x, y, 1, 1);
                            }
                        }
                    }
                }
                //this.players[this.localPlayerID].drawGUI(delta);  // removed this to prevent drawing gui during level transition
                //for (const i in this.players) this.players[i].updateDrawXY(delta);
            }
            else if (this.levelState === LevelState.LEVEL_GENERATION) {
                this.levelgen.draw(delta);
            }
            else if (this.levelState === LevelState.IN_LEVEL) {
                // Start of Selection
                this.drawScreenShake(delta);
                let playerDrawX = this.players[this.localPlayerID].drawX;
                let playerDrawY = this.players[this.localPlayerID].drawY;
                let cameraX = Math.round((this.players[this.localPlayerID].x - playerDrawX + 0.5) *
                    gameConstants_1.GameConstants.TILESIZE -
                    0.5 * gameConstants_1.GameConstants.WIDTH -
                    this.screenShakeX);
                let cameraY = Math.round((this.players[this.localPlayerID].y - playerDrawY + 0.5) *
                    gameConstants_1.GameConstants.TILESIZE -
                    0.5 * gameConstants_1.GameConstants.HEIGHT -
                    this.screenShakeY);
                Game.ctx.translate(-cameraX, -cameraY);
                this.drawRooms(delta);
                this.drawRoomShadeAndColor(delta);
                //      this.room.draw(delta);
                //      this.room.drawEntities(delta);
                // this.drawStuff(delta);
                Game.ctx.translate(cameraX, cameraY);
                this.room.drawTopLayer(delta);
                this.players[this.localPlayerID].drawGUI(delta);
                //for (const i in this.players) this.players[i].updateDrawXY(delta);
            }
            let CHAT_X = 10;
            let CHAT_BOTTOM_Y = gameConstants_1.GameConstants.HEIGHT - Game.letter_height - 32;
            let CHAT_OPACITY = 0.5;
            if (this.chatOpen) {
                Game.ctx.fillStyle = "black";
                if (gameConstants_1.GameConstants.ALPHA_ENABLED)
                    Game.ctx.globalAlpha = 0.75;
                Game.ctx.fillRect(0, 0, gameConstants_1.GameConstants.WIDTH, gameConstants_1.GameConstants.HEIGHT);
                Game.ctx.globalAlpha = 1;
                Game.ctx.fillStyle = "white";
                Game.fillText(this.chatTextBox.text, CHAT_X, CHAT_BOTTOM_Y);
                const cursorX = Game.measureText(this.chatTextBox.text.substring(0, this.chatTextBox.cursor)).width;
                Game.ctx.fillRect(CHAT_X + cursorX, CHAT_BOTTOM_Y, 1, Game.letter_height);
            }
            for (let i = 0; i < this.chat.length; i++) {
                Game.ctx.fillStyle = "white";
                if (this.chat[i][0] === "/")
                    Game.ctx.fillStyle = gameConstants_1.GameConstants.GREEN;
                let y = CHAT_BOTTOM_Y - (this.chat.length - 1 - i) * (Game.letter_height + 1);
                if (this.chatOpen)
                    y -= Game.letter_height + 1;
                let age = Date.now() - this.chat[i].timestamp;
                if (this.chatOpen) {
                    Game.ctx.globalAlpha = 1;
                }
                else {
                    if (age <= gameConstants_1.GameConstants.CHAT_APPEAR_TIME) {
                        if (gameConstants_1.GameConstants.ALPHA_ENABLED)
                            Game.ctx.globalAlpha = CHAT_OPACITY;
                    }
                    else if (age <=
                        gameConstants_1.GameConstants.CHAT_APPEAR_TIME + gameConstants_1.GameConstants.CHAT_FADE_TIME) {
                        if (gameConstants_1.GameConstants.ALPHA_ENABLED)
                            Game.ctx.globalAlpha =
                                CHAT_OPACITY *
                                    (1 -
                                        (age - gameConstants_1.GameConstants.CHAT_APPEAR_TIME) /
                                            gameConstants_1.GameConstants.CHAT_FADE_TIME);
                    }
                    else {
                        Game.ctx.globalAlpha = 0;
                    }
                }
                Game.fillText(this.chat[i].message, CHAT_X, y);
            }
            // game version
            if (gameConstants_1.GameConstants.ALPHA_ENABLED)
                Game.ctx.globalAlpha = 0.1;
            Game.ctx.fillStyle = levelConstants_1.LevelConstants.LEVEL_TEXT_COLOR;
            Game.fillText(gameConstants_1.GameConstants.VERSION, gameConstants_1.GameConstants.WIDTH - Game.measureText(gameConstants_1.GameConstants.VERSION).width - 1, 1);
            Game.ctx.globalAlpha = 1;
            // fps
            if (gameConstants_1.GameConstants.ALPHA_ENABLED)
                Game.ctx.globalAlpha = 0.1;
            Game.ctx.fillStyle = levelConstants_1.LevelConstants.LEVEL_TEXT_COLOR;
            Game.fillText(fps + "fps", 1, 1);
            Game.ctx.globalAlpha = 1;
            if (!this.started && this.levelState !== LevelState.LEVEL_GENERATION) {
                this.drawStartScreen(delta * 10);
            }
            mouseCursor_1.MouseCursor.getInstance().draw(delta, this.isMobile);
            Game.ctx.restore(); // Restore the canvas state
        };
        this.drawScreenShake = (delta) => {
            if (!this.screenShakeActive) {
                this.resetScreenShake();
                return;
            }
            this.shakeAmountX *= 0.8 ** delta;
            this.shakeAmountY *= 0.8 ** delta;
            this.screenShakeX = Math.sin(this.shakeFrame * Math.PI) * this.shakeAmountX;
            this.screenShakeY = Math.sin(this.shakeFrame * Math.PI) * this.shakeAmountY;
            this.shakeFrame += 0.15 * delta;
            if (Math.abs(this.shakeAmountX) < 0.5 &&
                Math.abs(this.shakeAmountY) < 0.5) {
                this.resetScreenShake();
            }
        };
        this.resetScreenShake = () => {
            this.shakeAmountX = 0;
            this.shakeAmountY = 0;
            this.shakeFrame = 0;
            this.screenShakeX = 0;
            this.screenShakeY = 0;
            this.screenShakeActive = false;
        };
        this.handleWindowBlur = () => {
            // Start a timeout when window loses focus
            this.focusTimeout = window.setTimeout(() => {
                // Store current state
                this.wasMuted = sound_1.Sound.audioMuted;
                this.wasStarted = this.started;
                // Mute audio and pause game
                sound_1.Sound.audioMuted = true;
                this.started = false;
                this.paused = true;
                // Optional: Show a message in chat
                this.pushMessage("Game paused - window inactive");
            }, this.FOCUS_TIMEOUT_DURATION);
        };
        this.handleWindowFocus = () => {
            // Clear the timeout if it exists
            if (this.focusTimeout) {
                clearTimeout(this.focusTimeout);
                this.focusTimeout = null;
            }
            // If game was paused due to inactivity, restore previous state
            if (this.paused) {
                sound_1.Sound.audioMuted = this.wasMuted;
                this.started = this.wasStarted;
                this.paused = false;
                // Optional: Show a message in chat
                this.pushMessage("Game resumed");
            }
        };
        window.addEventListener("load", () => {
            let canvas = document.getElementById("gameCanvas");
            Game.ctx = canvas.getContext("2d", {
                alpha: false,
            });
            // Create TextBox instances and associate them with HTML elements
            const usernameElement = document.createElement("input");
            usernameElement.type = "text";
            usernameElement.autocomplete = "off";
            usernameElement.autocapitalize = "off";
            usernameElement.style.position = "absolute";
            usernameElement.style.left = "-1000px"; // Position off-screen
            //const passwordElement = document.createElement("input");
            //passwordElement.type = "password";
            //passwordElement.style.position = "absolute";
            //passwordElement.style.left = "-1000px"; // Position off-screen
            const chatElement = document.createElement("input");
            chatElement.type = "text";
            chatElement.style.position = "absolute";
            chatElement.style.left = "-1000px"; // Position off-screen
            //document.body.appendChild(usernameElement);
            //document.body.appendChild(passwordElement);
            document.body.appendChild(chatElement);
            document.addEventListener("click", () => {
                usernameElement.focus();
            }, { once: true });
            this.chat = [];
            this.chatTextBox = new textbox_1.TextBox(chatElement);
            this.chatTextBox.setEnterCallback(() => {
                if (this.chatTextBox.text.length > 0) {
                    this.chat.push(new ChatMessage(this.chatTextBox.text));
                    this.chatTextBox.clear();
                }
                else {
                    this.chatOpen = false;
                }
            });
            this.chatTextBox.setEscapeCallback(() => {
                this.chatOpen = false;
            });
            this.worldCodes = [];
            this.selectedWorldCode = 0;
            Game.shade_canvases = {};
            Game.text_rendering_canvases = {};
            let resourcesLoaded = 0;
            const NUM_RESOURCES = 6;
            Game.tileset = new Image();
            Game.tileset.onload = () => {
                resourcesLoaded++;
            };
            Game.tileset.src = "res/tileset.png";
            Game.objset = new Image();
            Game.objset.onload = () => {
                resourcesLoaded++;
            };
            Game.objset.src = "res/objset.png";
            Game.mobset = new Image();
            Game.mobset.onload = () => {
                resourcesLoaded++;
            };
            Game.mobset.src = "res/mobset.png";
            Game.itemset = new Image();
            Game.itemset.onload = () => {
                resourcesLoaded++;
            };
            Game.itemset.src = "res/itemset.png";
            Game.fxset = new Image();
            Game.fxset.onload = () => {
                resourcesLoaded++;
            };
            Game.fxset.src = "res/fxset.png";
            Game.fontsheet = new Image();
            Game.fontsheet.onload = () => {
                resourcesLoaded++;
            };
            Game.fontsheet.src = "res/font.png";
            this.levelState = LevelState.LEVEL_GENERATION;
            let checkResourcesLoaded = () => {
                if (resourcesLoaded < NUM_RESOURCES) {
                    window.setTimeout(checkResourcesLoaded, 500);
                }
                else {
                    // proceed with constructor
                    Game.scale = gameConstants_1.GameConstants.SCALE;
                    document.addEventListener("touchstart", function (e) {
                        if (e.target == canvas) {
                            e.preventDefault();
                        }
                    }, false);
                    document.addEventListener("touchend", function (e) {
                        if (e.target == canvas) {
                            e.preventDefault();
                        }
                    }, false);
                    document.addEventListener("touchmove", function (e) {
                        if (e.target == canvas) {
                            e.preventDefault();
                        }
                    }, false);
                    document.addEventListener("touchstart", input_1.Input.handleTouchStart, {
                        passive: false,
                    });
                    document.addEventListener("touchmove", input_1.Input.handleTouchMove, {
                        passive: false,
                    });
                    document.addEventListener("touchend", input_1.Input.handleTouchEnd, {
                        passive: false,
                    });
                    input_1.Input.keyDownListener = (key) => {
                        this.keyDownListener(key);
                    };
                    window.requestAnimationFrame(this.run);
                    this.onResize();
                    window.addEventListener("resize", this.onResize);
                    window.addEventListener("orientationchange", () => {
                        // Small delay to ensure new dimensions are available
                        setTimeout(this.onResize, 100);
                    });
                    //Sound.playMusic(); // loops forever
                    this.players = {};
                    this.offlinePlayers = {};
                    this.chatOpen = false;
                    this.screenShakeX = 0;
                    this.screenShakeY = 0;
                    this.shakeAmountX = 0;
                    this.shakeAmountY = 0;
                    this.shakeFrame = (3 * Math.PI) / 2;
                    this.screenShakeCutoff = 0;
                    this.tutorialActive = false;
                    this.screenShakeActive = false;
                    this.levels = [];
                    this.encounteredEnemies = [];
                    this.newGame();
                }
            };
            checkResourcesLoaded();
        });
        reverb_1.ReverbEngine.initialize();
        sound_1.Sound.loadSounds();
        this.started = false;
        this.tutorialListener = null;
        this.setupEventListeners();
        eventBus_1.globalEventBus.on(events_1.EVENTS.LEVEL_GENERATION_STARTED, () => {
            this.levelState = LevelState.LEVEL_GENERATION;
        });
        eventBus_1.globalEventBus.on(events_1.EVENTS.LEVEL_GENERATION_COMPLETED, () => {
            this.levelState = LevelState.IN_LEVEL;
        });
        // Add focus/blur event listeners
        window.addEventListener("blur", this.handleWindowBlur);
        window.addEventListener("focus", this.handleWindowFocus);
    }
    setupEventListeners() {
        //console.log("Setting up event listeners");
        eventBus_1.globalEventBus.on("ChatCommand", this.commandHandler.bind(this));
    }
    destroy() {
        window.removeEventListener("blur", this.handleWindowBlur);
        window.removeEventListener("focus", this.handleWindowFocus);
        if (this.focusTimeout) {
            clearTimeout(this.focusTimeout);
        }
    }
}
exports.Game = Game;
Game.inputReceived = false;
Game.letters = "abcdefghijklmnopqrstuvwxyz1234567890,.!?:'()[]%-/";
Game.letter_widths = [
    4, 4, 4, 4, 3, 3, 4, 4, 1, 4, 4, 3, 5, 5, 4, 4, 4, 4, 4, 3, 4, 5, 5, 5, 5,
    3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 1, 1, 4, 1, 1, 2, 2, 2, 2, 5, 3, 3,
];
Game.letter_height = 6;
Game.letter_positions = [];
// [min, max] inclusive
Game.rand = (min, max, rand) => {
    if (max < min)
        return min;
    return Math.floor(rand() * (max - min + 1) + min);
};
Game.randTable = (table, rand) => {
    return table[Game.rand(0, table.length - 1, rand)];
};
Game.measureText = (text) => {
    let w = 0;
    for (const letter of text.toLowerCase()) {
        if (letter === " ")
            w += 4;
        else
            for (let i = 0; i < Game.letters.length; i++) {
                if (Game.letters[i] === letter) {
                    w += Game.letter_widths[i] + 1;
                }
            }
    }
    return { width: w, height: Game.letter_height };
};
Game.fillText = (text, x, y, maxWidth) => {
    x = Math.round(x);
    y = Math.round(y);
    if (Game.letter_positions.length === 0) {
        // calculate letter positions
        for (let i = 0; i < Game.letter_widths.length; i++) {
            if (i === 0)
                Game.letter_positions[0] = 0;
            else
                Game.letter_positions[i] =
                    Game.letter_positions[i - 1] + Game.letter_widths[i - 1] + 2;
        }
    }
    else {
        let dimensions = Game.measureText(text);
        if (dimensions.width > 0) {
            let key = text + Game.ctx.fillStyle;
            if (!Game.text_rendering_canvases[key]) {
                Game.text_rendering_canvases[key] = document.createElement("canvas");
                Game.text_rendering_canvases[key].width = dimensions.width;
                Game.text_rendering_canvases[key].height = dimensions.height;
                let bx = Game.text_rendering_canvases[key].getContext("2d");
                let letter_x = 0;
                for (const letter of text.toLowerCase()) {
                    if (letter === " ")
                        letter_x += 4;
                    else
                        for (let i = 0; i < Game.letters.length; i++) {
                            if (Game.letters[i] === letter) {
                                bx.drawImage(Game.fontsheet, Game.letter_positions[i] + 1, 0, Game.letter_widths[i], Game.letter_height, letter_x, 0, Game.letter_widths[i], Game.letter_height);
                                letter_x += Game.letter_widths[i] + 1;
                            }
                        }
                }
                bx.fillStyle = Game.ctx.fillStyle;
                bx.globalCompositeOperation = "source-in";
                bx.fillRect(0, 0, Game.text_rendering_canvases[key].width, Game.text_rendering_canvases[key].height);
                Game.ctx.drawImage(Game.text_rendering_canvases[key], x, y);
            }
            else {
                Game.ctx.drawImage(Game.text_rendering_canvases[key], x, y);
            }
        }
    }
};
Game.fillTextOutline = (text, x, y, outlineColor, fillColor) => {
    Game.ctx.fillStyle = outlineColor;
    for (let xx = -1; xx <= 1; xx++) {
        for (let yy = -1; yy <= 1; yy++) {
            Game.fillText(text, x + xx, y + yy);
        }
    }
    Game.ctx.fillStyle = fillColor;
    Game.fillText(text, x, y);
};
Game.drawHelper = (set, sX, sY, sW, sH, dX, dY, dW, dH, shadeColor = "black", shadeOpacity = 0, entity = false) => {
    Game.ctx.save(); // Save the current canvas state
    // Snap to nearest shading increment
    let divisor = entity ? 10 : 1;
    shadeOpacity =
        Math.round(shadeOpacity * Math.max(gameConstants_1.GameConstants.SHADE_LEVELS / divisor, 12)) / Math.max(gameConstants_1.GameConstants.SHADE_LEVELS / divisor, 12);
    // Include shadeColor in the cache key
    let key = getShadeCanvasKey(set, sX, sY, sW, sH, shadeOpacity, shadeColor);
    if (!Game.shade_canvases[key]) {
        Game.shade_canvases[key] = document.createElement("canvas");
        Game.shade_canvases[key].width = Math.round(sW * gameConstants_1.GameConstants.TILESIZE);
        Game.shade_canvases[key].height = Math.round(sH * gameConstants_1.GameConstants.TILESIZE);
        let shCtx = Game.shade_canvases[key].getContext("2d");
        shCtx.clearRect(0, 0, Game.shade_canvases[key].width, Game.shade_canvases[key].height);
        shCtx.globalCompositeOperation = "source-over";
        shCtx.drawImage(set, Math.round(sX * gameConstants_1.GameConstants.TILESIZE), Math.round(sY * gameConstants_1.GameConstants.TILESIZE), Math.round(sW * gameConstants_1.GameConstants.TILESIZE), Math.round(sH * gameConstants_1.GameConstants.TILESIZE), 0, 0, Math.round(sW * gameConstants_1.GameConstants.TILESIZE), Math.round(sH * gameConstants_1.GameConstants.TILESIZE));
        shCtx.globalAlpha = shadeOpacity;
        shCtx.fillStyle = shadeColor;
        shCtx.fillRect(0, 0, Game.shade_canvases[key].width, Game.shade_canvases[key].height);
        shCtx.globalAlpha = 1.0;
        shCtx.globalCompositeOperation = "destination-in";
        shCtx.drawImage(set, Math.round(sX * gameConstants_1.GameConstants.TILESIZE), Math.round(sY * gameConstants_1.GameConstants.TILESIZE), Math.round(sW * gameConstants_1.GameConstants.TILESIZE), Math.round(sH * gameConstants_1.GameConstants.TILESIZE), 0, 0, Math.round(sW * gameConstants_1.GameConstants.TILESIZE), Math.round(sH * gameConstants_1.GameConstants.TILESIZE));
    }
    Game.ctx.drawImage(Game.shade_canvases[key], Math.round(dX * gameConstants_1.GameConstants.TILESIZE), Math.round(dY * gameConstants_1.GameConstants.TILESIZE), Math.round(dW * gameConstants_1.GameConstants.TILESIZE), Math.round(dH * gameConstants_1.GameConstants.TILESIZE));
    Game.ctx.restore(); // Restore the canvas state
};
Game.drawTile = (sX, sY, sW, sH, dX, dY, dW, dH, shadeColor = "black", shadeOpacity = 0) => {
    Game.drawHelper(Game.tileset, sX, sY, sW, sH, dX, dY, dW, dH, shadeColor, shadeOpacity);
};
Game.drawObj = (sX, sY, sW, sH, dX, dY, dW, dH, shadeColor = "black", shadeOpacity = 0) => {
    Game.drawHelper(Game.objset, sX, sY, sW, sH, dX, dY, dW, dH, shadeColor, shadeOpacity, true);
};
Game.drawMob = (sX, sY, sW, sH, dX, dY, dW, dH, shadeColor = "black", shadeOpacity = 0) => {
    Game.drawHelper(Game.mobset, sX, sY, sW, sH, dX, dY, dW, dH, shadeColor, shadeOpacity, true);
};
Game.drawItem = (sX, sY, sW, sH, dX, dY, dW, dH, shadeColor = "black", shadeOpacity = 0) => {
    Game.drawHelper(Game.itemset, sX, sY, sW, sH, dX, dY, dW, dH, shadeColor, shadeOpacity, true);
};
Game.drawFX = (sX, sY, sW, sH, dX, dY, dW, dH, shadeColor = "black", shadeOpacity = 0) => {
    Game.drawHelper(Game.fxset, sX, sY, sW, sH, dX, dY, dW, dH, shadeColor, shadeOpacity, true);
};
exports.game = new Game();
exports.gs = new gameState_1.GameState();


/***/ }),

/***/ "./src/gameConstants.ts":
/*!******************************!*\
  !*** ./src/gameConstants.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GameConstants = void 0;
const armor_1 = __webpack_require__(/*! ./item/armor */ "./src/item/armor.ts");
const backpack_1 = __webpack_require__(/*! ./item/backpack */ "./src/item/backpack.ts");
const candle_1 = __webpack_require__(/*! ./item/candle */ "./src/item/candle.ts");
const coal_1 = __webpack_require__(/*! ./item/coal */ "./src/item/coal.ts");
const godStone_1 = __webpack_require__(/*! ./item/godStone */ "./src/item/godStone.ts");
const heart_1 = __webpack_require__(/*! ./item/heart */ "./src/item/heart.ts");
const torch_1 = __webpack_require__(/*! ./item/torch */ "./src/item/torch.ts");
const weaponBlood_1 = __webpack_require__(/*! ./item/weaponBlood */ "./src/item/weaponBlood.ts");
const weaponFragments_1 = __webpack_require__(/*! ./item/weaponFragments */ "./src/item/weaponFragments.ts");
const weaponPoison_1 = __webpack_require__(/*! ./item/weaponPoison */ "./src/item/weaponPoison.ts");
const levelConstants_1 = __webpack_require__(/*! ./levelConstants */ "./src/levelConstants.ts");
const dagger_1 = __webpack_require__(/*! ./weapon/dagger */ "./src/weapon/dagger.ts");
const dualdagger_1 = __webpack_require__(/*! ./weapon/dualdagger */ "./src/weapon/dualdagger.ts");
const spear_1 = __webpack_require__(/*! ./weapon/spear */ "./src/weapon/spear.ts");
const spellbook_1 = __webpack_require__(/*! ./weapon/spellbook */ "./src/weapon/spellbook.ts");
const hammer_1 = __webpack_require__(/*! ./item/hammer */ "./src/item/hammer.ts");
const greataxe_1 = __webpack_require__(/*! ./weapon/greataxe */ "./src/weapon/greataxe.ts");
class GameConstants {
}
exports.GameConstants = GameConstants;
GameConstants.VERSION = "v1.0.5"; //"v0.6.3";
GameConstants.DEVELOPER_MODE = false;
GameConstants.isMobile = false;
GameConstants.FPS = 120;
GameConstants.ALPHA_ENABLED = true;
GameConstants.SHADE_LEVELS = 25;
GameConstants.ENTITY_SHADE_LEVELS = 10;
GameConstants.TILESIZE = 16;
GameConstants.SCALE = 6;
GameConstants.SOFT_SCALE = 6;
GameConstants.MAX_SCALE = 10;
GameConstants.MIN_SCALE = 1;
GameConstants.SWIPE_THRESH = 25 ** 2; // (size of swipe threshold circle)^2
GameConstants.HOLD_THRESH = 250; // milliseconds
GameConstants.KEY_REPEAT_TIME = 300; // millseconds
GameConstants.MOVEMENT_COOLDOWN = 200; // milliseconds
GameConstants.MOVE_WITH_MOUSE = false;
GameConstants.CHAT_APPEAR_TIME = 2500;
GameConstants.CHAT_FADE_TIME = 500;
GameConstants.ANIMATION_SPEED = 1;
GameConstants.DEFAULTWIDTH = GameConstants.TILESIZE;
GameConstants.DEFAULTHEIGHT = GameConstants.TILESIZE;
GameConstants.WIDTH = levelConstants_1.LevelConstants.SCREEN_W * GameConstants.TILESIZE;
GameConstants.HEIGHT = levelConstants_1.LevelConstants.SCREEN_H * GameConstants.TILESIZE;
GameConstants.drawOtherRooms = true;
GameConstants.SCRIPT_FONT_SIZE = 16;
GameConstants.FONT_SIZE = 7;
GameConstants.BIG_FONT_SIZE = 15;
GameConstants.RED = "#ac3232";
GameConstants.WARNING_RED = "#ff0000";
GameConstants.GREEN = "#6abe30";
GameConstants.ARMOR_GREY = "#9badb7";
GameConstants.OUTLINE = "#222034";
GameConstants.HIT_ENEMY_TEXT_COLOR = "#76428a";
GameConstants.HEALTH_BUFF_COLOR = "#d77bba";
GameConstants.MISS_COLOR = "#639bff";
GameConstants.CUSTOM_SHADER_COLOR_ENABLED = false;
GameConstants.COLOR_LAYER_COMPOSITE_OPERATION = "soft-light"; //"soft-light";
GameConstants.SHADE_LAYER_COMPOSITE_OPERATION = "screen"; //"soft-light";
GameConstants.USE_OPTIMIZED_SHADING = false;
GameConstants.SMOOTH_LIGHTING = false;
GameConstants.ctxBlurEnabled = true;
GameConstants.BLUR_ENABLED = true;
GameConstants.COLOR_LAYER_COMPOSITE_OPERATIONS = [
    "soft-light",
    //"addition",
    //"darken",
    "overlay",
    //"hue",
    //"source-over",
    //"screen",
    "multiply",
    //"difference",
    //"exclusion",
    //"luminosity",
    //"color-dodge",
    //"color-burn",
    //"hard-light",
    //"soft-light",
    //"lighten",
];
GameConstants.SET_COLOR_LAYER_COMPOSITE_OPERATION = (shade, back = false) => {
    let operation = shade
        ? GameConstants.SHADE_LAYER_COMPOSITE_OPERATION
        : GameConstants.COLOR_LAYER_COMPOSITE_OPERATION;
    const currentIndex = GameConstants.COLOR_LAYER_COMPOSITE_OPERATIONS.indexOf(operation);
    let nextIndex;
    if (back) {
        // Decrement the index to move backward in the operations array
        nextIndex =
            (currentIndex -
                1 +
                GameConstants.COLOR_LAYER_COMPOSITE_OPERATIONS.length) %
                GameConstants.COLOR_LAYER_COMPOSITE_OPERATIONS.length;
    }
    else {
        // Increment the index to move forward in the operations array
        nextIndex =
            (currentIndex + 1) %
                GameConstants.COLOR_LAYER_COMPOSITE_OPERATIONS.length;
    }
    operation = GameConstants.COLOR_LAYER_COMPOSITE_OPERATIONS[nextIndex];
    if (shade) {
        GameConstants.SHADE_LAYER_COMPOSITE_OPERATION = operation;
    }
    else {
        GameConstants.COLOR_LAYER_COMPOSITE_OPERATION = operation;
    }
    console.log(`Color layer composite operation set to ${operation}`);
};
GameConstants.TOGGLE_USE_OPTIMIZED_SHADING = () => {
    GameConstants.USE_OPTIMIZED_SHADING = !GameConstants.USE_OPTIMIZED_SHADING;
};
GameConstants.SET_SCALE = () => {
    GameConstants.SCALE++;
    if (GameConstants.SCALE > GameConstants.MAX_SCALE) {
        GameConstants.SCALE = GameConstants.MIN_SCALE;
    }
};
GameConstants.INCREASE_SCALE = () => {
    if (GameConstants.SCALE < GameConstants.MAX_SCALE) {
        GameConstants.SCALE++;
        if (GameConstants.SCALE > GameConstants.MAX_SCALE) {
            GameConstants.SCALE = GameConstants.MIN_SCALE;
        }
    }
};
GameConstants.DECREASE_SCALE = () => {
    if (GameConstants.SCALE > GameConstants.MIN_SCALE) {
        GameConstants.SCALE--;
        if (GameConstants.SCALE < GameConstants.MIN_SCALE) {
            GameConstants.SCALE = GameConstants.MAX_SCALE;
        }
    }
};
GameConstants.STARTING_INVENTORY = [dagger_1.Dagger, torch_1.Torch];
GameConstants.STARTING_DEV_INVENTORY = [
    dagger_1.Dagger,
    greataxe_1.Greataxe,
    dualdagger_1.DualDagger,
    torch_1.Torch,
    godStone_1.GodStone,
    candle_1.Candle,
    spear_1.Spear,
    weaponPoison_1.WeaponPoison,
    weaponBlood_1.WeaponBlood,
    spellbook_1.Spellbook,
    armor_1.Armor,
    heart_1.Heart,
    backpack_1.Backpack,
    hammer_1.Hammer,
    coal_1.Coal,
    coal_1.Coal,
    coal_1.Coal,
    coal_1.Coal,
    coal_1.Coal,
    coal_1.Coal,
    weaponFragments_1.WeaponFragments,
    weaponFragments_1.WeaponFragments,
    weaponFragments_1.WeaponFragments,
];


/***/ }),

/***/ "./src/gameState.ts":
/*!**************************!*\
  !*** ./src/gameState.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.loadGameState = exports.createGameState = exports.GameState = exports.PlayerState = exports.InventoryState = exports.ItemState = exports.ItemType = exports.LevelState = exports.EnemyState = exports.EnemyType = exports.ProjectileState = exports.ProjectileType = exports.HitWarningState = void 0;
const barrel_1 = __webpack_require__(/*! ./entity/object/barrel */ "./src/entity/object/barrel.ts");
const bigSkullEnemy_1 = __webpack_require__(/*! ./entity/enemy/bigSkullEnemy */ "./src/entity/enemy/bigSkullEnemy.ts");
const chargeEnemy_1 = __webpack_require__(/*! ./entity/enemy/chargeEnemy */ "./src/entity/enemy/chargeEnemy.ts");
const chest_1 = __webpack_require__(/*! ./entity/object/chest */ "./src/entity/object/chest.ts");
const coalResource_1 = __webpack_require__(/*! ./entity/resource/coalResource */ "./src/entity/resource/coalResource.ts");
const crate_1 = __webpack_require__(/*! ./entity/object/crate */ "./src/entity/object/crate.ts");
const emeraldResource_1 = __webpack_require__(/*! ./entity/resource/emeraldResource */ "./src/entity/resource/emeraldResource.ts");
const goldResource_1 = __webpack_require__(/*! ./entity/resource/goldResource */ "./src/entity/resource/goldResource.ts");
const knightEnemy_1 = __webpack_require__(/*! ./entity/enemy/knightEnemy */ "./src/entity/enemy/knightEnemy.ts");
const pottedPlant_1 = __webpack_require__(/*! ./entity/object/pottedPlant */ "./src/entity/object/pottedPlant.ts");
const pot_1 = __webpack_require__(/*! ./entity/object/pot */ "./src/entity/object/pot.ts");
const skullEnemy_1 = __webpack_require__(/*! ./entity/enemy/skullEnemy */ "./src/entity/enemy/skullEnemy.ts");
const crabEnemy_1 = __webpack_require__(/*! ./entity/enemy/crabEnemy */ "./src/entity/enemy/crabEnemy.ts");
const spawner_1 = __webpack_require__(/*! ./entity/enemy/spawner */ "./src/entity/enemy/spawner.ts");
const vendingMachine_1 = __webpack_require__(/*! ./entity/object/vendingMachine */ "./src/entity/object/vendingMachine.ts");
const wizardEnemy_1 = __webpack_require__(/*! ./entity/enemy/wizardEnemy */ "./src/entity/enemy/wizardEnemy.ts");
const zombieEnemy_1 = __webpack_require__(/*! ./entity/enemy/zombieEnemy */ "./src/entity/enemy/zombieEnemy.ts");
const hitWarning_1 = __webpack_require__(/*! ./hitWarning */ "./src/hitWarning.ts");
const armor_1 = __webpack_require__(/*! ./item/armor */ "./src/item/armor.ts");
const bluegem_1 = __webpack_require__(/*! ./item/bluegem */ "./src/item/bluegem.ts");
const candle_1 = __webpack_require__(/*! ./item/candle */ "./src/item/candle.ts");
const coal_1 = __webpack_require__(/*! ./item/coal */ "./src/item/coal.ts");
const coin_1 = __webpack_require__(/*! ./item/coin */ "./src/item/coin.ts");
const equippable_1 = __webpack_require__(/*! ./item/equippable */ "./src/item/equippable.ts");
const gold_1 = __webpack_require__(/*! ./item/gold */ "./src/item/gold.ts");
const goldenKey_1 = __webpack_require__(/*! ./item/goldenKey */ "./src/item/goldenKey.ts");
const greengem_1 = __webpack_require__(/*! ./item/greengem */ "./src/item/greengem.ts");
const heart_1 = __webpack_require__(/*! ./item/heart */ "./src/item/heart.ts");
const key_1 = __webpack_require__(/*! ./item/key */ "./src/item/key.ts");
const lantern_1 = __webpack_require__(/*! ./item/lantern */ "./src/item/lantern.ts");
const redgem_1 = __webpack_require__(/*! ./item/redgem */ "./src/item/redgem.ts");
const torch_1 = __webpack_require__(/*! ./item/torch */ "./src/item/torch.ts");
const levelGenerator_1 = __webpack_require__(/*! ./levelGenerator */ "./src/levelGenerator.ts");
const player_1 = __webpack_require__(/*! ./player/player */ "./src/player/player.ts");
const enemySpawnAnimation_1 = __webpack_require__(/*! ./projectile/enemySpawnAnimation */ "./src/projectile/enemySpawnAnimation.ts");
const wizardFireball_1 = __webpack_require__(/*! ./projectile/wizardFireball */ "./src/projectile/wizardFireball.ts");
const random_1 = __webpack_require__(/*! ./random */ "./src/random.ts");
const dagger_1 = __webpack_require__(/*! ./weapon/dagger */ "./src/weapon/dagger.ts");
const dualdagger_1 = __webpack_require__(/*! ./weapon/dualdagger */ "./src/weapon/dualdagger.ts");
const shotgun_1 = __webpack_require__(/*! ./weapon/shotgun */ "./src/weapon/shotgun.ts");
const spear_1 = __webpack_require__(/*! ./weapon/spear */ "./src/weapon/spear.ts");
const pickaxe_1 = __webpack_require__(/*! ./weapon/pickaxe */ "./src/weapon/pickaxe.ts");
const backpack_1 = __webpack_require__(/*! ./item/backpack */ "./src/item/backpack.ts");
const energyWizard_1 = __webpack_require__(/*! ./entity/enemy/energyWizard */ "./src/entity/enemy/energyWizard.ts");
const eventBus_1 = __webpack_require__(/*! ./eventBus */ "./src/eventBus.ts");
const events_1 = __webpack_require__(/*! ./events */ "./src/events.ts");
class HitWarningState {
    constructor(hw) {
        this.x = hw.x;
        this.y = hw.y;
        this.dead = hw.dead;
    }
}
exports.HitWarningState = HitWarningState;
let loadHitWarning = (hws, game) => {
    let hw = new hitWarning_1.HitWarning(game, hws.x, hws.y, hws.x, hws.y);
    hw.dead = hws.dead;
    return hw;
};
var ProjectileType;
(function (ProjectileType) {
    ProjectileType[ProjectileType["SPAWN"] = 0] = "SPAWN";
    ProjectileType[ProjectileType["WIZARD"] = 1] = "WIZARD";
})(ProjectileType = exports.ProjectileType || (exports.ProjectileType = {}));
class ProjectileState {
    constructor(projectile, game) {
        this.x = projectile.x;
        this.y = projectile.y;
        this.dead = projectile.dead;
        if (projectile instanceof enemySpawnAnimation_1.EnemySpawnAnimation) {
            this.type = ProjectileType.SPAWN;
            this.levelID = game.rooms.indexOf(projectile.room);
            this.enemySpawn = new EnemyState(projectile.enemy, game);
        }
        if (projectile instanceof wizardFireball_1.WizardFireball) {
            this.type = ProjectileType.WIZARD;
            this.wizardState = projectile.state;
            this.levelID = game.rooms.indexOf(projectile.parent.room);
            this.wizardParentID = projectile.parent.room.entities.indexOf(projectile.parent);
        }
    }
}
exports.ProjectileState = ProjectileState;
let loadProjectile = (ps, game) => {
    if (ps.type === ProjectileType.SPAWN) {
        let level = game.rooms[ps.levelID];
        let enemy = loadEnemy(ps.enemySpawn, game);
        let p = new enemySpawnAnimation_1.EnemySpawnAnimation(level, enemy, ps.x, ps.y);
        p.dead = ps.dead;
        return p;
    }
    if (ps.type === ProjectileType.WIZARD) {
        let wizard = game.rooms[ps.levelID].entities[ps.wizardParentID];
        let p = new wizardFireball_1.WizardFireball(wizard, ps.x, ps.y);
        p.state = ps.wizardState;
        return p;
    }
};
var EnemyType;
(function (EnemyType) {
    EnemyType[EnemyType["BARREL"] = 0] = "BARREL";
    EnemyType[EnemyType["BIGSKULL"] = 1] = "BIGSKULL";
    EnemyType[EnemyType["CHARGE"] = 2] = "CHARGE";
    EnemyType[EnemyType["CHEST"] = 3] = "CHEST";
    EnemyType[EnemyType["COAL"] = 4] = "COAL";
    EnemyType[EnemyType["CRATE"] = 5] = "CRATE";
    EnemyType[EnemyType["EMERALD"] = 6] = "EMERALD";
    EnemyType[EnemyType["GOLD"] = 7] = "GOLD";
    EnemyType[EnemyType["KNIGHT"] = 8] = "KNIGHT";
    EnemyType[EnemyType["PLANT"] = 9] = "PLANT";
    EnemyType[EnemyType["SKULL"] = 10] = "SKULL";
    EnemyType[EnemyType["CRAB"] = 11] = "CRAB";
    EnemyType[EnemyType["SPAWNER"] = 12] = "SPAWNER";
    EnemyType[EnemyType["VENDINGMACHINE"] = 13] = "VENDINGMACHINE";
    EnemyType[EnemyType["WIZARD"] = 14] = "WIZARD";
    EnemyType[EnemyType["ZOMBIE"] = 15] = "ZOMBIE";
})(EnemyType = exports.EnemyType || (exports.EnemyType = {}));
class EnemyState {
    constructor(enemy, game) {
        this.levelID = game.rooms.indexOf(enemy.room);
        this.x = enemy.x;
        this.y = enemy.y;
        this.health = enemy.health;
        this.direction = enemy.direction;
        this.dead = enemy.dead;
        this.skipNextTurns = enemy.skipNextTurns;
        this.hasDrop = false;
        if (enemy.drop) {
            this.hasDrop = true;
            this.drop = new ItemState(enemy.drop, game);
        }
        this.alertTicks = enemy.alertTicks;
        if (enemy instanceof barrel_1.Barrel)
            this.type = EnemyType.BARREL;
        if (enemy instanceof bigSkullEnemy_1.BigSkullEnemy) {
            this.type = EnemyType.BIGSKULL;
            this.ticks = enemy.ticks;
            this.ticksSinceFirstHit = enemy.ticksSinceFirstHit;
            this.seenPlayer = enemy.seenPlayer;
            if (enemy.seenPlayer) {
                this.targetPlayerID = Object.keys(game.players).find((key) => game.players[key] === enemy.targetPlayer);
                if (!this.targetPlayerID)
                    this.targetPlayerID = Object.keys(game.offlinePlayers).find((key) => game.offlinePlayers[key] === enemy.targetPlayer);
            }
            this.drops = [];
            for (const d of enemy.drops)
                this.drops.push(new ItemState(d, game));
        }
        if (enemy instanceof chargeEnemy_1.ChargeEnemy) {
            this.type = EnemyType.CHARGE;
            this.ticks = enemy.ticks;
            this.chargeEnemyState = enemy.state;
            this.startX = enemy.startX;
            this.startY = enemy.startY;
            this.targetX = enemy.targetX;
            this.targetY = enemy.targetY;
            this.visualTargetX = enemy.visualTargetX;
            this.visualTargetY = enemy.visualTargetY;
        }
        if (enemy instanceof chest_1.Chest)
            this.type = EnemyType.CHEST;
        if (enemy instanceof coalResource_1.CoalResource)
            this.type = EnemyType.COAL;
        if (enemy instanceof crate_1.Crate)
            this.type = EnemyType.CRATE;
        if (enemy instanceof emeraldResource_1.EmeraldResource)
            this.type = EnemyType.EMERALD;
        if (enemy instanceof goldResource_1.GoldResource)
            this.type = EnemyType.GOLD;
        if (enemy instanceof knightEnemy_1.KnightEnemy) {
            this.type = EnemyType.KNIGHT;
            this.ticks = enemy.ticks;
            this.seenPlayer = enemy.seenPlayer;
            if (enemy.seenPlayer) {
                this.targetPlayerID = Object.keys(game.players).find((key) => game.players[key] === enemy.targetPlayer);
                if (!this.targetPlayerID)
                    this.targetPlayerID = Object.keys(game.offlinePlayers).find((key) => game.offlinePlayers[key] === enemy.targetPlayer);
            }
        }
        if (enemy instanceof pottedPlant_1.PottedPlant)
            this.type = EnemyType.PLANT;
        if (enemy instanceof pot_1.Pot)
            this.type = EnemyType.PLANT;
        if (enemy instanceof skullEnemy_1.SkullEnemy) {
            this.type = EnemyType.SKULL;
            this.ticks = enemy.ticks;
            this.ticksSinceFirstHit = enemy.ticksSinceFirstHit;
            this.seenPlayer = enemy.seenPlayer;
            if (enemy.seenPlayer) {
                this.targetPlayerID = Object.keys(game.players).find((key) => game.players[key] === enemy.targetPlayer);
                if (!this.targetPlayerID)
                    this.targetPlayerID = Object.keys(game.offlinePlayers).find((key) => game.offlinePlayers[key] === enemy.targetPlayer);
            }
        }
        if (enemy instanceof crabEnemy_1.CrabEnemy) {
            this.type = EnemyType.CRAB;
            this.ticks = enemy.ticks;
            this.seenPlayer = enemy.seenPlayer;
            if (enemy.seenPlayer) {
                this.targetPlayerID = Object.keys(game.players).find((key) => game.players[key] === enemy.targetPlayer);
                if (!this.targetPlayerID)
                    this.targetPlayerID = Object.keys(game.offlinePlayers).find((key) => game.offlinePlayers[key] === enemy.targetPlayer);
            }
        }
        if (enemy instanceof spawner_1.Spawner) {
            this.type = EnemyType.SPAWNER;
            this.ticks = enemy.ticks;
            this.seenPlayer = enemy.seenPlayer;
            this.enemySpawnType = enemy.enemySpawnType;
        }
        if (enemy instanceof vendingMachine_1.VendingMachine) {
            this.type = EnemyType.VENDINGMACHINE;
            this.isPlayerOpened = false;
            if (enemy.playerOpened) {
                this.isPlayerOpened = true;
                this.playerOpenedID = Object.keys(game.players).find((key) => game.players[key] === enemy.playerOpened);
                if (!this.playerOpenedID)
                    this.playerOpenedID = Object.keys(game.offlinePlayers).find((key) => game.offlinePlayers[key] === enemy.playerOpened);
            }
            this.open = enemy.open;
            this.costItems = [];
            for (const item of enemy.costItems)
                this.costItems.push(new ItemState(item, game));
            this.item = new ItemState(enemy.item, game);
            this.isInf = enemy.isInf;
            this.quantity = enemy.quantity;
        }
        if (enemy instanceof wizardEnemy_1.WizardEnemy) {
            this.type = EnemyType.WIZARD;
            this.ticks = enemy.ticks;
            this.wizardState = enemy.state;
            this.seenPlayer = enemy.seenPlayer;
        }
        if (enemy instanceof zombieEnemy_1.ZombieEnemy) {
            this.type = EnemyType.ZOMBIE;
            this.ticks = enemy.ticks;
            this.seenPlayer = enemy.seenPlayer;
            if (enemy.seenPlayer) {
                this.targetPlayerID = Object.keys(game.players).find((key) => game.players[key] === enemy.targetPlayer);
                if (!this.targetPlayerID)
                    this.targetPlayerID = Object.keys(game.offlinePlayers).find((key) => game.offlinePlayers[key] === enemy.targetPlayer);
            }
        }
    }
}
exports.EnemyState = EnemyState;
let loadEnemy = (es, game) => {
    let enemy;
    let level = game.rooms[es.levelID];
    if (es.type === EnemyType.BARREL)
        enemy = new barrel_1.Barrel(level, game, es.x, es.y);
    if (es.type === EnemyType.BIGSKULL) {
        enemy = new bigSkullEnemy_1.BigSkullEnemy(level, game, es.x, es.y);
        enemy.ticks = es.ticks;
        enemy.ticksSinceFirstHit = es.ticksSinceFirstHit;
        enemy.seenPlayer = es.seenPlayer;
        if (es.seenPlayer) {
            enemy.targetPlayer = game.players[es.targetPlayerID];
            if (!enemy.targetPlayer)
                enemy.targetPlayer = game.offlinePlayers[es.targetPlayerID];
        }
        enemy.drops = [];
        for (const d of es.drops)
            enemy.drops.push(loadItem(d, game));
    }
    if (es.type === EnemyType.CHARGE) {
        enemy = new chargeEnemy_1.ChargeEnemy(level, game, es.x, es.y);
        enemy.ticks = es.ticks;
        enemy.state = es.chargeEnemyState;
        enemy.startX = es.startX;
        enemy.startY = es.startY;
        enemy.targetX = es.targetX;
        enemy.targetY = es.targetY;
        enemy.visualTargetX = es.visualTargetX;
        enemy.visualTargetY = es.visualTargetY;
    }
    if (es.type === EnemyType.CHEST)
        enemy = new chest_1.Chest(level, game, es.x, es.y);
    if (es.type === EnemyType.COAL)
        enemy = new coalResource_1.CoalResource(level, game, es.x, es.y);
    if (es.type === EnemyType.CRATE)
        enemy = new crate_1.Crate(level, game, es.x, es.y);
    if (es.type === EnemyType.EMERALD)
        enemy = new emeraldResource_1.EmeraldResource(level, game, es.x, es.y);
    if (es.type === EnemyType.GOLD)
        enemy = new goldResource_1.GoldResource(level, game, es.x, es.y);
    if (es.type === EnemyType.KNIGHT) {
        enemy = new knightEnemy_1.KnightEnemy(level, game, es.x, es.y);
        enemy.ticks = es.ticks;
        enemy.seenPlayer = es.seenPlayer;
        if (es.seenPlayer) {
            enemy.targetPlayer = game.players[es.targetPlayerID];
            if (!enemy.targetPlayer)
                enemy.targetPlayer = game.offlinePlayers[es.targetPlayerID];
        }
    }
    if (es.type === EnemyType.PLANT)
        enemy = new pottedPlant_1.PottedPlant(level, game, es.x, es.y);
    if (es.type === EnemyType.PLANT)
        enemy = new pot_1.Pot(level, game, es.x, es.y);
    if (es.type === EnemyType.SKULL) {
        enemy = new skullEnemy_1.SkullEnemy(level, game, es.x, es.y);
        enemy.ticks = es.ticks;
        enemy.ticksSinceFirstHit = es.ticksSinceFirstHit;
        enemy.seenPlayer = es.seenPlayer;
        if (es.seenPlayer) {
            enemy.targetPlayer = game.players[es.targetPlayerID];
            if (!enemy.targetPlayer)
                enemy.targetPlayer = game.offlinePlayers[es.targetPlayerID];
        }
    }
    if (es.type === EnemyType.CRAB) {
        enemy = new crabEnemy_1.CrabEnemy(level, game, es.x, es.y);
        enemy.ticks = es.ticks;
        enemy.seenPlayer = es.seenPlayer;
        if (es.seenPlayer) {
            enemy.targetPlayer = game.players[es.targetPlayerID];
            if (!enemy.targetPlayer)
                enemy.targetPlayer = game.offlinePlayers[es.targetPlayerID];
        }
    }
    if (es.type === EnemyType.SPAWNER) {
        enemy = new spawner_1.Spawner(level, game, es.x, es.y, [es.enemySpawnType]);
        enemy.ticks = es.ticks;
        enemy.seenPlayer = es.seenPlayer;
        enemy.enemySpawnType = es.enemySpawnType;
    }
    if (es.type === EnemyType.VENDINGMACHINE) {
        let item = loadItem(es.item, game);
        enemy = new vendingMachine_1.VendingMachine(level, game, es.x, es.y, item);
        if (es.isPlayerOpened) {
            enemy.playerOpened = game.players[es.playerOpenedID];
            if (!enemy.playerOpened)
                enemy.playerOpened = game.offlinePlayers[es.playerOpenedID];
        }
        enemy.open = es.open;
        enemy.costItems = [];
        for (const item of es.costItems)
            enemy.costItems.push(loadItem(item, game));
        enemy.isInf = es.isInf;
        enemy.quantity = es.quantity;
    }
    if (es.type === EnemyType.WIZARD) {
        enemy = new energyWizard_1.EnergyWizardEnemy(level, game, es.x, es.y);
        enemy.ticks = es.ticks;
        enemy.state = es.wizardState;
        enemy.seenPlayer = es.seenPlayer;
    }
    if (es.type === EnemyType.ZOMBIE) {
        enemy = new zombieEnemy_1.ZombieEnemy(level, game, es.x, es.y);
        enemy.ticks = es.ticks;
        enemy.seenPlayer = es.seenPlayer;
        if (es.seenPlayer) {
            enemy.targetPlayer = game.players[es.targetPlayerID];
            if (!enemy.targetPlayer)
                enemy.targetPlayer = game.offlinePlayers[es.targetPlayerID];
        }
    }
    enemy.x = es.x;
    enemy.y = es.y;
    enemy.health = es.health;
    enemy.direction = es.direction;
    enemy.dead = es.dead;
    enemy.skipNextTurns = es.skipNextTurns;
    if (es.hasDrop)
        enemy.drop = loadItem(es.drop, game);
    enemy.alertTicks = es.alertTicks;
    return enemy;
};
class LevelState {
    constructor(level, game) {
        this.levelID = game.rooms.indexOf(level);
        this.entered = level.entered;
        this.enemies = [];
        this.items = [];
        this.projectiles = [];
        this.hitwarnings = [];
        for (const enemy of level.entities)
            this.enemies.push(new EnemyState(enemy, game));
        for (const item of level.items)
            this.items.push(new ItemState(item, game));
        for (const projectile of level.projectiles)
            this.projectiles.push(new ProjectileState(projectile, game));
        for (const hw of level.hitwarnings)
            this.hitwarnings.push(new HitWarningState(hw));
    }
}
exports.LevelState = LevelState;
let loadLevel = (level, levelState, game) => {
    level.entered = levelState.entered;
    level.entities = [];
    level.items = [];
    level.projectiles = [];
    level.hitwarnings = [];
    for (const enemy of levelState.enemies)
        level.entities.push(loadEnemy(enemy, game));
    for (const item of levelState.items)
        level.items.push(loadItem(item, game));
    for (const projectile of levelState.projectiles)
        level.projectiles.push(loadProjectile(projectile, game));
    for (const hw of levelState.hitwarnings)
        level.hitwarnings.push(loadHitWarning(hw, game));
};
//use the other one
var ItemType;
(function (ItemType) {
    ItemType[ItemType["ARMOR"] = 0] = "ARMOR";
    ItemType[ItemType["BLUEGEM"] = 1] = "BLUEGEM";
    ItemType[ItemType["CANDLE"] = 2] = "CANDLE";
    ItemType[ItemType["COAL"] = 3] = "COAL";
    ItemType[ItemType["COIN"] = 4] = "COIN";
    ItemType[ItemType["GOLD"] = 5] = "GOLD";
    ItemType[ItemType["GOLDENKEY"] = 6] = "GOLDENKEY";
    ItemType[ItemType["GREENGEM"] = 7] = "GREENGEM";
    ItemType[ItemType["KEY"] = 8] = "KEY";
    ItemType[ItemType["LANTERN"] = 9] = "LANTERN";
    ItemType[ItemType["REDGEM"] = 10] = "REDGEM";
    ItemType[ItemType["TORCH"] = 11] = "TORCH";
    ItemType[ItemType["DAGGER"] = 12] = "DAGGER";
    ItemType[ItemType["DUALDAGGER"] = 13] = "DUALDAGGER";
    ItemType[ItemType["SHOTGUN"] = 14] = "SHOTGUN";
    ItemType[ItemType["SPEAR"] = 15] = "SPEAR";
    ItemType[ItemType["PICKAXE"] = 16] = "PICKAXE";
    ItemType[ItemType["BACKPACK"] = 17] = "BACKPACK";
    ItemType[ItemType["SPELLBOOK"] = 18] = "SPELLBOOK";
    ItemType[ItemType["WEAPON_FRAGMENTS"] = 19] = "WEAPON_FRAGMENTS";
    ItemType[ItemType["WARHAMMER"] = 20] = "WARHAMMER";
    ItemType[ItemType["HAMMER"] = 21] = "HAMMER";
    ItemType[ItemType["WEAPON_POISON"] = 22] = "WEAPON_POISON";
    ItemType[ItemType["WEAPON_BLOOD"] = 23] = "WEAPON_BLOOD";
    ItemType[ItemType["HEART"] = 24] = "HEART";
    ItemType[ItemType["MUSHROOMS"] = 25] = "MUSHROOMS";
    ItemType[ItemType["STONE"] = 26] = "STONE";
    ItemType[ItemType["BLUE_POTION"] = 27] = "BLUE_POTION";
})(ItemType = exports.ItemType || (exports.ItemType = {}));
class ItemState {
    constructor(item, game) {
        if (item instanceof armor_1.Armor)
            this.type = ItemType.ARMOR;
        if (item instanceof bluegem_1.BlueGem)
            this.type = ItemType.BLUEGEM;
        if (item instanceof candle_1.Candle)
            this.type = ItemType.CANDLE;
        if (item instanceof coal_1.Coal)
            this.type = ItemType.COAL;
        if (item instanceof coin_1.Coin)
            this.type = ItemType.COIN;
        if (item instanceof gold_1.Gold)
            this.type = ItemType.GOLD;
        if (item instanceof goldenKey_1.GoldenKey)
            this.type = ItemType.GOLDENKEY;
        if (item instanceof greengem_1.GreenGem)
            this.type = ItemType.GREENGEM;
        if (item instanceof heart_1.Heart)
            this.type = ItemType.HEART;
        if (item instanceof key_1.Key)
            this.type = ItemType.KEY;
        if (item instanceof lantern_1.Lantern)
            this.type = ItemType.LANTERN;
        if (item instanceof redgem_1.RedGem)
            this.type = ItemType.REDGEM;
        if (item instanceof torch_1.Torch)
            this.type = ItemType.TORCH;
        if (item instanceof dagger_1.Dagger)
            this.type = ItemType.DAGGER;
        if (item instanceof dualdagger_1.DualDagger)
            this.type = ItemType.DUALDAGGER;
        if (item instanceof shotgun_1.Shotgun)
            this.type = ItemType.SHOTGUN;
        if (item instanceof spear_1.Spear)
            this.type = ItemType.SPEAR;
        if (item instanceof pickaxe_1.Pickaxe)
            this.type = ItemType.PICKAXE;
        if (item instanceof backpack_1.Backpack)
            this.type = ItemType.BACKPACK;
        this.equipped = item instanceof equippable_1.Equippable && item.equipped;
        this.x = item.x;
        this.y = item.y;
        this.levelID = game.rooms.indexOf(item.level);
        if (this.levelID === -1)
            this.levelID = 0;
        this.stackCount = item.stackCount;
        this.pickedUp = item.pickedUp;
    }
}
exports.ItemState = ItemState;
let loadItem = (i, game, player) => {
    let level = game.rooms[i.levelID];
    let item;
    if (i.type === ItemType.ARMOR)
        item = new armor_1.Armor(level, i.x, i.y);
    if (i.type === ItemType.BLUEGEM)
        item = new bluegem_1.BlueGem(level, i.x, i.y);
    if (i.type === ItemType.CANDLE)
        item = new candle_1.Candle(level, i.x, i.y);
    if (i.type === ItemType.COAL)
        item = new coal_1.Coal(level, i.x, i.y);
    if (i.type === ItemType.COIN)
        item = new coin_1.Coin(level, i.x, i.y);
    if (i.type === ItemType.GOLD)
        item = new gold_1.Gold(level, i.x, i.y);
    if (i.type === ItemType.GOLDENKEY)
        item = new goldenKey_1.GoldenKey(level, i.x, i.y);
    if (i.type === ItemType.GREENGEM)
        item = new greengem_1.GreenGem(level, i.x, i.y);
    if (i.type === ItemType.HEART)
        item = new heart_1.Heart(level, i.x, i.y);
    if (i.type === ItemType.KEY)
        item = new key_1.Key(level, i.x, i.y);
    if (i.type === ItemType.LANTERN)
        item = new lantern_1.Lantern(level, i.x, i.y);
    if (i.type === ItemType.REDGEM)
        item = new redgem_1.RedGem(level, i.x, i.y);
    if (i.type === ItemType.TORCH)
        item = new torch_1.Torch(level, i.x, i.y);
    if (i.type === ItemType.DAGGER) {
        item = new dagger_1.Dagger(level, i.x, i.y);
    }
    if (i.type === ItemType.DUALDAGGER) {
        item = new dualdagger_1.DualDagger(level, i.x, i.y);
    }
    if (i.type === ItemType.SHOTGUN) {
        item = new shotgun_1.Shotgun(level, i.x, i.y);
    }
    if (i.type === ItemType.SPEAR) {
        item = new spear_1.Spear(level, i.x, i.y);
    }
    if (i.type === ItemType.PICKAXE) {
        item = new pickaxe_1.Pickaxe(level, i.x, i.y);
    }
    if (i.type === ItemType.BACKPACK) {
        item = new backpack_1.Backpack(level, i.x, i.y);
    }
    if (i.equipped)
        item.equipped = true;
    if (item instanceof equippable_1.Equippable)
        item.setWielder(player);
    item.stackCount = i.stackCount;
    item.pickedUp = i.pickedUp;
    return item;
};
class InventoryState {
    constructor(inventory, game) {
        this.isOpen = inventory.isOpen;
        this.cols = inventory.cols;
        this.rows = inventory.rows;
        this.equipAnimAmount = inventory.equipAnimAmount.map((x) => x);
        this.isWeaponEquipped = false;
        if (inventory.weapon) {
            this.isWeaponEquipped = true;
            this.weaponI = inventory.items.indexOf(inventory.weapon);
        }
        this.coins = inventory.coins;
        this.selX = inventory.selX;
        this.selY = inventory.selY;
        this.items = Array();
        for (const item of inventory.items) {
            this.items.push(new ItemState(item, game));
        }
    }
}
exports.InventoryState = InventoryState;
let loadInventory = (inventory, i, game) => {
    inventory.clear();
    inventory.isOpen = i.isOpen;
    inventory.cols = i.cols;
    inventory.rows = i.rows;
    inventory.selX = i.selX;
    inventory.selY = i.selY;
    inventory.equipAnimAmount = i.equipAnimAmount.map((x) => x);
    inventory.coins = i.coins;
    for (const item of i.items)
        inventory.items.push(loadItem(item, game, inventory.player));
    if (i.isWeaponEquipped)
        inventory.weapon = inventory.items[i.weaponI];
};
class PlayerState {
    constructor(player, game) {
        this.x = player.x;
        this.y = player.y;
        this.dead = player.dead;
        this.levelID = player.levelID;
        this.direction = player.direction;
        this.health = player.health;
        this.maxHealth = player.maxHealth;
        this.lastTickHealth = player.lastTickHealth;
        this.inventory = new InventoryState(player.inventory, game);
        this.hasOpenVendingMachine = false;
        if (player.openVendingMachine) {
            this.hasOpenVendingMachine = true;
            this.openVendingMachineLevelID = game.rooms.indexOf(player.openVendingMachine.room);
            this.openVendingMachineID =
                player.openVendingMachine.room.entities.indexOf(player.openVendingMachine);
        }
        this.sightRadius = player.sightRadius;
    }
}
exports.PlayerState = PlayerState;
let loadPlayer = (id, p, game) => {
    let player = new player_1.Player(game, p.x, p.y, id === game.localPlayerID);
    player.dead = p.dead;
    player.levelID = p.levelID;
    if (player.levelID < game.levelgen.currentFloorFirstLevelID) {
        // catch up to the current level
        player.levelID = game.levelgen.currentFloorFirstLevelID;
        player.x =
            game.rooms[player.levelID].roomX +
                Math.floor(game.rooms[player.levelID].width / 2);
        player.y =
            game.rooms[player.levelID].roomY +
                Math.floor(game.rooms[player.levelID].height / 2);
    }
    player.direction = p.direction;
    player.health = p.health;
    player.maxHealth = p.maxHealth;
    player.lastTickHealth = p.lastTickHealth;
    loadInventory(player.inventory, p.inventory, game);
    if (p.hasOpenVendingMachine) {
        player.openVendingMachine = game.rooms[p.openVendingMachineLevelID]
            .entities[p.openVendingMachineID];
    }
    player.sightRadius = p.sightRadius;
    return player;
};
class GameState {
    constructor() {
        this.seed = 0;
        this.randomState = 0;
        this.depth = 0;
        this.players = {};
        this.offlinePlayers = {};
        this.levels = [];
    }
}
exports.GameState = GameState;
const createGameState = (game) => {
    let gs = new GameState();
    gs.seed = game.levelgen.seed; // random state for generating levels
    gs.randomState = random_1.Random.state; // current random state
    gs.depth = game.level.depth;
    for (const i in game.players)
        gs.players[i] = new PlayerState(game.players[i], game);
    for (const i in game.offlinePlayers) {
        gs.offlinePlayers[i] = new PlayerState(game.offlinePlayers[i], game);
    }
    for (let level of game.rooms) {
        level.catchUp();
        gs.levels.push(new LevelState(level, game));
    }
    return gs;
};
exports.createGameState = createGameState;
const loadGameState = (game, activeUsernames, gameState, newWorld) => {
    game.rooms = Array();
    game.levelgen = new levelGenerator_1.LevelGenerator();
    game.levelgen.setSeed(gameState.seed);
    if (newWorld)
        gameState.depth = 0;
    eventBus_1.globalEventBus.emit(events_1.EVENTS.LEVEL_GENERATION_STARTED, {});
    game.levelgen.generateFirstNFloors(game, gameState.depth).then(() => {
        eventBus_1.globalEventBus.emit(events_1.EVENTS.LEVEL_GENERATION_COMPLETED, {});
        if (!newWorld) {
            if (gameState.players) {
                for (const i in gameState.players) {
                    if (activeUsernames.includes(i))
                        game.players[i] = loadPlayer(i, gameState.players[i], game);
                    else
                        game.offlinePlayers[i] = loadPlayer(i, gameState.players[i], game);
                }
            }
            if (gameState.offlinePlayers) {
                for (const i in gameState.offlinePlayers) {
                    if (i === game.localPlayerID)
                        game.players[i] = loadPlayer(i, gameState.offlinePlayers[i], game);
                    else if (activeUsernames.includes(i))
                        game.players[i] = loadPlayer(i, gameState.offlinePlayers[i], game);
                    else
                        game.offlinePlayers[i] = loadPlayer(i, gameState.offlinePlayers[i], game);
                }
            }
            for (let levelState of gameState.levels) {
                for (let i = 0; i < game.rooms.length; i++) {
                    if (i === levelState.levelID) {
                        loadLevel(game.rooms[i], levelState, game);
                    }
                }
            }
            if (!(game.localPlayerID in gameState.players) &&
                !(game.localPlayerID in gameState.offlinePlayers)) {
                // we're not in the gamestate, create a new player
                game.players[game.localPlayerID] = new player_1.Player(game, 0, 0, true);
                game.players[game.localPlayerID].levelID =
                    game.levelgen.currentFloorFirstLevelID;
                game.players[game.localPlayerID].x =
                    game.rooms[game.levelgen.currentFloorFirstLevelID].roomX +
                        Math.floor(game.rooms[game.levelgen.currentFloorFirstLevelID].width / 2);
                game.players[game.localPlayerID].y =
                    game.rooms[game.levelgen.currentFloorFirstLevelID].roomY +
                        Math.floor(game.rooms[game.levelgen.currentFloorFirstLevelID].height / 2);
                game.room = game.rooms[game.levelgen.currentFloorFirstLevelID];
                game.room.enterLevel(game.players[game.localPlayerID]);
            }
            else {
                game.room = game.rooms[game.players[game.localPlayerID].levelID];
            }
        }
        else {
            // stub game state, start a new world
            game.players[game.localPlayerID] = new player_1.Player(game, 0, 0, true);
            game.room = game.rooms[game.players[game.localPlayerID].levelID];
            game.room.enterLevel(game.players[game.localPlayerID]);
        }
        random_1.Random.setState(gameState.randomState);
        game.room.updateLighting();
        let p = game.players[game.localPlayerID];
        game.room.items.push(new key_1.Key(game.room, p.x - 1, p.y + 1));
        //choose one door to lock
        let locked = false;
        game.room.doors.forEach((door) => {
            if (!locked) {
                door.lock();
                locked = true;
            }
        });
        game.chat = [];
    });
};
exports.loadGameState = loadGameState;


/***/ }),

/***/ "./src/guiButton.ts":
/*!**************************!*\
  !*** ./src/guiButton.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.guiButton = void 0;
class guiButton {
    constructor(x, y, width, height, text, onClick, toggleable = false) {
        this.toggleable = toggleable;
        this.toggled = false;
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
        this.text = text;
        this.onClick = onClick;
    }
}
exports.guiButton = guiButton;


/***/ }),

/***/ "./src/healthbar.ts":
/*!**************************!*\
  !*** ./src/healthbar.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HealthBar = void 0;
const game_1 = __webpack_require__(/*! ./game */ "./src/game.ts");
const levelConstants_1 = __webpack_require__(/*! ./levelConstants */ "./src/levelConstants.ts");
class HealthBar {
    constructor() {
        this.hurt = () => {
            this.hurtTimer = Date.now();
        };
        this.draw = (delta, hearts, maxHearts, x, y, flashing) => {
            let t = Date.now() - this.hurtTimer;
            if (t <= levelConstants_1.LevelConstants.HEALTH_BAR_TOTALTIME) {
                let fullHearts = Math.floor(hearts);
                let halfHearts = Math.ceil(hearts - fullHearts);
                let emptyHearts = maxHearts - fullHearts - halfHearts;
                // I wouldn't normally use magic numbers here, but these are hardcoded based on the tileset
                //   (which isn't really parameterizable)
                let drawWidth = Math.round(Math.min(9, Math.min(0.05 * (levelConstants_1.LevelConstants.HEALTH_BAR_TOTALTIME - t), 0.05 * t)));
                let drawHeight = Math.round(Math.min(0.5, Math.min(0.003 * (levelConstants_1.LevelConstants.HEALTH_BAR_TOTALTIME - t), 0.003 * t)) * 16) / 16.0;
                let width = (drawWidth * (maxHearts - 1) + 8) / 16.0;
                let xxStart = 0.5 + -width / 2;
                for (let i = 0; i < Math.ceil(0.5 * maxHearts); i++) {
                    let tileX = 0;
                    if (!flashing)
                        tileX = 1.5;
                    else if (i < fullHearts)
                        tileX = 0;
                    else if (i < fullHearts + halfHearts)
                        tileX = 0.5;
                    else
                        tileX = 1;
                    let xx = (drawWidth * i) / 16.0 + xxStart;
                    game_1.Game.drawFX(tileX, 8, 0.5, 0.5, x + xx, y - 1 - drawHeight / 2, 0.5, drawHeight);
                    xx += 9.0 / 16.0;
                    let j = maxHearts - i - 1;
                    if (j !== i) {
                        let tileX = 0;
                        if (!flashing)
                            tileX = 1.5;
                        else if (j < fullHearts)
                            tileX = 0;
                        else if (j < fullHearts + halfHearts)
                            tileX = 0.5;
                        else
                            tileX = 1;
                        let xx = (drawWidth * j) / 16.0 + xxStart;
                        game_1.Game.drawFX(tileX, 8, 0.5, 0.5, x + xx, y - 1 - drawHeight / 2, 0.5, drawHeight);
                        xx += 9.0 / 16.0;
                    }
                }
            }
        };
        this.hurtTimer = 0;
    }
}
exports.HealthBar = HealthBar;


/***/ }),

/***/ "./src/hitWarning.ts":
/*!***************************!*\
  !*** ./src/hitWarning.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HitWarning = void 0;
const game_1 = __webpack_require__(/*! ./game */ "./src/game.ts");
const drawable_1 = __webpack_require__(/*! ./drawable */ "./src/drawable.ts");
const utils_1 = __webpack_require__(/*! ./utils */ "./src/utils.ts");
var Direction;
(function (Direction) {
    Direction[Direction["North"] = 0] = "North";
    Direction[Direction["NorthEast"] = 1] = "NorthEast";
    Direction[Direction["East"] = 2] = "East";
    Direction[Direction["SouthEast"] = 3] = "SouthEast";
    Direction[Direction["South"] = 4] = "South";
    Direction[Direction["SouthWest"] = 5] = "SouthWest";
    Direction[Direction["West"] = 6] = "West";
    Direction[Direction["NorthWest"] = 7] = "NorthWest";
    Direction[Direction["Center"] = 8] = "Center";
})(Direction || (Direction = {}));
class HitWarning extends drawable_1.Drawable {
    constructor(game, x, y, eX, eY, isEnemy, dirOnly = false, parent = null) {
        super();
        this.parent = null;
        this._pointerDir = null;
        this._pointerOffset = null;
        this.alpha = 0;
        this.tickedForDeath = false;
        this.tick = () => {
            if (this.tickedForDeath)
                this.dead = true;
            this.tickedForDeath = true;
        };
        this.removeOverlapping = () => {
            for (const entity of this.game.room.entities) {
                if (entity.x === this.x &&
                    entity.y === this.y &&
                    entity.pushable === false) {
                    this.dead = true;
                    break;
                }
            }
            for (const door of this.game.room.doors) {
                if (door.x === this.x && door.y === this.y) {
                    this.dead = true;
                    break;
                }
            }
        };
        this.fadeHitwarnings = (delta) => {
            if (!this.tickedForDeath) {
                if (this.alpha < 1)
                    this.alpha += 0.03 * delta;
                if (this.alpha > 1)
                    this.alpha = 1;
            }
            else {
                if (this.alpha > 0)
                    this.alpha -= 0.03 * delta;
                if (this.alpha < 0)
                    this.alpha = 0;
            }
        };
        this.draw = (delta) => {
            this.fadeHitwarnings(delta);
            if (Math.abs(this.x - this.game.players[this.game.localPlayerID].x) <= 1 &&
                Math.abs(this.y - this.game.players[this.game.localPlayerID].y) <= 1) {
                game_1.Game.ctx.globalAlpha = this.alpha;
                if (this.isEnemy &&
                    utils_1.Utils.distance(this.x, this.y, this.game.players[this.game.localPlayerID].x, this.game.players[this.game.localPlayerID].y) <= 1) {
                    // Red Arrow that only renders one square away
                    game_1.Game.drawFX(this.tileX + Math.floor(HitWarning.frame), this.tileY, 1, 1, this.x + this.pointerOffset.x, this.y + this.pointerOffset.y - this.offsetY, 1, 1);
                }
                if (false) {}
                game_1.Game.ctx.globalAlpha = 1;
            }
        };
        this.drawTopLayer = (delta) => {
            this.fadeHitwarnings(delta);
            game_1.Game.ctx.globalAlpha = this.alpha;
            if (this.isEnemy && this.getPointerDir() !== Direction.North) {
                //white arrow top layer
                game_1.Game.drawFX(this.tileX + Math.floor(HitWarning.frame), this.tileY + 1, 1, 1, this.x + this.pointerOffset.x, this.y + this.pointerOffset.y - this.offsetY, 1, 1);
            }
            if (utils_1.Utils.distance(this.x, this.y, this.game.players[this.game.localPlayerID].x, this.game.players[this.game.localPlayerID].y) <= 1) {
                if (!this.dirOnly) {
                    // Red X that renders 1 square away for top layer
                    game_1.Game.drawFX(18 + Math.floor(HitWarning.frame), 6, 1, 1, this.x, this.y - this.offsetY + 0, 1, 1);
                }
            }
            game_1.Game.ctx.globalAlpha = 1;
        };
        this.x = x;
        this.y = y;
        this.dead = false;
        this.game = game;
        this.parent = parent;
        this.tileX = 0;
        this.tileY = 22;
        this.eX = eX;
        this.eY = eY;
        this.offsetY = 0.2;
        this.dirOnly = dirOnly;
        this.isEnemy = isEnemy !== undefined ? isEnemy : true;
        this.pointerOffset = this.getPointerOffset();
        this.removeOverlapping();
    }
    getPointerDir() {
        if (this._pointerDir === null) {
            const dx = this.eX - this.x;
            const dy = this.eY - this.y;
            if (dx === 0 && dy === 0) {
                this._pointerDir = Direction.Center;
            }
            else if (dx === 0) {
                this._pointerDir = dy < 0 ? Direction.South : Direction.North;
            }
            else if (dy === 0) {
                this._pointerDir = dx < 0 ? Direction.East : Direction.West;
            }
            else if (dx < 0) {
                this._pointerDir = dy < 0 ? Direction.SouthEast : Direction.NorthEast;
            }
            else {
                this._pointerDir = dy < 0 ? Direction.SouthWest : Direction.NorthWest;
            }
            this.tileX = 0 + 2 * this._pointerDir;
        }
        return this._pointerDir;
    }
    getPointerOffset() {
        if (this._pointerOffset === null) {
            const offsets = {
                [Direction.North]: { x: 0, y: 0.5 },
                [Direction.South]: { x: 0, y: -0.6 },
                [Direction.West]: { x: 0.6, y: 0 },
                [Direction.East]: { x: -0.6, y: 0 },
                [Direction.NorthEast]: { x: -0.5, y: 0.5 },
                [Direction.NorthWest]: { x: 0.5, y: 0.5 },
                [Direction.SouthEast]: { x: -0.5, y: -0.5 },
                [Direction.SouthWest]: { x: 0.5, y: -0.5 },
                [Direction.Center]: { x: 0, y: -0.25 },
            };
            this._pointerOffset = offsets[this.getPointerDir()];
        }
        return this._pointerOffset;
    }
}
exports.HitWarning = HitWarning;
HitWarning.frame = 0;
HitWarning.updateFrame = (delta) => {
    HitWarning.frame += 0.125 * delta;
    if (HitWarning.frame >= 2)
        HitWarning.frame = 0;
};


/***/ }),

/***/ "./src/input.ts":
/*!**********************!*\
  !*** ./src/input.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Input = exports.InputEnum = void 0;
const gameConstants_1 = __webpack_require__(/*! ./gameConstants */ "./src/gameConstants.ts");
const game_1 = __webpack_require__(/*! ./game */ "./src/game.ts");
const mouseCursor_1 = __webpack_require__(/*! ./mouseCursor */ "./src/mouseCursor.ts");
var InputEnum;
(function (InputEnum) {
    InputEnum[InputEnum["I"] = 0] = "I";
    InputEnum[InputEnum["M"] = 1] = "M";
    InputEnum[InputEnum["M_UP"] = 2] = "M_UP";
    InputEnum[InputEnum["Q"] = 3] = "Q";
    InputEnum[InputEnum["LEFT"] = 4] = "LEFT";
    InputEnum[InputEnum["RIGHT"] = 5] = "RIGHT";
    InputEnum[InputEnum["UP"] = 6] = "UP";
    InputEnum[InputEnum["DOWN"] = 7] = "DOWN";
    InputEnum[InputEnum["SPACE"] = 8] = "SPACE";
    InputEnum[InputEnum["COMMA"] = 9] = "COMMA";
    InputEnum[InputEnum["PERIOD"] = 10] = "PERIOD";
    InputEnum[InputEnum["LEFT_CLICK"] = 11] = "LEFT_CLICK";
    InputEnum[InputEnum["RIGHT_CLICK"] = 12] = "RIGHT_CLICK";
    InputEnum[InputEnum["MOUSE_MOVE"] = 13] = "MOUSE_MOVE";
    InputEnum[InputEnum["NUMBER_1"] = 14] = "NUMBER_1";
    InputEnum[InputEnum["NUMBER_2"] = 15] = "NUMBER_2";
    InputEnum[InputEnum["NUMBER_3"] = 16] = "NUMBER_3";
    InputEnum[InputEnum["NUMBER_4"] = 17] = "NUMBER_4";
    InputEnum[InputEnum["NUMBER_5"] = 18] = "NUMBER_5";
    InputEnum[InputEnum["NUMBER_6"] = 19] = "NUMBER_6";
    InputEnum[InputEnum["NUMBER_7"] = 20] = "NUMBER_7";
    InputEnum[InputEnum["NUMBER_8"] = 21] = "NUMBER_8";
    InputEnum[InputEnum["NUMBER_9"] = 22] = "NUMBER_9";
    InputEnum[InputEnum["MINUS"] = 23] = "MINUS";
    InputEnum[InputEnum["EQUALS"] = 24] = "EQUALS";
    InputEnum[InputEnum["ESCAPE"] = 25] = "ESCAPE";
})(InputEnum = exports.InputEnum || (exports.InputEnum = {}));
exports.Input = {
    _pressed: {},
    isTapHold: false,
    tapStartTime: null,
    IS_TAP_HOLD_THRESH: 300,
    keyDownListener: function (key) { },
    iListener: function () { },
    mListener: function () { },
    mUpListener: function () { },
    qListener: function () { },
    leftListener: function () { },
    rightListener: function () { },
    upListener: function () { },
    downListener: function () { },
    aListener: function () {
        exports.Input.leftListener();
    },
    dListener: function () {
        exports.Input.rightListener();
    },
    wListener: function () {
        exports.Input.upListener();
    },
    sListener: function () {
        exports.Input.downListener();
    },
    spaceListener: function () { },
    leftSwipeListener: function () { },
    rightSwipeListener: function () { },
    upSwipeListener: function () { },
    downSwipeListener: function () { },
    tapListener: function () { },
    commaListener: function () { },
    periodListener: function () { },
    numKeyListener: function (num) { },
    equalsListener: function () { },
    minusListener: function () { },
    escapeListener: function () { },
    mouseLeftClickListeners: [],
    mouseRightClickListeners: [],
    mouseMoveListeners: [],
    mouseDownListeners: [],
    mouseUpListeners: [],
    touchStartListeners: [],
    touchEndListeners: [],
    mouseX: 0,
    mouseY: 0,
    mouseDown: false,
    lastPressTime: 0,
    lastPressKey: "",
    SPACE: "Space",
    LEFT: "ArrowLeft",
    UP: "ArrowUp",
    RIGHT: "ArrowRight",
    DOWN: "ArrowDown",
    W: "KeyW",
    A: "KeyA",
    S: "KeyS",
    D: "KeyD",
    M: "KeyM",
    N: "KeyN",
    I: "KeyI",
    Q: "KeyQ",
    NUMBER_1: "Digit1",
    NUMBER_2: "Digit2",
    NUMBER_3: "Digit3",
    NUMBER_4: "Digit4",
    NUMBER_5: "Digit5",
    NUMBER_6: "Digit6",
    NUMBER_7: "Digit7",
    NUMBER_8: "Digit8",
    NUMBER_9: "Digit9",
    COMMA: "Comma",
    PERIOD: "Period",
    MINUS: "Minus",
    EQUALS: "Equal",
    ESCAPE: "Escape",
    isDown: function (keyCode) {
        return this._pressed[keyCode];
    },
    onKeydown: (event) => {
        if (event.repeat)
            return; // ignore repeat keypresses
        if (event.key)
            exports.Input.keyDownListener(event.key);
        if (event.cancelable && event.key != "F12" && event.key != "F5")
            event.preventDefault();
        exports.Input.lastPressTime = Date.now();
        exports.Input.lastPressKey = event.key;
        exports.Input._pressed[event.code] = true;
        switch (event.code) {
            case exports.Input.LEFT:
                exports.Input.leftListener();
                break;
            case exports.Input.A:
                exports.Input.aListener();
                break;
            case exports.Input.RIGHT:
                exports.Input.rightListener();
                break;
            case exports.Input.D:
                exports.Input.dListener();
                break;
            case exports.Input.UP:
                exports.Input.upListener();
                break;
            case exports.Input.W:
                exports.Input.wListener();
                break;
            case exports.Input.DOWN:
                exports.Input.downListener();
                break;
            case exports.Input.S:
                exports.Input.sListener();
                break;
            case exports.Input.SPACE:
                exports.Input.spaceListener();
                break;
            case exports.Input.M:
                exports.Input.mListener();
                break;
            case exports.Input.I:
                exports.Input.iListener();
                break;
            case exports.Input.Q:
                exports.Input.qListener();
                break;
            case exports.Input.COMMA:
                exports.Input.commaListener();
                break;
            case exports.Input.PERIOD:
                exports.Input.periodListener();
                break;
            case exports.Input.NUMBER_1:
            case exports.Input.NUMBER_2:
            case exports.Input.NUMBER_3:
            case exports.Input.NUMBER_4:
            case exports.Input.NUMBER_5:
            case exports.Input.NUMBER_6:
            case exports.Input.NUMBER_7:
            case exports.Input.NUMBER_8:
            case exports.Input.NUMBER_9:
                exports.Input.numKeyListener(parseInt(event.code.slice(-1)));
                break;
            case exports.Input.EQUALS:
                exports.Input.equalsListener();
                break;
            case exports.Input.MINUS:
                exports.Input.minusListener();
                break;
            case exports.Input.ESCAPE:
                exports.Input.escapeListener();
                break;
        }
    },
    onKeyup: function (event) {
        delete this._pressed[event.code];
        if (event.key === this.lastPressKey) {
            this.lastPressTime = 0;
            this.lastPressKey = 0;
        }
        if (event.code === exports.Input.M)
            exports.Input.mUpListener();
    },
    mouseLeftClickListener: function (x, y) {
        for (let i = 0; i < exports.Input.mouseLeftClickListeners.length; i++)
            exports.Input.mouseLeftClickListeners[i](x, y);
    },
    mouseRightClickListener: function (x, y) {
        for (let i = 0; i < exports.Input.mouseRightClickListeners.length; i++)
            exports.Input.mouseRightClickListeners[i](x, y);
    },
    mouseMoveListener: function (x, y) {
        for (let i = 0; i < exports.Input.mouseMoveListeners.length; i++)
            exports.Input.mouseMoveListeners[i](x, y);
    },
    mouseDownListener: function (x, y, button) {
        for (let i = 0; i < exports.Input.mouseDownListeners.length; i++)
            exports.Input.mouseDownListeners[i](x, y, button);
    },
    mouseUpListener: function (x, y, button) {
        for (let i = 0; i < exports.Input.mouseUpListeners.length; i++)
            exports.Input.mouseUpListeners[i](x, y, button);
    },
    mouseClickListener: function (event) {
        if (event.button === 0 || event.button === 2) {
            let rect = window.document
                .getElementById("gameCanvas")
                .getBoundingClientRect();
            let x = event.clientX - rect.left;
            let y = event.clientY - rect.top;
            let scaledX = Math.floor(x / game_1.Game.scale);
            let scaledY = Math.floor(y / game_1.Game.scale);
            if (event.button === 0) {
                exports.Input.mouseLeftClickListener(scaledX, scaledY);
            }
            else if (event.button === 2) {
                exports.Input.mouseRightClickListener(scaledX, scaledY);
            }
        }
    },
    updateMousePos: function (event) {
        game_1.Game.inputReceived = true;
        let rect = window.document
            .getElementById("gameCanvas")
            .getBoundingClientRect();
        let x = event.clientX - rect.left;
        let y = event.clientY - rect.top;
        exports.Input.mouseX = Math.floor(x / game_1.Game.scale);
        exports.Input.mouseY = Math.floor(y / game_1.Game.scale);
        exports.Input.mouseMoveListener(exports.Input.mouseX, exports.Input.mouseY);
    },
    handleMouseDown: function (event) {
        if (exports.Input.mouseDown)
            return; // Prevent multiple triggers
        mouseCursor_1.MouseCursor.getInstance().startClickAnim();
        exports.Input.mouseDown = true;
        exports.Input.mouseDownStartTime = Date.now();
        exports.Input.isMouseHold = false;
        exports.Input.mouseDownListener(exports.Input.mouseX, exports.Input.mouseY, event.button);
        // Start checking for hold
        if (!exports.Input._holdCheckInterval) {
            exports.Input._holdCheckInterval = setInterval(exports.Input.checkIsMouseHold, 16); // Check every frame
        }
    },
    handleMouseUp: function (event) {
        exports.Input.mouseDown = false;
        exports.Input.mouseDownStartTime = null;
        exports.Input.mouseUpListener(exports.Input.mouseX, exports.Input.mouseY, event.button);
        // Clear hold check interval
        if (exports.Input._holdCheckInterval) {
            clearInterval(exports.Input._holdCheckInterval);
            exports.Input._holdCheckInterval = null;
        }
        // Clear isMouseHold after a short delay to ensure click handler sees it
        setTimeout(() => {
            exports.Input.isMouseHold = false;
        }, 50);
    },
    _holdCheckInterval: null,
    checkIsMouseHold: function () {
        if (!exports.Input.mouseDown || exports.Input.mouseDownStartTime === null)
            return;
        if (Date.now() >= exports.Input.mouseDownStartTime + exports.Input.HOLD_THRESH) {
            if (!exports.Input.isMouseHold) {
                exports.Input.isMouseHold = true;
                // Call the hold callback if one is registered
                if (exports.Input.holdCallback) {
                    exports.Input.holdCallback();
                }
            }
        }
    },
    getTouches: function (evt) {
        game_1.Game.inputReceived = true;
        return (evt.touches || evt.originalEvent.touches // browser API
        ); // jQuery
    },
    xDown: null,
    yDown: null,
    currentX: 0,
    currentY: 0,
    swiped: false,
    handleTouchStart: function (evt) {
        //console.log("handleTouchStart triggered");
        game_1.Game.inputReceived = true;
        evt.preventDefault();
        const firstTouch = exports.Input.getTouches(evt)[0];
        exports.Input.xDown = firstTouch.clientX;
        exports.Input.yDown = firstTouch.clientY;
        exports.Input.currentX = firstTouch.clientX;
        exports.Input.currentY = firstTouch.clientY;
        exports.Input.tapStartTime = Date.now();
        exports.Input.updateMousePos({
            clientX: exports.Input.currentX,
            clientY: exports.Input.currentY,
        });
        exports.Input.swiped = false;
        // Unify with mouseDown logic, but force button=0 (left-click equivalent)
        exports.Input.mouseDown = true;
        exports.Input.mouseDownStartTime = Date.now();
        exports.Input.isMouseHold = false;
        exports.Input.mouseDownListener(exports.Input.mouseX, exports.Input.mouseY, 0);
        if (!exports.Input._holdCheckInterval) {
            exports.Input._holdCheckInterval = setInterval(exports.Input.checkIsMouseHold, 16);
            // console.log("_holdCheckInterval started");
        }
    },
    handleTouchMove: function (evt) {
        //console.log("handleTouchMove triggered");
        evt.preventDefault();
        exports.Input.currentX = evt.touches[0].clientX;
        exports.Input.currentY = evt.touches[0].clientY;
        exports.Input.updateMousePos({
            clientX: exports.Input.currentX,
            clientY: exports.Input.currentY,
        });
        if (exports.Input.swiped)
            return;
        var xDiff = exports.Input.xDown - exports.Input.currentX;
        var yDiff = exports.Input.yDown - exports.Input.currentY;
        // we have not swiped yet
        // check if we've swiped
        if (xDiff ** 2 + yDiff ** 2 >= gameConstants_1.GameConstants.SWIPE_THRESH) {
            if (Math.abs(xDiff) > Math.abs(yDiff)) {
                /*most significant*/
                if (xDiff > 0) {
                    exports.Input.leftSwipeListener();
                }
                else {
                    exports.Input.rightSwipeListener();
                }
                exports.Input.swiped = true;
            }
            else {
                if (yDiff > 0) {
                    exports.Input.upSwipeListener();
                }
                else {
                    exports.Input.downSwipeListener();
                }
                exports.Input.swiped = true;
            }
        }
    },
    handleTouchEnd: function (evt) {
        //console.log("handleTouchEnd triggered");
        evt.preventDefault();
        if (!exports.Input.isTapHold && !exports.Input.swiped)
            exports.Input.tapListener();
        exports.Input.isTapHold = false;
        exports.Input.tapStartTime = null;
        //if (Input.swiped) return;
        // Also unify with mouseUp logic, again forcing button=0
        exports.Input.mouseDown = false;
        exports.Input.mouseDownStartTime = null;
        exports.Input.mouseUpListener(exports.Input.mouseX, exports.Input.mouseY, 0);
        if (exports.Input._holdCheckInterval) {
            clearInterval(exports.Input._holdCheckInterval);
            exports.Input._holdCheckInterval = null;
            //console.log("_holdCheckInterval cleared");
        }
        setTimeout(() => {
            exports.Input.isMouseHold = false;
            //console.log("isMouseHold reset");
        }, 50);
    },
    checkIsTapHold: function () {
        if (exports.Input.tapStartTime !== null &&
            Date.now() >= exports.Input.tapStartTime + exports.Input.IS_TAP_HOLD_THRESH)
            exports.Input.isTapHold = true;
    },
    set isMouseHold(value) {
        //console.log(`isMouseHold set to: ${value}`);
        this._isMouseHold = value;
    },
    get isMouseHold() {
        return this._isMouseHold;
    },
    _isMouseHold: false,
    mouseDownStartTime: null,
    HOLD_THRESH: 200,
    holdCallback: null,
};
window.addEventListener("keyup", function (event) {
    exports.Input.onKeyup(event);
}, false);
window.addEventListener("keydown", function (event) {
    exports.Input.onKeydown(event);
}, false);
/**

window.addEventListener(
  "touchstart",
  function (event) {
    Input.handleTouchStart(event);
  },
  false,
);

window.addEventListener(
  "touchend",
  function (event) {
    Input.handleTouchEnd(event);
  },
  false,
);
*/
window.document
    .getElementById("gameCanvas")
    .addEventListener("click", (event) => exports.Input.mouseClickListener(event), false);
window.document
    .getElementById("gameCanvas")
    .addEventListener("mousemove", (event) => exports.Input.updateMousePos(event), false);
window.document
    .getElementById("gameCanvas")
    .addEventListener("mousedown", (event) => exports.Input.handleMouseDown(event), false);
window.document
    .getElementById("gameCanvas")
    .addEventListener("mouseup", (event) => exports.Input.handleMouseUp(event), false);
window.document
    .getElementById("gameCanvas")
    .addEventListener("contextmenu", (event) => event.preventDefault(), false);
/**
window.document
  .getElementById("gameCanvas")
  .addEventListener(
    "touchstart",
    (event) => Input.handleTouchStart(event),
    false,
  );
window.document
  .getElementById("gameCanvas")
  .addEventListener("touchend", (event) => Input.handleTouchEnd(event), false);
  */


/***/ }),

/***/ "./src/inventory/inventory.ts":
/*!************************************!*\
  !*** ./src/inventory/inventory.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Inventory = void 0;
const item_1 = __webpack_require__(/*! ../item/item */ "./src/item/item.ts");
const game_1 = __webpack_require__(/*! ../game */ "./src/game.ts");
const gameConstants_1 = __webpack_require__(/*! ../gameConstants */ "./src/gameConstants.ts");
const equippable_1 = __webpack_require__(/*! ../item/equippable */ "./src/item/equippable.ts");
const armor_1 = __webpack_require__(/*! ../item/armor */ "./src/item/armor.ts");
const coin_1 = __webpack_require__(/*! ../item/coin */ "./src/item/coin.ts");
const weapon_1 = __webpack_require__(/*! ../weapon/weapon */ "./src/weapon/weapon.ts");
const usable_1 = __webpack_require__(/*! ../item/usable */ "./src/item/usable.ts");
const mouseCursor_1 = __webpack_require__(/*! ../mouseCursor */ "./src/mouseCursor.ts");
const input_1 = __webpack_require__(/*! ../input */ "./src/input.ts");
let OPEN_TIME = 100; // milliseconds
// Dark gray color used for the background of inventory slots
let FILL_COLOR = "#5a595b";
// Very dark blue-gray color used for outlines and borders
let OUTLINE_COLOR = "#292c36";
// Light blue color used to indicate equipped items
let EQUIP_COLOR = "#85a8e6";
// White color used for the outer border of the inventory
let FULL_OUTLINE = "white";
class Inventory {
    constructor(game, player) {
        this.rows = 4;
        this.cols = 5;
        this.selX = 0;
        this.selY = 0;
        this.isOpen = false;
        this.openTime = Date.now();
        this.coins = 0;
        this.weapon = null;
        this._expansion = 0;
        this.grabbedItem = null;
        this._mouseDownStartX = null;
        this._mouseDownStartY = null;
        this._mouseDownItem = null;
        this._wasHoldDetected = false;
        this._isDragging = false;
        this._dragStartItem = null;
        this._dragStartSlot = null;
        this.itemEquipAnimations = new Map();
        // New state for using items on other items
        this.usingItem = null;
        this.usingItemIndex = null;
        this.mostRecentInput = "keyboard";
        this.clear = () => {
            this.items.fill(null);
            this.equipAnimAmount.fill(0);
        };
        this.open = () => {
            this.isOpen = !this.isOpen;
            if (this.isOpen)
                this.openTime = Date.now();
            if (!this.isOpen) {
                this.selY = 0;
                this.usingItem = null;
                this.usingItemIndex = null;
            }
        };
        this.toggleOpen = () => {
            if (this.isOpen) {
                this.close();
            }
            else {
                this.open();
            }
        };
        this.close = () => {
            if (!this.isOpen)
                return;
            this.isOpen = false;
            if (this.selY > 0) {
                this.selY = 0;
            }
            this.usingItem = null;
            this.usingItemIndex = null;
        };
        this.left = () => {
            if (this.selX > 0) {
                this.selX--;
            }
        };
        this.right = () => {
            if (this.selX < this.cols - 1) {
                this.selX++;
            }
        };
        this.up = () => {
            if (this.selY > 0) {
                this.selY--;
            }
        };
        this.down = () => {
            if (this.selY < this.rows + this._expansion - 1) {
                this.selY++;
            }
        };
        this.space = () => {
            this.itemUse();
        };
        this.itemAtSelectedSlot = () => {
            let index = this.selX + this.selY * this.cols;
            if (index < 0 || index >= this.items.length) {
                return null;
            }
            return this.items[index];
        };
        this.getIndexOfItem = (item) => {
            if (item === null)
                return -1;
            return this.items.indexOf(item);
        };
        this.itemUse = () => {
            let index = this.selX + this.selY * this.cols;
            if (index < 0 || index >= this.items.length)
                return;
            const item = this.items[index];
            if (this.usingItem) {
                // Attempt to use 'usingItem' on the currently selected item
                if (item === null) {
                    // Clicked on empty slot; cancel the using state
                    this.usingItem = null;
                    this.usingItemIndex = null;
                    return;
                }
                // Attempt to use on other
                if (item instanceof item_1.Item) {
                    this.usingItem.useOnOther(this.player, item);
                }
                // Exit tryingToUse state
                this.usingItem = null;
                this.usingItemIndex = null;
            }
            else {
                // Not in tryingToUse state
                if (item instanceof usable_1.Usable) {
                    if (item.canUseOnOther) {
                        // Enter tryingToUse state
                        this.usingItem = item;
                        this.usingItemIndex = index;
                    }
                    else {
                        // Use normally
                        item.onUse(this.player);
                        // Optionally remove the item
                        // this.items[index] = null;
                    }
                }
                else if (item instanceof equippable_1.Equippable) {
                    // Existing equipping logic
                    item.toggleEquip();
                    if (item instanceof weapon_1.Weapon) {
                        this.weapon = item.equipped ? item : null;
                    }
                    if (item.equipped) {
                        this.items.forEach((i, idx) => {
                            if (i instanceof equippable_1.Equippable &&
                                i !== item &&
                                !item.coEquippable(i)) {
                                i.equipped = false;
                                this.equipAnimAmount[idx] = 0;
                            }
                        });
                    }
                }
            }
        };
        this.leftQuickbar = () => {
            this.mostRecentInput = "keyboard";
            this.left();
        };
        this.rightQuickbar = () => {
            this.mostRecentInput = "keyboard";
            this.right();
        };
        this.spaceQuickbar = () => {
            this.mostRecentInput = "keyboard";
            this.itemUse();
        };
        this.mouseMove = () => {
            this.mostRecentInput = "mouse";
            const { x, y } = mouseCursor_1.MouseCursor.getInstance().getPosition();
            const bounds = this.isPointInInventoryBounds(x, y);
            if (bounds.inBounds) {
                const s = this.isOpen
                    ? Math.min(18, (18 * (Date.now() - this.openTime)) / OPEN_TIME)
                    : 18;
                const b = 2;
                const g = -2;
                const oldSelX = this.selX;
                const oldSelY = this.selY;
                this.selX = Math.max(0, Math.min(Math.floor((x - bounds.startX) / (s + 2 * b + g)), this.cols - 1));
                this.selY = this.isOpen
                    ? Math.max(0, Math.min(Math.floor((y - bounds.startY) / (s + 2 * b + g)), this.rows + this._expansion - 1))
                    : 0;
                if (oldSelX !== this.selX || oldSelY !== this.selY) {
                    // Optional: Handle selection change
                }
            }
        };
        this.moveItemToSlot = (item, index, otherItem, otherIndex) => {
            if (item === null)
                return;
            // Preserve animation states before moving
            const itemAnim = this.equipAnimAmount[index];
            const otherAnim = otherItem ? this.equipAnimAmount[otherIndex] : 0;
            if (otherItem === null) {
                this.items[index] = item;
                this.equipAnimAmount[index] = this.itemEquipAnimations.get(item) ?? 0;
            }
            else {
                this.items[index] = otherItem;
                this.items[otherIndex] = item;
                this.equipAnimAmount[index] =
                    this.itemEquipAnimations.get(otherItem) ?? 0;
                this.equipAnimAmount[otherIndex] =
                    this.itemEquipAnimations.get(item) ?? 0;
            }
        };
        this.grabItem = (item) => {
            if (item === null) {
                return;
            }
            if (this.grabbedItem !== null) {
                return;
            }
            // Remove the item from its slot when grabbed
            const index = this.getIndexOfItem(item);
            if (index !== -1) {
                this.items[index] = null;
                this.grabbedItem = item;
            }
            else {
            }
        };
        this.releaseItem = () => {
            if (this.grabbedItem === null) {
                return;
            }
            const targetIndex = this.selX + this.selY * this.cols;
            const existingItem = this.items[targetIndex];
            // If target slot is empty, place item there
            if (existingItem === null) {
                this.items[targetIndex] = this.grabbedItem;
            }
            else {
                // Swap items
                this.items[targetIndex] = this.grabbedItem;
            }
            this.grabbedItem = null;
        };
        this.drawDraggedItem = (delta) => {
            if (this.grabbedItem === null)
                return;
            const { x, y } = mouseCursor_1.MouseCursor.getInstance().getPosition();
            const drawX = Math.round(x - 0.5 * gameConstants_1.GameConstants.TILESIZE);
            const drawY = Math.round(y - 0.5 * gameConstants_1.GameConstants.TILESIZE);
            const drawXScaled = drawX / gameConstants_1.GameConstants.TILESIZE;
            const drawYScaled = drawY / gameConstants_1.GameConstants.TILESIZE;
            this.grabbedItem.drawIcon(delta, drawXScaled, drawYScaled);
        };
        this.drop = () => {
            if (!this.isOpen)
                return;
            let index = this.selX + this.selY * this.cols;
            if (index < 0 || index >= this.items.length)
                return;
            const item = this.items[index];
            if (item === null)
                return;
            this.dropItem(item, index);
        };
        this.dropItem = (item, index) => {
            item.level = this.game.levels[this.player.depth].rooms[this.player.levelID];
            item.x = this.player.x;
            item.y = this.player.y;
            item.alpha = 1;
            item.pickedUp = false;
            item.dropFromInventory();
            this.equipAnimAmount[index] = 0;
            item.drawableY = this.player.y;
            this.game.levels[this.player.depth].rooms[this.player.levelID].items.push(item);
            this.items[index] = null;
        };
        this.dropFromInventory = () => {
            // Intentionally left blank or implement if needed
        };
        this.hasItem = (itemType) => {
            return this.items.find((i) => i instanceof itemType) || null;
        };
        this.hasItemCount = (item) => {
            if (item === null)
                return false;
            if (item instanceof coin_1.Coin)
                return this.coinCount() >= item.stackCount;
            return this.items.some((i) => i !== null &&
                i.constructor === item.constructor &&
                i.stackCount >= item.stackCount);
        };
        this.subtractItemCount = (item) => {
            if (item === null)
                return;
            if (item instanceof coin_1.Coin) {
                this.subtractCoins(item.stackCount);
                return;
            }
            this.items.forEach((i, idx) => {
                if (i === null)
                    return;
                if (i.constructor === item.constructor) {
                    i.stackCount -= item.stackCount;
                    if (i.stackCount <= 0) {
                        this.items[idx] = null;
                    }
                }
            });
        };
        this.coinCount = () => {
            return this.coins;
        };
        this.subtractCoins = (n) => {
            this.coins = Math.max(0, this.coins - n);
        };
        this.addCoins = (n) => {
            this.coins += n;
        };
        this.isFull = () => {
            return (this.items.filter((i) => i !== null).length >=
                (this.rows + this._expansion) * this.cols);
        };
        this.addItem = (item) => {
            if (item === null)
                return false;
            if (item instanceof coin_1.Coin) {
                this.coins += item.stack;
                return true;
            }
            if (item instanceof equippable_1.Equippable) {
                item.setWielder(this.player);
            }
            if (item.stackable) {
                for (let i = 0; i < this.items.length; i++) {
                    if (this.items[i] !== null &&
                        this.items[i].constructor === item.constructor) {
                        this.items[i].stackCount += item.stackCount;
                        return true;
                    }
                }
            }
            if (!this.isFull()) {
                for (let i = 0; i < this.items.length; i++) {
                    if (this.items[i] === null) {
                        this.items[i] = item;
                        return true;
                    }
                }
            }
            return false;
        };
        this.removeItem = (item) => {
            if (item === null)
                return;
            const index = this.items.indexOf(item);
            if (index !== -1) {
                this.items[index] = null;
            }
        };
        this.getArmor = () => {
            return (this.items.find((i) => i instanceof armor_1.Armor && i.equipped) ||
                null);
        };
        this.hasWeapon = () => {
            return this.weapon !== null;
        };
        this.getWeapon = () => {
            return this.weapon;
        };
        this.tick = () => {
            this.items.forEach((i) => {
                if (i !== null)
                    i.tickInInventory();
            });
            // Check for drag initiation
            this.checkForDragStart();
        };
        this.textWrap = (text, x, y, maxWidth) => {
            // Returns y value for next line
            if (text === "")
                return y;
            let words = text.split(" ");
            let line = "";
            while (words.length > 0) {
                if (game_1.Game.measureText(line + words[0]).width > maxWidth) {
                    game_1.Game.fillText(line, x, y);
                    line = "";
                    y += 8;
                }
                else {
                    if (line !== "")
                        line += " ";
                    line += words[0];
                    words.splice(0, 1);
                }
            }
            if (line.trim() !== "") {
                game_1.Game.fillText(line, x, y);
                y += 8;
            }
            return y;
        };
        this.drawCoins = (delta) => {
            let coinTileX = 19;
            if (this.coins === 2)
                coinTileX = 20;
            else if (this.coins >= 3)
                coinTileX = 21;
            let coinX = gameConstants_1.GameConstants.WIDTH / gameConstants_1.GameConstants.TILESIZE - 2.25;
            let coinY = gameConstants_1.GameConstants.HEIGHT / gameConstants_1.GameConstants.TILESIZE - 1.25;
            if (gameConstants_1.GameConstants.WIDTH < 170) {
                //coinX -= 1.25;
                coinY -= 1.25;
            }
            game_1.Game.drawItem(coinTileX, 0, 1, 2, coinX, coinY - 1, 1, 2);
            const countText = `${this.coins}`;
            const width = game_1.Game.measureText(countText).width;
            const countX = 10;
            const countY = 9;
            game_1.Game.fillTextOutline(countText, coinX * gameConstants_1.GameConstants.TILESIZE + countX, coinY * gameConstants_1.GameConstants.TILESIZE + countY, gameConstants_1.GameConstants.OUTLINE, "white");
            /*
            const turnCountText = `${this.player.turnCount}`;
            Game.fillTextOutline(
              turnCountText,
              coinX * GameConstants.TILESIZE + countX,
              coinY * GameConstants.TILESIZE + countY - 15,
              GameConstants.OUTLINE,
              "white",
            );
            */
        };
        this.pointInside = (x, y) => {
            const s = Math.min(18, (18 * (Date.now() - this.openTime)) / OPEN_TIME); // size of box
            const b = 2; // border
            const g = -2; // gap
            const hg = 3 + Math.round(0.5 * Math.sin(Date.now() * 0.01) + 0.5); // highlighted growth
            const ob = 1; // outer border
            const width = this.cols * (s + 2 * b + g) - g;
            const height = (this.rows + this._expansion) * (s + 2 * b + g) - g;
            const startX = Math.round(0.5 * gameConstants_1.GameConstants.WIDTH - 0.5 * width) - ob;
            const startY = this.isOpen
                ? Math.round(0.5 * gameConstants_1.GameConstants.HEIGHT - 0.5 * height) - ob
                : gameConstants_1.GameConstants.HEIGHT - (s + 2 * b) - 5 - ob;
            const checkHeight = this.isOpen ? height + 2 * ob : s + 2 * b + 2 * ob;
            return (x >= startX &&
                x <= startX + width + 2 * ob &&
                y >= startY &&
                y <= startY + checkHeight);
        };
        this.drawQuickbar = (delta) => {
            const { x, y } = mouseCursor_1.MouseCursor.getInstance().getPosition();
            const isInBounds = this.isPointInInventoryBounds(x, y).inBounds;
            const s = 18; // size of box
            const b = 2; // border
            const g = -2; // gap
            const hg = 1; // + Math.round(0.5 * Math.sin(Date.now() * 0.01) + 0.5); // highlighted growth
            const ob = 1; // outer border
            const width = Math.floor(this.cols * (s + 2 * b + g) - g);
            const height = Math.floor(s + 2 * b);
            const startX = Math.round(0.5 * gameConstants_1.GameConstants.WIDTH - 0.5 * width);
            const startY = Math.floor(gameConstants_1.GameConstants.HEIGHT - height - 2);
            // Draw main background
            /*
            Game.ctx.fillStyle = FULL_OUTLINE;
            Game.ctx.fillRect(startX - ob, startY - 1, width + 2, height + 2);
            */
            //Game.ctx.globalCompositeOperation = "xor";
            // Draw highlighted background for selected item only if mouse is in bounds
            if (isInBounds || this.mostRecentInput === "keyboard") {
                /*
                Game.ctx.fillRect(
                  Math.floor(startX + this.selX * (s + 2 * b + g) - hg - ob),
                  Math.floor(startY - hg - ob),
                  Math.floor(s + 2 * b + 2 * hg + 2 * ob),
                  Math.floor(s + 2 * b + 2 * hg + 2 * ob),
                );
                */
            }
            // Draw individual item slots
            for (let xIdx = 0; xIdx < this.cols; xIdx++) {
                // Skip drawing normal background and icon if this is the selected slot
                const idx = xIdx;
                // Draw slot background
                if (xIdx !== this.selX) {
                    game_1.Game.ctx.fillStyle = FILL_COLOR;
                    game_1.Game.ctx.fillRect(Math.floor(startX + xIdx * (s + 2 * b + g) + b), Math.floor(startY + b), Math.floor(s), Math.floor(s));
                    game_1.Game.ctx.clearRect(Math.floor(startX + xIdx * (s + 2 * b + g) + b + 1), Math.floor(startY + b + 1), Math.floor(s - 2), Math.floor(s - 2));
                    // Draw equip animation (this should always show)
                    game_1.Game.ctx.fillStyle = EQUIP_COLOR;
                    game_1.Game.ctx.globalAlpha = 0.3;
                    const yOff = Math.floor(s * (1 - this.equipAnimAmount[idx]));
                    game_1.Game.ctx.fillRect(Math.floor(startX + xIdx * (s + 2 * b + g) + b), Math.floor(startY + b + yOff), Math.floor(s), Math.floor(s - yOff));
                    game_1.Game.ctx.globalAlpha = 1;
                    /*
                    Game.ctx.clearRect(
                      Math.floor(startX + xIdx * (s + 2 * b + g) + b + 1),
                      Math.floor(startY + b + 1),
                      Math.floor(s - 2),
                      Math.floor(s - 2),
                    );
                    */
                }
                // Draw item icon if exists
                if (idx < this.items.length && this.items[idx] !== null) {
                    const drawX = startX +
                        xIdx * (s + 2 * b + g) +
                        b +
                        Math.floor(0.5 * s) -
                        0.5 * gameConstants_1.GameConstants.TILESIZE;
                    const drawY = startY + b + Math.floor(0.5 * s) - 0.5 * gameConstants_1.GameConstants.TILESIZE;
                    const drawXScaled = drawX / gameConstants_1.GameConstants.TILESIZE;
                    const drawYScaled = drawY / gameConstants_1.GameConstants.TILESIZE;
                    this.items[idx]?.drawIcon(delta, drawXScaled, drawYScaled);
                }
            }
            // Draw selection box only if mouse is in bounds
            if (true) {
                const selStartX = Math.floor(startX + this.selX * (s + 2 * b + g));
                const selStartY = Math.floor(startY);
                /*
                // Outer selection box (dark)
                Game.ctx.fillStyle = OUTLINE_COLOR;
                Game.ctx.fillRect(
                  selStartX - hg,
                  selStartY - hg,
                  s + 2 * b + 2 * hg,
                  s + 2 * b + 2 * hg,
                );
                */
                // Inner selection box (light grey)
                game_1.Game.ctx.fillStyle = FILL_COLOR;
                game_1.Game.ctx.fillRect(Math.floor(selStartX + b - hg), Math.floor(selStartY + b - hg), Math.floor(s + 2 * hg), Math.floor(s + 2 * hg));
                game_1.Game.ctx.clearRect(Math.floor(startX + this.selX * (s + 2 * b + g) + b), Math.floor(startY + b), Math.floor(s), Math.floor(s));
                // Draw equip animation for selected slot with highlight
                const idx = this.selX;
                game_1.Game.ctx.fillStyle = EQUIP_COLOR;
                game_1.Game.ctx.globalAlpha = 0.3;
                const yOff = (s + 2 * hg) * (1 - this.equipAnimAmount[idx]);
                game_1.Game.ctx.fillRect(Math.round(startX + this.selX * (s + 2 * b + g) + b - hg), Math.round(startY + b + yOff - hg), Math.round(s + 2 * hg), Math.round(s + 2 * hg - yOff));
                game_1.Game.ctx.globalAlpha = 1;
                /*
                Game.ctx.clearRect(
                  Math.floor(startX + this.selX * (s + 2 * b + g) + b),
                  Math.floor(startY + b),
                  Math.floor(s),
                  Math.floor(s),
                );
                */
                this.drawUsingItem(delta, startX, startY, s, b, g);
                // Redraw the selected item
                if (idx < this.items.length && this.items[idx] !== null) {
                    const drawX = selStartX + b + Math.floor(0.5 * s) - 0.5 * gameConstants_1.GameConstants.TILESIZE;
                    const drawY = selStartY + b + Math.floor(0.5 * s) - 0.5 * gameConstants_1.GameConstants.TILESIZE;
                    const drawXScaled = drawX / gameConstants_1.GameConstants.TILESIZE;
                    const drawYScaled = drawY / gameConstants_1.GameConstants.TILESIZE;
                    this.items[idx]?.drawIcon(delta, drawXScaled, drawYScaled);
                }
                this.drawUsingItem(delta, startX, startY, s, b, g);
            }
            this.drawUsingItem(delta, startX, startY, s, b, g);
        };
        this.drawUsingItem = (delta, startX, startY, s, b, g) => {
            // Highlight the usingItem's slot if in using state and it's different from current selection
            game_1.Game.ctx.globalCompositeOperation = "source-over";
            if (this.usingItem && this.usingItemIndex !== null) {
                const usingX = this.usingItemIndex % this.cols;
                const usingY = Math.floor(this.usingItemIndex / this.cols);
                const highlightStartX = startX + usingX * (s + 2 * b + g);
                const highlightStartY = startY + usingY * (s + 2 * b + g);
                game_1.Game.ctx.strokeStyle = "yellow"; // Choose a distinct color for using item
                game_1.Game.ctx.lineWidth = 2;
                game_1.Game.ctx.strokeRect(highlightStartX, highlightStartY, s + 2 * b, s + 2 * b);
                game_1.Game.ctx.lineWidth = 1; // Reset line width
            }
        };
        this.updateEquipAnimAmount = (delta) => {
            this.equipAnimAmount.forEach((amount, idx) => {
                const item = this.items[idx];
                if (item instanceof equippable_1.Equippable) {
                    let targetAmount = item.equipped ? 1 : 0;
                    let currentAmount = this.itemEquipAnimations.get(item) ?? amount;
                    currentAmount += 0.2 * delta * (targetAmount - currentAmount);
                    currentAmount = Math.max(0, Math.min(1, currentAmount));
                    this.itemEquipAnimations.set(item, currentAmount);
                    this.equipAnimAmount[idx] = currentAmount;
                }
                else {
                    this.equipAnimAmount[idx] = 0;
                    if (item)
                        this.itemEquipAnimations.delete(item);
                }
            });
        };
        this.draw = (delta) => {
            game_1.Game.ctx.imageSmoothingEnabled = false;
            game_1.Game.ctx.imageSmoothingQuality = "low";
            const { x, y } = mouseCursor_1.MouseCursor.getInstance().getPosition();
            const isInBounds = this.isPointInInventoryBounds(x, y).inBounds;
            const s = Math.floor(Math.min(18, (18 * (Date.now() - this.openTime)) / OPEN_TIME)); // size of box
            const b = 2; // border
            const g = -2; // gap
            const hg = 3 + Math.round(0.5 * Math.sin(Date.now() * 0.01) + 0.5); // highlighted growth
            const invRows = Math.floor(this.rows + this._expansion);
            const ob = 1; // outer border
            const width = Math.floor(this.cols * (s + 2 * b + g) - g);
            const height = Math.floor(invRows * (s + 2 * b + g) - g);
            const mainBgX = Math.round(0.5 * gameConstants_1.GameConstants.WIDTH - 0.5 * width) - ob;
            const mainBgY = Math.round(0.5 * gameConstants_1.GameConstants.HEIGHT - 0.5 * height) - ob;
            // Draw coins and quickbar (these are always visible)
            this.drawCoins(delta);
            this.drawQuickbar(delta);
            this.updateEquipAnimAmount(delta);
            this.drawInventoryButton(delta);
            if (this.isOpen) {
                // Draw semi-transparent background for full inventory
                game_1.Game.ctx.fillStyle = "rgba(0, 0, 0, 0.8)";
                game_1.Game.ctx.fillRect(0, 0, gameConstants_1.GameConstants.WIDTH, gameConstants_1.GameConstants.HEIGHT);
                game_1.Game.ctx.globalAlpha = 1;
                // Define dimensions and styling variables (similar to drawQuickbar)
                const s = Math.floor(Math.min(18, (18 * (Date.now() - this.openTime)) / OPEN_TIME)); // size of box
                const b = 2; // border
                const g = -2; // gap
                const hg = Math.floor(3 + Math.round(0.5 * Math.sin(Date.now() * 0.01) + 0.5)); // highlighted growth
                const invRows = this.rows + this._expansion;
                const ob = 1; // outer border
                const width = Math.floor(this.cols * (s + 2 * b + g) - g);
                const height = Math.floor(invRows * (s + 2 * b + g) - g);
                // Draw main inventory background (similar to drawQuickbar)
                game_1.Game.ctx.fillStyle = FULL_OUTLINE;
                const mainBgX = Math.round(0.5 * gameConstants_1.GameConstants.WIDTH - 0.5 * width) - ob;
                const mainBgY = Math.round(0.5 * gameConstants_1.GameConstants.HEIGHT - 0.5 * height) - ob;
                game_1.Game.ctx.fillRect(mainBgX, mainBgY, width + 2 * ob, height + 2 * ob);
                // Draw highlighted background for selected item only if mouse is in bounds
                if (isInBounds || this.mostRecentInput === "keyboard") {
                    const highlightX = Math.round(0.5 * gameConstants_1.GameConstants.WIDTH -
                        0.5 * width +
                        this.selX * (s + 2 * b + g)) -
                        hg -
                        ob;
                    const highlightY = Math.round(0.5 * gameConstants_1.GameConstants.HEIGHT -
                        0.5 * height +
                        this.selY * (s + 2 * b + g)) -
                        hg -
                        ob;
                    game_1.Game.ctx.fillRect(highlightX, highlightY, s + 2 * b + 2 * hg + 2 * ob, s + 2 * b + 2 * hg + 2 * ob);
                }
                // Draw individual inventory slots (similar to drawQuickbar, but for all rows)
                for (let xIdx = 0; xIdx < this.cols; xIdx++) {
                    for (let yIdx = 0; yIdx < this.rows + this._expansion; yIdx++) {
                        // Draw slot outline
                        const slotX = Math.round(0.5 * gameConstants_1.GameConstants.WIDTH - 0.5 * width + xIdx * (s + 2 * b + g));
                        const slotY = Math.round(0.5 * gameConstants_1.GameConstants.HEIGHT - 0.5 * height + yIdx * (s + 2 * b + g));
                        game_1.Game.ctx.fillStyle = OUTLINE_COLOR;
                        game_1.Game.ctx.fillRect(slotX, slotY, s + 2 * b, s + 2 * b);
                        // Draw slot background
                        game_1.Game.ctx.fillStyle = FILL_COLOR;
                        game_1.Game.ctx.fillRect(slotX + b, slotY + b, s, s);
                        // Draw equip animation (unique to full inventory view)
                        const idx = xIdx + yIdx * this.cols;
                        game_1.Game.ctx.fillStyle = EQUIP_COLOR;
                        const yOff = Math.round(s * (1 - this.equipAnimAmount[idx]));
                        game_1.Game.ctx.fillRect(slotX + b, slotY + b + yOff, s, s - yOff);
                        // Draw item icon if exists
                        if (idx < this.items.length && this.items[idx] !== null) {
                            const drawX = Math.round(0.5 * gameConstants_1.GameConstants.WIDTH -
                                0.5 * width +
                                xIdx * (s + 2 * b + g) +
                                b +
                                Math.floor(0.5 * s) -
                                0.5 * gameConstants_1.GameConstants.TILESIZE);
                            const drawY = Math.round(0.5 * gameConstants_1.GameConstants.HEIGHT -
                                0.5 * height +
                                yIdx * (s + 2 * b + g) +
                                b +
                                Math.floor(0.5 * s) -
                                0.5 * gameConstants_1.GameConstants.TILESIZE);
                            const drawXScaled = drawX / gameConstants_1.GameConstants.TILESIZE;
                            const drawYScaled = drawY / gameConstants_1.GameConstants.TILESIZE;
                            this.items[idx]?.drawIcon(delta, drawXScaled, drawYScaled);
                        }
                    }
                }
                // Draw item icons after animation delay (similar to drawQuickbar, but for all items)
                if (Date.now() - this.openTime >= OPEN_TIME) {
                    this.items.forEach((item, idx) => {
                        if (item === null)
                            return;
                        const x = idx % this.cols;
                        const y = Math.floor(idx / this.cols);
                        const drawX = Math.round(0.5 * gameConstants_1.GameConstants.WIDTH -
                            0.5 * width +
                            x * (s + 2 * b + g) +
                            b +
                            Math.floor(0.5 * s) -
                            0.5 * gameConstants_1.GameConstants.TILESIZE);
                        const drawY = Math.round(0.5 * gameConstants_1.GameConstants.HEIGHT -
                            0.5 * height +
                            y * (s + 2 * b + g) +
                            b +
                            Math.floor(0.5 * s) -
                            0.5 * gameConstants_1.GameConstants.TILESIZE);
                        const drawXScaled = drawX / gameConstants_1.GameConstants.TILESIZE;
                        const drawYScaled = drawY / gameConstants_1.GameConstants.TILESIZE;
                        item.drawIcon(delta, drawXScaled, drawYScaled);
                    });
                    // Draw selection box and related elements only if mouse is in bounds
                    if (isInBounds || this.mostRecentInput === "keyboard") {
                        // Draw selection box
                        game_1.Game.ctx.fillStyle = OUTLINE_COLOR;
                        game_1.Game.ctx.fillRect(Math.round(0.5 * gameConstants_1.GameConstants.WIDTH -
                            0.5 * width +
                            this.selX * (s + 2 * b + g) -
                            hg), Math.round(0.5 * gameConstants_1.GameConstants.HEIGHT -
                            0.5 * height +
                            this.selY * (s + 2 * b + g) -
                            hg), s + 2 * b + 2 * hg, s + 2 * b + 2 * hg);
                        const slotX = Math.round(0.5 * gameConstants_1.GameConstants.WIDTH -
                            0.5 * width +
                            this.selX * (s + 2 * b + g) +
                            b -
                            hg);
                        const slotY = Math.round(0.5 * gameConstants_1.GameConstants.HEIGHT -
                            0.5 * height +
                            this.selY * (s + 2 * b + g) +
                            b -
                            hg);
                        game_1.Game.ctx.fillStyle = FILL_COLOR;
                        game_1.Game.ctx.fillRect(slotX, slotY, s + 2 * hg, s + 2 * hg);
                        // Draw equip animation for selected item (unique to full inventory view)
                        const idx = this.selX + this.selY * this.cols;
                        if (idx < this.items.length && this.items[idx] !== null) {
                            game_1.Game.ctx.fillStyle = EQUIP_COLOR;
                            const yOff = Math.round((s + 2 * hg) * (1 - this.equipAnimAmount[idx]));
                            game_1.Game.ctx.fillRect(Math.round(0.5 * gameConstants_1.GameConstants.WIDTH -
                                0.5 * width +
                                this.selX * (s + 2 * b + g) +
                                b -
                                hg), Math.round(0.5 * gameConstants_1.GameConstants.HEIGHT -
                                0.5 * height +
                                this.selY * (s + 2 * b + g) +
                                b -
                                hg +
                                yOff), s + 2 * hg, s + 2 * hg - yOff);
                            // Redraw selected item icon (similar to drawQuickbar)
                            const drawX = Math.round(0.5 * gameConstants_1.GameConstants.WIDTH -
                                0.5 * width +
                                this.selX * (s + 2 * b + g) +
                                b +
                                Math.floor(0.5 * s) -
                                0.5 * gameConstants_1.GameConstants.TILESIZE);
                            const drawY = Math.round(0.5 * gameConstants_1.GameConstants.HEIGHT -
                                0.5 * height +
                                this.selY * (s + 2 * b + g) +
                                b +
                                Math.floor(0.5 * s) -
                                0.5 * gameConstants_1.GameConstants.TILESIZE);
                            const drawXScaled = drawX / gameConstants_1.GameConstants.TILESIZE;
                            const drawYScaled = drawY / gameConstants_1.GameConstants.TILESIZE;
                            this.items[idx]?.drawIcon(delta, drawXScaled, drawYScaled);
                        }
                        // **Move drawUsingItem here, after the main selection box**
                    }
                    // **Ensure drawUsingItem is not called again here**
                    // this.drawUsingItem(delta, mainBgX, mainBgY, s, b, g);
                }
                // **Ensure drawUsingItem is not called again here**
                // this.drawUsingItem(delta, mainBgX, mainBgY, s, b, g);
                // Draw item description and action text (unique to full inventory view)
                const selectedIdx = this.selX + this.selY * this.cols;
                if (selectedIdx < this.items.length && this.items[selectedIdx] !== null) {
                    const item = this.items[selectedIdx];
                    game_1.Game.ctx.fillStyle = "white";
                    // Determine action text
                    let topPhrase = "";
                    if (item instanceof equippable_1.Equippable) {
                        topPhrase = item.equipped ? "[SPACE] to unequip" : "[SPACE] to equip";
                    }
                    if (item instanceof usable_1.Usable) {
                        topPhrase = "[SPACE] to use";
                    }
                    // Draw action text
                    const actionTextWidth = game_1.Game.measureText(topPhrase).width;
                    game_1.Game.fillText(topPhrase, Math.round(0.5 * (gameConstants_1.GameConstants.WIDTH - actionTextWidth)), 5);
                    // Draw item description
                    const lines = item.getDescription().split("\n");
                    let nextY = Math.round(0.5 * gameConstants_1.GameConstants.HEIGHT -
                        0.5 * height +
                        (this.rows + this.expansion) * (s + 2 * b + g) +
                        b +
                        5);
                    lines.forEach((line) => {
                        nextY = this.textWrap(line, 5, nextY, gameConstants_1.GameConstants.WIDTH - 10);
                    });
                }
            }
            if (this.isOpen) {
                this.drawUsingItem(delta, mainBgX + 1, mainBgY + 1, s, b, g);
            }
            this.drawDraggedItem(delta);
        };
        this.isPointInInventoryBounds = (x, y) => {
            const s = this.isOpen
                ? Math.min(18, (18 * (Date.now() - this.openTime)) / OPEN_TIME)
                : 18;
            const b = 2; // border
            const g = -2; // gap
            const hg = 3 + Math.round(0.5 * Math.sin(Date.now() * 0.01) + 0.5); // highlighted growth
            const ob = 1; // outer border
            const width = this.cols * (s + 2 * b + g) - g;
            let startX;
            let startY;
            let height;
            if (this.isOpen) {
                // Full inventory bounds
                height = (this.rows + this._expansion) * (s + 2 * b + g) - g;
                startX = Math.round(0.5 * gameConstants_1.GameConstants.WIDTH - 0.5 * width);
                startY = Math.round(0.5 * gameConstants_1.GameConstants.HEIGHT - 0.5 * height);
            }
            else {
                // Quickbar bounds
                height = s + 2 * b;
                startX = Math.round(0.5 * gameConstants_1.GameConstants.WIDTH - 0.5 * width);
                startY = Math.round(gameConstants_1.GameConstants.HEIGHT - height - 5);
            }
            const inBounds = x >= startX - ob &&
                x <= startX + width + ob &&
                y >= startY - ob &&
                y <= startY + height + ob;
            return {
                inBounds,
                startX,
                startY,
            };
        };
        this.isPointInQuickbarBounds = (x, y) => {
            const s = this.isOpen
                ? Math.min(18, (18 * (Date.now() - this.openTime)) / OPEN_TIME)
                : 18;
            const b = 2; // border
            const g = -2; // gap
            const width = this.cols * (s + 2 * b + g) - g;
            const startX = Math.round(0.5 * gameConstants_1.GameConstants.WIDTH - 0.5 * width);
            const startY = Math.round(gameConstants_1.GameConstants.HEIGHT - (s + 2 * b) - 5);
            const quickbarHeight = s + 2 * b;
            const inBounds = x >= startX &&
                x <= startX + width &&
                y >= startY &&
                y <= startY + quickbarHeight;
            return {
                inBounds,
                startX,
                startY,
            };
        };
        this.isPointInInventoryButton = (x, y) => {
            const tX = x / gameConstants_1.GameConstants.TILESIZE;
            const tY = y / gameConstants_1.GameConstants.TILESIZE;
            return (tX >= this.buttonX &&
                tX <= this.buttonX + 1 &&
                tY >= this.buttonY &&
                tY <= this.buttonY + 1);
        };
        /**
         * Draws the inventory button to the canvas.
         * Added `ctx.save()` at the beginning and `ctx.restore()` at the end
         * to ensure canvas state is preserved.
         */
        this.drawInventoryButton = (delta) => {
            game_1.Game.ctx.save(); // Save the current canvas state
            this.buttonX = gameConstants_1.GameConstants.WIDTH / gameConstants_1.GameConstants.TILESIZE - 1.25;
            this.buttonY = gameConstants_1.GameConstants.HEIGHT / gameConstants_1.GameConstants.TILESIZE - 1.25;
            if (gameConstants_1.GameConstants.WIDTH < 145) {
                //this.buttonX -= 1;
                this.buttonY -= 1.25;
            }
            game_1.Game.drawFX(0, 0, 1, 1, this.buttonX, this.buttonY, 1, 1);
            game_1.Game.ctx.restore(); // Restore the canvas state
        };
        this.getQuickbarStartX = () => {
            const s = 18; // size of box
            const b = 2; // border
            const g = -2; // gap
            const width = Math.floor(this.cols * (s + 2 * b + g) - g);
            return Math.round(0.5 * gameConstants_1.GameConstants.WIDTH - 0.5 * width);
        };
        this.handleMouseDown = (x, y, button) => {
            // Ignore if not left click
            if (button !== 0)
                return;
            const bounds = this.isPointInInventoryBounds(x, y);
            if (bounds.inBounds) {
                const selectedItem = this.itemAtSelectedSlot();
                if (selectedItem !== null) {
                    this._dragStartItem = selectedItem;
                    this._dragStartSlot = this.selX + this.selY * this.cols;
                }
            }
        };
        /**
         * Unified method to initiate dragging.
         */
        this.initiateDrag = () => {
            if (this._dragStartItem === null || this._isDragging) {
                return;
            }
            this._isDragging = true;
            this.grabbedItem = this._dragStartItem;
            // Remove item from original slot
            if (this._dragStartSlot !== null) {
                this.items[this._dragStartSlot] = null;
            }
        };
        /**
         * Handle hold detection for both mouse and touch.
         */
        this.onHoldDetected = () => {
            this.initiateDrag();
        };
        /**
         * Continuously check for mouse hold during tick.
         */
        this.checkForDragStart = () => {
            if (input_1.Input.mouseDown && input_1.Input.isMouseHold) {
                this.initiateDrag();
            }
            else if (input_1.Input.isTapHold) {
                this.initiateDrag();
            }
        };
        this.handleMouseUp = (x, y, button) => {
            // Ignore if not left click
            if (button !== 0)
                return;
            const invBounds = this.isPointInInventoryBounds(x, y);
            const quickbarBounds = this.isPointInQuickbarBounds(x, y);
            const isValidDropZone = this.isOpen
                ? invBounds.inBounds
                : quickbarBounds.inBounds;
            if (isValidDropZone) {
                if (this._isDragging && this.grabbedItem !== null) {
                    // We were dragging, place the item
                    const targetSlot = this.selX + this.selY * this.cols;
                    this.placeItemInSlot(targetSlot);
                }
                else if (this._dragStartItem !== null) {
                    // We had an item but weren't dragging (quick click)
                    this.itemUse();
                }
            }
            else if (this.grabbedItem !== null) {
                // Drop the item in the world
                this.dropItem(this.grabbedItem, this._dragStartSlot);
                this.grabbedItem = null;
                this.items[this._dragStartSlot] = null;
            }
            // Reset all drag/hold state
            this._isDragging = false;
            this._dragStartItem = null;
            this._dragStartSlot = null;
            this.grabbedItem = null;
        };
        this.placeItemInSlot = (targetSlot) => {
            if (this.grabbedItem === null)
                return;
            const existingItem = this.items[targetSlot];
            // If target slot is empty
            if (existingItem === null) {
                this.items[targetSlot] = this.grabbedItem;
            }
            else {
                // Swap items
                if (this._dragStartSlot !== null) {
                    this.items[this._dragStartSlot] = existingItem;
                }
                this.items[targetSlot] = this.grabbedItem;
            }
            this.grabbedItem = null;
        };
        this.game = game;
        this.player = player;
        this.buttonX =
            (Math.round(gameConstants_1.GameConstants.WIDTH / 2) + 3) / gameConstants_1.GameConstants.TILESIZE;
        this.buttonY = 10;
        input_1.Input.mouseDownListeners.push((x, y, button) => this.handleMouseDown(x, y, button));
        input_1.Input.mouseUpListeners.push((x, y, button) => this.handleMouseUp(x, y, button));
        input_1.Input.holdCallback = () => this.onHoldDetected();
        this.items = new Array((this.rows + this._expansion) * this.cols).fill(null);
        this.equipAnimAmount = new Array((this.rows + this._expansion) * this.cols).fill(0);
        let a = (i) => {
            if (i === null)
                return;
            if (i instanceof equippable_1.Equippable) {
                i.setWielder(this.player);
            }
            if (i instanceof weapon_1.Weapon && this.weapon === null) {
                i.toggleEquip();
                this.weapon = i;
                //this.player.weapon = this.weapon;
            }
            this.addItem(i);
        };
        let startingInv = gameConstants_1.GameConstants.DEVELOPER_MODE
            ? gameConstants_1.GameConstants.STARTING_DEV_INVENTORY
            : gameConstants_1.GameConstants.STARTING_INVENTORY;
        startingInv.forEach((item) => {
            a(new item({ game: this.game }, 0, 0));
        });
    }
    get isDragging() {
        return this._isDragging;
    }
    get expansion() {
        return this._expansion;
    }
    set expansion(value) {
        if (value !== this._expansion) {
            const oldTotalSlots = (this.rows + this._expansion) * this.cols;
            this._expansion = value;
            const newTotalSlots = (this.rows + this._expansion) * this.cols;
            // Resize items array
            if (newTotalSlots > oldTotalSlots) {
                this.items.push(...Array(newTotalSlots - oldTotalSlots).fill(null));
                this.equipAnimAmount.push(...Array(newTotalSlots - oldTotalSlots).fill(0));
            }
            else if (newTotalSlots < oldTotalSlots) {
                this.items.length = newTotalSlots;
                this.equipAnimAmount.length = newTotalSlots;
            }
        }
    }
    expandInventory(additionalRows) {
        this.expansion += additionalRows;
    }
}
exports.Inventory = Inventory;


/***/ }),

/***/ "./src/item/armor.ts":
/*!***************************!*\
  !*** ./src/item/armor.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Armor = void 0;
const game_1 = __webpack_require__(/*! ../game */ "./src/game.ts");
const levelConstants_1 = __webpack_require__(/*! ../levelConstants */ "./src/levelConstants.ts");
const equippable_1 = __webpack_require__(/*! ./equippable */ "./src/item/equippable.ts");
class Armor extends equippable_1.Equippable {
    constructor(level, x, y) {
        super(level, x, y);
        this.RECHARGE_TURNS = 25;
        this.coEquippable = (other) => {
            if (other instanceof Armor)
                return false;
            return true;
        };
        this.getDescription = () => {
            return ("ENCHANTED ARMOR\nA magic suit of armor. Absorbs one hit and regenerates after " +
                this.RECHARGE_TURNS +
                " turns.");
        };
        this.tickInInventory = () => {
            if (this.rechargeTurnCounter > 0) {
                this.rechargeTurnCounter--;
                if (this.rechargeTurnCounter === 0) {
                    this.rechargeTurnCounter = -1;
                    this.health = 1;
                }
            }
        };
        this.hurt = (damage) => {
            if (this.health <= 0)
                return;
            this.health -= Math.max(damage, 1);
            this.rechargeTurnCounter = this.RECHARGE_TURNS + 1;
        };
        this.drawGUI = (delta, playerHealth) => {
            if (this.rechargeTurnCounter === -1)
                game_1.Game.drawFX(5, 2, 0.75, 0.75, playerHealth * 0.75 + 0.1, levelConstants_1.LevelConstants.SCREEN_H - 1, 0.75, 0.75);
            else {
                let rechargeProportion = 1 - this.rechargeTurnCounter / this.RECHARGE_TURNS;
                if (rechargeProportion < 0.5)
                    game_1.Game.drawFX(7, 2, 0.75, 0.75, playerHealth * 0.75 + 0.1, levelConstants_1.LevelConstants.SCREEN_H - 1, 0.75, 0.75);
                else
                    game_1.Game.drawFX(8, 2, 0.75, 0.75, playerHealth * 0.75 + 0.1, levelConstants_1.LevelConstants.SCREEN_H - 1, 0.75, 0.75);
            }
        };
        this.health = 1;
        this.rechargeTurnCounter = -1;
        this.tileX = 5;
        this.tileY = 0;
    }
}
exports.Armor = Armor;
Armor.itemName = "armor";


/***/ }),

/***/ "./src/item/backpack.ts":
/*!******************************!*\
  !*** ./src/item/backpack.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Backpack = void 0;
const sound_1 = __webpack_require__(/*! ../sound */ "./src/sound.ts");
const usable_1 = __webpack_require__(/*! ./usable */ "./src/item/usable.ts");
class Backpack extends usable_1.Usable {
    constructor(level, x, y) {
        super(level, x, y);
        this.onUse = (player) => {
            if (this.level.game.rooms[player.levelID] === this.level.game.room)
                sound_1.Sound.heal();
            player.inventory.removeItem(this);
            player.inventory.expansion += 1;
            this.level.game.pushMessage("You equip the backpack, increasing the amount you can carry.");
            //this.level.items = this.level.items.filter((x) => x !== this); // removes itself from the level
        };
        this.getDescription = () => {
            return "BACKPACK\nA normal looking backpack. Increases the amount you can carry. ";
        };
        this.tileX = 4;
        this.tileY = 0;
        this.offsetY = 0;
    }
}
exports.Backpack = Backpack;
Backpack.itemName = "backpack";


/***/ }),

/***/ "./src/item/bluegem.ts":
/*!*****************************!*\
  !*** ./src/item/bluegem.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BlueGem = void 0;
const item_1 = __webpack_require__(/*! ./item */ "./src/item/item.ts");
class BlueGem extends item_1.Item {
    constructor(level, x, y) {
        super(level, x, y);
        this.getDescription = () => {
            return "ZIRCON";
        };
        this.tileX = 13;
        this.tileY = 0;
        this.stackable = true;
    }
}
exports.BlueGem = BlueGem;
BlueGem.itemName = "zircon";


/***/ }),

/***/ "./src/item/bombItem.ts":
/*!******************************!*\
  !*** ./src/item/bombItem.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BombItem = void 0;
const sound_1 = __webpack_require__(/*! ../sound */ "./src/sound.ts");
const usable_1 = __webpack_require__(/*! ./usable */ "./src/item/usable.ts");
//import { Bomb } from "../entity/object/bomb";
class BombItem extends usable_1.Usable {
    constructor(level, x, y) {
        super(level, x, y);
        this.onUse = (player) => {
            const { Bomb } = __webpack_require__(/*! ../entity/object/bomb */ "./src/entity/object/bomb.ts");
            Bomb.add(player.game.room, player.game, player.x, player.y);
            player.inventory.removeItem(this);
            sound_1.Sound.mine();
        };
        this.tileX = 20;
        this.tileY = 2;
        this.offsetY = -0.3;
        this.name = BombItem.itemName;
        this.description = "explodes";
    }
}
exports.BombItem = BombItem;
BombItem.itemName = "bomb";


/***/ }),

/***/ "./src/item/candle.ts":
/*!****************************!*\
  !*** ./src/item/candle.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Candle = void 0;
const light_1 = __webpack_require__(/*! ./light */ "./src/item/light.ts");
class Candle extends light_1.Light {
    constructor(level, x, y) {
        super(level, x, y);
        this.fuel = 50; //how many turns before it burns out
        this.tileX = 27;
        this.tileY = 0;
        this.name = "candle";
        this.fuelCap = 50;
        this.radius = 4;
        this.stackable = true;
        this.maxBrightness = 2;
        this.maxBrightness = 0.25;
    }
}
exports.Candle = Candle;
Candle.itemName = "candle";


/***/ }),

/***/ "./src/item/coal.ts":
/*!**************************!*\
  !*** ./src/item/coal.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Coal = void 0;
const usable_1 = __webpack_require__(/*! ./usable */ "./src/item/usable.ts");
const lantern_1 = __webpack_require__(/*! ./lantern */ "./src/item/lantern.ts");
const light_1 = __webpack_require__(/*! ./light */ "./src/item/light.ts");
class Coal extends usable_1.Usable {
    constructor(level, x, y) {
        super(level, x, y);
        this.onUse = (player) => {
            let l = player.inventory.hasItem(lantern_1.Lantern);
            if (l instanceof lantern_1.Lantern) {
                if (l.fuel <= l.fuelCap - 50) {
                    player.game.pushMessage("You add some fuel to your lantern.");
                    this.stackCount -= 1;
                    if (this.stackCount <= 0) {
                        player.inventory.removeItem(this);
                    }
                }
            }
        };
        this.useOnOther = (player, other) => {
            if (other instanceof light_1.Light) {
                if (other.canRefuel && other.fuel <= 0 && other.broken) {
                    let amountToRefuel = Math.min(this.stackCount * 25, other.fuelCap);
                    other.fuel += amountToRefuel;
                    this.stackCount -= amountToRefuel / 25;
                    other.broken = false;
                    this.level.game.pushMessage(`You add refuel your ${other.name} with ${amountToRefuel / 25} coal.`);
                    if (this.stackCount <= 0)
                        player.inventory.removeItem(this);
                }
            }
        };
        this.tileX = 17;
        this.tileY = 0;
        this.stackable = true;
        this.stackCount = Math.ceil(Math.random() * 7 + 3);
        this.name = Coal.itemName;
        this.description = "A piece of coal. Fuels lantern.";
        this.canUseOnOther = true;
    }
}
exports.Coal = Coal;
Coal.itemName = "coal";


/***/ }),

/***/ "./src/item/coin.ts":
/*!**************************!*\
  !*** ./src/item/coin.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Coin = void 0;
const item_1 = __webpack_require__(/*! ./item */ "./src/item/item.ts");
const sound_1 = __webpack_require__(/*! ../sound */ "./src/sound.ts");
class Coin extends item_1.Item {
    //checked: boolean;
    constructor(level, x, y) {
        super(level, x, y);
        this.onDrop = () => {
            const coinList = []; //array to store coin objects
            for (const item of this.level.items) {
                if (item instanceof Coin)
                    coinList.push(item);
            }
            for (const otherCoin of coinList) {
                if (this !== otherCoin &&
                    this.x === otherCoin.x &&
                    this.y === otherCoin.y) {
                    this.stack += otherCoin.stack;
                    this.level.items = this.level.items.filter((x) => x !== otherCoin);
                }
                if (this.stack === 2)
                    this.tileX = 20;
                else if (this.stack >= 3)
                    this.tileX = 21;
            }
        };
        this.pickupSound = () => {
            if (this.level === this.level.game.room)
                sound_1.Sound.pickupCoin();
        };
        this.tileX = 19;
        this.tileY = 0;
        this.stack = 1;
        this.stackable = true;
        this.name = Coin.itemName;
    }
    get distanceToBottomRight() {
        return Math.sqrt((this.x + this.w - window.innerWidth) ** 2 +
            (this.y + this.h - window.innerHeight) ** 2);
    }
}
exports.Coin = Coin;
Coin.itemName = "coin";


/***/ }),

/***/ "./src/item/dropTable.ts":
/*!*******************************!*\
  !*** ./src/item/dropTable.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DropTable = exports.ItemTypeMap = void 0;
const armor_1 = __webpack_require__(/*! ./armor */ "./src/item/armor.ts");
const bluegem_1 = __webpack_require__(/*! ./bluegem */ "./src/item/bluegem.ts");
const candle_1 = __webpack_require__(/*! ./candle */ "./src/item/candle.ts");
const coin_1 = __webpack_require__(/*! ./coin */ "./src/item/coin.ts");
const greengem_1 = __webpack_require__(/*! ./greengem */ "./src/item/greengem.ts");
const heart_1 = __webpack_require__(/*! ./heart */ "./src/item/heart.ts");
const redgem_1 = __webpack_require__(/*! ./redgem */ "./src/item/redgem.ts");
const weaponFragments_1 = __webpack_require__(/*! ./weaponFragments */ "./src/item/weaponFragments.ts");
const spear_1 = __webpack_require__(/*! ../weapon/spear */ "./src/weapon/spear.ts");
const warhammer_1 = __webpack_require__(/*! ../weapon/warhammer */ "./src/weapon/warhammer.ts");
const dualdagger_1 = __webpack_require__(/*! ../weapon/dualdagger */ "./src/weapon/dualdagger.ts");
const weaponPoison_1 = __webpack_require__(/*! ./weaponPoison */ "./src/item/weaponPoison.ts");
const weaponBlood_1 = __webpack_require__(/*! ./weaponBlood */ "./src/item/weaponBlood.ts");
const gold_1 = __webpack_require__(/*! ./gold */ "./src/item/gold.ts");
const stone_1 = __webpack_require__(/*! ./stone */ "./src/item/stone.ts");
const pickaxe_1 = __webpack_require__(/*! ../weapon/pickaxe */ "./src/weapon/pickaxe.ts");
const hammer_1 = __webpack_require__(/*! ./hammer */ "./src/item/hammer.ts");
const coal_1 = __webpack_require__(/*! ./coal */ "./src/item/coal.ts");
const torch_1 = __webpack_require__(/*! ./torch */ "./src/item/torch.ts");
const lantern_1 = __webpack_require__(/*! ./lantern */ "./src/item/lantern.ts");
const spellbook_1 = __webpack_require__(/*! ../weapon/spellbook */ "./src/weapon/spellbook.ts");
const spellbookPage_1 = __webpack_require__(/*! ./spellbookPage */ "./src/item/spellbookPage.ts");
const backpack_1 = __webpack_require__(/*! ./backpack */ "./src/item/backpack.ts");
const bombItem_1 = __webpack_require__(/*! ./bombItem */ "./src/item/bombItem.ts");
const greataxe_1 = __webpack_require__(/*! ../weapon/greataxe */ "./src/weapon/greataxe.ts");
exports.ItemTypeMap = {
    dualdagger: dualdagger_1.DualDagger,
    warhammer: warhammer_1.Warhammer,
    spear: spear_1.Spear,
    spellbook: spellbook_1.Spellbook,
    greataxe: greataxe_1.Greataxe,
    armor: armor_1.Armor,
    pickaxe: pickaxe_1.Pickaxe,
    hammer: hammer_1.Hammer,
    heart: heart_1.Heart,
    weaponpoison: weaponPoison_1.WeaponPoison,
    weaponblood: weaponBlood_1.WeaponBlood,
    coin: coin_1.Coin,
    weaponfragments: weaponFragments_1.WeaponFragments,
    spellbookPage: spellbookPage_1.SpellbookPage,
    backpack: backpack_1.Backpack,
    candle: candle_1.Candle,
    torch: torch_1.Torch,
    lantern: lantern_1.Lantern,
    redgem: redgem_1.RedGem,
    bluegem: bluegem_1.BlueGem,
    greengem: greengem_1.GreenGem,
    gold: gold_1.Gold,
    stone: stone_1.Stone,
    coal: coal_1.Coal,
    bomb: bombItem_1.BombItem,
};
class DropTable {
}
exports.DropTable = DropTable;
_a = DropTable;
DropTable.drops = [
    // Weapons
    { itemType: "dualdagger", dropWeight: 1, category: ["weapon", "melee"] },
    { itemType: "warhammer", dropWeight: 3, category: ["weapon", "melee"] },
    { itemType: "spear", dropWeight: 3, category: ["weapon", "melee"] },
    { itemType: "spellbook", dropWeight: 1, category: ["weapon", "magic"] },
    { itemType: "greataxe", dropWeight: 1, category: ["weapon", "melee"] },
    // Equipment
    { itemType: "armor", dropWeight: 8, category: ["equipment"] },
    // Tools
    { itemType: "pickaxe", dropWeight: 3, category: ["tool"] },
    { itemType: "hammer", dropWeight: 3, category: ["tool"] },
    // Consumables
    { itemType: "heart", dropWeight: 5, category: ["consumable"] },
    { itemType: "weaponpoison", dropWeight: 1, category: ["consumable"] },
    { itemType: "weaponblood", dropWeight: 1, category: ["consumable"] },
    { itemType: "coin", dropWeight: 100, category: ["coin"] },
    {
        itemType: "weaponfragments",
        dropWeight: 5,
        category: ["consumable", "melee"],
    },
    {
        itemType: "spellbookPage",
        dropWeight: 2,
        category: ["consumable", "magic"],
    },
    // Upgrades
    { itemType: "backpack", dropWeight: 5, category: ["upgrade"] },
    // Light sources
    { itemType: "candle", dropWeight: 10, category: ["light"] },
    { itemType: "torch", dropWeight: 5, category: ["light"] },
    { itemType: "lantern", dropWeight: 2, category: ["light"] },
    // Gems and minerals
    { itemType: "redgem", dropWeight: 5, category: ["gem", "resource"] },
    { itemType: "bluegem", dropWeight: 5, category: ["gem", "resource"] },
    { itemType: "greengem", dropWeight: 5, category: ["gem", "resource"] },
    { itemType: "gold", dropWeight: 5, category: ["gem", "resource"] },
    { itemType: "stone", dropWeight: 5, category: ["gem", "resource"] },
    {
        itemType: "coal",
        dropWeight: 15,
        category: ["fuel", "lantern", "resource"],
    },
    { itemType: "bomb", dropWeight: 10, category: ["bomb", "weapon"] },
];
DropTable.getDrop = (entity, uniqueTable = false, useCategory = ["coin"], force = false, currentDepth = 0) => {
    let filteredDropsByCategory = [];
    let filteredDropsByItem = [];
    let filteredDropsByDepth = [];
    const allCategories = Array.from(new Set(_a.drops.flatMap((drop) => drop.category)));
    const allItemTypes = Object.keys(exports.ItemTypeMap);
    const allDepth = _a.drops.map((drop) => drop.minDepth);
    // Separate categories and specific item names from useCategory
    const categories = useCategory.filter((cat) => allCategories.includes(cat));
    const specificItems = useCategory.filter((item) => allItemTypes.includes(item));
    const itemsByDepth = _a.drops.filter((drop) => drop.minDepth === undefined || drop.minDepth <= currentDepth);
    // Get drops from specified categories
    if (categories.length > 0) {
        filteredDropsByCategory = itemsByDepth.filter((drop) => drop.category.some((cat) => categories.includes(cat)));
    }
    // Get specific drops by item name
    if (specificItems.length > 0) {
        filteredDropsByItem = itemsByDepth.filter((drop) => specificItems.includes(drop.itemType));
    }
    // Combine and remove duplicates
    const combinedDropsMap = {};
    filteredDropsByCategory.forEach((drop) => {
        combinedDropsMap[drop.itemType] = drop;
    });
    filteredDropsByItem.forEach((drop) => {
        combinedDropsMap[drop.itemType] = drop;
    });
    let combinedDrops = Object.values(combinedDropsMap);
    // If no categories or specific items matched, use items by depth
    if (combinedDrops.length === 0) {
        combinedDrops = itemsByDepth;
    }
    if (combinedDrops.length === 0) {
        if (force) {
            combinedDrops = itemsByDepth;
            if (combinedDrops.length === 0)
                return null;
        }
        else
            return null;
    }
    const totalWeight = combinedDrops.reduce((acc, drop) => acc + drop.dropWeight, 0);
    const randomWeight = Math.floor(Math.random() * totalWeight);
    let cumulativeWeight = 0;
    for (const drop of combinedDrops) {
        cumulativeWeight += drop.dropWeight;
        if (randomWeight <= cumulativeWeight) {
            _a.addNewItem(drop.itemType, entity);
            return;
        }
    }
    if (force && combinedDrops.length > 0) {
        _a.addNewItem(combinedDrops[0].itemType, entity);
        return;
    }
    return null;
};
DropTable.addNewItem = (itemType, entity) => {
    const ItemClass = exports.ItemTypeMap[itemType];
    if (!ItemClass) {
        console.error(`Item type "${itemType}" is not recognized.`);
        return;
    }
    entity.drop = ItemClass.add(entity.room, entity.x, entity.y);
    //console.log(
    //  `Drop for ${entity.constructor.name}:`,
    //  entity.drop.constructor.name,
    //);
};


/***/ }),

/***/ "./src/item/equippable.ts":
/*!********************************!*\
  !*** ./src/item/equippable.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Equippable = void 0;
const item_1 = __webpack_require__(/*! ./item */ "./src/item/item.ts");
const game_1 = __webpack_require__(/*! ../game */ "./src/game.ts");
class Equippable extends item_1.Item {
    constructor(level, x, y) {
        super(level, x, y);
        this.equipTick = false;
        this.setWielder = (wielder) => {
            this.wielder = wielder;
        };
        this.coEquippable = (other) => {
            return true;
        };
        this.toggleEquip = () => {
            this.equipped = !this.equipped;
            if (this.broken) {
                this.equipped = false;
                let pronoun = this.name.endsWith("s") ? "them" : "it";
                this.level.game.pushMessage("You'll have to fix your " +
                    this.name +
                    " before you can use " +
                    pronoun +
                    ".");
            }
        };
        this.drawEquipped = (delta, x, y) => {
            game_1.Game.drawItem(this.tileX, this.tileY, 1, 2, x, y - 1, this.w, this.h);
        };
        this.degrade = (degradeAmount = 1) => {
            this.durability -= degradeAmount;
            if (this.durability <= 0)
                this.break();
        };
        this.break = () => {
            this.durability = 0;
            this.broken = true;
            this.toggleEquip();
            //this.wielder.inventory.removeItem(this);
            //this.wielder = null;
        };
        this.onDrop = () => { };
        this.dropFromInventory = () => {
            this.wielder = null;
            this.equipped = false;
        };
        this.equipped = false;
    }
}
exports.Equippable = Equippable;


/***/ }),

/***/ "./src/item/godStone.ts":
/*!******************************!*\
  !*** ./src/item/godStone.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GodStone = void 0;
const room_1 = __webpack_require__(/*! ../room/room */ "./src/room/room.ts");
const usable_1 = __webpack_require__(/*! ./usable */ "./src/item/usable.ts");
class GodStone extends usable_1.Usable {
    constructor(level, x, y) {
        super(level, x, y);
        this.onUse = (player) => {
            this.teleportToExit(player);
        };
        this.teleportToExit = (player) => {
            let downLadders = this.room.game.rooms.filter((room) => room.type === room_1.RoomType.DOWNLADDER);
            console.log("downLadders", downLadders);
            const room = downLadders[downLadders.length - 1];
            this.room.game.rooms.forEach((room) => {
                room.entered = true;
                room.calculateWallInfo();
            });
            room.game.changeLevelThroughDoor(player, room.doors[0], 1);
            player.x = room.roomX + 2;
            player.y = room.roomY + 3;
        };
        this.getDescription = () => {
            return "YOU SHOULD NOT HAVE THIS";
        };
        this.room = level;
        this.count = 0;
        this.tileX = 31;
        this.tileY = 0;
        this.stackable = true;
    }
}
exports.GodStone = GodStone;


/***/ }),

/***/ "./src/item/gold.ts":
/*!**************************!*\
  !*** ./src/item/gold.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Gold = void 0;
const item_1 = __webpack_require__(/*! ./item */ "./src/item/item.ts");
class Gold extends item_1.Item {
    constructor(level, x, y) {
        super(level, x, y);
        this.tileX = 18;
        this.tileY = 0;
        this.name = Gold.itemName;
        this.stackable = true;
        this.description = "A bar of gold";
    }
}
exports.Gold = Gold;
Gold.itemName = "gold";


/***/ }),

/***/ "./src/item/goldenKey.ts":
/*!*******************************!*\
  !*** ./src/item/goldenKey.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GoldenKey = void 0;
const equippable_1 = __webpack_require__(/*! ./equippable */ "./src/item/equippable.ts");
class GoldenKey extends equippable_1.Equippable {
    constructor(level, x, y) {
        super(level, x, y);
        this.getDescription = () => {
            return "GOLD KEY\nA heavy gold key.";
        };
        this.tileX = 6;
        this.tileY = 0;
    }
}
exports.GoldenKey = GoldenKey;
GoldenKey.itemName = "goldenKey";


/***/ }),

/***/ "./src/item/greengem.ts":
/*!******************************!*\
  !*** ./src/item/greengem.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GreenGem = void 0;
const item_1 = __webpack_require__(/*! ./item */ "./src/item/item.ts");
class GreenGem extends item_1.Item {
    constructor(level, x, y) {
        super(level, x, y);
        this.getDescription = () => {
            return "PERIDOT";
        };
        this.tileX = 11;
        this.tileY = 0;
        this.stackable = true;
    }
}
exports.GreenGem = GreenGem;
GreenGem.itemName = "peridot";


/***/ }),

/***/ "./src/item/hammer.ts":
/*!****************************!*\
  !*** ./src/item/hammer.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Hammer = void 0;
const sound_1 = __webpack_require__(/*! ../sound */ "./src/sound.ts");
const usable_1 = __webpack_require__(/*! ./usable */ "./src/item/usable.ts");
const weapon_1 = __webpack_require__(/*! ../weapon/weapon */ "./src/weapon/weapon.ts");
const weaponFragments_1 = __webpack_require__(/*! ./weaponFragments */ "./src/item/weaponFragments.ts");
class Hammer extends usable_1.Usable {
    constructor(level, x, y) {
        super(level, x, y);
        this.onUse = (player) => {
            player.health = Math.min(player.maxHealth, player.health + 1);
            if (this.level.game.rooms[player.levelID] === this.level.game.room)
                sound_1.Sound.heal();
            //this.level.items = this.level.items.filter((x) => x !== this); // removes itself from the level
        };
        this.useOnOther = (player, other) => {
            if (other instanceof weapon_1.Weapon && other.name !== "dagger") {
                other.disassemble();
            }
            else if (other.name === "dagger") {
                this.level.game.pushMessage(`You probably shouldn't disassemble your dagger...`);
            }
            else if (other.name === "hammer" && other !== this) {
                let hammer = other;
                hammer.disassemble(player);
                this.level.game.pushMessage(`I only needed one of those anyways...`);
            }
        };
        this.disassemble = (player) => {
            let inventoryX = this.x;
            let inventoryY = this.y;
            let numFragments = Math.ceil(Math.random() * 5 + 5);
            player.inventory.removeItem(this);
            player.inventory.addItem(new weaponFragments_1.WeaponFragments(this.level, inventoryX, inventoryY, numFragments));
        };
        this.tileX = 21;
        this.tileY = 2;
        this.offsetY = -0.3;
        this.canUseOnOther = true;
        this.description = "useful for breaking weapons down into fragments";
        this.name = Hammer.itemName;
    }
}
exports.Hammer = Hammer;
Hammer.itemName = "hammer";


/***/ }),

/***/ "./src/item/heart.ts":
/*!***************************!*\
  !*** ./src/item/heart.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Heart = void 0;
const sound_1 = __webpack_require__(/*! ../sound */ "./src/sound.ts");
const usable_1 = __webpack_require__(/*! ./usable */ "./src/item/usable.ts");
class Heart extends usable_1.Usable {
    constructor(level, x, y) {
        super(level, x, y);
        this.onUse = (player) => {
            if (player.health < player.maxHealth) {
                player.health = Math.min(player.maxHealth, player.health + 1);
                if (this.level.game.rooms[player.levelID] === this.level.game.room)
                    sound_1.Sound.heal();
                player.inventory.removeItem(this);
            }
            //this.level.items = this.level.items.filter((x) => x !== this); // removes itself from the level
        };
        this.tileX = 8;
        this.tileY = 0;
        this.offsetY = -0.3;
        this.name = Heart.itemName;
        this.description = "restores 1 health";
    }
}
exports.Heart = Heart;
Heart.itemName = "health potion";


/***/ }),

/***/ "./src/item/item.ts":
/*!**************************!*\
  !*** ./src/item/item.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Item = void 0;
const game_1 = __webpack_require__(/*! ../game */ "./src/game.ts");
const gameConstants_1 = __webpack_require__(/*! ../gameConstants */ "./src/gameConstants.ts");
const sound_1 = __webpack_require__(/*! ../sound */ "./src/sound.ts");
const drawable_1 = __webpack_require__(/*! ../drawable */ "./src/drawable.ts");
const utils_1 = __webpack_require__(/*! ../utils */ "./src/utils.ts");
// Item class extends Drawable class and represents an item in the game
class Item extends drawable_1.Drawable {
    // Constructor for the Item class
    constructor(level, x, y) {
        super();
        // Empty tick function to be overridden by subclasses
        this.tick = () => { };
        // Empty tick function for inventory behavior to be overridden by subclasses
        this.tickInInventory = () => { };
        // Function to get description of the item, to be overridden by subclasses
        this.getDescription = () => {
            const stackText = this.stackable ? `\nAmount: ${this.stackCount}` : "";
            return `${this.name} \n${this.description} \n${stackText}`;
        };
        this.animateFromChest = () => {
            this.chestOffsetY = 0.5;
            this.alpha = 0;
            this.inChest = true;
            this.sineAnimateFactor = 0;
        };
        // Function to play sound when item is picked up
        this.pickupSound = () => {
            if (this.level === this.level.game.room)
                sound_1.Sound.genericPickup();
        };
        // Empty function to be called when item is dropped, to be overridden by subclasses
        this.onDrop = () => { };
        // Function to be called when item is picked up
        this.onPickup = (player) => {
            if (!this.pickedUp) {
                this.startY = player.y;
                this.drawableY = this.y;
                this.alpha = 1;
                this.pickedUp = player.inventory.addItem(this);
                if (this.pickedUp)
                    this.pickupSound();
            }
        };
        this.dropFromInventory = () => {
            this.setDrawOffset();
        };
        // Function to get the amount of shade at the item's location
        this.shadeAmount = () => {
            if (!this.x || !this.y)
                return 0;
            else
                return this.level.softVis[this.x][this.y];
        };
        this.drawStatus = (x, y) => { };
        this.drawBrokenSymbol = (x, y) => {
            if (this.broken) {
                game_1.Game.drawFX(5, 0, 1, 1, x - 0.5 / gameConstants_1.GameConstants.TILESIZE, y - 0.5 / gameConstants_1.GameConstants.TILESIZE, 1, 1);
            }
        };
        // Function to draw the item
        this.draw = (delta) => {
            game_1.Game.ctx.save();
            if (!this.pickedUp) {
                game_1.Game.ctx.globalAlpha = this.alpha;
                if (this.alpha < 1)
                    this.alpha += 0.01 * delta;
                this.drawableY = this.y;
                if (this.inChest) {
                    this.chestOffsetY -= Math.abs(this.chestOffsetY + 0.5) * 0.035 * delta;
                    if (this.chestOffsetY < -0.47) {
                        this.chestOffsetY = -0.5;
                    }
                }
                if (this.sineAnimateFactor < 1 && this.chestOffsetY < -0.45)
                    this.sineAnimateFactor += 0.2 * delta;
                if (this.scaleFactor > 0)
                    this.scaleFactor *= 0.5 ** delta;
                else
                    this.scaleFactor = 0;
                const scale = 1 / (this.scaleFactor + 1);
                game_1.Game.ctx.imageSmoothingEnabled = false;
                game_1.Game.drawItem(0, 0, 1, 1, this.x, this.y, 1, 1);
                this.frame += (delta * (Math.PI * 2)) / 60;
                game_1.Game.drawItem(this.tileX, this.tileY, 1, 2, this.x + this.w * (scale * -0.5 + 0.5) + this.drawOffset, this.y +
                    this.sineAnimateFactor * Math.sin(this.frame) * 0.07 -
                    1 +
                    this.offsetY +
                    this.h * (scale * -0.5 + 0.5) +
                    this.chestOffsetY, this.w * scale, this.h * scale, this.level.shadeColor, this.shadeAmount());
            }
            game_1.Game.ctx.restore();
        };
        this.setDrawOffset = () => {
            const itemsOnTile = this.level.items.filter((item) => item.x === this.x && item.y === this.y);
            if (itemsOnTile.length > 1) {
                itemsOnTile.forEach((item) => {
                    item.drawOffset =
                        (-itemsOnTile.length / 2 + itemsOnTile.indexOf(item) + 1) /
                            itemsOnTile.length;
                });
            }
        };
        this.degrade = () => {
            this.durability -= 1;
        };
        // Function to draw the top layer of the item
        this.drawTopLayer = (delta) => {
            if (this.pickedUp) {
                this.pickupOffsetY += (4.5 - this.pickupOffsetY) * 0.1 * delta;
                //this.x += (Math.sin(Date.now() / 50) * delta) / 10;
                this.alpha *= 0.9 ** delta;
                if (Math.abs(this.alpha) < 0.01) {
                    this.drawOffset = 0;
                    this.pickupOffsetY = 1;
                    this.level.items = this.level.items.filter((x) => x !== this);
                }
                if (gameConstants_1.GameConstants.ALPHA_ENABLED)
                    game_1.Game.ctx.globalAlpha = Math.max(0, this.alpha);
                game_1.Game.drawItem(this.tileX, this.tileY, 1, 2, this.x, this.y - this.pickupOffsetY, this.w, this.h);
                game_1.Game.ctx.globalAlpha = 1.0;
            }
        };
        // Function to draw the item's icon
        this.drawIcon = (delta, x, y, opacity = 1, count) => {
            if (gameConstants_1.GameConstants.ALPHA_ENABLED)
                game_1.Game.ctx.globalAlpha = opacity;
            this.drawDurability(x, y);
            let shake = 0;
            if (this.durability <= 1 && !this.broken)
                shake =
                    Math.round(Math.sin(Date.now() / 25) + 1 / 2) /
                        2 /
                        gameConstants_1.GameConstants.TILESIZE;
            game_1.Game.drawItem(this.tileX, this.tileY, 1, 2, x + shake, y - 1 + this.iconOffset, this.w, this.h);
            game_1.Game.ctx.globalAlpha = 1;
            let countToUse = count ? count : this.stackCount;
            let countText = countToUse <= 1 ? "" : "" + countToUse;
            let width = game_1.Game.measureText(countText).width;
            let countX = 16 - width;
            let countY = 10;
            game_1.Game.fillTextOutline(countText, x * gameConstants_1.GameConstants.TILESIZE + countX, y * gameConstants_1.GameConstants.TILESIZE + countY, gameConstants_1.GameConstants.OUTLINE, "white");
            this.drawStatus(x, y);
            this.drawBrokenSymbol(x, y);
        };
        // Function to draw the item's durability bar with color transitioning from green to red
        this.drawDurability = (x, y) => {
            if (this.durability < this.durabilityMax) {
                // Calculate durability ratio (1 = full, 0 = broken)
                const durabilityRatio = this.durability / this.durabilityMax;
                // Map durability ratio to hue (120 = green, 0 = red)
                let color = utils_1.Utils.hsvToHex(120 * durabilityRatio, // Hue from 120 (green) to 0 (red)
                1, // Full saturation
                1);
                const iconWidth = gameConstants_1.GameConstants.TILESIZE;
                const barWidth = Math.ceil(durabilityRatio * iconWidth); // Round to nearest pixel
                const barHeight = 2; // 2 pixels tall
                // Calculate the position of the durability bar
                const barX = Math.ceil(x * gameConstants_1.GameConstants.TILESIZE); // Round to nearest pixel
                const barY = Math.ceil(y * gameConstants_1.GameConstants.TILESIZE + gameConstants_1.GameConstants.TILESIZE - 2); // Round to nearest pixel
                // Set the fill style for the durability bar
                game_1.Game.ctx.fillStyle = color;
                game_1.Game.ctx.imageSmoothingEnabled = false;
                // Draw the durability bar
                game_1.Game.ctx.fillRect(barX, barY, barWidth, barHeight);
                // Reset settings
                game_1.Game.ctx.fillStyle = "white";
            }
        };
        // Initialize properties
        this.level = level;
        this.x = x;
        this.y = y;
        this.drawableY = y;
        this.w = 1;
        this.h = 2;
        this.tileX = 0;
        this.tileY = 0;
        this.frame = 0;
        this.stackable = false;
        this.stackCount = 1;
        this.pickedUp = false;
        this.alpha = 1;
        this.scaleFactor = 5;
        this.offsetY = -0.25;
        this.name = "";
        this.startY = y;
        this.randomOffset = Math.random();
        this.durability = 50;
        this.durabilityMax = 50;
        this.broken = false;
        this.description = "";
        this.drawOffset = 0;
        this.pickupOffsetY = 1;
        this.chestOffsetY = 0;
        this.sineAnimateFactor = 1;
        this.iconOffset = 0;
    }
    static add(room, x, y, ...rest) {
        return new this(room, x, y, ...rest);
    }
}
exports.Item = Item;


/***/ }),

/***/ "./src/item/key.ts":
/*!*************************!*\
  !*** ./src/item/key.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Key = void 0;
const item_1 = __webpack_require__(/*! ./item */ "./src/item/item.ts");
const sound_1 = __webpack_require__(/*! ../sound */ "./src/sound.ts");
class Key extends item_1.Item {
    constructor(level, x, y) {
        super(level, x, y);
        this.getDescription = () => {
            return "KEY\nAn iron key.";
        };
        this.onPickup = (player) => {
            if (!this.pickedUp) {
                this.pickedUp = player.inventory.addItem(this);
                if (this.pickedUp)
                    sound_1.Sound.keyPickup();
            }
        };
        this.tileX = 1;
        this.tileY = 0;
    }
}
exports.Key = Key;
Key.itemName = "key";


/***/ }),

/***/ "./src/item/lantern.ts":
/*!*****************************!*\
  !*** ./src/item/lantern.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Lantern = void 0;
const light_1 = __webpack_require__(/*! ./light */ "./src/item/light.ts");
class Lantern extends light_1.Light {
    constructor(level, x, y) {
        super(level, x, y);
        this.getDescription = () => {
            const percentage = Math.round((this.fuel / this.fuelCap) * 100);
            return `LANTERN - Fuel: ${percentage}%, Capacity: ${this.fuelCap / 50}`;
        };
        this.fuel = 0;
        this.tileX = 29;
        this.tileY = 0;
        this.fuelCap = 250;
        this.name = "lantern";
        this.canRefuel = true;
        this.maxBrightness = 20;
        this.minBrightness = 5;
        this.radius = 7;
        this.broken = this.fuel <= 0 ? true : false;
    }
}
exports.Lantern = Lantern;
Lantern.itemName = "lantern";


/***/ }),

/***/ "./src/item/light.ts":
/*!***************************!*\
  !*** ./src/item/light.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Light = void 0;
const game_1 = __webpack_require__(/*! ../game */ "./src/game.ts");
const equippable_1 = __webpack_require__(/*! ./equippable */ "./src/item/equippable.ts");
const gameConstants_1 = __webpack_require__(/*! ../gameConstants */ "./src/gameConstants.ts");
const utils_1 = __webpack_require__(/*! ../utils */ "./src/utils.ts");
class Light extends equippable_1.Equippable {
    constructor(level, x, y) {
        super(level, x, y);
        this.canRefuel = false;
        this.updateLighting = () => {
            this.wielder.game.rooms[this.wielder.levelID].updateLighting();
        };
        this.isIgnited = () => {
            if (this.fuel > 0 && this.equipped) {
                return true;
            }
            return false;
        };
        this.setRadius = () => {
            this.wielder.sightRadius = this.radius + this.fuelPercentage * this.radius;
        };
        this.setBrightness = () => {
            this.wielder.lightBrightness =
                this.minBrightness + this.fuelPercentage * this.maxBrightness;
        };
        this.toggleEquip = () => {
            if (this.fuel > 0) {
                this.equipped = !this.equipped;
                if (this.isIgnited()) {
                    //this.setRadius();
                    this.setBrightness();
                    this.wielder.lightEquipped = true;
                }
                else {
                    //this.resetRadius();
                    this.resetBrightness();
                    this.wielder.lightEquipped = false;
                }
            }
            else {
                this.wielder.game.pushMessage("I'll need some fuel before I can use this");
            }
            this.updateLighting();
        };
        this.coEquippable = (other) => {
            return !(other instanceof Light);
        };
        this.resetRadius = () => {
            this.wielder.sightRadius = this.wielder.defaultSightRadius;
        };
        this.resetBrightness = () => {
            this.wielder.lightBrightness = 0.5;
        };
        this.burn = () => {
            // Handle active burning
            if (this.isIgnited()) {
                this.fuel--;
                this.setRadius();
                this.setBrightness();
            }
            // Handle depleted fuel
            if (this.fuel <= 0) {
                if (this.stackable) {
                    this.stackCount--;
                    this.fuel = this.fuelCap;
                }
                // Check if item should be removed after stack reduction
                if (this.equipped) {
                    if ((this.stackable && this.stackCount <= 0) ||
                        (!this.stackable && !this.canRefuel)) {
                        this.resetRadius();
                        this.wielder.lightEquipped = false;
                        this.wielder.inventory.removeItem(this);
                        this.wielder.game.pushMessage(`${this.name} depletes.`);
                    }
                    else if (this.canRefuel) {
                        this.wielder.game.pushMessage(`${this.name} depletes.`);
                        this.equipped = false;
                        this.resetRadius();
                        this.wielder.lightEquipped = false;
                        this.broken = true;
                    }
                    this.updateLighting();
                }
            }
        };
        this.drawDurability = (x, y) => {
            if (this.fuel < this.fuelCap) {
                // Calculate durability ratio (1 = full, 0 = broken)
                const durabilityRatio = this.fuel / this.fuelCap;
                // Map durability ratio to hue (120 = green, 0 = red)
                let color = utils_1.Utils.hsvToHex(120 * durabilityRatio, // Hue from 120 (green) to 0 (red)
                1, // Full saturation
                1);
                const iconWidth = gameConstants_1.GameConstants.TILESIZE;
                const barWidth = durabilityRatio * iconWidth;
                const barHeight = 2; // 2 pixels tall
                // Calculate the position of the durability bar
                const barX = x * gameConstants_1.GameConstants.TILESIZE;
                const barY = y * gameConstants_1.GameConstants.TILESIZE + gameConstants_1.GameConstants.TILESIZE - 2;
                // Set the fill style for the durability bar
                game_1.Game.ctx.fillStyle = color;
                // Set the interpolation mode to nearest neighbor
                game_1.Game.ctx.imageSmoothingEnabled = false;
                // Draw the durability bar
                game_1.Game.ctx.fillRect(barX, barY, barWidth, barHeight);
                // Reset fill style to default
                game_1.Game.ctx.fillStyle = "white";
            }
        };
        this.tickInInventory = () => {
            this.burn();
        };
        this.getDescription = () => {
            return `${this.name}: ${Math.ceil(this.fuelPercentage * 100)}%`;
        };
        this.tileX = 28;
        this.tileY = 0;
        this.fuel = 0;
        this.fuelCap = 250;
        this.maxBrightness = 5;
        this.minBrightness = 2;
        this.radius = 6;
        this.equipped = false;
    }
    get fuelPercentage() {
        return this.fuel / this.fuelCap;
    }
}
exports.Light = Light;


/***/ }),

/***/ "./src/item/redgem.ts":
/*!****************************!*\
  !*** ./src/item/redgem.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RedGem = void 0;
const item_1 = __webpack_require__(/*! ./item */ "./src/item/item.ts");
class RedGem extends item_1.Item {
    constructor(level, x, y) {
        super(level, x, y);
        this.getDescription = () => {
            return "GARNET";
        };
        this.tileX = 12;
        this.tileY = 0;
        this.stackable = true;
    }
}
exports.RedGem = RedGem;
RedGem.itemName = "garnet";


/***/ }),

/***/ "./src/item/spellbookPage.ts":
/*!***********************************!*\
  !*** ./src/item/spellbookPage.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SpellbookPage = void 0;
const sound_1 = __webpack_require__(/*! ../sound */ "./src/sound.ts");
const usable_1 = __webpack_require__(/*! ./usable */ "./src/item/usable.ts");
const equippable_1 = __webpack_require__(/*! ./equippable */ "./src/item/equippable.ts");
class SpellbookPage extends usable_1.Usable {
    constructor(level, x, y, stackCount) {
        super(level, x, y);
        this.onUse = (player) => {
            player.health = Math.min(player.maxHealth, player.health + 1);
            if (this.level.game.rooms[player.levelID] === this.level.game.room)
                sound_1.Sound.heal();
            player.inventory.removeItem(this);
            //this.level.items = this.level.items.filter((x) => x !== this); // removes itself from the level
        };
        this.useOnOther = (player, other) => {
            if (other instanceof equippable_1.Equippable &&
                other.broken &&
                other.name === "spellbook") {
                let repairAmount = Math.min(other.durabilityMax - other.durability, this.stackCount);
                other.durability += repairAmount;
                this.stackCount -= repairAmount;
                other.broken = false;
                this.level.game.pushMessage(`You feel your ${other.name}'s power return as you add ${repairAmount} pages to it.`);
                if (this.stackCount <= 0)
                    player.inventory.removeItem(this);
            }
        };
        this.tileX = 25;
        this.tileY = 2;
        this.offsetY = -0.3;
        this.name = "spellbook pages";
        this.canUseOnOther = true;
        this.stackable = true;
        this.stackCount = stackCount || Math.ceil(Math.random() * 3);
        this.description = "Can be used to restore power to a depleted spellbook";
    }
}
exports.SpellbookPage = SpellbookPage;
SpellbookPage.itemName = "weapon fragments";


/***/ }),

/***/ "./src/item/stone.ts":
/*!***************************!*\
  !*** ./src/item/stone.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Stone = void 0;
const item_1 = __webpack_require__(/*! ./item */ "./src/item/item.ts");
class Stone extends item_1.Item {
    constructor(level, x, y) {
        super(level, x, y);
        this.getDescription = () => {
            return "STONE\nSome fragments of stone.";
        };
        this.tileX = 15;
        this.tileY = 0;
        this.stackable = true;
    }
}
exports.Stone = Stone;
Stone.itemName = "stones";


/***/ }),

/***/ "./src/item/torch.ts":
/*!***************************!*\
  !*** ./src/item/torch.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Torch = void 0;
const light_1 = __webpack_require__(/*! ./light */ "./src/item/light.ts");
class Torch extends light_1.Light {
    constructor(level, x, y) {
        super(level, x, y);
        this.tileX = 28;
        this.tileY = 0;
        this.name = "torch";
        this.fuelCap = 250;
        this.fuel = 250;
        this.radius = 7;
        this.maxBrightness = 5;
        this.minBrightness = 2;
    }
}
exports.Torch = Torch;
Torch.itemName = "torch";


/***/ }),

/***/ "./src/item/usable.ts":
/*!****************************!*\
  !*** ./src/item/usable.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Usable = void 0;
const item_1 = __webpack_require__(/*! ./item */ "./src/item/item.ts");
class Usable extends item_1.Item {
    constructor(level, x, y) {
        super(level, x, y);
        this.onUse = (player) => { };
        this.useOnOther = (player, other) => { };
        this.canUseOnOther = false;
    }
}
exports.Usable = Usable;


/***/ }),

/***/ "./src/item/weaponBlood.ts":
/*!*********************************!*\
  !*** ./src/item/weaponBlood.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WeaponBlood = void 0;
const sound_1 = __webpack_require__(/*! ../sound */ "./src/sound.ts");
const usable_1 = __webpack_require__(/*! ./usable */ "./src/item/usable.ts");
const weapon_1 = __webpack_require__(/*! ../weapon/weapon */ "./src/weapon/weapon.ts");
class WeaponBlood extends usable_1.Usable {
    constructor(level, x, y) {
        super(level, x, y);
        this.onUse = (player) => {
            player.health = Math.min(player.maxHealth, player.health + 1);
            if (this.level.game.rooms[player.levelID] === this.level.game.room)
                sound_1.Sound.heal();
            //this.level.items = this.level.items.filter((x) => x !== this); // removes itself from the level
        };
        this.useOnOther = (player, other) => {
            if (other instanceof weapon_1.Weapon) {
                other.applyStatus({ blood: true, poison: false });
                player.inventory.removeItem(this);
                this.level.game.pushMessage(`You coat your ${other.name} in cursed blood.`);
            }
        };
        this.getDescription = () => {
            return "WEAPON BLOOD\nCan be applied to weapons to deal bleed damage";
        };
        this.tileX = 12;
        this.tileY = 4;
        this.offsetY = -0.3;
        this.canUseOnOther = true;
    }
}
exports.WeaponBlood = WeaponBlood;
WeaponBlood.itemName = "cursed blood";


/***/ }),

/***/ "./src/item/weaponFragments.ts":
/*!*************************************!*\
  !*** ./src/item/weaponFragments.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WeaponFragments = void 0;
const sound_1 = __webpack_require__(/*! ../sound */ "./src/sound.ts");
const usable_1 = __webpack_require__(/*! ./usable */ "./src/item/usable.ts");
const equippable_1 = __webpack_require__(/*! ./equippable */ "./src/item/equippable.ts");
class WeaponFragments extends usable_1.Usable {
    constructor(level, x, y, stackCount) {
        super(level, x, y);
        this.onUse = (player) => {
            player.health = Math.min(player.maxHealth, player.health + 1);
            if (this.level.game.rooms[player.levelID] === this.level.game.room)
                sound_1.Sound.heal();
            player.inventory.removeItem(this);
            //this.level.items = this.level.items.filter((x) => x !== this); // removes itself from the level
        };
        this.useOnOther = (player, other) => {
            if (other instanceof equippable_1.Equippable &&
                other.durabilityMax - other.durability >= 1 &&
                other.name !== "spellbook") {
                let repairAmount = Math.min(other.durabilityMax - other.durability, this.stackCount);
                other.durability += repairAmount;
                this.stackCount -= repairAmount;
                other.broken = false;
                this.level.game.pushMessage(`You repair your ${other.name} with ${repairAmount} fragments.`);
                if (this.stackCount <= 0)
                    player.inventory.removeItem(this);
            }
            else if (other.name === "spellbook") {
                this.level.game.pushMessage("You'll need some book pages to replenish that.");
            }
        };
        this.tileX = 3;
        this.tileY = 0;
        this.offsetY = -0.3;
        this.name = "weapon fragments";
        this.canUseOnOther = true;
        this.stackable = true;
        this.stackCount = stackCount || Math.ceil(Math.random() * 10) + 7;
        this.description = "Can be used to repair broken weapons";
    }
}
exports.WeaponFragments = WeaponFragments;
WeaponFragments.itemName = "weapon fragments";


/***/ }),

/***/ "./src/item/weaponPoison.ts":
/*!**********************************!*\
  !*** ./src/item/weaponPoison.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WeaponPoison = void 0;
const sound_1 = __webpack_require__(/*! ../sound */ "./src/sound.ts");
const usable_1 = __webpack_require__(/*! ./usable */ "./src/item/usable.ts");
const weapon_1 = __webpack_require__(/*! ../weapon/weapon */ "./src/weapon/weapon.ts");
class WeaponPoison extends usable_1.Usable {
    constructor(level, x, y) {
        super(level, x, y);
        this.onUse = (player) => {
            player.health = Math.min(player.maxHealth, player.health + 1);
            if (this.level.game.rooms[player.levelID] === this.level.game.room)
                sound_1.Sound.heal();
            //this.level.items = this.level.items.filter((x) => x !== this); // removes itself from the level
        };
        this.useOnOther = (player, other) => {
            if (other instanceof weapon_1.Weapon) {
                other.applyStatus({ poison: true, blood: false });
                player.inventory.removeItem(this);
                this.level.game.pushMessage(`You apply the poison to your ${other.name}.`);
                console.log(`weapon poison used on ${other.name}`);
            }
        };
        this.getDescription = () => {
            return "WEAPON POISON\nCan be applied to weapons to deal poison damage";
        };
        this.tileX = 11;
        this.tileY = 4;
        this.offsetY = -0.3;
        this.canUseOnOther = true;
    }
}
exports.WeaponPoison = WeaponPoison;
WeaponPoison.itemName = "weapon poison";


/***/ }),

/***/ "./src/level.ts":
/*!**********************!*\
  !*** ./src/level.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Level = exports.enemyMinimumDepth = void 0;
const room_1 = __webpack_require__(/*! ./room/room */ "./src/room/room.ts");
const environment_1 = __webpack_require__(/*! ./environment */ "./src/environment.ts");
exports.enemyMinimumDepth = {
    1: 0,
    2: 1,
    3: 0,
    4: 0,
    5: 1,
    6: 2,
    7: 1,
    8: 1,
    9: 1,
    10: 2,
    11: 2,
    12: 1,
    13: 2,
    14: 2,
    15: 2, // ArmoredSkullEnemy  16: 2, // ArmoredKnightEnemy
};
/*
interface enemySpawnPoolData {
  maxCount: number;
  minCount: number;
}

interface environmentData {
  name: string;
  preferredEnemies: Array<Enemy>;
  preferredEntities: Array<Entity>;
  entityBlacklist: Array<Entity>;
  enemySpawnPoolData: enemySpawnPoolData;
  roomData: roomData;
}

interface entitySpawnData {
  enemy: Enemy;
  spawnChance: number;
  maximumCount: number;
}
*/
class Level {
    constructor(game, depth, width, height) {
        this.initializeLevelArray = () => {
            // Create a 300x300 grid for depth 0
            this.levelArray = [];
            for (let x = 0; x < this.width; x++) {
                this.levelArray[x] = [];
                for (let y = 0; y < this.height; y++) {
                    this.levelArray[x][y] = null;
                }
            }
        };
        this.loadRoomsIntoLevelArray = () => {
            for (let room of this.rooms) {
                for (let x = room.roomX; x < room.roomX + room.width; x++) {
                    for (let y = room.roomY; y < room.roomY + room.height; y++) {
                        this.levelArray[x][y] = room.roomArray[x][y];
                    }
                }
            }
        };
        this.game = game;
        this.depth = depth;
        this.width = width;
        this.height = height;
        this.rooms = [];
        this.initializeLevelArray();
        //this.loadRoomsIntoLevelArray();
        //console.log(`level depth: ${this.depth}`);
        this.enemyParameters = this.getEnemyParameters();
        let envType = Math.floor(Math.random() * 3); //multiply by number of environments to choose from
        this.environment = new environment_1.Environment(envType);
    }
    setExitRoom() {
        this.exitRoom = this.rooms.find((room) => room.type === room_1.RoomType.DOWNLADDER);
    }
    setStartRoom() {
        this.startRoom = this.rooms.find((room) => room.type === room_1.RoomType.START);
    }
    setRooms(rooms) {
        this.rooms = rooms;
        this.setExitRoom();
        this.setStartRoom();
        this.rooms.filter((room) => room.depth === this.depth);
        rooms.forEach((room) => {
            room.id = this.rooms.indexOf(room);
        });
    }
    /**
     * Generates enemy parameters based on the current depth.
     * @param depth The current depth level.
     * @returns An object conforming to the EnemyParameters interface.
     */
    getEnemyParameters() {
        let currentDepth = this.depth;
        // Generate the enemy pool based on current depth
        const enemyPoolIds = this.generateEnemyPoolIds(currentDepth);
        // Create enemyTables where each level maps to the enemyPoolIds
        const enemyTables = {};
        for (let tableDepth = 0; tableDepth <= currentDepth; tableDepth++) {
            // Assign the same pool for all tables up to current depth
            enemyTables[tableDepth] = enemyPoolIds;
        }
        const newEnemies = enemyTables[currentDepth].filter((id) => !this.game.encounteredEnemies.includes(id));
        this.game.encounteredEnemies.push(...newEnemies);
        //console.log(
        //`encounteredEnemies for depth ${this.depth}: ${this.game.encounteredEnemies}`,
        //);
        return {
            enemyTables,
            maxDepthTable: currentDepth,
            minDepths: exports.enemyMinimumDepth,
        };
    }
    /**
     * Generates the enemy pool IDs based on the current depth, introducing up to 2 new enemies each level.
     * @param depth The current depth level.
     * @returns An array of selected enemy IDs.
     */
    generateEnemyPoolIds(depth) {
        const availableEnemies = Object.entries(exports.enemyMinimumDepth)
            .filter(([enemyId, minDepth]) => depth >= minDepth)
            .map(([enemyId]) => Number(enemyId));
        // Determine which enemies are new (not yet encountered)
        const newEnemies = availableEnemies.filter((id) => !this.game.encounteredEnemies.includes(id));
        // Decide how many new enemies to introduce (1 or 2)
        const newEnemiesToAddCount = Math.min(newEnemies.length, 2);
        const newEnemiesToAdd = this.getRandomElements(newEnemies, newEnemiesToAddCount);
        // Add the new enemies to encounteredEnemies
        this.game.encounteredEnemies.push(...newEnemiesToAdd);
        // Log the newly added enemies for debugging
        // console.log(`New enemies introduced at depth ${depth}: ${newEnemiesToAdd}`);
        // Combine encountered enemies to form the enemy pool
        const enemyPoolIds = this.game.encounteredEnemies.slice();
        // Determine the number of enemy types for the current depth
        const numberOfTypes = this.getNumberOfEnemyTypes(depth);
        // Select the final set of enemy IDs for the pool
        const selectedEnemyIds = this.getRandomElements(enemyPoolIds, numberOfTypes);
        // Ensure uniqueness and limit based on available enemies
        return Array.from(new Set(selectedEnemyIds)).slice(0, numberOfTypes);
    }
    /**
     * Determines the number of enemy types allowed based on the current depth.
     * @param depth The current depth level.
     * @returns The number of enemy types.
     */
    getNumberOfEnemyTypes(depth) {
        // Example logic: depth 0 -> 2 types, depth 1 -> 4, depth 2 -> 6, etc.
        let numberOfTypes = depth === 0 ? 2 : Math.ceil(Math.sqrt(depth + 1)) + 4;
        //console.log(`numberOfTypes: ${numberOfTypes}`);
        return numberOfTypes;
    }
    /**
     * Utility function to get random elements from an array.
     * @param array The array to select from.
     * @param count The number of elements to select.
     * @returns An array of randomly selected elements.
     */
    getRandomElements(array, count) {
        const shuffled = [...array];
        for (let i = shuffled.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
        }
        return shuffled.slice(0, Math.min(count, shuffled.length));
    }
}
exports.Level = Level;


/***/ }),

/***/ "./src/levelConstants.ts":
/*!*******************************!*\
  !*** ./src/levelConstants.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LevelConstants = void 0;
class LevelConstants {
}
exports.LevelConstants = LevelConstants;
LevelConstants.SCREEN_W = 1;
LevelConstants.SCREEN_H = 1;
LevelConstants.COMPUTER_TURN_DELAY = 300; // milliseconds
LevelConstants.TURN_TIME = 3000; // milliseconds
LevelConstants.LEVEL_TRANSITION_TIME = 300; // milliseconds
LevelConstants.LEVEL_TRANSITION_TIME_LADDER = 1000; // milliseconds
LevelConstants.ROOM_COUNT = 50;
LevelConstants.HEALTH_BAR_FADEIN = 100;
LevelConstants.HEALTH_BAR_FADEOUT = 350;
LevelConstants.HEALTH_BAR_TOTALTIME = 1000;
LevelConstants.SHADED_TILE_CUTOFF = 1;
LevelConstants.MIN_VISIBILITY = 0; // visibility level of places you've already seen
LevelConstants.LIGHTING_ANGLE_STEP = 2; // how many degrees between each ray, previously 5
LevelConstants.LIGHTING_MAX_DISTANCE = 7;
//static readonly LIGHT_RESOLUTION = 0.1; //1 is default
LevelConstants.LEVEL_TEXT_COLOR = "yellow";
LevelConstants.AMBIENT_LIGHT_COLOR = [12, 15, 12];
LevelConstants.TORCH_LIGHT_COLOR = [120, 35, 10];


/***/ }),

/***/ "./src/levelGenerator.ts":
/*!*******************************!*\
  !*** ./src/levelGenerator.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LevelGenerator = exports.PartialLevel = void 0;
const game_1 = __webpack_require__(/*! ./game */ "./src/game.ts");
const room_1 = __webpack_require__(/*! ./room/room */ "./src/room/room.ts");
const random_1 = __webpack_require__(/*! ./random */ "./src/random.ts");
const downLadder_1 = __webpack_require__(/*! ./tile/downLadder */ "./src/tile/downLadder.ts");
const levelParametersGenerator_1 = __webpack_require__(/*! ./levelParametersGenerator */ "./src/levelParametersGenerator.ts");
const level_1 = __webpack_require__(/*! ./level */ "./src/level.ts");
const gameConstants_1 = __webpack_require__(/*! ./gameConstants */ "./src/gameConstants.ts");
// animation delays in ms
let ANIMATION_PARTITION_SPLIT_DELAY = 0; // for partition splitting
let ANIMATION_PATHFINDING_DELAY = 0; // for pathfinding
let ANIMATION_LARGE_DELAY = 0; // in between larger steps
if (document.cookie.includes("showgeneration=true")) {
    ANIMATION_PARTITION_SPLIT_DELAY = 10; // for partition splitting
    ANIMATION_PATHFINDING_DELAY = 100; // for pathfinding
    ANIMATION_LARGE_DELAY = 100; // in between larger steps
}
class PartitionConnection {
    constructor(x, y, other) {
        this.x = x;
        this.y = y;
        this.other = other;
    }
}
class Partition {
    constructor(x, y, w, h, fillStyle) {
        this.split = async () => {
            await new Promise((resolve) => setTimeout(resolve, LevelGenerator.ANIMATION_CONSTANT * ANIMATION_PARTITION_SPLIT_DELAY));
            // Reset open walls when a partition is split
            this.isTopOpen = true;
            this.isRightOpen = true;
            this.isBottomOpen = true;
            this.isLeftOpen = true;
            // This function generates a random number around the center (0.5) within a certain width (0.6).
            // It uses the Random.rand() function to generate a random number between 0 and 1, subtracts 0.5 to center it around 0,
            // multiplies it by the width to scale it, and then adds the center (0.5) to shift it back to being between 0 and 1.
            let rand_mid = () => {
                let center = 0.5;
                let width = 0.6;
                return (random_1.Random.rand() - 0.5) * width + center;
            };
            let sizeRange = () => {
                let sizes = [
                    { size: 1, probability: 0.2 },
                    { size: 3, probability: 0.6 },
                    { size: 10, probability: 0.2 },
                ];
                let rand = random_1.Random.rand();
                let sum = 0;
                for (let size of sizes) {
                    sum += size.probability;
                    if (rand <= sum)
                        return size.size;
                }
                return sizes[sizes.length - 1].size;
            };
            let MIN_SIZE = 4;
            if (this.w > this.h) {
                //if the partitions width is greater than its height
                let w1 = Math.floor(rand_mid() * this.w);
                //choose a random tile within the width of the tiles
                let w2 = this.w - w1 - 1;
                //The remaining border - 1
                if (w1 < MIN_SIZE || w2 < MIN_SIZE)
                    return [this];
                //if either of these are less than the min size: return an array with this Partition
                return [
                    new Partition(this.x, this.y, w1, this.h, this.fillStyle),
                    new Partition(this.x + w1 + 1, this.y, w2, this.h, this.fillStyle),
                ];
                //return an array with two new partitions
            }
            else {
                let h1 = Math.floor(rand_mid() * this.h);
                let h2 = this.h - h1 - 1;
                if (h1 < MIN_SIZE || h2 < MIN_SIZE)
                    return [this];
                return [
                    new Partition(this.x, this.y, this.w, h1, this.fillStyle),
                    new Partition(this.x, this.y + h1 + 1, this.w, h2, this.fillStyle),
                ];
                //identical code for case where height > width
            }
        };
        this.point_in = (x, y) => {
            //given the input argument x,y coordinates output boolean
            return (x >= this.x && x < this.x + this.w && y >= this.y && y < this.y + this.h);
            //only return true if both input x and input y are within the partitions x and y
        };
        this.point_next_to = (x, y) => {
            return ((x >= this.x - 1 &&
                x < this.x + this.w + 1 &&
                y >= this.y &&
                y < this.y + this.h) ||
                (x >= this.x &&
                    x < this.x + this.w &&
                    y >= this.y - 1 &&
                    y < this.y + this.h + 1));
            //return true if the input x and y are next to any point of the partition
        };
        this.area = () => {
            return this.w * this.h;
            //return the damn area
        };
        this.overlaps = (other) => {
            return (other.x < this.x + this.w + 1 &&
                other.x + other.w > this.x - 1 &&
                other.y < this.y + this.h + 1 &&
                other.y + other.h > this.y - 1);
            //takes another partition instance as argument
            //returns true if any points of each overlap
        };
        this.setOpenWall = (connection) => {
            if (connection.y === this.y - 1 &&
                connection.x >= this.x &&
                connection.x < this.x + this.w) {
                this.isTopOpen = false;
            }
            if (connection.y === this.y + this.h &&
                connection.x >= this.x &&
                connection.x < this.x + this.w) {
                this.isBottomOpen = false;
            }
            if (connection.x === this.x + this.w &&
                connection.y >= this.y &&
                connection.y < this.y + this.h) {
                this.isRightOpen = false;
            }
            if (connection.x === this.x - 1 &&
                connection.y >= this.y &&
                connection.y < this.y + this.h) {
                this.isLeftOpen = false;
            }
        };
        this.get_branch_point = () => {
            let points = [];
            for (let x = this.x; x < this.x + this.w; x++) {
                //count up from the partitions x to its width
                points.push({ x: x, y: this.y - 1 /*one row above partition*/ });
                points.push({ x: x, y: this.y + this.h /*one row below partition*/ });
            } // pushes the points above and below the partition
            for (let y = this.y; y < this.y + this.h; y++) {
                points.push({ x: this.x - 1, y: y });
                points.push({ x: this.x + this.w, y: y });
            } //pushes points to left and right of the partition
            points = points.filter((p) => !this.connections.some((c) => Math.abs(c.x - p.x) + Math.abs(c.y - p.y) <= 1));
            points.sort(() => 0.5 - random_1.Random.rand());
            return points[0]; //return first object of x y points in array points
        };
        this.draw = (delta, levelCenterX, levelCenterY) => {
            game_1.Game.ctx.fillStyle = this.fillStyle;
            game_1.Game.ctx.fillRect(Math.round(gameConstants_1.GameConstants.WIDTH / 2 + this.x - levelCenterX), Math.round(gameConstants_1.GameConstants.HEIGHT / 2 + this.y - levelCenterY), this.w, this.h);
            for (let connection of this.connections) {
                game_1.Game.ctx.fillRect(Math.round(gameConstants_1.GameConstants.WIDTH / 2 + connection.x - levelCenterX), Math.round(gameConstants_1.GameConstants.HEIGHT / 2 + connection.y - levelCenterY), 1, 1);
            }
        };
        this.x = x;
        this.y = y;
        this.w = w;
        this.h = h;
        this.fillStyle = fillStyle;
        this.type = room_1.RoomType.DUNGEON;
        this.connections = [];
        this.distance = 1000;
        this.isTopOpen = true;
        this.isRightOpen = true;
        this.isBottomOpen = true;
        this.isLeftOpen = true;
        this.pathIndex = 0;
    }
} //end of Partition class
let split_partitions = async (partitions, prob) => {
    for (let partition of partitions) {
        if (random_1.Random.rand() < prob) {
            partitions = partitions.filter((p) => p !== partition); // remove partition
            partitions = partitions.concat(await partition.split()); // add splits
        }
    }
    return partitions;
    //takes input partitions array, randomly removes partitions and adds splits, output modified partitions array
};
let split_partition = async (partition, prob) => {
    if (random_1.Random.rand() < prob) {
        return await partition.split();
    }
    else {
        return [partition];
    }
    // Takes a single partition and probability
    // Returns an array with either the split partitions or the original partition
};
let reduce_dimensions = (partition, params) => {
    let reduceY = 0;
    let reduceX = 0;
    let translateX = 0;
    let translateY = 0;
    partition.connections.forEach((connection) => {
        if (connection.y === partition.y)
            reduceY++, translateY++;
        if (connection.y === partition.y + partition.h)
            reduceY++;
        if (connection.x === partition.x)
            reduceX++, translateX++;
        if (connection.x === partition.x + partition.w)
            reduceX++;
    });
    if (partition.w > 7) {
        partition.w -= translateX;
        partition.x += translateX;
    }
    if (partition.h > 7) {
        partition.h -= translateY;
        partition.y += translateY;
    }
};
let get_wall_rooms = (partitions, mapWidth, mapHeight) => {
    return partitions.filter((partition, index) => {
        // Helper function to check if a specific path is clear
        const isPathClear = (direction) => {
            switch (direction) {
                case "left":
                    for (let y = partition.y; y < partition.y + partition.h; y++) {
                        let blocked = partitions.some((other) => {
                            if (other === partition)
                                return false;
                            // Check if other partition overlaps this y-coordinate and is to the left
                            return (other.y <= y &&
                                y < other.y + other.h &&
                                other.x + other.w > 0 &&
                                other.x + other.w <= partition.x);
                        });
                        if (!blocked)
                            return true; // Found at least one y without a blocker
                    }
                    return false;
                case "right":
                    for (let y = partition.y; y < partition.y + partition.h; y++) {
                        let blocked = partitions.some((other) => {
                            if (other === partition)
                                return false;
                            // Check if other partition overlaps this y-coordinate and is to the right
                            return (other.y <= y &&
                                y < other.y + other.h &&
                                other.x < mapWidth &&
                                other.x >= partition.x + partition.w);
                        });
                        if (!blocked)
                            return true;
                    }
                    return false;
                case "top":
                    for (let x = partition.x; x < partition.x + partition.w; x++) {
                        let blocked = partitions.some((other) => {
                            if (other === partition)
                                return false;
                            // Check if other partition overlaps this x-coordinate and is above
                            return (other.x <= x &&
                                x < other.x + other.w &&
                                other.y + other.h > 0 &&
                                other.y + other.h <= partition.y);
                        });
                        if (!blocked)
                            return true;
                    }
                    return false;
                case "bottom":
                    for (let x = partition.x; x < partition.x + partition.w; x++) {
                        let blocked = partitions.some((other) => {
                            if (other === partition)
                                return false;
                            // Check if other partition overlaps this x-coordinate and is below
                            return (other.x <= x &&
                                x < other.x + other.w &&
                                other.y < mapHeight &&
                                other.y >= partition.y + partition.h);
                        });
                        if (!blocked)
                            return true;
                    }
                    return false;
                default:
                    return false;
            }
        };
        const hasLeftPath = isPathClear("left");
        const hasRightPath = isPathClear("right");
        const hasTopPath = isPathClear("top");
        const hasBottomPath = isPathClear("bottom");
        // Count the number of open paths
        const openPaths = [
            hasLeftPath,
            hasRightPath,
            hasTopPath,
            hasBottomPath,
        ].filter(Boolean).length;
        // Define wall rooms as those with exactly one open path
        const isWallRoom = openPaths === 1;
        return isWallRoom;
    });
};
let remove_wall_rooms = (partitions, w, h, prob = 1.0) => {
    // Get all wall rooms
    const wallRooms = get_wall_rooms(partitions, w, h);
    // Remove wall rooms based on probability
    for (const wallRoom of wallRooms) {
        if (random_1.Random.rand() < prob) {
            partitions = partitions.filter((p) => p !== wallRoom);
        }
    }
    return partitions;
};
let populate_grid = (partitions, grid, w, h) => {
    for (let x = 0; x < w; x++) {
        //loop through the horizontal tiles
        grid[x] = []; //empty array at x index
        for (let y = 0; y < h; y++) {
            grid[x][y] = false;
            for (const partition of partitions) {
                if (partition.point_in(x, y))
                    grid[x][y] = partition;
            }
        }
    }
    return grid;
    //input grid array, partitions array and width and height
    //output grid array that indicates which cells are in which partition
};
let generate_dungeon_candidate = async (game, partialLevel, map_w, map_h, depth, params) => {
    const { minRoomCount, maxRoomCount, maxRoomArea, splitProbabilities, wallRemoveProbability, softMaxRoomArea, } = params;
    partialLevel.partitions = [new Partition(0, 0, map_w, map_h, "white")];
    let grid = [];
    // Use splitProbabilities for splitting
    while (partialLevel.partitions.length < params.maxRoomCount) {
        for (let i = 0; i < splitProbabilities.length; i++) {
            partialLevel.partitions = await split_partitions(partialLevel.partitions, splitProbabilities[i]);
        }
    }
    for (let i = 0; i < 100; i++) {
        partialLevel.partitions.forEach(async (partition) => {
            let roomArea = Math.random() > 0.95 ? softMaxRoomArea : maxRoomArea; //Math.random() > 0.95 ? params.softMaxRoomArea : params.maxRoomArea;
            if (partition.area() > roomArea) {
                partialLevel.partitions = partialLevel.partitions.filter((p) => p !== partition);
                partialLevel.partitions = partialLevel.partitions.concat(await split_partition(partition, 0.5));
            }
        });
    }
    //visualize_partialLevel.partitions(partialLevel.partitions, map_w, map_h);
    partialLevel.partitions = remove_wall_rooms(partialLevel.partitions, map_w, map_h, wallRemoveProbability);
    await new Promise((resolve) => setTimeout(resolve, LevelGenerator.ANIMATION_CONSTANT * ANIMATION_LARGE_DELAY));
    // Remove wall rooms based on probability
    /*
    if (partitions.length > params.minRoomCount) {
      for (let i = 0; i < 1; i++) {
        partitions = remove_wall_rooms(partitions, map_w, map_h, wallRemoveProbability);
      }
    }
    
    /*
      partitions = partitions.filter((p) => {
        if (p.area() > maxRoomArea && partitions.length > params.minRoomCount) {
          return false;
        }
        return true;
      });
     
      while (partitions.length > maxRoomCount) {
        partitions.pop();
      }
    */
    // Check if we have any partitions before proceeding
    if (partialLevel.partitions.length === 0) {
        partialLevel.partitions = [];
        return;
    }
    //populate the grid with partitions
    partialLevel.partitions.sort((a, b) => a.area() - b.area());
    // shade each partition's fillStyle based on its area, medium gray for smallest, white for largest
    partialLevel.partitions.forEach((partition) => {
        partition.fillStyle = `rgba(128, 128, 128, ${partition.area() / partialLevel.partitions[0].area()})`;
    });
    await new Promise((resolve) => setTimeout(resolve, LevelGenerator.ANIMATION_CONSTANT * ANIMATION_LARGE_DELAY));
    // Make sure we have at least one partition before assigning spawn
    if (partialLevel.partitions.length === 0) {
        partialLevel.partitions = [];
        return;
    }
    let spawn = partialLevel.partitions[0];
    if (!spawn) {
        partialLevel.partitions = [];
        return;
    }
    spawn.type = room_1.RoomType.START;
    spawn.fillStyle = "rgb(0, 255, 0)";
    if (partialLevel.partitions.length > 1) {
        partialLevel.partitions[partialLevel.partitions.length - 1].type =
            room_1.RoomType.BOSS;
        partialLevel.partitions[partialLevel.partitions.length - 1].fillStyle =
            "red";
    }
    await new Promise((resolve) => setTimeout(resolve, LevelGenerator.ANIMATION_CONSTANT * ANIMATION_LARGE_DELAY));
    let connected = [spawn];
    let frontier = [spawn];
    let found_boss = false;
    // connect rooms until we find the boss
    while (frontier.length > 0 && !found_boss) {
        let room = frontier[0];
        if (room !== spawn)
            room.fillStyle = "green";
        frontier.splice(0, 1);
        let doors_found = 0;
        const num_doors = Math.floor(random_1.Random.rand() * 2 + 1);
        let tries = 0;
        const max_tries = 1000;
        while (doors_found < num_doors && tries < max_tries) {
            let point = room.get_branch_point();
            for (const p of partialLevel.partitions) {
                if (p !== room &&
                    connected.indexOf(p) === -1 &&
                    p.point_next_to(point.x, point.y)) {
                    room.connections.push(new PartitionConnection(point.x, point.y, p));
                    p.connections.push(new PartitionConnection(point.x, point.y, room));
                    // Set open walls based on connection
                    room.setOpenWall(new PartitionConnection(point.x, point.y, p));
                    p.setOpenWall(new PartitionConnection(point.x, point.y, room));
                    frontier.push(p);
                    connected.push(p);
                    doors_found++;
                    if (p.type === room_1.RoomType.BOSS) {
                        found_boss = true;
                        p.fillStyle = "rgb(255, 0, 0)";
                    }
                    break;
                }
            }
            tries++;
        }
        await new Promise((resolve) => setTimeout(resolve, LevelGenerator.ANIMATION_CONSTANT * ANIMATION_PATHFINDING_DELAY));
    }
    // remove rooms we haven't connected to yet
    for (const partition of partialLevel.partitions) {
        if (partition.connections.length === 0)
            partialLevel.partitions = partialLevel.partitions.filter((p) => p !== partition);
    }
    await new Promise((resolve) => setTimeout(resolve, LevelGenerator.ANIMATION_CONSTANT * ANIMATION_LARGE_DELAY));
    grid = populate_grid(partialLevel.partitions, grid, map_w, map_h); // recalculate with removed rooms
    // make sure we haven't removed all the rooms
    if (partialLevel.partitions.length === 0) {
        partialLevel.partitions = [];
        return; // for now just return an empty list so we can retry
    }
    // make some loops
    let num_loop_doors = Math.floor(random_1.Random.rand() * 4 + 4);
    for (let i = 0; i < num_loop_doors; i++) {
        let roomIndex = Math.floor(random_1.Random.rand() * partialLevel.partitions.length);
        let room = partialLevel.partitions[roomIndex];
        let found_door = false;
        let tries = 0;
        const max_tries = 10;
        let not_already_connected = partialLevel.partitions.filter((p) => !room.connections.some((c) => c.other === p));
        while (!found_door && tries < max_tries) {
            let point = room.get_branch_point();
            for (const p of not_already_connected) {
                if (p !== room && p.point_next_to(point.x, point.y)) {
                    room.connections.push(new PartitionConnection(point.x, point.y, p));
                    p.connections.push(new PartitionConnection(point.x, point.y, room));
                    // Set open walls based on connection
                    room.setOpenWall(new PartitionConnection(point.x, point.y, p));
                    p.setOpenWall(new PartitionConnection(point.x, point.y, room));
                    found_door = true;
                    break;
                }
            }
            tries++;
        }
    }
    // add stair room
    if (!partialLevel.partitions.some((p) => p.type === room_1.RoomType.BOSS)) {
        partialLevel.partitions = [];
        return;
    }
    let boss = partialLevel.partitions.find((p) => p.type === room_1.RoomType.BOSS);
    let found_stair = false;
    const max_stair_tries = 5;
    const stairRoomWidth = 5;
    const stairRoomHeight = 5;
    for (let stair_tries = 0; stair_tries < max_stair_tries; stair_tries++) {
        let stair = new Partition(game_1.Game.rand(boss.x - 1, boss.x + boss.w - 2, random_1.Random.rand), boss.y - stairRoomHeight - 1, stairRoomWidth, stairRoomHeight, "white");
        stair.type = room_1.RoomType.DOWNLADDER;
        stair.fillStyle = "blue";
        if (!partialLevel.partitions.some((p) => p.overlaps(stair))) {
            found_stair = true;
            partialLevel.partitions.push(stair);
            stair.connections.push(new PartitionConnection(stair.x + 1, stair.y + stairRoomHeight, boss));
            boss.connections.push(new PartitionConnection(stair.x + 1, stair.y + stairRoomHeight, stair));
            // Set open walls for stair and boss connection
            stair.setOpenWall(new PartitionConnection(stair.x + 1, stair.y + 3, boss));
            boss.setOpenWall(new PartitionConnection(stair.x + 1, stair.y + 3, stair));
            break;
        }
    }
    if (!found_stair) {
        console.log("No stair found");
        partialLevel.partitions = [];
        //game.pushMessage("No stair found");
        return;
    }
    // calculate room distances
    frontier = [spawn];
    let seen = [];
    spawn.distance = 0;
    while (frontier.length > 0) {
        let room = frontier[0];
        frontier.splice(0, 1);
        seen.push(room);
        for (let c of room.connections) {
            let other = c.other;
            other.distance = Math.min(other.distance, room.distance + 1);
            if (seen.indexOf(other) === -1)
                frontier.push(other);
        }
    }
    /*
    // add special rooms
    let added_rope_hole = false;
    for (const p of partialLevel.partitions) {
      if (p.type === RoomType.DUNGEON) {
        if (p.distance > 4 && p.area() <= 30 && Random.rand() < 0) {
          p.type = RoomType.TREASURE;
        } else if (
          !added_rope_hole //&&
          //p.distance > 1 &&
          //p.area() <= 40 &&
          //Random.rand() < 0.5
        ) {
          p.type = RoomType.ROPEHOLE;
          added_rope_hole = true;
          console.log("ADDED ROPEHOLE!!!!!!");
        }
      }
    }
  */
    await new Promise((resolve) => setTimeout(resolve, 10 * LevelGenerator.ANIMATION_CONSTANT * ANIMATION_LARGE_DELAY));
};
let generate_dungeon = async (game, partialLevel, map_w, map_h, depth, params) => {
    let passes_checks = false;
    let tries = 0;
    while (!passes_checks) {
        await generate_dungeon_candidate(game, partialLevel, map_w, map_h, depth, params);
        passes_checks = true;
        if (partialLevel.partitions.length < params.minRoomCount) {
            passes_checks = false;
            if (document.cookie.includes("showgeneration=true"))
                game.pushMessage("Not enough rooms");
        }
        else if (!partialLevel.partitions.some((p) => p.type === room_1.RoomType.BOSS)) {
            passes_checks = false;
            if (document.cookie.includes("showgeneration=true"))
                game.pushMessage("Boss room unreachable");
        }
        else if (partialLevel.partitions.find((p) => p.type === room_1.RoomType.BOSS).distance < 3) {
            passes_checks = false;
            if (document.cookie.includes("showgeneration=true"))
                game.pushMessage("Boss room too close to spawn");
        }
        tries++;
        //if (tries > 100) break;
    }
    //game.pushMessage("Dungeon passed all checks");
    await new Promise((resolve) => setTimeout(resolve, 10 * LevelGenerator.ANIMATION_CONSTANT * ANIMATION_LARGE_DELAY));
    console.log("finished generation");
    //partialLevel.partitions.forEach((partition) => reduce_dimensions(partition, params));
};
let generate_cave_candidate = async (partialLevel, map_w, map_h, num_rooms) => {
    partialLevel.partitions = [new Partition(0, 0, map_w, map_h, "white")];
    let grid = [];
    for (let i = 0; i < 3; i++)
        partialLevel.partitions = await split_partitions(partialLevel.partitions, 0.75);
    for (let i = 0; i < 3; i++)
        partialLevel.partitions = await split_partitions(partialLevel.partitions, 1);
    for (let i = 0; i < 3; i++)
        partialLevel.partitions = await split_partitions(partialLevel.partitions, 0.5);
    grid = populate_grid(partialLevel.partitions, grid, map_w, map_h);
    partialLevel.partitions.sort((a, b) => a.area() - b.area());
    if (partialLevel.partitions.length === 0) {
        throw new Error("No partitions generated."); // Throw an error if no partitions
    }
    let spawn = partialLevel.partitions[0];
    spawn.type = room_1.RoomType.ROPECAVE;
    for (let i = 1; i < partialLevel.partitions.length; i++)
        partialLevel.partitions[i].type = room_1.RoomType.CAVE;
    let connected = [spawn];
    let frontier = [spawn];
    // connect rooms until we hit num_rooms
    while (frontier.length > 0 && connected.length < num_rooms) {
        let room = frontier[0];
        frontier.splice(0, 1);
        let doors_found = 0;
        const num_doors = Math.floor(random_1.Random.rand() * 2 + 1);
        let tries = 0;
        const max_tries = 1000;
        while (doors_found < num_doors &&
            tries < max_tries &&
            connected.length < num_rooms) {
            let point = room.get_branch_point();
            if (!point) {
            }
            for (const p of partialLevel.partitions) {
                if (p !== room &&
                    connected.indexOf(p) === -1 &&
                    p.point_next_to(point.x, point.y)) {
                    room.connections.push(new PartitionConnection(point.x, point.y, p));
                    p.connections.push(new PartitionConnection(point.x, point.y, room));
                    frontier.push(p);
                    connected.push(p);
                    doors_found++;
                    break;
                }
            }
            tries++;
        }
    }
    // remove rooms we haven't connected to yet
    partialLevel.partitions = partialLevel.partitions.filter((partition) => partition.connections.length > 0);
    grid = populate_grid(partialLevel.partitions, grid, map_w, map_h); // recalculate with removed rooms
    // make sure we haven't removed all the rooms
    if (partialLevel.partitions.length === 0) {
        throw new Error("No valid rooms after filtering."); // Throw an error if no valid rooms
    }
    // make some loops
    let num_loop_doors = Math.floor(random_1.Random.rand() * 4 + 4);
    for (let i = 0; i < num_loop_doors; i++) {
        let roomIndex = Math.floor(random_1.Random.rand() * partialLevel.partitions.length);
        let room = partialLevel.partitions[roomIndex];
        let found_door = false;
        let tries = 0;
        const max_tries = 100;
        let not_already_connected = partialLevel.partitions.filter((p) => !room.connections.some((c) => c.other === p));
        while (!found_door && tries < max_tries) {
            let point = room.get_branch_point();
            if (!point) {
                break; // Skip if no valid branch point found
            }
            for (const p of not_already_connected) {
                if (p !== room && p.point_next_to(point.x, point.y)) {
                    room.connections.push(new PartitionConnection(point.x, point.y, p));
                    p.connections.push(new PartitionConnection(point.x, point.y, room));
                    found_door = true;
                    break;
                }
            }
            tries++;
        }
    }
    // calculate room distances
    frontier = [spawn];
    let seen = [];
    spawn.distance = 0;
    while (frontier.length > 0) {
        let room = frontier[0];
        frontier.splice(0, 1);
        seen.push(room);
        for (let c of room.connections) {
            let other = c.other;
            other.distance = Math.min(other.distance, room.distance + 1);
            if (seen.indexOf(other) === -1)
                frontier.push(other);
        }
    }
    return partialLevel.partitions;
};
let generate_cave = async (partialLevel, mapWidth, mapHeight) => {
    const numberOfRooms = 5; // don't set this too high or cave generation will time out
    do {
        await generate_cave_candidate(partialLevel, mapWidth, mapHeight, numberOfRooms);
    } while (partialLevel.partitions.length < numberOfRooms);
    return partialLevel.partitions;
};
let generate_tutorial = (height = 7, width = 7) => {
    let partitions;
    partitions = [new Partition(0, 0, height, width, "white")];
    partitions[0].type = room_1.RoomType.TUTORIAL;
    return partitions;
};
let visualize_partitions = (partitions, mapWidth, mapHeight) => {
    // Create grid with padded spaces
    const grid = Array.from({ length: mapHeight }, () => Array(mapWidth).fill(" . "));
    // Calculate the maximum number of digits needed
    const maxIndex = partitions.length - 1;
    const padLength = maxIndex.toString().length;
    partitions.forEach((partition, index) => {
        // Pad the index number with spaces to maintain consistent width
        const paddedIndex = index.toString().padStart(padLength, " ");
        for (let x = partition.x; x < partition.x + partition.w; x++) {
            for (let y = partition.y; y < partition.y + partition.h; y++) {
                if (x >= 0 && x < mapWidth && y >= 0 && y < mapHeight) {
                    grid[y][x] = ` ${paddedIndex} `; // Pad numbers with spaces
                }
            }
        }
    });
    console.log("Partition Layout:");
    console.log("   " + [...Array(mapWidth)].map((_, i) => i % 10).join("  ") + " X"); // Column headers
    grid.forEach((row, index) => {
        const paddedIndex = index.toString().padStart(2, " ");
        console.log(`${paddedIndex} ${row.join("")}`);
    });
    console.log("Y");
};
let check_overlaps = (partitions) => {
    for (let i = 0; i < partitions.length; i++) {
        for (let j = i + 1; j < partitions.length; j++) {
            const a = partitions[i];
            const b = partitions[j];
            if (a.x < b.x + b.w &&
                a.x + a.w > b.x &&
                a.y < b.y + b.h &&
                a.y + a.h > b.y) {
                return true;
            }
        }
    }
    return false;
};
class PartialLevel {
}
exports.PartialLevel = PartialLevel;
class LevelGenerator {
    constructor() {
        this.depthReached = 0;
        this.currentFloorFirstLevelID = 0;
        this.setOpenWallsForPartitions = (partitions, mapWidth, mapHeight) => {
            for (const partition of partitions) {
                // Reset all walls to closed by default
                partition.isTopOpen = false;
                partition.isRightOpen = false;
                partition.isBottomOpen = false;
                partition.isLeftOpen = false;
                // Check if partition touches map boundaries
                if (partition.x === 0) {
                    partition.isLeftOpen = true;
                }
                if (partition.y === 0) {
                    partition.isTopOpen = true;
                }
                if (partition.x + partition.w === mapWidth) {
                    partition.isRightOpen = true;
                }
                if (partition.y + partition.h === mapHeight) {
                    partition.isBottomOpen = true;
                }
            }
        };
        this.createLevel = (depth) => {
            let newLevel = new level_1.Level(this.game, depth, 100, 100);
            return newLevel;
        };
        this.getRooms = (partitions, depth, mapGroup) => {
            //this.setOpenWallsForPartitions(partitions, 35, 35); // Using standard map size
            let rooms = [];
            for (let i = 0; i < partitions.length; i++) {
                let partition = partitions[i];
                // Pass open walls information to the Room constructor
                let room = new room_1.Room(this.game, partition.x - 1, partition.y - 1, partition.w + 2, partition.h + 2, partition.type, depth, mapGroup, this.game.levels[depth], random_1.Random.rand);
                rooms.push(room);
            }
            let doors_added = [];
            partitions.forEach((partition, index) => {
                partition.connections.forEach((connection) => {
                    let door = rooms[index].addDoor(connection.x, connection.y);
                    let existingDoor = doors_added.find((existing) => existing.x === door.x && existing.y === door.y);
                    if (existingDoor) {
                        existingDoor.link(door);
                        door.link(existingDoor);
                    }
                    doors_added.push(door);
                });
            });
            for (let room of rooms) {
                room.populate(random_1.Random.rand);
            }
            return rooms;
        };
        this.setSeed = (seed) => {
            this.seed = seed;
        };
        this.generate = async (game, depth, cave = false, callback) => {
            this.levelParams = levelParametersGenerator_1.LevelParameterGenerator.getParameters(depth);
            this.depthReached = depth;
            // Set the random state based on the seed and depth
            random_1.Random.setState(this.seed + depth);
            this.game = game;
            // Determine the map group
            let mapGroup = this.game.rooms.length > 0
                ? this.game.rooms[this.game.rooms.length - 1].mapGroup + 1
                : 0;
            this.partialLevel = new PartialLevel();
            // Generate partitions based on whether it's a cave or a dungeon
            if (cave)
                await generate_cave(this.partialLevel, 20, 20); // You might want to make these dynamic based on params
            else
                await generate_dungeon(game, this.partialLevel, this.levelParams.mapWidth, this.levelParams.mapHeight, depth, this.levelParams);
            // Call this function before get_wall_rooms
            if (check_overlaps(this.partialLevel.partitions)) {
                console.warn("There are overlapping partitions.");
            }
            // Get the levels based on the partitions
            let newLevel = this.createLevel(depth);
            this.game.levels.push(newLevel);
            this.game.level = newLevel;
            let rooms = this.getRooms(this.partialLevel.partitions, depth, mapGroup);
            newLevel.setRooms(rooms);
            newLevel.exitRoom.linkExitToStart();
            // Update the current floor first level ID if it's not a cave
            if (!cave)
                this.currentFloorFirstLevelID = this.game.rooms.length;
            // Add the new levels to the game rooms
            this.game.rooms = rooms;
            // // Generate the rope hole if it exists
            for (let room of rooms) {
                if (room.type === room_1.RoomType.ROPEHOLE) {
                    for (let x = room.roomX; x < room.roomX + room.width; x++) {
                        for (let y = room.roomY; y < room.roomY + room.height; y++) {
                            let tile = room.roomArray[x][y];
                            if (tile instanceof downLadder_1.DownLadder && tile.isRope) {
                                tile.generate();
                                callback(cave
                                    ? rooms.find((r) => r.type === room_1.RoomType.ROPECAVE)
                                    : rooms.find((r) => r.type === room_1.RoomType.START));
                                return;
                            }
                        }
                    }
                }
            }
            // Return the start room or the rope cave room
            callback(cave
                ? rooms.find((r) => r.type === room_1.RoomType.ROPECAVE)
                : rooms.find((r) => r.type === room_1.RoomType.START));
        };
        this.generateFirstNFloors = async (game, numFloors) => {
            await this.generate(game, 0, false, () => { });
            for (let i = 0; i < numFloors; i++) {
                let foundRoom = this.game.rooms
                    .slice()
                    .reverse()
                    .find((room) => room.type === room_1.RoomType.DOWNLADDER);
                if (foundRoom) {
                    for (let x = foundRoom.roomX; x < foundRoom.roomX + foundRoom.width; x++) {
                        for (let y = foundRoom.roomY; y < foundRoom.roomY + foundRoom.height; y++) {
                            let tile = foundRoom.roomArray[x][y];
                            if (tile instanceof downLadder_1.DownLadder) {
                                tile.generate();
                                break;
                            }
                        }
                    }
                }
            }
        };
        this.draw = (delta) => {
            game_1.Game.ctx.fillStyle = "rgba(0, 0, 0, 1)";
            game_1.Game.ctx.fillRect(0, 0, gameConstants_1.GameConstants.WIDTH, gameConstants_1.GameConstants.HEIGHT);
            if (document.cookie.includes("showgeneration=true")) {
                if (this.partialLevel.partitions) {
                    this.partialLevel.partitions.forEach((partition) => {
                        partition.draw(delta, this.levelParams.mapWidth / 2, this.levelParams.mapHeight / 2);
                    });
                }
            }
            else {
                game_1.Game.ctx.fillStyle = "rgb(255, 255, 255)";
                let dimensions = game_1.Game.measureText("generating level...");
                game_1.Game.fillText("generating level...", gameConstants_1.GameConstants.WIDTH / 2 - dimensions.width / 2, gameConstants_1.GameConstants.HEIGHT / 2 - dimensions.height / 2);
            }
        };
    }
}
exports.LevelGenerator = LevelGenerator;
LevelGenerator.ANIMATION_CONSTANT = 1;


/***/ }),

/***/ "./src/levelParametersGenerator.ts":
/*!*****************************************!*\
  !*** ./src/levelParametersGenerator.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LevelParameterGenerator = exports.enemyClasses = void 0;
const crabEnemy_1 = __webpack_require__(/*! ./entity/enemy/crabEnemy */ "./src/entity/enemy/crabEnemy.ts");
const frogEnemy_1 = __webpack_require__(/*! ./entity/enemy/frogEnemy */ "./src/entity/enemy/frogEnemy.ts");
const zombieEnemy_1 = __webpack_require__(/*! ./entity/enemy/zombieEnemy */ "./src/entity/enemy/zombieEnemy.ts");
const skullEnemy_1 = __webpack_require__(/*! ./entity/enemy/skullEnemy */ "./src/entity/enemy/skullEnemy.ts");
const energyWizard_1 = __webpack_require__(/*! ./entity/enemy/energyWizard */ "./src/entity/enemy/energyWizard.ts");
const chargeEnemy_1 = __webpack_require__(/*! ./entity/enemy/chargeEnemy */ "./src/entity/enemy/chargeEnemy.ts");
const bishopEnemy_1 = __webpack_require__(/*! ./entity/enemy/bishopEnemy */ "./src/entity/enemy/bishopEnemy.ts");
const armoredzombieEnemy_1 = __webpack_require__(/*! ./entity/enemy/armoredzombieEnemy */ "./src/entity/enemy/armoredzombieEnemy.ts");
const bigSkullEnemy_1 = __webpack_require__(/*! ./entity/enemy/bigSkullEnemy */ "./src/entity/enemy/bigSkullEnemy.ts");
const queenEnemy_1 = __webpack_require__(/*! ./entity/enemy/queenEnemy */ "./src/entity/enemy/queenEnemy.ts");
const knightEnemy_1 = __webpack_require__(/*! ./entity/enemy/knightEnemy */ "./src/entity/enemy/knightEnemy.ts");
const bigKnightEnemy_1 = __webpack_require__(/*! ./entity/enemy/bigKnightEnemy */ "./src/entity/enemy/bigKnightEnemy.ts");
const fireWizard_1 = __webpack_require__(/*! ./entity/enemy/fireWizard */ "./src/entity/enemy/fireWizard.ts");
const rookEnemy_1 = __webpack_require__(/*! ./entity/enemy/rookEnemy */ "./src/entity/enemy/rookEnemy.ts");
const armoredSkullEnemy_1 = __webpack_require__(/*! ./entity/enemy/armoredSkullEnemy */ "./src/entity/enemy/armoredSkullEnemy.ts");
const mummyEnemy_1 = __webpack_require__(/*! ./entity/enemy/mummyEnemy */ "./src/entity/enemy/mummyEnemy.ts");
const spiderEnemy_1 = __webpack_require__(/*! ./entity/enemy/spiderEnemy */ "./src/entity/enemy/spiderEnemy.ts");
exports.enemyClasses = {
    1: crabEnemy_1.CrabEnemy,
    2: frogEnemy_1.FrogEnemy,
    3: zombieEnemy_1.ZombieEnemy,
    4: skullEnemy_1.SkullEnemy,
    5: energyWizard_1.EnergyWizardEnemy,
    6: chargeEnemy_1.ChargeEnemy,
    7: rookEnemy_1.RookEnemy,
    8: bishopEnemy_1.BishopEnemy,
    9: armoredzombieEnemy_1.ArmoredzombieEnemy,
    10: bigSkullEnemy_1.BigSkullEnemy,
    11: queenEnemy_1.QueenEnemy,
    12: knightEnemy_1.KnightEnemy,
    13: bigKnightEnemy_1.BigKnightEnemy,
    14: fireWizard_1.FireWizardEnemy,
    15: armoredSkullEnemy_1.ArmoredSkullEnemy,
    16: mummyEnemy_1.MummyEnemy,
    17: spiderEnemy_1.SpiderEnemy,
};
class LevelParameterGenerator {
    /**
     * Generates level parameters based on the current depth.
     * @param depth The current depth level.
     * @returns An object conforming to the LevelParameters interface.
     */
    static getParameters(depth) {
        return {
            minRoomCount: depth > 0 ? 0 : 0,
            maxRoomCount: depth > 0 ? 12 : 6,
            maxRoomArea: depth > 0 ? 120 + 10 * depth : 40,
            mapWidth: 25 + 5 * depth,
            mapHeight: 25 + 5 * depth,
            splitProbabilities: [0.75, 1.0, 0.25],
            wallRemoveProbability: depth > 0 ? 0.1 : 1,
            numLoopDoorsRange: [4, 8],
            numberOfRooms: depth > 0 ? 5 : 3,
            softMaxRoomArea: depth > 0 ? 0.5 * (120 + 10 * depth) : 40,
        };
    }
}
exports.LevelParameterGenerator = LevelParameterGenerator;


/***/ }),

/***/ "./src/lightSource.ts":
/*!****************************!*\
  !*** ./src/lightSource.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LightSource = void 0;
class LightSource {
    constructor(x, y, r, c = [180, 60, 5], b = 1) {
        this.b = 1;
        this.updatePosition = (x, y) => {
            this.x = x;
            this.y = y;
        };
        this.shouldUpdate = () => {
            return true;
            this.hasChanged =
                this.x !== this.oldX ||
                    this.y !== this.oldY ||
                    this.r !== this.oldR ||
                    this.c !== this.oldC ||
                    this.b !== this.oldB ||
                    this.hasChanged;
            return this.hasChanged;
        };
        this.x = x;
        this.y = y;
        this.r = r;
        this.c = c;
        this.b = b;
        this.oldX = x;
        this.oldY = y;
        this.oldR = r;
        this.oldC = c;
        this.oldB = b;
        this.hasChanged = true;
    }
}
exports.LightSource = LightSource;


/***/ }),

/***/ "./src/lighting.ts":
/*!*************************!*\
  !*** ./src/lighting.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Lighting = void 0;
const lightSource_1 = __webpack_require__(/*! ./lightSource */ "./src/lightSource.ts");
class Lighting {
}
exports.Lighting = Lighting;
Lighting.momentaryLight = (room, x, y, radius, color, duration, brightness, delay) => {
    const lightSource = Lighting.newLightSource(x, y, color, radius, brightness);
    setTimeout(() => {
        room.updateLightSources(lightSource);
        setTimeout(() => {
            room.updateLightSources(lightSource, true);
        }, duration);
    }, delay);
};
Lighting.newLightSource = (x, y, color, radius, brightness) => {
    return new lightSource_1.LightSource(x, y, radius, color, brightness);
};
Lighting.addLightSource = (room, lightSource) => {
    room.lightSources.push(lightSource);
};
Lighting.removeLightSource = (room, lightSource) => {
    room.lightSources = room.lightSources.filter((ls) => ls !== lightSource);
};


/***/ }),

/***/ "./src/map.ts":
/*!********************!*\
  !*** ./src/map.ts ***!
  \********************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Map = void 0;
const game_1 = __webpack_require__(/*! ./game */ "./src/game.ts");
const gameConstants_1 = __webpack_require__(/*! ./gameConstants */ "./src/gameConstants.ts");
const room_1 = __webpack_require__(/*! ./room/room */ "./src/room/room.ts");
const entity_1 = __webpack_require__(/*! ./entity/entity */ "./src/entity/entity.ts");
class Map {
    constructor(game, player) {
        this.mapData = [];
        this.oldMapData = [];
        this.offsetX = 0;
        this.offsetY = 0;
        this.softOffsetX = 0;
        this.softOffsetY = 0;
        this.saveMapData = () => {
            this.clearMap();
            for (const room of this.game.levels[this.player.depth].rooms) {
                if (this.game.room.mapGroup === room.mapGroup &&
                    (room.entered === true || gameConstants_1.GameConstants.DEVELOPER_MODE)) {
                    this.mapData.push({
                        room: room,
                        walls: room.innerWalls,
                        doors: room.doors,
                        entities: room.entities,
                        items: room.items,
                        players: this.game.players,
                    });
                }
            }
            const enteredRooms = this.mapData
                .map((data) => data.room)
                .filter((room) => room.entered);
            if (enteredRooms.length > 0) {
                const sortedByX = [...enteredRooms].sort((a, b) => a.roomX - b.roomX);
                const sortedByY = [...enteredRooms].sort((a, b) => a.roomY - b.roomY);
                const maxX = sortedByX[sortedByX.length - 1].roomX;
                const minY = sortedByY[0].roomY;
                this.offsetX = maxX;
                this.offsetY = minY;
            }
            else {
                this.offsetX = 0;
                this.offsetY = 0;
            }
        };
        this.clearMap = () => {
            this.mapData = [];
        };
        this.saveOldMap = () => {
            this.oldMapData = [...this.mapData];
        };
        this.renderMap = (delta) => {
            game_1.Game.ctx.save(); // Save the current canvas state
            this.setInitialCanvasSettings(1);
            this.translateCanvas(0);
            for (const data of this.mapData) {
                this.drawRoom(data, delta);
            }
            /*for (const data of this.oldMapData) {
              this.drawRoom(data);
            }*/
            this.resetCanvasTransform();
            game_1.Game.ctx.restore(); // Restore the canvas state
        };
        this.updateOffsetXY = () => {
            let diffX = this.offsetX - this.softOffsetX;
            let diffY = this.offsetY - this.softOffsetY;
            if (Math.abs(diffX) > 0.01) {
                this.softOffsetX += diffX * 0.1;
                this.softOffsetX = this.softOffsetX;
            }
            else
                this.softOffsetX = this.offsetX;
            if (Math.abs(diffY) > 0.01) {
                this.softOffsetY += diffY * 0.1;
                this.softOffsetY = this.softOffsetY;
            }
            else
                this.softOffsetY = this.offsetY;
        };
        this.draw = (delta) => {
            this.updateOffsetXY();
            this.renderMap(delta);
        };
        this.setInitialCanvasSettings = (alpha) => {
            game_1.Game.ctx.globalAlpha = alpha;
            game_1.Game.ctx.globalCompositeOperation = "source-over";
        };
        this.translateCanvas = (offset) => {
            game_1.Game.ctx.translate(Math.floor(0.95 * gameConstants_1.GameConstants.WIDTH) -
                //this.game.room.roomX -
                //Math.floor(0.5 * this.game.room.width) +
                15 * this.scale -
                Math.floor(this.softOffsetX), Math.floor(0.05 * gameConstants_1.GameConstants.HEIGHT) -
                //this.game.room.roomY -
                //Math.floor(0.5 * this.game.room.height) -
                1 * this.scale -
                offset -
                Math.floor(this.softOffsetY));
        };
        this.drawRoom = (data, delta) => {
            //this.drawUnderRoomPlayers(data.players, delta);
            this.drawRoomOutline(data.room);
            this.drawRoomWalls(data.walls);
            this.drawRoomDoors(data.doors);
            this.drawRoomEntities(data.entities);
            this.drawRoomItems(data.items);
            this.drawRoomPlayers(data.players, delta);
        };
        this.drawRoomOutline = (level) => {
            const s = this.scale;
            game_1.Game.ctx.fillStyle = "#5A5A5A";
            game_1.Game.ctx.fillRect(level.roomX * s + 0, level.roomY * s + 0, level.width * s - 0, level.height * s - 0);
            if (level.type === room_1.RoomType.UPLADDER)
                game_1.Game.ctx.fillStyle = "#101460";
            if (level.type === room_1.RoomType.DOWNLADDER)
                game_1.Game.ctx.fillStyle = "#601410";
            game_1.Game.ctx.fillStyle = "black";
            game_1.Game.ctx.fillRect(level.roomX * s + 1, level.roomY * s + 1, level.width * s - 2, level.height * s - 2);
        };
        this.drawRoomWalls = (walls) => {
            const s = this.scale;
            game_1.Game.ctx.save(); // Save the current canvas state
            for (const wall of walls) {
                game_1.Game.ctx.fillStyle = "#404040";
                game_1.Game.ctx.fillRect(wall.x * s, wall.y * s, 1 * s, 1 * s);
            }
            game_1.Game.ctx.restore(); // Restore the canvas state
        };
        this.drawRoomDoors = (doors) => {
            const s = this.scale;
            game_1.Game.ctx.save(); // Save the current canvas state
            for (const door of doors) {
                if (door.opened === false)
                    game_1.Game.ctx.fillStyle = "#5A5A5A";
                if (door.opened === true) {
                    game_1.Game.ctx.fillStyle = "black";
                    game_1.Game.ctx.fillRect(door.x * s, door.y * s, 1 * s, 1 * s);
                }
                game_1.Game.ctx.fillStyle = "#5A5A5A"; // Reset to default after each door
            }
            game_1.Game.ctx.restore(); // Restore the canvas state
        };
        this.drawRoomPlayers = (players, delta) => {
            const s = this.scale;
            game_1.Game.ctx.save(); // Save the current canvas state
            for (const i in players) {
                game_1.Game.ctx.fillStyle = "white";
                if (this.game.levels[players[i].depth].rooms[players[i].levelID]
                    .mapGroup === this.game.room.mapGroup) {
                    game_1.Game.ctx.fillRect(players[i].x * s, players[i].y * s, 1 * s, 1 * s);
                }
            }
            game_1.Game.ctx.restore(); // Restore the canvas state
        };
        this.drawUnderRoomPlayers = (players, delta) => {
            const s = this.scale;
            game_1.Game.ctx.save(); // Save the current canvas state
            for (const i in players) {
                this.game.rooms[players[i].levelID].mapGroup === this.game.room.mapGroup;
                {
                    if (Math.floor(Date.now() / 300) % 2) {
                        game_1.Game.ctx.fillStyle = "#4D8C8C";
                        // Draw 3x3 outline box around player
                        game_1.Game.ctx.fillRect((players[i].x - 1) * s, (players[i].y - 1) * s, 1 * s, 1 * s); // Top left
                        game_1.Game.ctx.fillRect(players[i].x * s, (players[i].y - 1) * s, 1 * s, 1 * s); // Top middle
                        game_1.Game.ctx.fillRect((players[i].x + 1) * s, (players[i].y - 1) * s, 1 * s, 1 * s); // Top right
                        game_1.Game.ctx.fillRect((players[i].x - 1) * s, players[i].y * s, 1 * s, 1 * s); // Middle left
                        game_1.Game.ctx.fillRect((players[i].x + 1) * s, players[i].y * s, 1 * s, 1 * s); // Middle right
                        game_1.Game.ctx.fillRect((players[i].x - 1) * s, (players[i].y + 1) * s, 1 * s, 1 * s); // Bottom left
                        game_1.Game.ctx.fillRect(players[i].x * s, (players[i].y + 1) * s, 1 * s, 1 * s); // Bottom middle
                        game_1.Game.ctx.fillRect((players[i].x + 1) * s, (players[i].y + 1) * s, 1 * s, 1 * s); // Bottom right
                    }
                }
            }
            game_1.Game.ctx.restore(); // Restore the canvas state
        };
        this.drawRoomEntities = (entities) => {
            const s = this.scale;
            game_1.Game.ctx.save(); // Save the current canvas state
            for (const enemy of entities) {
                this.setEntityColor(enemy);
                game_1.Game.ctx.fillRect(enemy.x * s, enemy.y * s, 1 * s, 1 * s);
            }
            game_1.Game.ctx.restore(); // Restore the canvas state
        };
        this.setEntityColor = (enemy) => {
            // No need to save/restore here as only fillStyle is being set
            if (enemy.type === entity_1.EntityType.ENEMY) {
                game_1.Game.ctx.fillStyle = "yellow";
            }
            if (enemy.type === entity_1.EntityType.PROP) {
                game_1.Game.ctx.fillStyle = "#847e87";
            }
            if (enemy.type === entity_1.EntityType.RESOURCE) {
                game_1.Game.ctx.fillStyle = "#5a595b";
            }
            if (enemy.type === entity_1.EntityType.FRIENDLY) {
                game_1.Game.ctx.fillStyle = "cyan";
            }
        };
        this.drawRoomItems = (items) => {
            const s = this.scale;
            game_1.Game.ctx.save(); // Save the current canvas state
            for (const item of items) {
                let x = item.x;
                let y = item.y;
                game_1.Game.ctx.fillStyle = "#ac3232";
                if (!item.pickedUp) {
                    game_1.Game.ctx.fillRect(item.x * s, item.y * s, 1 * s, 1 * s);
                }
            }
            game_1.Game.ctx.restore(); // Restore the canvas state
        };
        this.resetCanvasTransform = () => {
            game_1.Game.ctx.setTransform(1, 0, 0, 1, 0, 0);
        };
        this.game = game;
        this.scale = 1;
        this.player = player;
        //this.depth = player.game.level.depth
    }
}
exports.Map = Map;


/***/ }),

/***/ "./src/menu.ts":
/*!*********************!*\
  !*** ./src/menu.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Menu = void 0;
const game_1 = __webpack_require__(/*! ./game */ "./src/game.ts");
const guiButton_1 = __webpack_require__(/*! ./guiButton */ "./src/guiButton.ts");
const input_1 = __webpack_require__(/*! ./input */ "./src/input.ts");
const gameConstants_1 = __webpack_require__(/*! ./gameConstants */ "./src/gameConstants.ts");
class Menu {
    constructor() {
        // Example action methods
        this.startGame = () => {
            console.log("Game Started");
            this.close();
            // Implement game start logic
        };
        this.exitGame = () => {
            console.log("Exit Game");
            // Implement exit game logic
        };
        this.openAudioSettings = () => {
            console.log("Audio Settings Opened");
            // Implement audio settings logic
        };
        this.openGraphicsSettings = () => {
            console.log("Graphics Settings Opened");
            // Implement graphics settings logic
        };
        this.openControlsSettings = () => {
            console.log("Controls Settings Opened");
            // Implement controls settings logic
        };
        this.buttons = [];
        this.open = false;
        this.selectedButton = 0;
        this.subMenus = {};
        this.currentSubMenu = null;
        //this.initializeMainMenu();
    }
    initializeMainMenu() {
        this.addButton(new guiButton_1.guiButton(0, 0, 200, 50, "Start Game", this.startGame));
        this.addButton(new guiButton_1.guiButton(0, 60, 200, 50, "Settings", () => this.openSubMenu("Settings")));
        this.addButton(new guiButton_1.guiButton(0, 120, 200, 50, "Exit", this.exitGame));
        this.initializeSettingsMenu();
        this.positionButtons();
    }
    initializeSettingsMenu() {
        const settingsMenu = new Menu();
        settingsMenu.addButton(new guiButton_1.guiButton(0, 0, 200, 50, "Audio", this.openAudioSettings));
        settingsMenu.addButton(new guiButton_1.guiButton(0, 60, 200, 50, "Graphics", this.openGraphicsSettings));
        settingsMenu.addButton(new guiButton_1.guiButton(0, 120, 200, 50, "Controls", this.openControlsSettings));
        settingsMenu.addButton(new guiButton_1.guiButton(0, 180, 200, 50, "Back", () => this.closeSubMenu()));
        settingsMenu.positionButtons();
        this.subMenus["Settings"] = settingsMenu;
    }
    addButton(button) {
        this.buttons.push(button);
    }
    drawMenu() {
        if (!this.open && !this.currentSubMenu)
            return;
        game_1.Game.ctx.save();
        game_1.Game.ctx.fillStyle = "rgba(0, 0, 0, 0.5)";
        game_1.Game.ctx.fillRect(0, 0, innerWidth, innerHeight);
        const menuToDraw = this.currentSubMenu
            ? this.subMenus[this.currentSubMenu]
            : this;
        menuToDraw.buttons.forEach((button) => {
            this.drawButton(button, menuToDraw);
        });
        game_1.Game.ctx.restore();
    }
    drawButton(button, menu) {
        game_1.Game.ctx.fillStyle =
            menu.selectedButton === menu.buttons.indexOf(button)
                ? "rgba(200, 200, 200, 1)"
                : "rgba(255, 255, 255, 1)";
        game_1.Game.ctx.fillRect(button.x, button.y, button.width, button.height);
        game_1.Game.ctx.fillStyle = "rgba(0, 0, 0, 1)";
        game_1.Game.ctx.font = "20px Arial";
        const textWidth = game_1.Game.measureText(button.text).width;
        const textX = button.x + (button.width - textWidth) / 2;
        const textY = button.y + button.height / 2 + game_1.Game.letter_height / 2;
        game_1.Game.fillText(button.text, textX, textY);
    }
    inputHandler(input) {
        if (!this.open)
            return;
        switch (input) {
            case input_1.InputEnum.ESCAPE:
                if (this.currentSubMenu) {
                    this.closeSubMenu();
                }
                else {
                    this.open = false;
                }
                break;
            case input_1.InputEnum.UP:
                this.up();
                break;
            case input_1.InputEnum.DOWN:
                this.down();
                break;
            case input_1.InputEnum.SPACE:
                this.select();
                break;
            default:
                break;
        }
    }
    openSubMenu(menuName) {
        if (this.subMenus[menuName]) {
            this.currentSubMenu = menuName;
            this.selectedButton = 0;
        }
    }
    closeSubMenu() {
        this.currentSubMenu = null;
        this.selectedButton = 0;
    }
    close() {
        this.open = false;
        this.currentSubMenu = null;
    }
    select() {
        const menuToSelect = this.currentSubMenu
            ? this.subMenus[this.currentSubMenu]
            : this;
        if (menuToSelect.open) {
            menuToSelect.buttons[menuToSelect.selectedButton].onClick();
        }
    }
    up() {
        const menuToNavigate = this.currentSubMenu
            ? this.subMenus[this.currentSubMenu]
            : this;
        if (menuToNavigate.open) {
            menuToNavigate.selectedButton =
                (menuToNavigate.selectedButton - 1 + menuToNavigate.buttons.length) %
                    menuToNavigate.buttons.length;
        }
    }
    down() {
        const menuToNavigate = this.currentSubMenu
            ? this.subMenus[this.currentSubMenu]
            : this;
        if (menuToNavigate.open) {
            menuToNavigate.selectedButton =
                (menuToNavigate.selectedButton + 1) % menuToNavigate.buttons.length;
        }
    }
    positionButtons() {
        const startX = (gameConstants_1.GameConstants.WIDTH - 200) / 2;
        const startY = (gameConstants_1.GameConstants.HEIGHT - this.buttons.length * 60) / 2;
        this.buttons.forEach((button, index) => {
            button.x = startX;
            button.y = startY + index * 60;
        });
    }
}
exports.Menu = Menu;


/***/ }),

/***/ "./src/mouseCursor.ts":
/*!****************************!*\
  !*** ./src/mouseCursor.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MouseCursor = void 0;
const game_1 = __webpack_require__(/*! ./game */ "./src/game.ts");
const input_1 = __webpack_require__(/*! ./input */ "./src/input.ts");
const gameConstants_1 = __webpack_require__(/*! ./gameConstants */ "./src/gameConstants.ts");
class MouseCursor {
    constructor() {
        this.cursorSize = 5; // Size of the cursor rectangle
        this.clickX = 0;
        this.clickY = 0;
        this.tileX = 6;
        this.frame = 0;
        this.setIcon = (icon) => {
            switch (icon) {
                case "arrow":
                    this.tileX = 8;
                    break;
                case "sword":
                    this.tileX = 7;
                    break;
                case "hand":
                    this.tileX = 6;
                    break;
                case "wait":
                    this.tileX = 9;
                    break;
                case "grab":
                    this.tileX = 10;
                    break;
                case "up":
                    this.tileX = 11;
                    break;
                case "right":
                    this.tileX = 12;
                    break;
                case "down":
                    this.tileX = 13;
                    break;
                case "left":
                    this.tileX = 14;
                    break;
                case "mine":
                    this.tileX = 15;
                    break;
            }
        };
        this.draw = (delta, mobile = false) => {
            if (!mobile)
                this.drawCursor();
            this.drawAnimation(delta);
        };
    }
    static getInstance() {
        if (!MouseCursor.instance) {
            MouseCursor.instance = new MouseCursor();
        }
        return MouseCursor.instance;
    }
    drawCursor() {
        game_1.Game.ctx.save();
        //Game.ctx.fillRect(Input.mouseX, Input.mouseY, 1, 1);
        game_1.Game.drawFX(this.tileX, 0, 1, 1, input_1.Input.mouseX / gameConstants_1.GameConstants.TILESIZE - 8 / gameConstants_1.GameConstants.TILESIZE, input_1.Input.mouseY / gameConstants_1.GameConstants.TILESIZE - 8 / gameConstants_1.GameConstants.TILESIZE, 1, 1);
        game_1.Game.ctx.restore();
    }
    drawAnimation(delta) {
        if (this.frame > 5) {
            //14 is max frame for animation
            return;
        }
        game_1.Game.drawFX(9 + Math.ceil(this.frame), 1, 1, 1, this.clickX / gameConstants_1.GameConstants.TILESIZE - 8 / gameConstants_1.GameConstants.TILESIZE, this.clickY / gameConstants_1.GameConstants.TILESIZE - 8 / gameConstants_1.GameConstants.TILESIZE, 1, 1);
        this.frame = this.frame + delta / 5;
    }
    startClickAnim() {
        this.frame = 0;
        this.clickX = input_1.Input.mouseX;
        this.clickY = input_1.Input.mouseY;
    }
    getPosition() {
        return { x: input_1.Input.mouseX, y: input_1.Input.mouseY };
    }
    getTilePosition() {
        return {
            x: Math.floor(input_1.Input.mouseX / gameConstants_1.GameConstants.TILESIZE),
            y: Math.floor(input_1.Input.mouseY / gameConstants_1.GameConstants.TILESIZE),
        };
    }
    getInventoryPosition() {
        return {
            x: input_1.Input.mouseX,
            y: input_1.Input.mouseY,
        };
    }
}
exports.MouseCursor = MouseCursor;


/***/ }),

/***/ "./src/particle/attackAnimation.ts":
/*!*****************************************!*\
  !*** ./src/particle/attackAnimation.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AttackAnimation = void 0;
const game_1 = __webpack_require__(/*! ../game */ "./src/game.ts");
const particle_1 = __webpack_require__(/*! ./particle */ "./src/particle/particle.ts");
class AttackAnimation extends particle_1.Particle {
    constructor(x, y, type, direction) {
        super();
        this.drawTopLayer = (delta) => {
            // if (this.frame <= this.frames / 2)
            this.drawAnimation(delta);
        };
        this.drawAnimation = (delta) => {
            if (this.dead)
                return;
            if (this.frame >= 0) {
                game_1.Game.drawFX(this.tileX + 2 * Math.round(Math.max(0, this.frame) / 2), this.tileY + this.tileYOffset, 2, 2, this.x - 0.5 + this.xOffset, this.y - 0.5 + this.yOffset, 2, 2);
            }
            this.frame += this.animationSpeed * delta;
            if (this.frame > this.frames)
                this.dead = true;
        };
        this.x = x;
        this.y = y - 0.25;
        this.dead = false;
        this.frame = 0;
        this.type = type;
        this.xOffset = 0;
        this.yOffset = 0;
        this.tileX = 12;
        this.animationSpeed = 1;
        switch (type) {
            case "dagger":
                this.frames = 8;
                this.tileY = 24;
                this.yOffset = 0;
                this.xOffset = 0;
                switch (direction) {
                    case game_1.Direction.DOWN:
                        this.yOffset -= 0.75;
                        break;
                    case game_1.Direction.UP:
                        this.yOffset += 0.5;
                        break;
                    case game_1.Direction.LEFT:
                        this.xOffset += 0.8;
                        this.yOffset += 0.25;
                        break;
                    case game_1.Direction.RIGHT:
                        this.xOffset -= 0.8;
                        this.yOffset -= 0.25;
                        break;
                }
                break;
            case "warhammer":
                this.frames = 8;
                this.tileX = 12;
                this.tileY = 32;
                this.yOffset = -0.75;
                this.xOffset = -0;
                this.frame = -5;
                this.animationSpeed = 2;
                switch (direction) {
                    case game_1.Direction.DOWN:
                        this.yOffset -= 0.25;
                        this.xOffset += 0.125;
                        break;
                    case game_1.Direction.UP:
                        this.yOffset += 1;
                        this.xOffset += 0.25;
                        break;
                    case game_1.Direction.LEFT:
                        this.xOffset += 0.75;
                        this.yOffset += 0.5;
                        break;
                    case game_1.Direction.RIGHT:
                        this.xOffset -= 0.75;
                        this.yOffset += 0.5;
                        break;
                }
                break;
            case "dualdagger":
                this.frames = 8;
                this.tileY = 40;
                this.yOffset = 0;
                this.xOffset = 0;
                switch (direction) {
                    case game_1.Direction.DOWN:
                        this.yOffset -= 1;
                        break;
                    case game_1.Direction.UP:
                        this.yOffset += 0.5;
                        break;
                    case game_1.Direction.LEFT:
                        this.xOffset += 0.8;
                        this.yOffset -= 0.25;
                        break;
                    case game_1.Direction.RIGHT:
                        this.xOffset -= 0.8;
                        this.yOffset -= 0.25;
                        break;
                }
                break;
            case "dualdagger2":
                this.frames = 8;
                this.tileY = 48;
                this.yOffset = 0;
                this.xOffset = 0;
                //this.animationSpeed = 1;
                switch (direction) {
                    case game_1.Direction.DOWN:
                        this.yOffset -= 1;
                        break;
                    case game_1.Direction.UP:
                        this.yOffset += 0.5;
                        break;
                    case game_1.Direction.LEFT:
                        this.xOffset += 0.8;
                        this.yOffset -= 0.25;
                        break;
                    case game_1.Direction.RIGHT:
                        this.xOffset -= 0.8;
                        this.yOffset -= 0.25;
                        break;
                }
                break;
            case "spear":
                this.frames = 5;
                this.tileY = 32;
                this.tileX = 22;
                this.animationSpeed = 0.5;
                switch (direction) {
                    case game_1.Direction.DOWN:
                        this.yOffset -= 0.75;
                        this.xOffset += 0.125;
                        break;
                    case game_1.Direction.UP:
                        //needs to draw behind player but its fine for now
                        this.yOffset += 1;
                        this.xOffset -= 0.125;
                        break;
                    case game_1.Direction.LEFT:
                        this.xOffset += 1;
                        this.yOffset += 0.25;
                        break;
                    case game_1.Direction.RIGHT:
                        this.xOffset -= 1;
                        this.yOffset += 0.25;
                        break;
                }
        }
        switch (direction) {
            case game_1.Direction.DOWN:
                this.tileYOffset = 0;
                break;
            case game_1.Direction.UP:
                this.tileYOffset = 2;
                break;
            case game_1.Direction.LEFT:
                this.tileYOffset = 4;
                break;
            case game_1.Direction.RIGHT:
                this.tileYOffset = 6;
                break;
        }
    }
}
exports.AttackAnimation = AttackAnimation;


/***/ }),

/***/ "./src/particle/damageNumber.ts":
/*!**************************************!*\
  !*** ./src/particle/damageNumber.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DamageNumber = void 0;
const game_1 = __webpack_require__(/*! ../game */ "./src/game.ts");
const gameConstants_1 = __webpack_require__(/*! ../gameConstants */ "./src/gameConstants.ts");
const particle_1 = __webpack_require__(/*! ./particle */ "./src/particle/particle.ts");
class DamageNumber extends particle_1.Particle {
    constructor(room, x, y, damage, color, outlineColor) {
        super();
        this.alpha = 1;
        this.frame = 0;
        this.xoffset = 0;
        this.getXoffset = () => {
            if (this.room.particles.length > 0) {
                let damageNumbers = this.room.particles.filter((p) => p instanceof DamageNumber);
                if (damageNumbers.length % 3 === 0)
                    return 0.5;
                if (damageNumbers.length % 3 === 1)
                    return 0;
                if (damageNumbers.length % 3 === 2)
                    return 0.25;
            }
        };
        this.drawTopLayer = (delta) => {
            game_1.Game.ctx.save();
            if (this.dead) {
                game_1.Game.ctx.restore();
                return;
            }
            if (this.frame > 15)
                this.alpha -= 0.025 * delta;
            this.y -= 0.03 * delta;
            this.frame += delta;
            let width = game_1.Game.measureText(this.damage.toString()).width;
            if (this.alpha <= 0.002) {
                this.alpha = 0;
                this.dead = true;
            }
            game_1.Game.ctx.globalAlpha = this.alpha;
            game_1.Game.fillTextOutline(this.damage.toString(), (this.x + 0.4 + this.xoffset) * gameConstants_1.GameConstants.TILESIZE - width / 2, (this.y - 0.6) * gameConstants_1.GameConstants.TILESIZE, this.outlineColor, this.color);
            game_1.Game.ctx.globalAlpha = 1;
            game_1.Game.ctx.restore();
        };
        this.room = room;
        this.damage = damage;
        this.x = x;
        this.y = y;
        if (color)
            this.color = color;
        else
            this.color = "red";
        if (outlineColor)
            this.outlineColor = outlineColor;
        else
            this.outlineColor = gameConstants_1.GameConstants.OUTLINE;
        this.xoffset = Math.random() * 0.2;
    }
}
exports.DamageNumber = DamageNumber;


/***/ }),

/***/ "./src/particle/deathParticle.ts":
/*!***************************************!*\
  !*** ./src/particle/deathParticle.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DeathParticle = void 0;
const game_1 = __webpack_require__(/*! ../game */ "./src/game.ts");
const gameConstants_1 = __webpack_require__(/*! ../gameConstants */ "./src/gameConstants.ts");
const particle_1 = __webpack_require__(/*! ./particle */ "./src/particle/particle.ts");
class DeathParticle extends particle_1.Particle {
    constructor(x, y) {
        super();
        this.drawTopLayer = (delta) => {
            if (this.dead)
                return;
            let yOffset = Math.max(0, ((this.frame - 3) * 3) / gameConstants_1.GameConstants.TILESIZE);
            let f = Math.round(this.frame);
            if (f == 2 || f == 4 || f == 6)
                game_1.Game.drawMob(2, 0, 1, 2, this.x, this.y - yOffset, 1, 2);
            else
                game_1.Game.drawFX(Math.round(this.frame), 4, 1, 2, this.x, this.y - yOffset, 1, 2);
            this.frame += 0.3 * delta;
            if (this.frame > 10)
                this.dead = true;
        };
        this.x = x;
        this.y = y - 1.5;
        this.dead = false;
        this.frame = 0;
    }
}
exports.DeathParticle = DeathParticle;


/***/ }),

/***/ "./src/particle/genericParticle.ts":
/*!*****************************************!*\
  !*** ./src/particle/genericParticle.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GenericParticle = void 0;
const particle_1 = __webpack_require__(/*! ./particle */ "./src/particle/particle.ts");
const game_1 = __webpack_require__(/*! ../game */ "./src/game.ts");
const gameConstants_1 = __webpack_require__(/*! ../gameConstants */ "./src/gameConstants.ts");
class GenericParticle extends particle_1.Particle {
    constructor(level, x, y, z, s, dx, dy, dz, color, delay, expirationTimer, targetX, targetY, targetZ) {
        super();
        this.render = () => {
            let scale = gameConstants_1.GameConstants.TILESIZE;
            let scaledS = this.s * this.alpha; // using alpha for scaling, not alpha
            let halfS = 0.5 * scaledS;
            let oldFillStyle = game_1.Game.ctx.fillStyle;
            game_1.Game.ctx.fillStyle = this.color;
            game_1.Game.ctx.imageSmoothingEnabled = false;
            game_1.Game.ctx.beginPath();
            game_1.Game.ctx.arc(Math.round(this.x * scale), Math.round((this.y - this.z) * scale), Math.round(halfS * scale), 0, 2 * Math.PI, false);
            game_1.Game.ctx.fill();
            game_1.Game.ctx.fillStyle = oldFillStyle;
        };
        this.draw = (delta) => {
            if (this.targetX)
                this.x += 0.1 * (this.targetX - this.x);
            else
                this.x += this.dx;
            if (this.targetY)
                this.y += 0.1 * (this.targetY - this.y);
            else
                this.y += this.dy;
            if (this.targetZ)
                this.z += 0.1 * (this.targetZ - this.z);
            else
                this.z += this.dz;
            this.dx *= 0.97;
            this.dy *= 0.97;
            if (this.z <= 0) {
                this.z = 0;
                this.dz *= -0.8;
            }
            // apply gravity
            this.dz -= 0.01;
            if (this.alpha < 0.2)
                this.alpha -= 0.007;
            else
                this.alpha -= 0.02;
            if (this.alpha <= 0.1)
                this.dead = true;
            this.expirationTimer--;
            if (this.expirationTimer <= 0)
                this.dead = true;
            if (this.dead)
                return;
            this.drawableY = this.y;
            this.render();
        };
        this.level = level;
        this.x = x;
        this.y = y;
        this.z = z;
        this.s = s;
        this.dx = dx;
        this.dy = dy;
        this.dz = dz;
        this.color = color;
        this.alpha = 1.0;
        if (delay !== undefined)
            this.delay = delay;
        this.targetX = targetX;
        this.targetY = targetY;
        this.targetZ = targetZ;
        this.expirationTimer = 1000000;
        if (expirationTimer !== undefined)
            this.expirationTimer = expirationTimer;
    }
}
exports.GenericParticle = GenericParticle;
GenericParticle.shotgun = (level, cx, cy, tx, ty, color) => {
    for (let i = 0; i < 4; i++) {
        level.particles.push(new GenericParticle(level, cx, cy, 0, Math.random() * 0.5 + 0.3, 0, 0, 0, color, 0, 10000000, tx + Math.random() - 0.5, ty + Math.random() - 0.5, 0));
    }
};
GenericParticle.spawnCluster = (level, cx, cy, color) => {
    for (let i = 0; i < 4; i++) {
        level.particles.push(new GenericParticle(level, cx + Math.random() * 0.05 - 0.025, cy + Math.random() * 0.05 - 0.025, Math.random() * 0.5, 0.0625 * (i + 8), 0.025 * (Math.random() * 2 - 1), 0.025 * (Math.random() * 2 - 1), 0.2 * (Math.random() - 1), color, 0));
    }
};


/***/ }),

/***/ "./src/particle/imageParticle.ts":
/*!***************************************!*\
  !*** ./src/particle/imageParticle.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ImageParticle = void 0;
const particle_1 = __webpack_require__(/*! ./particle */ "./src/particle/particle.ts");
const game_1 = __webpack_require__(/*! ../game */ "./src/game.ts");
const gameConstants_1 = __webpack_require__(/*! ../gameConstants */ "./src/gameConstants.ts");
class ImageParticle extends particle_1.Particle {
    constructor(room, x, y, z, s, dx, dy, dz, tileX, tileY, size, delay, expirationTimer, targetX, targetY, targetZ) {
        super();
        this.render = () => {
            let scale = gameConstants_1.GameConstants.TILESIZE;
            let yOffset = this.z * scale;
            let frame = this.s > 0.5 ? 1 : 0; // Placeholder frames for large and small particles
            game_1.Game.ctx.imageSmoothingEnabled = false;
            let adjustedTileX = this.tileX + this.size;
            game_1.Game.drawFX(adjustedTileX, this.tileY, 1, 1, this.x - this.alpha / 2, this.y - this.z - this.alpha / 2, 1, 1, this.shadeColor(), this.shadeAmount());
        };
        this.draw = (delta) => {
            game_1.Game.ctx.imageSmoothingEnabled = false;
            if (this.targetX)
                this.x += 0.2 * (this.targetX - this.x) * delta;
            else
                this.x += this.dx * delta;
            if (this.targetY)
                this.y += 0.2 * (this.targetY - this.y) * delta;
            else
                this.y += this.dy * delta;
            if (this.targetZ)
                this.z += 0.2 * (this.targetZ - this.z) * delta;
            else
                this.z += this.dz * delta;
            this.dx *= Math.pow(0.97, delta);
            this.dy *= Math.pow(0.97, delta);
            if (this.z <= 0) {
                this.z = 0;
                this.dz *= -0.8;
            }
            this.dz -= 0.01 * delta;
            this.expirationTimer -= delta;
            if (this.expirationTimer <= 0)
                this.dead = true;
            if (this.dead)
                return;
            this.drawableY = this.y;
            this.render();
        };
        this.room = room;
        this.x = x;
        this.y = y;
        this.z = z; // Use provided height
        this.s = s;
        this.dx = dx;
        this.dy = dy;
        this.dz = dz;
        this.tileX = tileX;
        this.tileY = tileY;
        this.size = size;
        this.alpha = 1.0;
        if (delay !== undefined)
            this.delay = delay;
        this.targetX = targetX;
        this.targetY = targetY;
        this.targetZ = targetZ;
        this.expirationTimer = 100; // Increased life duration
        if (expirationTimer !== undefined)
            this.expirationTimer = expirationTimer;
    }
}
exports.ImageParticle = ImageParticle;
ImageParticle.shotgun = (room, cx, cy, tx, ty, tileX, tileY) => {
    for (let i = 0; i < 4; i++) {
        room.particles.push(new ImageParticle(room, cx, cy, 0, Math.random() * 0.5 + 0.3, 0, 0, 0, tileX, tileY, 0));
    }
};
ImageParticle.spawnCluster = (level, cx, cy, tileX, tileY) => {
    for (let i = Math.floor(Math.random() * 3); i < 5; i++) {
        level.particles.push(new ImageParticle(level, cx + Math.random() * 0.05 - 0.025, // x
        cy + Math.random() * 0.05 - 0.025, // y
        Math.random() * 0.5, // z
        0.0625 * (i + 8), // s
        0.025 * (Math.random() * 2 - 1), //dx
        0.025 * (Math.random() * 2 - 1), //dy
        0.2 * (Math.random() - 1), //dz
        tileX, tileY, [2, 1, 0, 1, 2, 2, 2][i]));
    }
};


/***/ }),

/***/ "./src/particle/particle.ts":
/*!**********************************!*\
  !*** ./src/particle/particle.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Particle = void 0;
const drawable_1 = __webpack_require__(/*! ../drawable */ "./src/drawable.ts");
class Particle extends drawable_1.Drawable {
    constructor() {
        super(...arguments);
        this.drawTopLayer = (delta) => { };
        this.shadeAmount = () => {
            const x = Math.floor(this.x);
            const y = Math.floor(this.y);
            if (!this.room.softVis[x])
                return 0.9;
            const shade = this.room.softVis[x][y];
            return shade ?? 0.9;
        };
        this.shadeColor = () => {
            return this.room.shadeColor;
        };
    }
}
exports.Particle = Particle;


/***/ }),

/***/ "./src/particle/wizardTeleportParticle.ts":
/*!************************************************!*\
  !*** ./src/particle/wizardTeleportParticle.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WizardTeleportParticle = void 0;
const particle_1 = __webpack_require__(/*! ./particle */ "./src/particle/particle.ts");
const game_1 = __webpack_require__(/*! ../game */ "./src/game.ts");
class WizardTeleportParticle extends particle_1.Particle {
    constructor(x, y) {
        super();
        this.draw = (delta) => {
            if (this.dead)
                return;
            game_1.Game.drawFX(Math.floor(this.frame), 3, 1, 1, this.x, this.y - this.z, 1, 1);
            this.z += this.dz * delta;
            this.dz *= 0.9;
            this.frame += 0.3 * delta;
            if (this.frame > 6)
                this.dead = true;
        };
        this.x = x;
        this.y = y;
        this.dead = false;
        this.frame = 0;
        this.z = 0;
        this.dz = 0.1;
    }
}
exports.WizardTeleportParticle = WizardTeleportParticle;


/***/ }),

/***/ "./src/player/player.ts":
/*!******************************!*\
  !*** ./src/player/player.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Player = exports.PlayerDirection = void 0;
const input_1 = __webpack_require__(/*! ../input */ "./src/input.ts");
const gameConstants_1 = __webpack_require__(/*! ../gameConstants */ "./src/gameConstants.ts");
const game_1 = __webpack_require__(/*! ../game */ "./src/game.ts");
const door_1 = __webpack_require__(/*! ../tile/door */ "./src/tile/door.ts");
const trapdoor_1 = __webpack_require__(/*! ../tile/trapdoor */ "./src/tile/trapdoor.ts");
const inventory_1 = __webpack_require__(/*! ../inventory/inventory */ "./src/inventory/inventory.ts");
const sound_1 = __webpack_require__(/*! ../sound */ "./src/sound.ts");
const levelConstants_1 = __webpack_require__(/*! ../levelConstants */ "./src/levelConstants.ts");
const map_1 = __webpack_require__(/*! ../map */ "./src/map.ts");
const healthbar_1 = __webpack_require__(/*! ../healthbar */ "./src/healthbar.ts");
const drawable_1 = __webpack_require__(/*! ../drawable */ "./src/drawable.ts");
const hitWarning_1 = __webpack_require__(/*! ../hitWarning */ "./src/hitWarning.ts");
const item_1 = __webpack_require__(/*! ../item/item */ "./src/item/item.ts");
const enemy_1 = __webpack_require__(/*! ../entity/enemy/enemy */ "./src/entity/enemy/enemy.ts");
const mouseCursor_1 = __webpack_require__(/*! ../mouseCursor */ "./src/mouseCursor.ts");
const menu_1 = __webpack_require__(/*! ../menu */ "./src/menu.ts");
const bestiary_1 = __webpack_require__(/*! ../bestiary */ "./src/bestiary.ts");
const playerInputHandler_1 = __webpack_require__(/*! ./playerInputHandler */ "./src/player/playerInputHandler.ts");
const playerActionProcessor_1 = __webpack_require__(/*! ./playerActionProcessor */ "./src/player/playerActionProcessor.ts");
const playerMovement_1 = __webpack_require__(/*! ./playerMovement */ "./src/player/playerMovement.ts");
const playerRenderer_1 = __webpack_require__(/*! ./playerRenderer */ "./src/player/playerRenderer.ts");
var PlayerDirection;
(function (PlayerDirection) {
    PlayerDirection[PlayerDirection["DOWN"] = 0] = "DOWN";
    PlayerDirection[PlayerDirection["UP"] = 1] = "UP";
    PlayerDirection[PlayerDirection["RIGHT"] = 2] = "RIGHT";
    PlayerDirection[PlayerDirection["LEFT"] = 3] = "LEFT";
})(PlayerDirection = exports.PlayerDirection || (exports.PlayerDirection = {}));
var DrawDirection;
(function (DrawDirection) {
    DrawDirection[DrawDirection["X"] = 0] = "X";
    DrawDirection[DrawDirection["Y"] = 1] = "Y";
})(DrawDirection || (DrawDirection = {}));
class Player extends drawable_1.Drawable {
    constructor(game, x, y, isLocalPlayer) {
        super();
        this.drawMoveQueue = [];
        this.seenEnemies = new Set();
        this.bestiary = null;
        this.setHitXY = (newX, newY, distance = 0.5) => {
            this.renderer.hitX = distance * (this.x - newX);
            this.renderer.hitY = distance * (this.y - newY);
        };
        this.applyStatus = (enemy, status) => {
            if (enemy instanceof enemy_1.Enemy) {
                if (status.poison) {
                    enemy.poison();
                    return true;
                }
                if (status.blood) {
                    enemy.bleed();
                    return true;
                }
            }
        };
        this.isMouseOnPlayerTile = () => {
            return this.mouseToTile().x === this.x && this.mouseToTile().y === this.y;
        };
        this.isMouseAboveFloor = (offsetY = 0) => {
            const mouseX = this.mouseToTile().x;
            const mouseY = this.mouseToTile(offsetY).y;
            if (this.game.levelState === game_1.LevelState.LEVEL_GENERATION ||
                !this.game.started ||
                !this.game.room ||
                !this.game.room.roomArray ||
                !Array.isArray(this.game.room.roomArray[mouseX]) ||
                this.game.room.roomArray[mouseX][mouseY] === undefined)
                return false;
            return !(!this.game.room?.tileInside(mouseX, mouseY) ||
                (this.game.room?.tileInside(mouseX, mouseY) &&
                    this.game.room?.roomArray[mouseX][mouseY].isSolid() &&
                    !(this.game.room?.roomArray[mouseX][mouseY] instanceof door_1.Door)));
        };
        this.mouseInLine = () => {
            const mouseTile = this.mouseToTile();
            return mouseTile.x === this.x || mouseTile.y === this.y;
        };
        this.canMoveWithMouse = () => {
            if (!this.isMouseAboveFloor() && !this.isMouseAboveFloor(8))
                return;
            const mouseTile = this.mouseToTile();
            const offsetMouseTile = this.mouseToTile(8);
            let y = mouseTile.y;
            if (this.isMouseAboveFloor(8) && this.checkTileForEntity(offsetMouseTile)) {
                y = offsetMouseTile.y;
            }
            // Get mouse tile coordinates
            // Check if we're on same row or column
            const sameX = mouseTile.x === this.x;
            const sameY = y === this.y;
            // If both same, no movement needed
            if (sameX && sameY)
                return null;
            // Check for straight line movements first
            if (sameX) {
                if (y < this.y) {
                    return { direction: game_1.Direction.UP, x: this.x, y: this.y - 1 };
                }
                else {
                    return { direction: game_1.Direction.DOWN, x: this.x, y: this.y + 1 };
                }
            }
            if (sameY) {
                if (mouseTile.x < this.x) {
                    return { direction: game_1.Direction.LEFT, x: this.x - 1, y: this.y };
                }
                else {
                    return { direction: game_1.Direction.RIGHT, x: this.x + 1, y: this.y };
                }
            }
            return null;
        };
        this.moveWithMouse = () => {
            if (!gameConstants_1.GameConstants.MOVE_WITH_MOUSE)
                return;
            const moveData = this.canMoveWithMouse();
            if (moveData) {
                this.direction = moveData.direction;
                this.tryMove(moveData.x, moveData.y);
            }
        };
        this.mouseToTile = (offsetY = 0) => {
            // Get screen center coordinates
            const screenCenterX = gameConstants_1.GameConstants.WIDTH / 2;
            const screenCenterY = gameConstants_1.GameConstants.HEIGHT / 2;
            // Convert pixel offset to tile offset (this part was working correctly)
            const tileOffsetX = Math.floor((input_1.Input.mouseX - screenCenterX + gameConstants_1.GameConstants.TILESIZE / 2) /
                gameConstants_1.GameConstants.TILESIZE);
            const tileOffsetY = Math.floor((input_1.Input.mouseY + offsetY - screenCenterY + gameConstants_1.GameConstants.TILESIZE / 2) /
                gameConstants_1.GameConstants.TILESIZE);
            return {
                x: this.x + tileOffsetX,
                y: this.y + tileOffsetY,
            };
        };
        this.tileToMouse = (tileX, tileY) => {
            // Get screen center coordinates
            const screenCenterX = gameConstants_1.GameConstants.WIDTH / 2;
            const screenCenterY = gameConstants_1.GameConstants.HEIGHT / 2;
            // Calculate the offset from the center position
            const tileOffsetX = tileX - this.x;
            const tileOffsetY = tileY - this.y;
            // Convert tile offset to pixel coordinates
            const pixelX = screenCenterX + tileOffsetX * gameConstants_1.GameConstants.TILESIZE;
            const pixelY = screenCenterY + tileOffsetY * gameConstants_1.GameConstants.TILESIZE;
            return {
                x: pixelX,
                y: pixelY,
            };
        };
        this.moveRangeCheck = (x, y) => {
            const dx = Math.abs(this.x - x);
            const dy = Math.abs(this.y - y);
            return (dx <= this.moveRange &&
                dy <= this.moveRange &&
                (dx === 0 || dy === 0) &&
                dx + dy !== 0);
        };
        this.setTileCursorPosition = () => {
            const offsetX = Math.floor(gameConstants_1.GameConstants.WIDTH / 2) / gameConstants_1.GameConstants.TILESIZE;
            const offsetY = Math.floor(gameConstants_1.GameConstants.HEIGHT / 2) / gameConstants_1.GameConstants.TILESIZE;
            /*
            this.tileCursor = {
              x: this.mouseToTile().x - this.x + offsetX - 0.5,
              y: this.mouseToTile().y - this.y + offsetY - 0.5,
            };
            */
            const moveData = this.canMoveWithMouse();
            if (moveData) {
                this.tileCursor = {
                    x: moveData.x - this.x + offsetX - 0.5,
                    y: moveData.y - this.y + offsetY - 0.5,
                };
            }
        };
        this.enemyInRange = (eX, eY, range) => {
            // Use nullish coalescing operator for cleaner default value
            const r = range ?? 1;
            // Same tile - not in range
            if (eX === this.x && eY === this.y)
                return false;
            // Diagonal - not in range
            if (eX !== this.x && eY !== this.y)
                return false;
            // Check horizontal range
            if (eY === this.y) {
                return Math.abs(eX - this.x) <= r;
            }
            // Check vertical range
            if (eX === this.x) {
                return Math.abs(eY - this.y) <= r;
            }
            return false;
        };
        this.getDirectionFromCoords = (inputX, inputY) => {
            // Same position - no direction
            if (inputX === this.x && inputY === this.y)
                return "";
            // Diagonal - no direction
            if (inputX !== this.x && inputY !== this.y)
                return "";
            // Check horizontal
            if (inputY === this.y) {
                return inputX > this.x ? "right" : "left";
            }
            // Check vertical
            if (inputX === this.x) {
                return inputY > this.y ? "down" : "up";
            }
            return "arrow";
        };
        this.setCursorIcon = () => {
            // Early return cases
            if (this.inventory.isDragging) {
                mouseCursor_1.MouseCursor.getInstance().setIcon("grab");
                return;
            }
            const cursor = mouseCursor_1.MouseCursor.getInstance();
            const mousePos = cursor.getPosition();
            const mouseTile = this.mouseToTile();
            // Check cursor states in order of priority
            const cursorState = this.getCursorState(mousePos, mouseTile);
            cursor.setIcon(cursorState);
        };
        this.getCursorState = (mousePos, mouseTile) => {
            // 1. Check UI interactions
            if (this.isMouseInUI(mousePos)) {
                return "hand";
            }
            if (this.isEntityAttackable(mouseTile)) {
                return "sword";
            }
            // 2. Check game world interactions
            if (this.isMouseAboveFloor() && this.mouseInLine()) {
                // 2a. Check for attackable entities
                // 2b. Check for movement target
                if (this.enemyInRange(mouseTile.x, mouseTile.y, 1)) {
                    return this.getDirectionFromCoords(mouseTile.x, mouseTile.y);
                }
                // 2c. Default floor interaction
                return "hand";
            }
            // 3. Default cursor state
            return "arrow";
        };
        this.isMouseInUI = (mousePos) => {
            const { x, y } = mousePos;
            return (this.inventory.isPointInInventoryButton(x, y) ||
                this.isInventoryItemInteraction(x, y));
        };
        this.isInventoryItemInteraction = (x, y) => {
            const hasSelectedItem = this.inventory.itemAtSelectedSlot() instanceof item_1.Item;
            return ((this.inventory.isPointInQuickbarBounds(x, y).inBounds &&
                hasSelectedItem) ||
                (this.inventory.isOpen &&
                    this.inventory.isPointInInventoryBounds(x, y).inBounds &&
                    hasSelectedItem));
        };
        this.isEntityAttackable = (mouseTile) => {
            // Check current tile
            const currentTileCheck = this.checkTileForEntity(mouseTile);
            if (currentTileCheck)
                return true;
            // Check tile above with 0.5 tile offset
            const belowTileCheck = this.checkTileForEntity({
                x: mouseTile.x,
                y: this.mouseToTile(gameConstants_1.GameConstants.TILESIZE / 2).y,
            });
            return belowTileCheck;
        };
        this.checkTileForEntity = (tile) => {
            const range = this.inventory.weapon?.range ?? 1;
            return this.game.room.entities.some((entity) => {
                return (entity.x === tile.x &&
                    entity.y === tile.y &&
                    this.enemyInRange(entity.x, entity.y, range));
            });
        };
        this.restart = () => {
            this.dead = false;
            this.game.newGame();
        };
        this.hit = () => {
            return 1;
        };
        this.tryCollide = (other, newX, newY) => {
            if (newX >= other.x + other.w || newX + this.w <= other.x)
                return false;
            if (newY >= other.y + other.h || newY + this.h <= other.y)
                return false;
            return true;
        };
        this.tryMove = (x, y) => {
            if (this.busyAnimating)
                return;
            // TODO don't move if hit by enemy
            this.game.levels[this.depth].rooms[this.levelID].catchUp();
            if (this.dead)
                return;
            for (let i = 0; i < 2; i++)
                if (this.inventory.hasWeapon() &&
                    !this.inventory.getWeapon().weaponMove(x, y)) {
                    //for (let h of this.game.levels[this.levelID].hitwarnings) {
                    //if (newMove instanceof HitWarning)
                    return;
                    //}
                }
            for (let e of this.game.levels[this.depth].rooms[this.levelID].entities) {
                e.lastX = e.x;
                e.lastY = e.y;
                //console.log(`e.lastX, e.lastY: ${e.lastX}, ${e.lastY}`);
                if (this.tryCollide(e, x, y)) {
                    if (e.pushable) {
                        // pushing a crate or barrel
                        let dx = x - this.x;
                        let dy = y - this.y;
                        let nextX = x + dx;
                        let nextY = y + dy;
                        let foundEnd = false; // end of the train of whatever we're pushing
                        let enemyEnd = false; // end of the train is a solid enemy (i.e. potted plant)
                        let pushedEnemies = [];
                        while (true) {
                            foundEnd = true;
                            for (const f of this.game.levels[this.depth].rooms[this.levelID]
                                .entities) {
                                f.lastX = f.x;
                                f.lastY = f.y;
                                if (f.pointIn(nextX, nextY)) {
                                    if (!f.chainPushable) {
                                        enemyEnd = true;
                                        foundEnd = true;
                                        break;
                                    }
                                    foundEnd = false;
                                    pushedEnemies.push(f);
                                    break;
                                }
                            }
                            if (foundEnd)
                                break;
                            nextX += dx * pushedEnemies[pushedEnemies.length - 1].w;
                            nextY += dy * pushedEnemies[pushedEnemies.length - 1].h;
                        }
                        /* if no enemies and there is a wall, no move
                        otherwise, push everything, killing last enemy if there is a wall */
                        // here, (nextX, nextY) is the position immediately after the end of the train
                        if (pushedEnemies.length === 0 &&
                            (this.game.levels[this.depth].rooms[this.levelID].roomArray[nextX][nextY].canCrushEnemy() ||
                                enemyEnd)) {
                            if (e.destroyable) {
                                e.hurt(this, e.health, "none");
                                if (this.game.levels[this.depth].rooms[this.levelID] ===
                                    this.game.room)
                                    sound_1.Sound.hit();
                                this.shakeScreen(this.x, this.y, e.x, e.y);
                                this.hitShake(this.x, this.y, e.x, e.y);
                                this.game.levels[this.depth].rooms[this.levelID].tick(this);
                                return;
                            }
                        }
                        else {
                            if (this.game.levels[this.depth].rooms[this.levelID] ===
                                this.game.room)
                                sound_1.Sound.push();
                            // here pushedEnemies may still be []
                            for (const f of pushedEnemies) {
                                f.lastX = f.x;
                                f.lastY = f.y;
                                f.x += dx;
                                f.y += dy;
                                f.drawX = dx;
                                f.drawY = dy;
                                f.skipNextTurns = 1; // skip next turn, so they don't move while we're pushing them
                            }
                            if (this.game.levels[this.depth].rooms[this.levelID].roomArray[nextX][nextY].canCrushEnemy() ||
                                enemyEnd) {
                                pushedEnemies[pushedEnemies.length - 1].crush();
                                if (this.game.levels[this.depth].rooms[this.levelID] ===
                                    this.game.room)
                                    sound_1.Sound.hit();
                            }
                            e.x += dx;
                            e.y += dy;
                            e.drawX = dx;
                            e.drawY = dy;
                            this.move(x, y);
                            this.moveDistance++;
                            this.game.levels[this.depth].rooms[this.levelID].tick(this);
                            return;
                        }
                    }
                    else {
                        // if we're trying to hit an enemy, check if it's destroyable
                        if (!e.dead) {
                            if (e.interactable)
                                e.interact(this);
                            //this.actionTab.actionState = ActionState.ATTACK;
                            //sets the action tab state to Attack
                            return;
                        }
                    }
                }
            }
            let other = this.game.levels[this.depth].rooms[this.levelID].roomArray[x][y];
            if (!other.isSolid()) {
                this.move(x, y);
                other.onCollide(this);
                if (!(other instanceof door_1.Door || other instanceof trapdoor_1.Trapdoor))
                    this.game.levels[this.depth].rooms[this.levelID].tick(this);
            }
            else {
                if (other instanceof door_1.Door) {
                    this.shakeScreen(this.x, this.y, x, y);
                    if (other.canUnlock(this))
                        other.unlock(this);
                }
            }
        };
        this.updateLastPosition = (x, y) => {
            this.lastX = x;
            this.lastY = y;
        };
        //get cancelHoldMove = () => {};
        this.wouldHurt = (x, y) => {
            for (let h of this.game.levels[this.depth].rooms[this.levelID]
                .hitwarnings) {
                if (h instanceof hitWarning_1.HitWarning && h.x == x && h.y == y)
                    return true;
                else {
                    return false;
                }
            }
        };
        this.hurt = (damage, enemy) => {
            if (this.game.levels[this.depth].rooms[this.levelID] === this.game.room)
                sound_1.Sound.hurt();
            if (this.inventory.getArmor() && this.inventory.getArmor().health > 0) {
                this.inventory.getArmor().hurt(damage);
                this.renderer.hurtShield();
                this.hurtShield = true;
            }
            {
                this.lastHitBy = enemy;
                //console.log("Last Hit by: ", enemy);
                this.healthBar.hurt();
                this.renderer.flash();
                if (!this.hurtShield)
                    this.health -= damage;
                this.hurtShield = false;
                this.renderer.hurt();
                if (this.health <= 0 && !gameConstants_1.GameConstants.DEVELOPER_MODE) {
                    this.dead = true;
                }
                /*
                if (this.health <= 0) {
                  this.health = 0;
                  
                  if (!this.game.tutorialActive) {
                    this.dead = true;
                  } else {
                    this.health = 2;
                    this.game.pushMessage("You are dead, but you can try again!");
                  }
                  */
            }
        };
        this.dashMove = (x, y) => {
            this.x = x;
            this.y = y;
            for (let i of this.game.levels[this.depth].rooms[this.levelID].items) {
                if (i.x === x && i.y === y) {
                    i.onPickup(this);
                }
            }
            //this.game.rooms[this.levelID].updateLighting();
        };
        this.beginSlowMotion = () => {
            this.renderer.beginSlowMotion();
        };
        this.endSlowMotion = () => {
            this.renderer.endSlowMotion();
        };
        this.move = (x, y) => {
            this.updateLastPosition(this.x, this.y);
            //this.actionTab.setState(ActionState.MOVE);
            if (this.game.levels[this.depth].rooms[this.levelID] === this.game.room)
                sound_1.Sound.playerStoneFootstep();
            if (this.openVendingMachine)
                this.openVendingMachine.close();
            this.renderer.setNewDrawXY(x, y);
            this.drawMoveQueue.push({
                drawX: x - this.x,
                drawY: y - this.y,
            });
            /*
            if (this.drawX > 1) this.drawX = 1;
            if (this.drawY > 1) this.drawY = 1;
            if (this.drawX < -1) this.drawX = -1;
            if (this.drawY < -1) this.drawY = -1;
            */
            this.x = x;
            this.y = y;
            for (let i of this.game.levels[this.depth].rooms[this.levelID].items) {
                if (i.x === x && i.y === y) {
                    i.onPickup(this);
                }
            }
            let diffX = x - this.lastX;
            let diffY = y - this.lastY;
            if (diffX === 0 && diffY === 0)
                return;
            //this.game.rooms[this.levelID].updateLighting();
            let roomsOnScreen = 0;
            for (let room of this.game.level.rooms) {
                room.roomOnScreen(this);
                //console.log("On Screen? " + room.onScreen + " levelID: " + room.id);
                if (room.onScreen)
                    roomsOnScreen++;
            }
            //console.log("Rooms On Screen Currently: " + roomsOnScreen);
        };
        this.moveNoSmooth = (x, y) => {
            // doesn't touch smoothing
            this.x = x;
            this.y = y;
        };
        this.moveSnap = (x, y) => {
            // no smoothing
            this.x = Math.round(x);
            this.y = Math.round(y);
            this.renderer.snapDrawStuff();
        };
        this.update = () => { };
        this.finishTick = () => {
            this.turnCount += 1;
            this.inventory.tick();
            this.renderer.disableFlash();
            let totalHealthDiff = this.health - this.lastTickHealth;
            this.lastTickHealth = this.health; // update last tick health
            if (totalHealthDiff < 0) {
                this.renderer.flash();
            }
            this.moveDistance = 0;
            //this.actionTab.actionState = ActionState.READY;
            //Sets the action tab state to Wait (during enemy turn)
        };
        this.draw = (delta) => {
            this.renderer.draw(delta);
        };
        this.heal = (amount) => {
            this.health += amount;
            if (this.health > this.maxHealth)
                this.health = this.maxHealth;
        };
        this.hitShake = (playerX, playerY, otherX, otherY) => {
            const range = gameConstants_1.GameConstants.TILESIZE;
            const hitX = Math.min(Math.max(0.5 * (playerX - otherX), -range), range);
            const hitY = Math.min(Math.max(0.5 * (playerY - otherY), -range), range);
            this.renderer.setHitXY(hitX, hitY);
        };
        this.shakeScreen = (playerX, playerY, otherX, otherY, shakeStrength = 10) => {
            const range = gameConstants_1.GameConstants.TILESIZE;
            const shakeX = Math.min(Math.max(0.5 * (playerX - otherX), -range), range);
            const shakeY = Math.min(Math.max(0.5 * (playerY - otherY), -range), range);
            this.renderer.setHitXY(shakeX, shakeY);
            this.game.shakeScreen(-shakeX * 1 * shakeStrength, -shakeY * 1 * shakeStrength);
        };
        this.updateSlowMotion = () => {
            this.renderer.updateSlowMotion();
        };
        this.drawGUI = (delta) => {
            this.renderer.drawGUI(delta);
        };
        this.game = game;
        this.levelID = 0;
        this.x = x;
        this.y = y;
        this.w = 1;
        this.h = 1;
        this.moveDistance = 0;
        this.direction = game_1.Direction.UP;
        this.lastDirection = game_1.Direction.UP;
        this.lastX = 0;
        this.lastY = 0;
        this.isLocalPlayer = isLocalPlayer;
        this.depth = 0;
        this.menu = new menu_1.Menu();
        this.busyAnimating = false;
        this.mapToggled = true;
        this.health = 2;
        this.maxHealth = 2;
        this.healthBar = new healthbar_1.HealthBar();
        this.dead = false;
        this.lastTickHealth = this.health;
        this.inventory = new inventory_1.Inventory(game, this);
        this.defaultSightRadius = 3;
        this.sightRadius = levelConstants_1.LevelConstants.LIGHTING_MAX_DISTANCE; //this.defaultSightRadius;
        this.map = new map_1.Map(this.game, this);
        this.turnCount = 0;
        this.triedMove = false;
        this.tutorialRoom = false;
        this.tileCursor = { x: 0, y: 0 };
        this.moveRange = 1;
        this.lightEquipped = false;
        this.hurtShield = false;
        this.lightBrightness = 0.3;
        this.moveQueue = [];
        this.justMoved = DrawDirection.Y;
        this.inputHandler = new playerInputHandler_1.PlayerInputHandler(this);
        this.actionProcessor = new playerActionProcessor_1.PlayerActionProcessor(this);
        this.movement = new playerMovement_1.PlayerMovement(this);
        this.renderer = new playerRenderer_1.PlayerRenderer(this);
        this.bestiary = new bestiary_1.Bestiary(this.game, this);
        this.cooldownRemaining = 0;
    }
    get hitX() {
        return this.renderer?.drawX ?? 0;
    }
    get hitY() {
        return this.renderer?.drawY ?? 0;
    }
    get drawX() {
        return this.renderer?.drawX ?? 0;
    }
    get drawY() {
        return this.renderer?.drawY ?? 0;
    }
}
exports.Player = Player;
Player.minSightRadius = 2; //hard minimum sight radius that ignores depth


/***/ }),

/***/ "./src/player/playerActionProcessor.ts":
/*!*********************************************!*\
  !*** ./src/player/playerActionProcessor.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PlayerActionProcessor = void 0;
class PlayerActionProcessor {
    constructor(player) {
        this.player = player;
    }
    process(action) {
        switch (action.type) {
            case "Move":
                this.player.movement.move(action.direction);
                break;
            case "OpenInventory":
                this.player.inventory.open();
                break;
            case "CloseInventory":
                this.player.inventory.close();
                break;
            case "Restart":
                this.player.restart();
                break;
            case "Attack":
                // TODO: Route to PlayerCombat module once it's ready
                console.warn("Attack action received but not yet implemented.");
                break;
            case "Interact":
                this.player.tryMove(action.target.x, action.target.y); // will replace with cleaner interaction API later
                break;
        }
    }
}
exports.PlayerActionProcessor = PlayerActionProcessor;


/***/ }),

/***/ "./src/player/playerInputHandler.ts":
/*!******************************************!*\
  !*** ./src/player/playerInputHandler.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PlayerInputHandler = void 0;
const input_1 = __webpack_require__(/*! ../input */ "./src/input.ts");
const game_1 = __webpack_require__(/*! ../game */ "./src/game.ts");
const mouseCursor_1 = __webpack_require__(/*! ../mouseCursor */ "./src/mouseCursor.ts");
const vendingMachine_1 = __webpack_require__(/*! ../entity/object/vendingMachine */ "./src/entity/object/vendingMachine.ts");
const gameConstants_1 = __webpack_require__(/*! ../gameConstants */ "./src/gameConstants.ts");
class PlayerInputHandler {
    constructor(player) {
        this.handleNumKey = (num) => {
            this.mostRecentInput = "keyboard";
            if (num <= 5) {
                this.player.inventory.selX = Math.max(0, Math.min(num - 1, this.player.inventory.cols - 1));
                this.player.inventory.selY = 0;
                this.player.inventory.itemUse();
            }
            else {
                if (gameConstants_1.GameConstants.DEVELOPER_MODE) {
                    switch (num) {
                        case 6:
                            gameConstants_1.GameConstants.SET_COLOR_LAYER_COMPOSITE_OPERATION(false, true);
                            break;
                        case 7:
                            gameConstants_1.GameConstants.SET_COLOR_LAYER_COMPOSITE_OPERATION(false);
                            break;
                    }
                }
                {
                    switch (num) {
                        case 9:
                            gameConstants_1.GameConstants.ctxBlurEnabled = !gameConstants_1.GameConstants.ctxBlurEnabled;
                            this.player.game.pushMessage("Custom shade color is now " +
                                (gameConstants_1.GameConstants.ctxBlurEnabled ? "on" : "off"));
                            break;
                        case 8:
                            gameConstants_1.GameConstants.BLUR_ENABLED = !gameConstants_1.GameConstants.BLUR_ENABLED;
                            break;
                    }
                }
            }
        };
        this.ignoreDirectionInput = () => {
            return (this.player.inventory.isOpen ||
                this.player.dead ||
                this.player.game.levelState !== game_1.LevelState.IN_LEVEL ||
                (this.player.inventory.isPointInQuickbarBounds(input_1.Input.mouseX, input_1.Input.mouseY)
                    .inBounds &&
                    this.player.game.isMobile));
        };
        this.faceMouse = () => {
            if (!gameConstants_1.GameConstants.MOVE_WITH_MOUSE)
                return;
            const mousePosition = mouseCursor_1.MouseCursor.getInstance().getPosition();
            const playerPixelPosition = {
                x: gameConstants_1.GameConstants.WIDTH / 2,
                y: gameConstants_1.GameConstants.HEIGHT / 2,
            };
            const dx = mousePosition.x - playerPixelPosition.x;
            const dy = mousePosition.y - playerPixelPosition.y;
            const angle = Math.atan2(dy, dx);
            // Convert angle to direction
            // atan2 returns angle in radians (- to )
            // Divide the circle into 4 sectors for the 4 directions
            if (angle >= -Math.PI / 4 && angle < Math.PI / 4) {
                this.player.direction = game_1.Direction.RIGHT;
            }
            else if (angle >= Math.PI / 4 && angle < (3 * Math.PI) / 4) {
                this.player.direction = game_1.Direction.DOWN;
            }
            else if (angle >= (-3 * Math.PI) / 4 && angle < -Math.PI / 4) {
                this.player.direction = game_1.Direction.UP;
            }
            else {
                this.player.direction = game_1.Direction.LEFT;
            }
        };
        this.player = player;
        this.mostRecentInput = "keyboard";
        if (player.isLocalPlayer) {
            this.setupListeners();
        }
    }
    setupListeners() {
        input_1.Input.leftSwipeListener = () => this.handleInput(input_1.InputEnum.LEFT);
        input_1.Input.rightSwipeListener = () => this.handleInput(input_1.InputEnum.RIGHT);
        input_1.Input.upSwipeListener = () => this.handleInput(input_1.InputEnum.UP);
        input_1.Input.downSwipeListener = () => this.handleInput(input_1.InputEnum.DOWN);
        input_1.Input.commaListener = () => this.handleInput(input_1.InputEnum.COMMA);
        input_1.Input.periodListener = () => this.handleInput(input_1.InputEnum.PERIOD);
        input_1.Input.tapListener = () => this.handleTap();
        input_1.Input.mouseMoveListener = () => this.handleInput(input_1.InputEnum.MOUSE_MOVE);
        input_1.Input.mouseLeftClickListeners.push(() => this.handleInput(input_1.InputEnum.LEFT_CLICK));
        input_1.Input.mouseRightClickListeners.push(() => this.handleInput(input_1.InputEnum.RIGHT_CLICK));
        input_1.Input.numKeyListener = (num) => this.handleInput(input_1.InputEnum.NUMBER_1 + num - 1);
        input_1.Input.equalsListener = () => this.handleInput(input_1.InputEnum.EQUALS);
        input_1.Input.minusListener = () => this.handleInput(input_1.InputEnum.MINUS);
        input_1.Input.escapeListener = () => this.handleInput(input_1.InputEnum.ESCAPE);
    }
    handleInput(input) {
        if (this.player.busyAnimating)
            return;
        if (this.player.menu.open) {
            this.player.menu.inputHandler(input);
            return;
        }
        if (!this.player.game.started && input !== input_1.InputEnum.MOUSE_MOVE) {
            this.player.game.startedFadeOut = true;
            return;
        }
        switch (input) {
            case input_1.InputEnum.I:
                this.player.inventory.open();
                break;
            case input_1.InputEnum.Q:
                this.player.inventory.drop();
                break;
            case input_1.InputEnum.LEFT:
                if (!this.ignoreDirectionInput())
                    this.player.actionProcessor.process({
                        type: "Move",
                        direction: game_1.Direction.LEFT,
                    });
                break;
            case input_1.InputEnum.RIGHT:
                if (!this.ignoreDirectionInput())
                    this.player.actionProcessor.process({
                        type: "Move",
                        direction: game_1.Direction.RIGHT,
                    });
                break;
            case input_1.InputEnum.UP:
                if (!this.ignoreDirectionInput())
                    this.player.actionProcessor.process({
                        type: "Move",
                        direction: game_1.Direction.UP,
                    });
                break;
            case input_1.InputEnum.DOWN:
                if (!this.ignoreDirectionInput())
                    this.player.actionProcessor.process({
                        type: "Move",
                        direction: game_1.Direction.DOWN,
                    });
                break;
            case input_1.InputEnum.SPACE:
                const player = this.player;
                this.mostRecentInput = "keyboard";
                if (player.game.chatOpen)
                    return;
                if (player.dead) {
                    player.restart();
                    return;
                }
                if (this.player.openVendingMachine &&
                    this.player.openVendingMachine.open) {
                    this.player.openVendingMachine.space();
                    break;
                }
                if (player.inventory.isOpen ||
                    player.game.levelState === game_1.LevelState.IN_LEVEL) {
                    this.mostRecentInput = "keyboard";
                    player.inventory.itemUse();
                }
                break;
            case input_1.InputEnum.COMMA:
                this.mostRecentInput = "keyboard";
                this.player.inventory.left();
                break;
            case input_1.InputEnum.PERIOD:
                this.mostRecentInput = "keyboard";
                this.player.inventory.right();
                break;
            case input_1.InputEnum.LEFT_CLICK:
                this.handleMouseLeftClick();
                break;
            case input_1.InputEnum.RIGHT_CLICK:
                this.handleMouseRightClick();
                break;
            case input_1.InputEnum.MOUSE_MOVE:
                //when mouse moves
                this.mostRecentInput = "mouse";
                this.player.inventory.mouseMove();
                this.faceMouse();
                this.player.setTileCursorPosition();
                break;
            case input_1.InputEnum.NUMBER_1:
            case input_1.InputEnum.NUMBER_2:
            case input_1.InputEnum.NUMBER_3:
            case input_1.InputEnum.NUMBER_4:
            case input_1.InputEnum.NUMBER_5:
            case input_1.InputEnum.NUMBER_6:
            case input_1.InputEnum.NUMBER_7:
            case input_1.InputEnum.NUMBER_8:
            case input_1.InputEnum.NUMBER_9:
                this.mostRecentInput = "keyboard";
                this.handleNumKey(input - 13);
                break;
            case input_1.InputEnum.EQUALS:
                this.player.game.increaseScale();
                break;
            case input_1.InputEnum.MINUS:
                this.player.game.decreaseScale();
                break;
            case input_1.InputEnum.ESCAPE:
                this.player.inventory.close();
                break;
        }
    }
    handleMouseRightClick() {
        this.mostRecentInput = "mouse";
        const { x, y } = mouseCursor_1.MouseCursor.getInstance().getPosition();
        const bounds = this.player.inventory.isPointInInventoryBounds(x, y);
        if (bounds.inBounds) {
            this.player.inventory.drop();
        }
    }
    handleMouseLeftClick() {
        const player = this.player;
        const cursor = mouseCursor_1.MouseCursor.getInstance();
        const { x, y } = cursor.getPosition();
        this.mostRecentInput = "mouse";
        if (player.dead) {
            player.restart();
            return;
        }
        const inventory = player.inventory;
        const clickedOutsideInventory = (inventory.isOpen &&
            !inventory.isPointInInventoryBounds(x, y).inBounds) ||
            inventory.isPointInInventoryButton(x, y);
        if (clickedOutsideInventory) {
            inventory.toggleOpen();
        }
        if (player.openVendingMachine) {
            if (vendingMachine_1.VendingMachine.isPointInVendingMachineBounds(x, y, player.openVendingMachine)) {
                player.openVendingMachine.space();
            }
            else {
                this.mostRecentInput = "mouse";
                const { x, y } = mouseCursor_1.MouseCursor.getInstance().getPosition();
                const bounds = this.player.inventory.isPointInInventoryBounds(x, y);
            }
            return;
        }
        const notInInventoryUI = !inventory.isPointInInventoryButton(x, y) &&
            !inventory.isPointInQuickbarBounds(x, y).inBounds &&
            !inventory.isOpen;
        if (notInInventoryUI) {
            player.moveWithMouse();
        }
    }
    handleTap() {
        if (this.player.dead) {
            this.player.restart();
            return;
        }
        else if (!this.player.game.started) {
            this.player.game.startedFadeOut = true;
            return;
        }
        const x = input_1.Input.mouseX;
        const y = input_1.Input.mouseY;
        const isInInventory = this.player.inventory.isPointInInventoryBounds(x, y).inBounds;
        const isInQuickbar = this.player.inventory.isPointInQuickbarBounds(x, y).inBounds;
        if (this.player.openVendingMachine && this.player.openVendingMachine.open) {
            const isInVMUI = vendingMachine_1.VendingMachine.isPointInVendingMachineBounds(input_1.Input.mouseX, input_1.Input.mouseY, this.player.openVendingMachine);
            if (isInVMUI) {
                this.player.openVendingMachine.space();
                return;
            }
            else if (!isInVMUI) {
                this.player.openVendingMachine.close();
                this.mostRecentInput = "mouse";
                const { x, y } = mouseCursor_1.MouseCursor.getInstance().getPosition();
                const bounds = this.player.inventory.isPointInInventoryBounds(x, y);
            }
            return;
        }
        if (!this.player.inventory.isOpen &&
            this.player.inventory.isPointInInventoryButton(x, y)) {
            this.player.inventory.open();
        }
        else if (this.player.inventory.isOpen) {
            if (isInInventory) {
                this.handleInput(input_1.InputEnum.LEFT_CLICK);
            }
            else {
                this.player.inventory.close();
            }
        }
        else if (isInQuickbar) {
            this.handleInput(input_1.InputEnum.LEFT_CLICK);
        }
    }
    handleKeyboardKey(key) {
        switch (key.toUpperCase()) {
            case "A":
            case "ARROWLEFT":
                this.handleInput(input_1.InputEnum.LEFT);
                break;
            case "D":
            case "ARROWRIGHT":
                this.handleInput(input_1.InputEnum.RIGHT);
                break;
            case "W":
            case "ARROWUP":
                this.handleInput(input_1.InputEnum.UP);
                break;
            case "S":
            case "ARROWDOWN":
                this.handleInput(input_1.InputEnum.DOWN);
                break;
            case " ":
                this.handleInput(input_1.InputEnum.SPACE);
                break;
            case "I":
                this.handleInput(input_1.InputEnum.I);
                break;
            case "Q":
                this.handleInput(input_1.InputEnum.Q);
                break;
            // Possibly add number keys for inventory here too
            default:
                // Unknown key; ignore or log if needed
                break;
        }
    }
}
exports.PlayerInputHandler = PlayerInputHandler;


/***/ }),

/***/ "./src/player/playerMovement.ts":
/*!**************************************!*\
  !*** ./src/player/playerMovement.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PlayerMovement = void 0;
const game_1 = __webpack_require__(/*! ../game */ "./src/game.ts");
const gameConstants_1 = __webpack_require__(/*! ../gameConstants */ "./src/gameConstants.ts");
class PlayerMovement {
    constructor(player) {
        this.moveQueue = [];
        this.isProcessingQueue = false;
        this.animationFrameId = null;
        this.lastMoveTime = 0;
        this.adjustedCooldown = 0;
        this.queueHandler = () => {
            if (!this.isProcessingQueue)
                return;
            const now = Date.now();
            const cooldown = gameConstants_1.GameConstants.MOVEMENT_COOLDOWN;
            if (now - this.lastMoveTime >= cooldown) {
                if (this.moveQueue.length > 0) {
                    const nextMove = this.moveQueue.shift();
                    this.handleMoveLoop(nextMove);
                    this.lastMoveTime = now;
                }
                else {
                    this.stopQueueProcessing();
                }
            }
            this.animationFrameId = requestAnimationFrame(this.queueHandler);
        };
        this.player = player;
    }
    move(direction) {
        const { x, y } = this.getTargetCoords(direction);
        if (this.canMove()) {
            this.player.lastDirection = this.player.direction;
            this.player.direction = direction;
            this.player.tryMove(x, y);
        }
        else {
            if (this.canQueue)
                this.queueMove(x, y, direction);
        }
    }
    getTargetCoords(direction) {
        switch (direction) {
            case game_1.Direction.LEFT:
                return { x: this.player.x - 1, y: this.player.y };
            case game_1.Direction.RIGHT:
                return { x: this.player.x + 1, y: this.player.y };
            case game_1.Direction.UP:
                return { x: this.player.x, y: this.player.y - 1 };
            case game_1.Direction.DOWN:
                return { x: this.player.x, y: this.player.y + 1 };
        }
    }
    canMove() {
        const now = Date.now();
        const cooldown = gameConstants_1.GameConstants.MOVEMENT_COOLDOWN;
        this.adjustedCooldown = cooldown - this.moveQueue.length * 25;
        this.player.cooldownRemaining =
            now - this.lastMoveTime / this.adjustedCooldown;
        if (now - this.lastMoveTime >= this.adjustedCooldown) {
            this.lastMoveTime = now;
            return true;
        }
        return false;
    }
    canQueue() {
        const now = Date.now();
        const cooldown = gameConstants_1.GameConstants.MOVEMENT_COOLDOWN;
        this.adjustedCooldown = cooldown - this.moveQueue.length * 25;
        this.player.cooldownRemaining =
            now - this.lastMoveTime / this.adjustedCooldown;
        if (now - this.lastMoveTime >= this.adjustedCooldown / 5) {
            this.lastMoveTime = now;
            return true;
        }
        return false;
    }
    queueMove(x, y, direction) {
        if (!x || !y || this.moveQueue.length > 0)
            return;
        this.moveQueue.push({ x, y, direction });
        this.startQueueProcessing();
    }
    handleMoveLoop({ x, y, direction, }) {
        this.move(direction);
    }
    startQueueProcessing() {
        if (!this.isProcessingQueue) {
            this.isProcessingQueue = true;
            this.animationFrameId = requestAnimationFrame(() => this.queueHandler());
        }
    }
    stopQueueProcessing() {
        this.isProcessingQueue = false;
        if (this.animationFrameId !== null) {
            cancelAnimationFrame(this.animationFrameId);
            this.animationFrameId = null;
        }
    }
}
exports.PlayerMovement = PlayerMovement;


/***/ }),

/***/ "./src/player/playerRenderer.ts":
/*!**************************************!*\
  !*** ./src/player/playerRenderer.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PlayerRenderer = void 0;
const game_1 = __webpack_require__(/*! ../game */ "./src/game.ts");
const gameConstants_1 = __webpack_require__(/*! ../gameConstants */ "./src/gameConstants.ts");
const hitWarning_1 = __webpack_require__(/*! ../hitWarning */ "./src/hitWarning.ts");
const levelConstants_1 = __webpack_require__(/*! ../levelConstants */ "./src/levelConstants.ts");
const postProcess_1 = __webpack_require__(/*! ../postProcess */ "./src/postProcess.ts");
const stats_1 = __webpack_require__(/*! ../stats */ "./src/stats.ts");
const utils_1 = __webpack_require__(/*! ../utils */ "./src/utils.ts");
const spellbook_1 = __webpack_require__(/*! ../weapon/spellbook */ "./src/weapon/spellbook.ts");
class PlayerRenderer {
    constructor(player) {
        this.hurt = () => {
            this.hurting = true;
            this.hurtAlpha = 0.25;
        };
        this.hurtShield = () => {
            this.hurtingShield = true;
        };
        this.flash = () => {
            this.flashing = true;
        };
        this.disableFlash = () => {
            this.flashing = false;
        };
        this.beginSlowMotion = () => {
            this.slowMotionEnabled = true;
        };
        this.endSlowMotion = () => {
            this.slowMotionEnabled = false;
        };
        this.setNewDrawXY = (x, y) => {
            this.drawX += x - this.player.x;
            this.drawY += y - this.player.y;
        };
        this.enableSlowMotion = () => {
            if (this.motionSpeed < 1 && !this.slowMotionEnabled) {
                this.motionSpeed *= 1.08;
                if (this.motionSpeed >= 1)
                    this.motionSpeed = 1;
            }
            if (this.slowMotionEnabled && this.motionSpeed > 0.25) {
                this.motionSpeed *= 0.95;
                if (this.motionSpeed < 0.25)
                    this.motionSpeed = 0.25;
            }
        };
        this.updateSlowMotion = () => {
            if (this.slowMotionTickDuration > 0)
                this.slowMotionTickDuration -= 1;
            if (this.slowMotionTickDuration === 0)
                this.slowMotionEnabled = false;
        };
        /**
         * Draws the player sprite to the canvas.
         * Added `ctx.save()` at the beginning and `ctx.restore()` at the end
         * to ensure canvas state is preserved.
         */
        this.drawPlayerSprite = (delta) => {
            const player = this.player;
            game_1.Game.ctx.save(); // Save the current canvas state
            if (this.drawSmear()) {
                game_1.Game.drawMob(this.setSmearFrame().x, this.setSmearFrame().y, 1, 2, player.x - this.drawX - this.hitX, player.y - 1.45 - this.drawY - this.jumpY - this.hitY, 1, 2, this.shadeColor());
            }
            else {
                this.frame += 0.1 * delta;
                if (this.frame >= 4)
                    this.frame = 0;
                game_1.Game.drawMob(1 + Math.floor(this.frame), 8 + player.direction * 2, 1, 2, player.x - this.drawX - this.hitX, player.y - 1.45 - this.drawY - this.jumpY - this.hitY, 1, 2, this.shadeColor());
            }
            if (player.inventory.getArmor() && player.inventory.getArmor().health > 0) {
                // TODO draw armor
            }
            game_1.Game.ctx.restore(); // Restore the canvas state
        };
        this.drawSmear = () => {
            if (this.player.direction === this.player.lastDirection)
                return false;
            let t = 100;
            const lastDir = this.player.lastDirection;
            const dir = this.player.direction;
            if ((dir === game_1.Direction.UP && lastDir === game_1.Direction.DOWN) ||
                (dir === game_1.Direction.DOWN && lastDir === game_1.Direction.UP) ||
                (dir === game_1.Direction.LEFT && lastDir === game_1.Direction.RIGHT) ||
                (dir === game_1.Direction.RIGHT && lastDir === game_1.Direction.LEFT))
                t = 150;
            const timeSince = Date.now() - this.player.movement.lastMoveTime;
            if (timeSince <= t)
                return true;
            else
                return false;
        };
        this.setSmearFrame = () => {
            let tile = { x: 1, y: 18 };
            const timeSince = Date.now() - this.player.movement.lastMoveTime;
            const t = 50;
            if ((this.player.direction === game_1.Direction.UP &&
                this.player.lastDirection === game_1.Direction.LEFT) ||
                (this.player.direction === game_1.Direction.LEFT &&
                    this.player.lastDirection === game_1.Direction.UP)) {
                tile.x = 3;
                return tile;
            }
            if ((this.player.direction === game_1.Direction.UP &&
                this.player.lastDirection === game_1.Direction.RIGHT) ||
                (this.player.direction === game_1.Direction.RIGHT &&
                    this.player.lastDirection === game_1.Direction.UP)) {
                tile.x = 4;
                return tile;
            }
            if ((this.player.direction === game_1.Direction.DOWN &&
                this.player.lastDirection === game_1.Direction.RIGHT) ||
                (this.player.direction === game_1.Direction.RIGHT &&
                    this.player.lastDirection === game_1.Direction.DOWN)) {
                tile.x = 2;
                return tile;
            }
            if ((this.player.direction === game_1.Direction.DOWN &&
                this.player.lastDirection === game_1.Direction.LEFT) ||
                (this.player.direction === game_1.Direction.LEFT &&
                    this.player.lastDirection === game_1.Direction.DOWN)) {
                tile.x = 1;
                return tile;
            }
            if (this.player.direction === game_1.Direction.DOWN &&
                this.player.lastDirection === game_1.Direction.UP) {
                if (timeSince < t)
                    tile.x = 3;
                if (timeSince >= t && timeSince < t * 2) {
                    tile.x = 1;
                    tile.y = 14;
                }
                if (timeSince >= t * 2 && timeSince < t * 3)
                    tile.x = 1;
                return tile;
            }
            if (this.player.direction === game_1.Direction.LEFT &&
                this.player.lastDirection === game_1.Direction.RIGHT) {
                if (timeSince < t)
                    tile.x = 2;
                if (timeSince >= t && timeSince < t * 2) {
                    tile.x = 1;
                    tile.y = 8;
                }
                if (timeSince >= t * 2 && timeSince < t * 3)
                    tile.x = 1;
                return tile;
            }
            if (this.player.direction === game_1.Direction.UP &&
                this.player.lastDirection === game_1.Direction.DOWN) {
                if (timeSince < t)
                    tile.x = 2;
                if (timeSince >= t && timeSince < t * 2) {
                    tile.x = 1;
                    tile.y = 12;
                }
                if (timeSince >= t * 2 && timeSince < t * 3)
                    tile.x = 4;
                return tile;
            }
            if (this.player.direction === game_1.Direction.RIGHT &&
                this.player.lastDirection === game_1.Direction.LEFT) {
                if (timeSince < t)
                    tile.x = 1;
                if (timeSince >= t && timeSince < t * 2) {
                    tile.x = 1;
                    tile.y = 8;
                }
                if (timeSince >= t * 2 && timeSince < t * 3)
                    tile.x = 2;
                return tile;
            }
        };
        this.draw = (delta) => {
            const player = this.player;
            game_1.Game.ctx.save();
            this.updateDrawXY(delta);
            player.drawableY = player.y;
            this.flashingFrame += (delta * 12) / gameConstants_1.GameConstants.FPS;
            if (!player.dead) {
                game_1.Game.drawMob(0, 0, 1, 1, player.x - this.drawX, player.y - this.drawY, 1, 1);
                if (!this.flashing || Math.floor(this.flashingFrame) % 2 === 0) {
                    this.drawPlayerSprite(delta);
                }
            }
            this.drawSpellBeam(delta);
            game_1.Game.ctx.restore();
        };
        this.drawSpellBeam = (delta) => {
            game_1.Game.ctx.save();
            // Clear existing beam effects each frame
            this.player.game.levels[this.player.depth].rooms[this.player.levelID].beamEffects = [];
            if (this.player.inventory.getWeapon() instanceof spellbook_1.Spellbook) {
                const spellbook = this.player.inventory.getWeapon();
                if (spellbook.isTargeting) {
                    let targets = spellbook.targets;
                    for (let target of targets) {
                        // Create a new beam effect from the player to the enemy
                        this.player.game.levels[this.player.depth].rooms[this.player.levelID].addBeamEffect(this.player.x - this.drawX, this.player.y - this.drawY, target.x - target.drawX, target.y - target.drawY, target);
                        // Retrieve the newly added beam effect
                        const beam = this.player.game.levels[this.player.depth].rooms[this.player.levelID].beamEffects[this.player.game.levels[this.player.depth].rooms[this.player.levelID].beamEffects.length - 1];
                        // Render the beam
                        beam.render(this.player.x - this.drawX, this.player.y - this.drawY, target.x - target.drawX, target.y - target.drawY, "cyan", 2, delta);
                    }
                }
            }
            game_1.Game.ctx.restore();
        };
        this.shadeColor = () => {
            const player = this.player;
            if (!gameConstants_1.GameConstants.CUSTOM_SHADER_COLOR_ENABLED) {
                return "black";
            }
            else {
                return utils_1.Utils.rgbToHex(player.game.levels[player.depth].rooms[player.levelID].col[player.x][player.y][0], player.game.levels[player.depth].rooms[player.levelID].col[player.x][player.y][1], player.game.levels[player.depth].rooms[player.levelID].col[player.x][player.y][2]);
            }
        };
        this.drawTopLayer = (delta) => {
            game_1.Game.ctx.save(); // Save the current canvas state
            this.player.healthBar.draw(delta, this.player.health, this.player.maxHealth, this.player.x - this.drawX, this.player.y - this.drawY, !this.flashing || Math.floor(this.flashingFrame) % 2 === 0);
            game_1.Game.ctx.restore(); // Restore the canvas state
        };
        this.updateDrawXY = (delta) => {
            if (!this.doneMoving()) {
                this.drawX *= 0.85 ** delta;
                this.drawY *= 0.85 ** delta;
                this.drawX = Math.abs(this.drawX) < 0.01 ? 0 : this.drawX;
                this.drawY = Math.abs(this.drawY) < 0.01 ? 0 : this.drawY;
            }
            if (this.doneHitting()) {
                this.jump(delta);
            }
            if (!this.doneHitting()) {
                this.updateHitXY(delta);
            }
            this.enableSlowMotion();
            gameConstants_1.GameConstants.ANIMATION_SPEED = this.motionSpeed;
        };
        this.updateHitXY = (delta) => {
            const hitX = this.hitX - this.hitX * 0.3;
            const hitY = this.hitY - this.hitY * 0.3;
            this.hitX = Math.min(Math.max(hitX, -1), 1);
            this.hitY = Math.min(Math.max(hitY, -1), 1);
            if (Math.abs(hitX) < 0.01)
                this.hitX = 0;
            if (Math.abs(hitY) < 0.01)
                this.hitY = 0;
        };
        this.doneMoving = () => {
            let EPSILON = 0.01;
            return Math.abs(this.drawX) < EPSILON && Math.abs(this.drawY) < EPSILON;
        };
        this.doneHitting = () => {
            let EPSILON = 0.01;
            return Math.abs(this.hitX) < EPSILON && Math.abs(this.hitY) < EPSILON;
        };
        this.snapDrawStuff = () => {
            this.drawX = 0;
            this.drawY = 0;
            this.hitX = 0;
            this.hitY = 0;
            this.jumpY = 0;
        };
        this.setHitXY = (x, y) => {
            this.hitX = x;
            this.hitY = y;
        };
        this.drawGUI = (delta, transitioning = false) => {
            game_1.Game.ctx.save();
            if (!this.player.dead) {
                if (!transitioning)
                    this.player.inventory.draw(delta);
                if (this.player.bestiary)
                    this.player.bestiary.draw(delta);
                //this.actionTab.draw(delta);
                if (this.guiHeartFrame > 0)
                    this.guiHeartFrame += delta;
                if (this.guiHeartFrame > 5) {
                    this.guiHeartFrame = 0;
                }
                for (let i = 0; i < this.player.maxHealth; i++) {
                    let shake = 0;
                    let shakeY = 0;
                    if (this.player.health <= 1) {
                        shake =
                            Math.round(Math.sin(Date.now() / 25 / (i + 1)) + i / 2) /
                                2 /
                                gameConstants_1.GameConstants.TILESIZE;
                        shakeY =
                            Math.round(Math.sin(Date.now() / 25 / (i + 2)) + i / 2) /
                                2 /
                                gameConstants_1.GameConstants.TILESIZE;
                    }
                    let frame = this.guiHeartFrame > 0 ? 1 : 0;
                    let offsetY = gameConstants_1.GameConstants.WIDTH > 155 ? 0 : -1.25;
                    if (i >= Math.floor(this.player.health)) {
                        if (i == Math.floor(this.player.health) &&
                            (this.player.health * 2) % 2 == 1) {
                            // draw half heart
                            game_1.Game.drawFX(4, 2, 0.75, 0.75, i / 1.5 + shake + 0.25, gameConstants_1.GameConstants.HEIGHT / gameConstants_1.GameConstants.TILESIZE -
                                1 +
                                shakeY +
                                offsetY, 0.75, 0.75);
                        }
                        else {
                            game_1.Game.drawFX(3, 2, 0.75, 0.75, i / 1.5 + shake + 0.25, gameConstants_1.GameConstants.HEIGHT / gameConstants_1.GameConstants.TILESIZE -
                                1 +
                                shakeY +
                                offsetY, 0.75, 0.75);
                        }
                    }
                    else {
                        game_1.Game.drawFX(frame, 2, 0.75, 0.75, i / 1.5 + shake + 0.25, gameConstants_1.GameConstants.HEIGHT / gameConstants_1.GameConstants.TILESIZE -
                            1 +
                            shakeY +
                            offsetY, 0.75, 0.75);
                    }
                }
                this.drawCooldownBar();
                if (this.player.inventory.getArmor())
                    this.player.inventory.getArmor().drawGUI(delta, this.player.maxHealth);
            }
            else {
                game_1.Game.ctx.fillStyle = levelConstants_1.LevelConstants.LEVEL_TEXT_COLOR;
                const enemies = stats_1.statsTracker.getStats().enemies;
                // Count the occurrences of each enemy
                const enemyCounts = enemies.reduce((acc, enemy) => {
                    acc[enemy] = (acc[enemy] || 0) + 1;
                    return acc;
                }, {});
                // Create individual lines
                const lines = [];
                // Line 1: Game Over or slain by
                if (this.player.lastHitBy !== "enemy") {
                    lines.push(`You were slain by ${this.player.lastHitBy}.`);
                }
                else {
                    lines.push("Game Over");
                }
                lines.push(`Depth reached: ${this.player.game.levels[this.player.depth].rooms[this.player.levelID].depth}`);
                // Line 2: Enemies killed
                lines.push(`${Object.values(enemyCounts).reduce((a, b) => a + b, 0)} enemies killed in total:`);
                // Subsequent lines: Each enemy count
                Object.entries(enemyCounts).forEach(([enemy, count]) => {
                    lines.push(`${enemy} x${count}`);
                });
                // Line after enemy counts: Restart instruction
                let restartButton = "Press space or click to restart";
                if (gameConstants_1.GameConstants.isMobile)
                    restartButton = "Tap to restart";
                // Calculate total height based on number of lines
                const lineHeight = game_1.Game.letter_height + 2; // Adjust spacing as needed
                const totalHeight = lines.length * lineHeight + lineHeight; // Additional space for restart button
                // Starting Y position to center the text block
                let startY = gameConstants_1.GameConstants.HEIGHT / 2 - totalHeight / 2;
                // Draw each line centered horizontally
                lines.forEach((line, index) => {
                    const textWidth = game_1.Game.measureText(line).width;
                    const spacing = index === 0 || index === 1 || index === lines.length - 1
                        ? lineHeight * 1.5
                        : lineHeight;
                    game_1.Game.fillText(line, gameConstants_1.GameConstants.WIDTH / 2 - textWidth / 2, startY);
                    startY += spacing;
                });
                // Draw the restart button
                const restartTextWidth = game_1.Game.measureText(restartButton).width;
                game_1.Game.fillText(restartButton, gameConstants_1.GameConstants.WIDTH / 2 - restartTextWidth / 2, startY);
            }
            postProcess_1.PostProcessor.draw(delta);
            if (this.hurting)
                this.drawHurt(delta);
            if (this.player.mapToggled === true)
                this.player.map.draw(delta);
            //this.drawTileCursor(delta);
            this.player.setCursorIcon();
            //this.drawInventoryButton(delta);
            if (this.player.menu.open)
                this.player.menu.drawMenu();
            game_1.Game.ctx.restore();
        };
        this.drawCooldownBar = () => {
            game_1.Game.ctx.save();
            if (this.player.cooldownRemaining > 0) {
                this.player.cooldownRemaining =
                    1 -
                        (Date.now() - this.player.movement.lastMoveTime) /
                            this.player.movement.adjustedCooldown;
            }
            else
                this.player.cooldownRemaining = 0;
            const tile = gameConstants_1.GameConstants.TILESIZE;
            game_1.Game.drawFX(12 +
                Math.max(0, Math.min(14, Math.floor(17 * this.player.cooldownRemaining))), 2, 1, 1, 0.45, gameConstants_1.GameConstants.HEIGHT / tile - 2.125, 1, 1);
            game_1.Game.ctx.restore();
        };
        this.drawHurt = (delta) => {
            game_1.Game.ctx.save(); // Save the current canvas state
            game_1.Game.ctx.globalAlpha = this.hurtAlpha;
            this.hurtAlpha -= (this.hurtAlpha / 10) * delta;
            if (this.hurtAlpha <= 0.01) {
                this.hurtAlpha = 0;
                this.hurting = false;
                this.hurtingShield = false;
            }
            game_1.Game.ctx.globalCompositeOperation = "source-over";
            game_1.Game.ctx.fillStyle = "#cc3333"; // bright but not fully saturated red
            if (this.hurtingShield) {
                game_1.Game.ctx.fillStyle = "#639bff"; // bright but not fully saturated blue
            }
            game_1.Game.ctx.fillRect(0, 0, gameConstants_1.GameConstants.WIDTH, gameConstants_1.GameConstants.HEIGHT);
            game_1.Game.ctx.restore(); // Restore the canvas state
        };
        this.drawLowHealth = (delta) => {
            game_1.Game.ctx.save();
            //unused
            if (this.player.health <= 1 && !this.player.dead) {
                // Calculate pulsating alpha for the vignette effect
                const lowHealthAlpha = 0.5; //Math.sin(this.lowHealthFrame / 10) * 0.5 + 0.5;
                game_1.Game.ctx.globalAlpha = lowHealthAlpha;
                this.lowHealthFrame += delta;
                const gradientBottom = game_1.Game.ctx.createLinearGradient(0, gameConstants_1.GameConstants.HEIGHT, 0, (gameConstants_1.GameConstants.HEIGHT * 2) / 3);
                // Define gradient color stops
                [gradientBottom].forEach((gradient) => {
                    gradient.addColorStop(0, "#cc3333"); // Solid red at edges
                    gradient.addColorStop(1, "rgba(0, 0, 0, 0)"); // Transparent toward center
                });
                // Draw the gradients
                game_1.Game.ctx.globalCompositeOperation = "source-over";
                game_1.Game.ctx.fillStyle = gradientBottom;
                game_1.Game.ctx.fillRect(0, 0, gameConstants_1.GameConstants.WIDTH, gameConstants_1.GameConstants.HEIGHT);
                // Reset composite operation and alpha
                game_1.Game.ctx.globalCompositeOperation = "source-over";
                game_1.Game.ctx.globalAlpha = 1.0;
            }
            else {
                this.lowHealthFrame = 0;
            }
            game_1.Game.ctx.restore();
        };
        this.heartbeat = () => {
            this.guiHeartFrame = 1;
        };
        /**
         * Draws the tile cursor to the canvas.
         * Added `ctx.save()` at the beginning and `ctx.restore()` at the end
         * to ensure canvas state is preserved.
         */
        this.drawTileCursor = (delta) => {
            if (this.player.inventory.isOpen)
                return;
            game_1.Game.ctx.save(); // Save the current canvas state
            if (!this.player.mouseInLine() ||
                !this.player.isMouseAboveFloor() ||
                this.player.isMouseOnPlayerTile())
                return;
            let tileX = 22; //inRange ? 22 : 24;
            let tileY = 3;
            const moveData = this.player.canMoveWithMouse();
            if (moveData && moveData.direction !== undefined) {
                switch (moveData.direction) {
                    case game_1.Direction.UP:
                        tileY = 3;
                        break;
                    case game_1.Direction.RIGHT:
                        tileY = 4;
                        break;
                    case game_1.Direction.DOWN:
                        tileY = 5;
                        break;
                    case game_1.Direction.LEFT:
                        tileY = 6;
                        break;
                }
            }
            game_1.Game.drawFX(tileX + Math.floor(hitWarning_1.HitWarning.frame), tileY, 1, 1, this.player.tileCursor.x, this.player.tileCursor.y, 1, 1);
            game_1.Game.ctx.restore(); // Restore the canvas state
        };
        this.jump = (delta) => {
            let j = Math.max(Math.abs(this.drawX), Math.abs(this.drawY));
            this.jumpY = Math.abs(Math.sin(j * Math.PI) * this.jumpHeight);
            if (Math.abs(this.jumpY) < 0.01)
                this.jumpY = 0;
            if (this.jumpY > this.jumpHeight)
                this.jumpY = this.jumpHeight;
        };
        this.player = player;
        this.jumpY = 0;
        this.flashingFrame = 0;
        this.guiHeartFrame = 0;
        this.motionSpeed = 1;
        this.hitX = 0;
        this.hitY = 0;
        this.drawX = 0;
        this.drawY = 0;
        this.hurtAlpha = 0.25;
        this.jumpHeight = 0.25;
        this.hurting = false;
        this.hurtingShield = false;
        this.slowMotionEnabled = false;
        this.slowMotionTickDuration = 0;
        this.flashing = false;
        this.lowHealthFrame = 0;
        this.frame = 0;
    }
}
exports.PlayerRenderer = PlayerRenderer;


/***/ }),

/***/ "./src/postProcess.ts":
/*!****************************!*\
  !*** ./src/postProcess.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PostProcessor = void 0;
const game_1 = __webpack_require__(/*! ./game */ "./src/game.ts");
const gameConstants_1 = __webpack_require__(/*! ./gameConstants */ "./src/gameConstants.ts");
class PostProcessor {
}
exports.PostProcessor = PostProcessor;
PostProcessor.draw = (delta) => {
    game_1.Game.ctx.save();
    game_1.Game.ctx.globalAlpha = 0.15;
    game_1.Game.ctx.globalCompositeOperation = "screen";
    // GameConstants.SHADE_LAYER_COMPOSITE_OPERATION as GlobalCompositeOperation; //"soft-light";
    game_1.Game.ctx.fillStyle = "#006A6E"; //dark teal
    //Game.ctx.fillStyle = "#003B6F"; //deep underwater blue
    //Game.ctx.fillStyle = "#2F2F2F"; //smoky fog prison
    //Game.ctx.fillStyle = "#4a6c4b"; //darker muddy green
    //Game.ctx.fillStyle = "#800000"; // lighter red for dungeon hell theme
    game_1.Game.ctx.fillRect(0, 0, gameConstants_1.GameConstants.WIDTH, gameConstants_1.GameConstants.HEIGHT);
    game_1.Game.ctx.restore();
};


/***/ }),

/***/ "./src/projectile/enemyShield.ts":
/*!***************************************!*\
  !*** ./src/projectile/enemyShield.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EnemyShield = void 0;
const projectile_1 = __webpack_require__(/*! ./projectile */ "./src/projectile/projectile.ts");
const game_1 = __webpack_require__(/*! ../game */ "./src/game.ts");
const lighting_1 = __webpack_require__(/*! ../lighting */ "./src/lighting.ts");
const beamEffect_1 = __webpack_require__(/*! ../beamEffect */ "./src/beamEffect.ts");
class EnemyShield extends projectile_1.Projectile {
    constructor(parent, x, y, health = 1) {
        super(parent, x, y);
        this.remove = () => {
            this.parent.shielded = false;
            this.parent.removeLightSource(this.lightSource);
            this.parent.room.projectiles = this.parent.room.projectiles.filter((projectile) => projectile !== this);
            let beam = this.parent.room.projectiles.find((projectile) => projectile instanceof beamEffect_1.BeamEffect && projectile.parent === this.parent);
            if (beam) {
                beam.dead = true;
            }
            this.parent.shadeColor = "black";
            this.lightSource = null;
            this.parent.shield = null;
        };
        this.updateLightSourcePos = () => {
            if (this.lightSource === null)
                return;
            let index = this.parent.room.lightSources.indexOf(this.lightSource);
            this.parent.room.lightSources[index].x = this.parent.x + 0.5;
            this.parent.room.lightSources[index].y = this.parent.y + 0.5;
            this.parent.room.updateLighting();
        };
        this.hurt = (damage) => {
            const damageOverShield = Math.max(0, damage - this.health);
            this.health -= damage;
            /*
            GenericParticle.spawnCluster(
              this.parent.room,
              this.parent.x + 0.5,
              this.parent.y + 0.5,
              "#fbf236",
            );
            */
            if (this.health <= 0) {
                this.remove();
            }
            return damageOverShield;
        };
        this.tick = () => {
            if (this.parent.dead) {
                this.remove();
            }
            if (this.dead) {
                this.parent.room.projectiles = this.parent.room.projectiles.filter((projectile) => projectile !== this);
            }
        };
        this.draw = (delta) => {
            if (this.dead)
                return;
            game_1.Game.ctx.save();
            game_1.Game.ctx.globalAlpha = 1;
            this.frame += 0.1 * delta;
            if (this.frame >= 4)
                this.frame = 0;
            this.drawableY = this.parent.drawableY - 0.05;
            game_1.Game.ctx.globalCompositeOperation = "difference";
            if (this.parent.shielded) {
                game_1.Game.drawFX(18 + Math.floor(this.frame), 9, 1, 1, this.parent.x - this.parent.drawX, this.parent.y - this.parent.drawY, 1, 1);
            }
            game_1.Game.ctx.restore();
        };
        this.parent = parent;
        this.frame = 0;
        this.health = health;
        this.parent.shielded = true;
        this.lightSource = lighting_1.Lighting.newLightSource(this.x + 0.5, this.y + 0.5, [20, 0, 40], 3.5, 20);
        this.parent.addLightSource(this.lightSource);
        this.parent.room.projectiles.push(this);
        this.parent.room.updateLighting();
    }
}
exports.EnemyShield = EnemyShield;


/***/ }),

/***/ "./src/projectile/enemySpawnAnimation.ts":
/*!***********************************************!*\
  !*** ./src/projectile/enemySpawnAnimation.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EnemySpawnAnimation = void 0;
const projectile_1 = __webpack_require__(/*! ./projectile */ "./src/projectile/projectile.ts");
const game_1 = __webpack_require__(/*! ../game */ "./src/game.ts");
const genericParticle_1 = __webpack_require__(/*! ../particle/genericParticle */ "./src/particle/genericParticle.ts");
const sound_1 = __webpack_require__(/*! ../sound */ "./src/sound.ts");
const hitWarning_1 = __webpack_require__(/*! ../hitWarning */ "./src/hitWarning.ts");
class EnemySpawnAnimation extends projectile_1.Projectile {
    constructor(room, enemy, x, y) {
        super(enemy, x, y);
        this.ANIM_COUNT = 3;
        this.tick = () => {
            if (this.room === this.room.game.room)
                sound_1.Sound.enemySpawn();
            let hitPlayer = false;
            for (const i in this.room.game.players) {
                if (this.room.game.players[i].x === this.x &&
                    this.room.game.players[i].y === this.y) {
                    this.room.game.players[i].hurt(0.5, "reaper");
                    hitPlayer = true;
                }
            }
            if (!hitPlayer) {
                this.dead = true;
                this.enemy.skipNextTurns = 1;
                this.room.entities.push(this.enemy);
                genericParticle_1.GenericParticle.spawnCluster(this.room, this.x + 0.5, this.y + 0.5, "#ffffff");
                genericParticle_1.GenericParticle.spawnCluster(this.room, this.x + 0.5, this.y + 0.5, "#ffffff");
            }
            else {
                this.room.hitwarnings.push(new hitWarning_1.HitWarning(this.room.game, this.x, this.y, this.x, this.y));
            }
        };
        this.drawTopLayer = (delta) => {
            if (this.dead)
                return;
            this.frame += 0.25 * delta;
            if (this.frame >= 8)
                this.frame = 0;
            for (let i = 0; i < this.ANIM_COUNT; i++) {
                let offsetX = 0;
                game_1.Game.drawFX(Math.floor(this.frame), 27, 1, 1, this.x + Math.round(offsetX) / 16.0, this.y - 0.5, 1, 1);
            }
            if (Math.floor(this.frame * 4) % 2 == 0)
                this.room.particles.push(new genericParticle_1.GenericParticle(this.room, this.x + 0.5 + Math.random() * 0.05 - 0.025, this.y + Math.random() * 0.05 - 0.025, 0.25, Math.random() * 0.5, 0.025 * (Math.random() * 1 - 0.5), 0.025 * (Math.random() * 1 - 0.5), 0.2 * (Math.random() - 1), "#ffffff", 0));
        };
        this.room = room;
        this.enemy = enemy;
        this.frame = 0;
    }
}
exports.EnemySpawnAnimation = EnemySpawnAnimation;


/***/ }),

/***/ "./src/projectile/explosion.ts":
/*!*************************************!*\
  !*** ./src/projectile/explosion.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Explosion = void 0;
const projectile_1 = __webpack_require__(/*! ./projectile */ "./src/projectile/projectile.ts");
const game_1 = __webpack_require__(/*! ../game */ "./src/game.ts");
const lighting_1 = __webpack_require__(/*! ../lighting */ "./src/lighting.ts");
const utils_1 = __webpack_require__(/*! ../utils */ "./src/utils.ts");
const bomb_1 = __webpack_require__(/*! ../entity/object/bomb */ "./src/entity/object/bomb.ts");
class Explosion extends projectile_1.Projectile {
    constructor(entity, x, y, playerHitBy) {
        super(entity, x, y);
        this.drawTopLayer = (delta) => {
            if (this.dead)
                return;
            if (this.offsetFrame < 0)
                this.offsetFrame += 10 * delta;
            if (this.offsetFrame >= 0) {
                this.frame += 0.25 * delta;
            }
            if (this.frame > 17)
                this.dead = true;
            game_1.Game.drawFX(Math.floor(this.frame), 6, 1, 2, this.x, this.y - 1, 1, 2);
        };
        this.state = 0;
        this.frame = 6;
        this.parent = entity;
        this.offsetFrame =
            -utils_1.Utils.distance(this.parent.x, this.parent.y, this.x, this.y) * 100;
        this.delay = 0;
        lighting_1.Lighting.momentaryLight(this.parent.room, this.x + 0.5, this.y + 0.5, 0.5, [255, 100, 0], 350, 20, Math.abs(this.offsetFrame));
        const distance = utils_1.Utils.distance(this.parent.x, this.parent.y, this.x, this.y);
        let damage = distance === 0 ? 1 : Math.max(0.5, Math.floor((1 / distance) * 4) / 2);
        console.log("damage:", damage);
        for (let entity of this.parent.room.entities) {
            if (entity.x === this.x &&
                entity.y === this.y &&
                entity !== this.parent) {
                if (entity instanceof bomb_1.Bomb) {
                    entity.fuseLength = 1;
                }
                entity.hurt(playerHitBy, damage);
                console.log(playerHitBy);
            }
            if (playerHitBy.x === this.x && playerHitBy.y === this.y) {
                playerHitBy.hurt(damage, "bomb");
            }
        }
    }
}
exports.Explosion = Explosion;


/***/ }),

/***/ "./src/projectile/playerFireball.ts":
/*!******************************************!*\
  !*** ./src/projectile/playerFireball.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PlayerFireball = void 0;
const projectile_1 = __webpack_require__(/*! ./projectile */ "./src/projectile/projectile.ts");
const game_1 = __webpack_require__(/*! ../game */ "./src/game.ts");
const lighting_1 = __webpack_require__(/*! ../lighting */ "./src/lighting.ts");
const utils_1 = __webpack_require__(/*! ../utils */ "./src/utils.ts");
class PlayerFireball extends projectile_1.Projectile {
    constructor(parent, x, y) {
        super(parent, x, y);
        this.drawTopLayer = (delta) => {
            if (this.dead)
                return;
            if (this.offsetFrame < 0)
                this.offsetFrame += 10 * delta;
            if (this.offsetFrame >= 0) {
                this.frame += 0.25 * delta;
            }
            if (this.frame > 17)
                this.dead = true;
            game_1.Game.drawFX(Math.floor(this.frame), 6, 1, 2, this.x, this.y - 1, 1, 2);
        };
        this.state = 0;
        this.frame = 6;
        this.offsetFrame =
            -utils_1.Utils.distance(this.parent.x, this.parent.y, this.x, this.y) * 50;
        this.delay = 0;
        lighting_1.Lighting.momentaryLight(this.parent.game.rooms[this.parent.levelID], this.x + 0.5, this.y + 0.5, 0.5, [255, 100, 0], 250, 10, 1);
    }
}
exports.PlayerFireball = PlayerFireball;


/***/ }),

/***/ "./src/projectile/projectile.ts":
/*!**************************************!*\
  !*** ./src/projectile/projectile.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Projectile = void 0;
const drawable_1 = __webpack_require__(/*! ../drawable */ "./src/drawable.ts");
class Projectile extends drawable_1.Drawable {
    constructor(parent, x, y) {
        super();
        this.hitPlayer = (player) => { };
        this.hitEnemy = (enemy) => { };
        this.tick = () => { };
        this.draw = (delta) => { };
        this.drawTopLayer = (delta) => { };
        this.x = x;
        this.y = y;
        this.dead = false;
        this.parent = parent;
        this.drawableY = y;
        this.hasBloom = false;
        this.bloomColor = "#00BFFF";
    }
    get distanceToParent() {
        return Math.abs(this.x - this.parent.x) + Math.abs(this.y - this.parent.y);
    }
    setTarget(x, y, x2, y2) { }
}
exports.Projectile = Projectile;


/***/ }),

/***/ "./src/projectile/wizardFireball.ts":
/*!******************************************!*\
  !*** ./src/projectile/wizardFireball.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WizardFireball = void 0;
const projectile_1 = __webpack_require__(/*! ./projectile */ "./src/projectile/projectile.ts");
const game_1 = __webpack_require__(/*! ../game */ "./src/game.ts");
const hitWarning_1 = __webpack_require__(/*! ../hitWarning */ "./src/hitWarning.ts");
const lightSource_1 = __webpack_require__(/*! ../lightSource */ "./src/lightSource.ts");
const lighting_1 = __webpack_require__(/*! ../lighting */ "./src/lighting.ts");
class WizardFireball extends projectile_1.Projectile {
    constructor(parent, x, y) {
        super(parent, x, y);
        this.setMarkerFrame = () => {
            // Calculate offsetX based on direction
            this.offsetX = Math.floor(((this.dir + 1) % 8) / 2);
        };
        this.tick = () => {
            if (this.parent.dead || this.state === 3) {
                this.parent.removeLightSource(this.lightSource);
                this.dead = true;
            }
            if (!this.dead && this.state === 0) {
                this.bloomAlpha = 1;
            }
            this.state++;
            if (!this.dead && this.state === 1) {
                this.bloomAlpha = 0.5;
                const lightSource = this.parent.room.lightSources.find((ls) => ls === this.lightSource);
                lightSource.b = 0.4;
                this.parent.room.hitwarnings.push(new hitWarning_1.HitWarning(this.parent.game, this.x, this.y, this.parent.x, this.parent.y, true));
            }
            if (!this.dead && this.state === 2) {
                this.bloomAlpha = 0;
                lighting_1.Lighting.momentaryLight(this.parent.room, this.x, this.y, 3, this.parent.projectileColor, 500, 5, 350);
                this.parent.removeLightSource(this.lightSource);
                this.frame = 0;
                this.delay = game_1.Game.rand(0, 10, Math.random);
            }
        };
        this.hitPlayer = (player) => {
            if (!this.dead && this.state === 2) {
                player.hurt(1, this.parent.name);
            }
        };
        this.draw = (delta) => {
            if (this.dead)
                return;
            /*Game.drawFX(
              18 + this.offsetX, //+ Math.floor(HitWarning.frame),
              4,
              1,
              1,
              this.x,
              this.y,
              1,
              1
            );*/
            if (this.state >= 0) {
                if (this.state === 0) {
                    this.frame += 0.25 * delta;
                    if (this.frame >= 4)
                        this.frame = 0;
                    game_1.Game.drawFX(22 + Math.floor(this.frame), this.tileY, 1, 1, this.x, this.y, 1, 1);
                }
                else if (this.state === 1) {
                    this.frame += 0.25 * delta;
                    if (this.frame >= 4)
                        this.frame = 0;
                    game_1.Game.drawFX(18 + Math.floor(this.frame), this.tileY, 1, 1, this.x, this.y - 0.2, 1, 1);
                }
                else {
                    if (this.delay > 0) {
                        this.delay--;
                        return;
                    }
                    this.frame += 0.3 * delta;
                    if (this.frame > 17)
                        this.dead = true;
                    game_1.Game.drawFX(Math.floor(this.frame), 6, 1, 2, this.x, this.y - 1, 1, 2);
                }
            }
        };
        this.tileY = parent.name === "wizard bomber" ? 7 : 8;
        this.parent = parent;
        this.frame = 0;
        this.state = 0; // this.distanceToParent;
        this.lightSource = new lightSource_1.LightSource(this.x + 0.5, this.y + 0.5, 4, parent.projectileColor, 0.1);
        this.parent.addLightSource(this.lightSource);
        //this.parent.room.updateLighting();
        this.hasBloom = true;
        this.bloomColor = "#00BFFF";
        this.bloomAlpha = 0.5;
        this.softBloomAlpha = 0;
    }
}
exports.WizardFireball = WizardFireball;


/***/ }),

/***/ "./src/random.ts":
/*!***********************!*\
  !*** ./src/random.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Random = void 0;
class Random {
}
exports.Random = Random;
Random.setState = (state) => {
    Random.state = state;
};
Random.rand = () => {
    Random.state ^= Random.state << 21;
    Random.state ^= Random.state >>> 35;
    Random.state ^= Random.state << 4;
    return (Random.state >>> 0) / 4294967296;
};
// copy and paste into browser console
// let state;
// let rand = () => { state ^= (state << 21); state ^= (state >>> 35); state ^= (state << 4); return (state >>> 0) / 4294967296; }


/***/ }),

/***/ "./src/reverb.ts":
/*!***********************!*\
  !*** ./src/reverb.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ReverbEngine = void 0;
const game_1 = __webpack_require__(/*! ./game */ "./src/game.ts");
const sound_1 = __webpack_require__(/*! ./sound */ "./src/sound.ts");
class ReverbEngine {
    // Initialize the AudioContext and ConvolverNode
    static async initialize() {
        if (ReverbEngine.initialized)
            return;
        let canInitialize = false;
        if (!game_1.Game.inputReceived) {
            console.time("initializeReverb");
            try {
                await new Promise((resolve) => {
                    const checkInput = () => {
                        if (game_1.Game.inputReceived) {
                            resolve();
                            canInitialize = true;
                            console.timeEnd("initializeReverb");
                        }
                        else {
                            requestAnimationFrame(checkInput);
                        }
                    };
                    checkInput();
                });
            }
            catch (error) {
                console.error("Failed to initialize ReverbEngine:", error);
                return;
            }
        }
        if (!ReverbEngine.audioContext &&
            !ReverbEngine.initialized &&
            canInitialize) {
            ReverbEngine.audioContext = new (window.AudioContext ||
                window.webkitAudioContext)();
            ReverbEngine.convolver = ReverbEngine.audioContext.createConvolver();
            ReverbEngine.convolver.connect(ReverbEngine.audioContext.destination);
            await ReverbEngine.loadReverbBuffer(`res/SFX/impulses/small.mp3`);
            ReverbEngine.setDefaultReverb();
            ReverbEngine.initialized = true;
            if (sound_1.Sound.initialized)
                sound_1.Sound.audioMuted = false;
        }
    }
    // Load a specified impulse response
    static async loadReverbBuffer(filePath) {
        try {
            const response = await fetch(filePath);
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            const arrayBuffer = await response.arrayBuffer();
            ReverbEngine.reverbBuffer =
                await ReverbEngine.audioContext.decodeAudioData(arrayBuffer);
        }
        catch (error) {
            console.error("Error loading reverb buffer:", error);
        }
    }
    // Set the default reverb buffer
    static setDefaultReverb() {
        if (ReverbEngine.reverbBuffer) {
            ReverbEngine.convolver.buffer = ReverbEngine.reverbBuffer;
        }
    }
    /**
     * Set the reverb characteristics by specifying an impulse response file.
     * @param filePath - The path to the impulse response file.
     */
    static async setReverbImpulse(filePath) {
        if (!ReverbEngine.initialized)
            return;
        try {
            await ReverbEngine.loadReverbBuffer(filePath);
            if (ReverbEngine.reverbBuffer) {
                ReverbEngine.convolver.buffer = ReverbEngine.reverbBuffer;
            }
        }
        catch (error) {
            console.error("Error setting reverb impulse:", error);
        }
    }
    // Apply reverb to a given HTMLAudioElement
    static async applyReverb(audioElement) {
        await ReverbEngine.initialize();
        if (!ReverbEngine.initialized)
            return;
        try {
            if (ReverbEngine.mediaSources.has(audioElement)) {
                return;
            }
            const track = ReverbEngine.audioContext.createMediaElementSource(audioElement);
            track.connect(ReverbEngine.convolver);
            ReverbEngine.mediaSources.set(audioElement, track);
        }
        catch (error) {
            console.error("Error applying reverb:", error);
        }
    }
    // Remove reverb from a given HTMLAudioElement
    static async removeReverb(audioElement) {
        await ReverbEngine.initialize();
        if (!ReverbEngine.initialized)
            return;
        const track = ReverbEngine.mediaSources.get(audioElement);
        if (track) {
            track.disconnect();
            ReverbEngine.mediaSources.delete(audioElement);
        }
    }
}
exports.ReverbEngine = ReverbEngine;
ReverbEngine.reverbBuffer = null;
ReverbEngine.mediaSources = new WeakMap();
ReverbEngine.initialized = false;


/***/ }),

/***/ "./src/room/room.ts":
/*!**************************!*\
  !*** ./src/room/room.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Room = exports.WallDirection = exports.TurnState = exports.RoomType = exports.EnemyTypeMap = exports.EnemyType = void 0;
// #region imports
const wall_1 = __webpack_require__(/*! ../tile/wall */ "./src/tile/wall.ts");
const levelConstants_1 = __webpack_require__(/*! ../levelConstants */ "./src/levelConstants.ts");
const floor_1 = __webpack_require__(/*! ../tile/floor */ "./src/tile/floor.ts");
const game_1 = __webpack_require__(/*! ../game */ "./src/game.ts");
const door_1 = __webpack_require__(/*! ../tile/door */ "./src/tile/door.ts");
const tile_1 = __webpack_require__(/*! ../tile/tile */ "./src/tile/tile.ts");
const knightEnemy_1 = __webpack_require__(/*! ../entity/enemy/knightEnemy */ "./src/entity/enemy/knightEnemy.ts");
const entity_1 = __webpack_require__(/*! ../entity/entity */ "./src/entity/entity.ts");
const chest_1 = __webpack_require__(/*! ../entity/object/chest */ "./src/entity/object/chest.ts");
const goldenKey_1 = __webpack_require__(/*! ../item/goldenKey */ "./src/item/goldenKey.ts");
const spawnfloor_1 = __webpack_require__(/*! ../tile/spawnfloor */ "./src/tile/spawnfloor.ts");
const gameConstants_1 = __webpack_require__(/*! ../gameConstants */ "./src/gameConstants.ts");
const skullEnemy_1 = __webpack_require__(/*! ../entity/enemy/skullEnemy */ "./src/entity/enemy/skullEnemy.ts");
const barrel_1 = __webpack_require__(/*! ../entity/object/barrel */ "./src/entity/object/barrel.ts");
const crate_1 = __webpack_require__(/*! ../entity/object/crate */ "./src/entity/object/crate.ts");
const armor_1 = __webpack_require__(/*! ../item/armor */ "./src/item/armor.ts");
const particle_1 = __webpack_require__(/*! ../particle/particle */ "./src/particle/particle.ts");
const spiketrap_1 = __webpack_require__(/*! ../tile/spiketrap */ "./src/tile/spiketrap.ts");
const fountainTile_1 = __webpack_require__(/*! ../tile/fountainTile */ "./src/tile/fountainTile.ts");
const coffinTile_1 = __webpack_require__(/*! ../tile/coffinTile */ "./src/tile/coffinTile.ts");
const pottedPlant_1 = __webpack_require__(/*! ../entity/object/pottedPlant */ "./src/entity/object/pottedPlant.ts");
const insideLevelDoor_1 = __webpack_require__(/*! ../tile/insideLevelDoor */ "./src/tile/insideLevelDoor.ts");
const button_1 = __webpack_require__(/*! ../tile/button */ "./src/tile/button.ts");
const hitWarning_1 = __webpack_require__(/*! ../hitWarning */ "./src/hitWarning.ts");
const upLadder_1 = __webpack_require__(/*! ../tile/upLadder */ "./src/tile/upLadder.ts");
const downLadder_1 = __webpack_require__(/*! ../tile/downLadder */ "./src/tile/downLadder.ts");
const coalResource_1 = __webpack_require__(/*! ../entity/resource/coalResource */ "./src/entity/resource/coalResource.ts");
const goldResource_1 = __webpack_require__(/*! ../entity/resource/goldResource */ "./src/entity/resource/goldResource.ts");
const emeraldResource_1 = __webpack_require__(/*! ../entity/resource/emeraldResource */ "./src/entity/resource/emeraldResource.ts");
const chasm_1 = __webpack_require__(/*! ../tile/chasm */ "./src/tile/chasm.ts");
const spawner_1 = __webpack_require__(/*! ../entity/enemy/spawner */ "./src/entity/enemy/spawner.ts");
const vendingMachine_1 = __webpack_require__(/*! ../entity/object/vendingMachine */ "./src/entity/object/vendingMachine.ts");
const wallTorch_1 = __webpack_require__(/*! ../tile/wallTorch */ "./src/tile/wallTorch.ts");
const chargeEnemy_1 = __webpack_require__(/*! ../entity/enemy/chargeEnemy */ "./src/entity/enemy/chargeEnemy.ts");
const shotgun_1 = __webpack_require__(/*! ../weapon/shotgun */ "./src/weapon/shotgun.ts");
const heart_1 = __webpack_require__(/*! ../item/heart */ "./src/item/heart.ts");
const spear_1 = __webpack_require__(/*! ../weapon/spear */ "./src/weapon/spear.ts");
const player_1 = __webpack_require__(/*! ../player/player */ "./src/player/player.ts");
const crabEnemy_1 = __webpack_require__(/*! ../entity/enemy/crabEnemy */ "./src/entity/enemy/crabEnemy.ts");
const zombieEnemy_1 = __webpack_require__(/*! ../entity/enemy/zombieEnemy */ "./src/entity/enemy/zombieEnemy.ts");
const bigSkullEnemy_1 = __webpack_require__(/*! ../entity/enemy/bigSkullEnemy */ "./src/entity/enemy/bigSkullEnemy.ts");
const random_1 = __webpack_require__(/*! ../random */ "./src/random.ts");
const lantern_1 = __webpack_require__(/*! ../item/lantern */ "./src/item/lantern.ts");
const dualdagger_1 = __webpack_require__(/*! ../weapon/dualdagger */ "./src/weapon/dualdagger.ts");
const pot_1 = __webpack_require__(/*! ../entity/object/pot */ "./src/entity/object/pot.ts");
const bishopEnemy_1 = __webpack_require__(/*! ../entity/enemy/bishopEnemy */ "./src/entity/enemy/bishopEnemy.ts");
const rockResource_1 = __webpack_require__(/*! ../entity/resource/rockResource */ "./src/entity/resource/rockResource.ts");
const mushrooms_1 = __webpack_require__(/*! ../entity/object/mushrooms */ "./src/entity/object/mushrooms.ts");
const armoredzombieEnemy_1 = __webpack_require__(/*! ../entity/enemy/armoredzombieEnemy */ "./src/entity/enemy/armoredzombieEnemy.ts");
const tombStone_1 = __webpack_require__(/*! ../entity/object/tombStone */ "./src/entity/object/tombStone.ts");
const pumpkin_1 = __webpack_require__(/*! ../entity/object/pumpkin */ "./src/entity/object/pumpkin.ts");
const queenEnemy_1 = __webpack_require__(/*! ../entity/enemy/queenEnemy */ "./src/entity/enemy/queenEnemy.ts");
const frogEnemy_1 = __webpack_require__(/*! ../entity/enemy/frogEnemy */ "./src/entity/enemy/frogEnemy.ts");
const bigKnightEnemy_1 = __webpack_require__(/*! ../entity/enemy/bigKnightEnemy */ "./src/entity/enemy/bigKnightEnemy.ts");
const enemy_1 = __webpack_require__(/*! ../entity/enemy/enemy */ "./src/entity/enemy/enemy.ts");
const fireWizard_1 = __webpack_require__(/*! ../entity/enemy/fireWizard */ "./src/entity/enemy/fireWizard.ts");
const energyWizard_1 = __webpack_require__(/*! ../entity/enemy/energyWizard */ "./src/entity/enemy/energyWizard.ts");
const reverb_1 = __webpack_require__(/*! ../reverb */ "./src/reverb.ts");
const astarclass_1 = __webpack_require__(/*! ../astarclass */ "./src/astarclass.ts");
const warhammer_1 = __webpack_require__(/*! ../weapon/warhammer */ "./src/weapon/warhammer.ts");
const spellbook_1 = __webpack_require__(/*! ../weapon/spellbook */ "./src/weapon/spellbook.ts");
const torch_1 = __webpack_require__(/*! ../item/torch */ "./src/item/torch.ts");
const rookEnemy_1 = __webpack_require__(/*! ../entity/enemy/rookEnemy */ "./src/entity/enemy/rookEnemy.ts");
const beamEffect_1 = __webpack_require__(/*! ../beamEffect */ "./src/beamEffect.ts");
const environment_1 = __webpack_require__(/*! ../environment */ "./src/environment.ts");
const pickaxe_1 = __webpack_require__(/*! ../weapon/pickaxe */ "./src/weapon/pickaxe.ts");
const occultistEnemy_1 = __webpack_require__(/*! ../entity/enemy/occultistEnemy */ "./src/entity/enemy/occultistEnemy.ts");
const puddle_1 = __webpack_require__(/*! ../tile/decorations/puddle */ "./src/tile/decorations/puddle.ts");
const decoration_1 = __webpack_require__(/*! ../tile/decorations/decoration */ "./src/tile/decorations/decoration.ts");
const bomb_1 = __webpack_require__(/*! ../entity/object/bomb */ "./src/entity/object/bomb.ts");
const sound_1 = __webpack_require__(/*! ../sound */ "./src/sound.ts");
const block_1 = __webpack_require__(/*! ../entity/object/block */ "./src/entity/object/block.ts");
const armoredSkullEnemy_1 = __webpack_require__(/*! ../entity/enemy/armoredSkullEnemy */ "./src/entity/enemy/armoredSkullEnemy.ts");
const mummyEnemy_1 = __webpack_require__(/*! ../entity/enemy/mummyEnemy */ "./src/entity/enemy/mummyEnemy.ts");
const spiderEnemy_1 = __webpack_require__(/*! ../entity/enemy/spiderEnemy */ "./src/entity/enemy/spiderEnemy.ts");
const roomBuilder_1 = __webpack_require__(/*! ./roomBuilder */ "./src/room/roomBuilder.ts");
// #endregion
// #region Enums & Interfaces
/**
 * Enumeration of available enemy types.
 */
var EnemyType;
(function (EnemyType) {
    EnemyType["crab"] = "crab";
    EnemyType["frog"] = "frog";
    EnemyType["zombie"] = "zombie";
    EnemyType["skull"] = "skull";
    EnemyType["energyWizard"] = "energywizard";
    EnemyType["charge"] = "charge";
    EnemyType["rook"] = "rook";
    EnemyType["bishop"] = "bishop";
    EnemyType["armoredzombie"] = "armoredzombie";
    EnemyType["bigskull"] = "bigskull";
    EnemyType["queen"] = "queen";
    EnemyType["knight"] = "knight";
    EnemyType["bigknight"] = "bigknight";
    EnemyType["firewizard"] = "firewizard";
    EnemyType["spawner"] = "spawner";
    EnemyType["occultist"] = "occultist";
    EnemyType["bomb"] = "bomb";
    EnemyType["armoredskull"] = "armoredskull";
    EnemyType["mummy"] = "mummy";
    EnemyType["spider"] = "spider";
    // Add other enemy types here
})(EnemyType = exports.EnemyType || (exports.EnemyType = {}));
/**
 * Mapping of enemy types to their corresponding classes.
 */
exports.EnemyTypeMap = {
    [EnemyType.crab]: crabEnemy_1.CrabEnemy,
    [EnemyType.frog]: frogEnemy_1.FrogEnemy,
    [EnemyType.zombie]: zombieEnemy_1.ZombieEnemy,
    [EnemyType.skull]: skullEnemy_1.SkullEnemy,
    [EnemyType.energyWizard]: energyWizard_1.EnergyWizardEnemy,
    [EnemyType.charge]: chargeEnemy_1.ChargeEnemy,
    [EnemyType.rook]: rookEnemy_1.RookEnemy,
    [EnemyType.bishop]: bishopEnemy_1.BishopEnemy,
    [EnemyType.armoredzombie]: armoredzombieEnemy_1.ArmoredzombieEnemy,
    [EnemyType.bigskull]: bigSkullEnemy_1.BigSkullEnemy,
    [EnemyType.queen]: queenEnemy_1.QueenEnemy,
    [EnemyType.knight]: knightEnemy_1.KnightEnemy,
    [EnemyType.bigknight]: bigKnightEnemy_1.BigKnightEnemy,
    [EnemyType.firewizard]: fireWizard_1.FireWizardEnemy,
    [EnemyType.spawner]: spawner_1.Spawner,
    [EnemyType.occultist]: occultistEnemy_1.OccultistEnemy,
    [EnemyType.bomb]: bomb_1.Bomb,
    [EnemyType.armoredskull]: armoredSkullEnemy_1.ArmoredSkullEnemy,
    [EnemyType.mummy]: mummyEnemy_1.MummyEnemy,
    [EnemyType.spider]: spiderEnemy_1.SpiderEnemy,
    // Add other enemy mappings here
};
var RoomType;
(function (RoomType) {
    RoomType[RoomType["START"] = 0] = "START";
    RoomType[RoomType["DUNGEON"] = 1] = "DUNGEON";
    RoomType[RoomType["BOSS"] = 2] = "BOSS";
    RoomType[RoomType["BIGDUNGEON"] = 3] = "BIGDUNGEON";
    RoomType[RoomType["TREASURE"] = 4] = "TREASURE";
    RoomType[RoomType["FOUNTAIN"] = 5] = "FOUNTAIN";
    RoomType[RoomType["COFFIN"] = 6] = "COFFIN";
    RoomType[RoomType["GRASS"] = 7] = "GRASS";
    RoomType[RoomType["PUZZLE"] = 8] = "PUZZLE";
    RoomType[RoomType["KEYROOM"] = 9] = "KEYROOM";
    RoomType[RoomType["CHESSBOARD"] = 10] = "CHESSBOARD";
    RoomType[RoomType["MAZE"] = 11] = "MAZE";
    RoomType[RoomType["CORRIDOR"] = 12] = "CORRIDOR";
    RoomType[RoomType["SPIKECORRIDOR"] = 13] = "SPIKECORRIDOR";
    RoomType[RoomType["UPLADDER"] = 14] = "UPLADDER";
    RoomType[RoomType["DOWNLADDER"] = 15] = "DOWNLADDER";
    RoomType[RoomType["SHOP"] = 16] = "SHOP";
    RoomType[RoomType["BIGCAVE"] = 17] = "BIGCAVE";
    RoomType[RoomType["CAVE"] = 18] = "CAVE";
    RoomType[RoomType["SPAWNER"] = 19] = "SPAWNER";
    RoomType[RoomType["ROPEHOLE"] = 20] = "ROPEHOLE";
    RoomType[RoomType["ROPECAVE"] = 21] = "ROPECAVE";
    RoomType[RoomType["TUTORIAL"] = 22] = "TUTORIAL";
})(RoomType = exports.RoomType || (exports.RoomType = {}));
var TurnState;
(function (TurnState) {
    TurnState[TurnState["playerTurn"] = 0] = "playerTurn";
    TurnState[TurnState["computerTurn"] = 1] = "computerTurn";
})(TurnState = exports.TurnState || (exports.TurnState = {}));
var WallDirection;
(function (WallDirection) {
    WallDirection["NORTH"] = "North";
    WallDirection["EAST"] = "East";
    WallDirection["SOUTH"] = "South";
    WallDirection["WEST"] = "West";
    WallDirection["TOPLEFT"] = "TopLeft";
    WallDirection["TOPRIGHT"] = "TopRight";
    WallDirection["BOTTOMLEFT"] = "BottomLeft";
    WallDirection["BOTTOMRIGHT"] = "BottomRight";
})(WallDirection = exports.WallDirection || (exports.WallDirection = {}));
// #endregion
class Room {
    constructor(game, x, y, w, h, type, depth, mapGroup, level, rand = random_1.Random.rand) {
        this.name = "";
        this.shadeColor = "#000000";
        this.wallInfo = new Map();
        this.tunnelDoor = null; // this is the door that connects the start room to the exit room
        this.blurOffsetX = 5;
        this.blurOffsetY = 5;
        this.lastDraw = 0;
        this.drawTimestamp = 0;
        this.drawInterval = 4;
        // Add a list to keep track of BeamEffect instances
        this.beamEffects = [];
        // Add this property to track created mask canvases
        this.maskCanvases = [];
        // #region TILE ADDING METHODS
        this.removeWall = (x, y) => {
            if (this.roomArray[x][y] instanceof wall_1.Wall) {
                this.roomArray[x][y] = null;
            }
            //this.innerWalls = this.innerWalls.filter((w) => w.x !== x && w.y !== y);
            //this.outerWalls = this.outerWalls.filter((w) => w.x !== x && w.y !== y);
        };
        this.addDoor = (x, y, room = this, tunnelDoor = false) => {
            let d;
            let t = door_1.DoorType.DOOR;
            if (room.type === RoomType.BOSS)
                t = door_1.DoorType.GUARDEDDOOR;
            if (room.type === RoomType.KEYROOM)
                t = door_1.DoorType.LOCKEDDOOR;
            if (tunnelDoor)
                t = door_1.DoorType.TUNNELDOOR;
            if (x === room.roomX) {
                d = new door_1.Door(room, room.game, x, y, game_1.Direction.RIGHT, t);
                room.roomArray[x + 1][y] = new spawnfloor_1.SpawnFloor(room, x + 1, y);
            }
            else if (x === room.roomX + room.width - 1) {
                d = new door_1.Door(room, room.game, x, y, game_1.Direction.LEFT, t);
                room.roomArray[x - 1][y] = new spawnfloor_1.SpawnFloor(room, x - 1, y);
            }
            else if (y === room.roomY) {
                d = new door_1.Door(room, room.game, x, y, game_1.Direction.UP, t);
                room.roomArray[x][y + 1] = new spawnfloor_1.SpawnFloor(room, x, y + 1);
            }
            else if (y === room.roomY + room.height - 1) {
                d = new door_1.Door(room, room.game, x, y, game_1.Direction.DOWN, t);
                room.roomArray[x][y - 1] = new spawnfloor_1.SpawnFloor(room, x, y - 1);
            }
            if (tunnelDoor) {
                room.tunnelDoor = d;
            }
            room.doors.push(d);
            if (room.roomArray[d.x] == undefined) {
                console.log("door not added");
            }
            room.roomArray[d.x][d.y] = d;
            return d;
        };
        //used for spawn commands, implement elsewhere later
        /**
         * Adds a new enemy to the room based on the provided enemy type string.
         *
         * @param enemyType - The string identifier for the enemy type.
         */
        this.addNewEnemy = (enemyType) => {
            const EnemyClass = exports.EnemyTypeMap[enemyType];
            if (!EnemyClass) {
                console.error(`Enemy type "${enemyType}" is not recognized.`);
                return;
            }
            const tiles = this.getEmptyTiles();
            if (!tiles || tiles.length === 0) {
                // console.log(`No tiles left to spawn enemies.`);
                return;
            }
            const { x, y } = this.getRandomEmptyPosition(tiles);
            EnemyClass.add(this, this.game, x, y);
        };
        this.addNewSpawner = (enemyType) => {
            const EnemyClass = exports.EnemyTypeMap[enemyType];
            if (!EnemyClass) {
                //console.error(`Enemy type "${enemyType}" is not recognized.`);
                return;
            }
            const tiles = this.getEmptyTiles();
            if (!tiles || tiles.length === 0) {
                // console.log(`No tiles left to spawn enemies.`);
                return;
            }
            const { x, y } = this.getRandomEmptyPosition(tiles);
            spawner_1.Spawner.add(this, this.game, x, y);
        };
        // #endregion
        // #region POPULATING METHODS
        this.linkExitToStart = () => {
            //if (this.type === RoomType.ROPEHOLE) return;
            if (this.addDoorWithOffset(this.level.startRoom.roomX +
                Math.floor(this.level.startRoom.width / 2) +
                1, this.level.startRoom.roomY, this.level.startRoom, true) &&
                this.addDoorWithOffset(this.roomX + Math.floor(this.width / 2) - 1, this.roomY, this, true)) {
                this.tunnelDoor.linkedDoor = this.level.startRoom.tunnelDoor;
                this.tunnelDoor.linkedDoor.linkedDoor = this.tunnelDoor;
            }
        };
        this.populateEmpty = (rand) => {
            this.addTorchesByArea();
        };
        this.populateDungeon = (rand) => {
            //this.addChests(10, rand);
            let factor = game_1.Game.rand(1, 36, rand);
            if (factor < 30)
                this.builder.addWallBlocks(rand);
            if (factor % 4 === 0)
                this.addChasms(rand);
            this.addTorchesByArea();
            if (factor > 15)
                this.addSpikeTraps(game_1.Game.randTable([0, 0, 0, 1, 1, 2, 3], rand), rand);
            let numEmptyTiles = this.getEmptyTiles().length;
            let numTotalObstacles = Math.floor(numEmptyTiles * 0.35 * rand());
            let numPlants = Math.ceil(numTotalObstacles * rand());
            let numObstacles = numTotalObstacles - numPlants;
            this.addPlants(numPlants, rand);
            //this.addDecorations(Game.randTable([0, 0, 0, 1, 1, 2, 3], rand), rand);
            this.addObstacles(numObstacles, rand);
            if (factor <= 6)
                this.addVendingMachine(rand);
            this.addRandomEnemies();
            this.removeDoorObstructions();
        };
        this.populateBoss = (rand) => {
            this.addTorchesByArea();
            this.addSpikeTraps(game_1.Game.randTable([0, 0, 0, 1, 1, 2, 5], rand), rand);
            let numEmptyTiles = this.getEmptyTiles().length;
            let numTotalObstacles = Math.floor(numEmptyTiles * 0.2);
            let numPlants = Math.floor(numTotalObstacles * rand());
            let numObstacles = numTotalObstacles - numPlants;
            this.addPlants(numPlants, rand);
            this.addObstacles(numObstacles, rand);
            this.addRandomEnemies();
        };
        this.populateBigDungeon = (rand) => {
            if (game_1.Game.rand(1, 4, rand) === 1)
                this.addChasms(rand);
            this.addTorchesByArea();
            if (game_1.Game.rand(1, 4, rand) === 1)
                this.addPlants(game_1.Game.randTable([0, 0, 0, 0, 0, 1, 1, 2, 2, 3, 4], rand), rand);
            if (game_1.Game.rand(1, 3, rand) === 1)
                this.addSpikeTraps(game_1.Game.randTable([3, 5, 7, 8], rand), rand);
            this.addRandomEnemies();
            this.addObstacles(game_1.Game.randTable([0, 0, 1, 1, 2, 3, 5], rand), rand);
            this.removeDoorObstructions();
        };
        this.populateSpawner = (rand) => {
            this.addTorchesByArea();
            spawner_1.Spawner.add(this, this.game, Math.floor(this.roomX + this.width / 2), Math.floor(this.roomY + this.height / 2));
            this.removeDoorObstructions();
        };
        this.populateKeyRoom = (rand) => {
            this.addRandomTorches("medium");
            this.items.push(new goldenKey_1.GoldenKey(this, Math.floor(this.roomX + this.width / 2), Math.floor(this.roomY + this.height / 2)));
        };
        this.populateFountain = (rand) => {
            this.addRandomTorches("medium");
            let centerX = Math.floor(this.roomX + this.width / 2);
            let centerY = Math.floor(this.roomY + this.height / 2);
            for (let x = centerX - 1; x <= centerX + 1; x++) {
                for (let y = centerY - 1; y <= centerY + 1; y++) {
                    this.roomArray[x][y] = new fountainTile_1.FountainTile(this, x, y, x - (centerX - 1), y - (centerY - 1));
                }
            }
            this.addPlants(game_1.Game.randTable([0, 0, 1, 2], rand), rand);
        };
        this.placeCoffin = (x, y) => {
            this.roomArray[x][y] = new coffinTile_1.CoffinTile(this, x, y, 0);
            this.roomArray[x][y + 1] = new coffinTile_1.CoffinTile(this, x, y + 1, 1);
        };
        this.populateCoffin = (rand) => {
            this.addRandomTorches("medium");
            this.placeCoffin(Math.floor(this.roomX + this.width / 2 - 2), Math.floor(this.roomY + this.height / 2));
            this.placeCoffin(Math.floor(this.roomX + this.width / 2), Math.floor(this.roomY + this.height / 2));
            this.placeCoffin(Math.floor(this.roomX + this.width / 2) + 2, Math.floor(this.roomY + this.height / 2));
        };
        this.populatePuzzle = (rand) => {
            let d;
            for (let x = this.roomX; x < this.roomX + this.width; x++) {
                let y = this.roomY + Math.floor(this.height / 2);
                if (x === this.roomX + Math.floor(this.width / 2)) {
                    d = new insideLevelDoor_1.InsideLevelDoor(this, this.game, x, y + 1);
                    this.roomArray[x][y + 1] = d;
                }
                else {
                    this.roomArray[x][y] = new wall_1.Wall(this, x, y);
                }
            }
            let x = game_1.Game.rand(this.roomX, this.roomX + this.width - 1, rand);
            let y = game_1.Game.rand(this.roomY + Math.floor(this.height / 2) + 3, this.roomY + this.height - 2, rand);
            this.roomArray[x][y] = new button_1.Button(this, x, y, d);
            let crateTiles = this.getEmptyTiles().filter((t) => t.x >= this.roomX + 1 &&
                t.x <= this.roomX + this.width - 2 &&
                t.y >= this.roomY + Math.floor(this.height / 2) + 3 &&
                t.y <= this.roomY + this.height - 2);
            let numCrates = game_1.Game.randTable([1, 2, 2, 3, 4], rand);
            for (let i = 0; i < numCrates; i++) {
                let t = crateTiles.splice(game_1.Game.rand(0, crateTiles.length - 1, rand), 1)[0];
                if (t)
                    this.entities.push(new crate_1.Crate(this, this.game, t.x, t.y));
            }
            this.addPlants(game_1.Game.randTable([0, 0, 0, 0, 0, 1, 1, 2, 2, 3, 4], rand), rand);
            this.removeDoorObstructions();
        };
        this.populateSpikeCorridor = (rand) => {
            for (let x = this.roomX; x < this.roomX + this.width; x++) {
                for (let y = this.roomY + 1; y < this.roomY + this.height - 1; y++) {
                    this.roomArray[x][y] = new spiketrap_1.SpikeTrap(this, x, y, game_1.Game.rand(0, 3, rand));
                }
            }
            this.removeDoorObstructions();
            this.addRandomTorches("medium");
        };
        this.populateTreasure = (rand) => {
            this.addRandomTorches("medium");
            this.addChests(game_1.Game.randTable([4, 4, 5, 5, 5, 6, 8], rand), rand);
            this.addPlants(game_1.Game.randTable([0, 1, 2, 4, 5, 6], rand), rand);
        };
        this.populateCave = (rand) => {
            let factor = game_1.Game.rand(1, 36, rand);
            this.builder.addWallBlocks(rand);
            if (factor > 15)
                this.addSpikeTraps(game_1.Game.randTable([0, 0, 0, 1, 1, 2, 5], rand), rand);
            let numEmptyTiles = this.getEmptyTiles().length;
            let numEnemies = Math.ceil(numEmptyTiles * game_1.Game.randTable([0.25, 0.3, 0.35], rand));
            this.addEnemies(numEnemies, rand);
            if (this.level.environment.type === environment_1.EnvType.CAVE)
                this.addResources((numEmptyTiles - numEnemies) * game_1.Game.randTable([0.1, 0.2, 0.3], rand), rand);
            this.removeDoorObstructions();
        };
        this.populateUpLadder = (rand) => {
            this.addRandomTorches("medium");
            const { x, y } = this.getRoomCenter();
            this.roomArray[x - 1][y - 1] = new upLadder_1.UpLadder(this, this.game, x - 1, y - 1);
        };
        this.populateDownLadder = (rand) => {
            this.addTorches(1, rand, this.roomX + 3, this.roomY);
            const { x, y } = this.getRoomCenter();
            this.roomArray[x + 1][y - 1] = new downLadder_1.DownLadder(this, this.game, x + 1, y - 1);
            const numChests = Math.ceil(Math.random() * 5);
            let tiles = this.getEmptyTiles();
            tiles = tiles.filter((tile) => tile.x !== x || tile.y !== y);
            let weaponDropped = false;
            let toolDropped = false;
            let lightDropped = false;
            for (let i = 0; i < numChests; i++) {
                if (tiles.length > 0) {
                    const { x, y } = this.getRandomEmptyPosition(tiles);
                    let chest = new chest_1.Chest(this, this.game, x, y);
                    if (!weaponDropped) {
                        chest.getDrop(["weapon"], true);
                        weaponDropped = true;
                    }
                    else {
                        chest.getDrop(["consumable", "gem", "light", "tool", "fuel", "backpack"], true);
                    }
                    tiles.filter((tile) => tile.x !== x && tile.y !== y);
                    this.entities.push(chest);
                }
            }
        };
        this.populateRopeHole = (rand) => {
            this.addRandomTorches("medium");
            const { x, y } = this.getRoomCenter();
            let d = new downLadder_1.DownLadder(this, this.game, x, y);
            d.isRope = true;
            this.roomArray[x][y] = d;
        };
        this.populateRopeCave = (rand) => {
            const { x, y } = this.getRoomCenter();
            let upLadder = new upLadder_1.UpLadder(this, this.game, x, y);
            upLadder.isRope = true;
            this.roomArray[x][y] = upLadder;
            this.removeDoorObstructions();
        };
        this.populateShop = (rand) => {
            this.addTorches(2, rand);
            const { x, y } = this.getRoomCenter();
            vendingMachine_1.VendingMachine.add(this, this.game, x - 2, y - 1, new shotgun_1.Shotgun(this, 0, 0));
            vendingMachine_1.VendingMachine.add(this, this.game, x + 2, y - 1, new heart_1.Heart(this, 0, 0));
            vendingMachine_1.VendingMachine.add(this, this.game, x - 2, y + 2, new armor_1.Armor(this, 0, 0));
            vendingMachine_1.VendingMachine.add(this, this.game, x + 2, y + 2, new spear_1.Spear(this, 0, 0));
            this.removeDoorObstructions();
        };
        this.addTorchesByArea = () => {
            let numTorches = Math.max(1, Math.floor(Math.sqrt(this.roomArea) / 3) -
                Math.floor(Math.sqrt(this.depth)));
            if (this.depth === 0) {
                if (Math.random() < 0.25) {
                    numTorches = 0;
                }
            }
            else {
                // Exponential falloff starting at depth 1, approaching 90% chance
                const falloffRate = 0.4; // Controls how quickly it approaches 90%
                const maxChance = 0.9;
                const chance = maxChance * (1 - Math.exp(-falloffRate * (this.depth - 1)));
                if (Math.random() < chance) {
                    numTorches = 0;
                }
            }
            console.log("numTorches:" + numTorches, "roomArea" + this.roomArea);
            this.addTorches(numTorches, random_1.Random.rand);
        };
        this.populate = (rand) => {
            this.name = "";
            switch (this.type) {
                case RoomType.START:
                    //this.addNewEnemy(EnemyType.zombie);
                    //this.addNewEnemy(EnemyType.occultist);
                    //this.addNewEnemy(EnemyType.occultist);
                    //   this.addNewEnemy(EnemyType.occultist);
                    if (this.depth !== 0) {
                        this.populateUpLadder(rand);
                        //this.addVendingMachine(rand, this.roomX + 1, this.roomY + 1);
                        this.placeVendingMachineInWall();
                    }
                    this.populateEmpty(rand);
                    this.name = "FLOOR " + -this.depth;
                    if (this.level.environment.type === environment_1.EnvType.CAVE) {
                        const { x, y } = this.getRoomCenter();
                        let sign = Math.random() < 0.5 ? -1 : 1;
                        let offsetX = Math.floor(Math.random()) * sign;
                        let offsetY = offsetX !== 0 ? 0 : sign;
                        this.items.push(new pickaxe_1.Pickaxe(this, x + offsetX, y + offsetY));
                    }
                    break;
                case RoomType.BOSS:
                    this.populateBoss(rand);
                    this.name = "BOSS";
                    break;
                case RoomType.DUNGEON:
                    if (this.level.environment.type === environment_1.EnvType.CAVE &&
                        Math.random() <= 0.2) {
                        this.populateCave(rand);
                    }
                    else {
                        this.populateDungeon(rand);
                    }
                    break;
                case RoomType.BIGDUNGEON:
                    this.populateBigDungeon(rand);
                    break;
                case RoomType.FOUNTAIN:
                    this.populateFountain(rand);
                    break;
                case RoomType.COFFIN:
                    this.populateCoffin(rand);
                    break;
                case RoomType.PUZZLE:
                    this.populatePuzzle(rand);
                    break;
                case RoomType.SPIKECORRIDOR:
                    this.populateSpikeCorridor(rand);
                    break;
                case RoomType.TREASURE:
                    this.populateTreasure(rand);
                    break;
                case RoomType.KEYROOM:
                    this.populateKeyRoom(rand);
                    break;
                case RoomType.GRASS:
                    this.populateDungeon(rand);
                    break;
                case RoomType.BIGCAVE:
                    this.populateCave(rand);
                case RoomType.CAVE:
                    this.populateCave(rand);
                    break;
                case RoomType.UPLADDER:
                    this.populateUpLadder(rand);
                    this.name = "FLOOR " + -this.depth;
                    break;
                case RoomType.DOWNLADDER:
                    this.populateDownLadder(rand);
                    this.name = "FLOOR " + -this.depth;
                    break;
                case RoomType.ROPEHOLE:
                    this.populateRopeHole(rand);
                    break;
                case RoomType.ROPECAVE:
                    this.populateRopeCave(rand);
                    break;
                case RoomType.SHOP:
                    /* shop rates:
                     * 10 coal for an gold coin
                     * 1 gold for 10 coins
                     * 1 emerald for 100 coins
                     *
                     * shop items:
                     * 1 empty heart   4 ^ (maxHealth + maxHealth ^ 1.05 ^ maxHealth - 2.05) coins
                     * fill all hearts  1 coin
                     * better torch    5 ^ (torchLevel + 1.05 ^ torchLevel - 2.05) coins
                     * weapons
                     */
                    this.populateShop(rand);
                    break;
                case RoomType.SPAWNER:
                    this.populateSpawner(rand);
                    break;
            }
            this.message = this.name;
        };
        // #endregion
        // #region ENTERING / EXITING ROOM METHODS
        this.exitLevel = () => {
            //this.game.onResize(); // stupid hack to keep fps high
            game_1.Game.shade_canvases = {};
            game_1.Game.text_rendering_canvases = {};
            for (let door of this.doors) {
                if (door.linkedDoor.lightSource !== null &&
                    !door.linkedDoor.room.active &&
                    door.linkedDoor.room.entered) {
                    door.linkedDoor.lightSource.b = 0;
                    door.linkedDoor.lightSource.r = 0;
                    door.room.updateLighting();
                }
            }
            this.active = false;
            this.updateLighting();
            this.particles.splice(0, this.particles.length);
            this.disableFuseSounds();
        };
        this.disableFuseSounds = () => {
            for (const b of this.entities.filter((e) => e instanceof bomb_1.Bomb)) {
                //if (!bomb.soundPaused) {
                //bomb.soundPaused = true;
                const bomb = b;
                sound_1.Sound.stopSound(bomb.fuseSound);
                //}
            }
        };
        this.enableFuseSounds = () => {
            for (const b of this.entities.filter((e) => e instanceof bomb_1.Bomb)) {
                //if (!bomb.soundPaused) {
                //bomb.soundPaused = true;
                const bomb = b;
                if (bomb.lit) {
                    sound_1.Sound.playWithReverb(bomb.fuseSound);
                }
            }
        };
        this.onEnterRoom = (player) => {
            this.enableFuseSounds();
            for (let room of this.level.rooms) {
                room.roomOnScreen(player);
            }
            this.entered = true;
            this.clearDeadStuff();
            this.calculateWallInfo();
            this.resetDoorLightSources();
            this.particles = [];
            this.alertEnemiesOnEntry();
            this.message = this.name;
            player.map.saveMapData();
            this.setReverb();
            this.active = true;
            this.updateLighting();
        };
        this.enterLevel = (player) => {
            this.game.updateLevel();
            player.moveSnap(this.getRoomCenter().x, this.getRoomCenter().y);
            this.onEnterRoom(player);
        };
        this.enterLevelThroughDoor = (player, door, side) => {
            // console.log(door.linkedDoor.x, door.linkedDoor.y, door.x, door.y);
            if (door.doorDir === door.linkedDoor.doorDir) {
                door.opened = true;
                player.moveSnap(door.x, door.y + 1);
                setTimeout(() => {
                    player.direction = game_1.Direction.DOWN;
                }, 150);
            }
            if (door instanceof door_1.Door && door.doorDir === game_1.Direction.UP) {
                //if top door
                door.opened = true;
                player.moveNoSmooth(door.x, door.y + 1);
            }
            else if (door instanceof door_1.Door && door.doorDir === game_1.Direction.DOWN) {
                //if bottom door
                player.moveNoSmooth(door.x, door.y - 1);
            }
            else if (door instanceof door_1.Door &&
                [game_1.Direction.RIGHT, game_1.Direction.LEFT].includes(door.doorDir)) {
                // if side door
                player.moveNoSmooth(door.x + side, door.y);
            }
            this.onEnterRoom(player);
        };
        this.alertEnemiesOnEntry = () => {
            for (const e of this.entities) {
                if (e instanceof enemy_1.Enemy)
                    e.lookForPlayer(false);
            }
        };
        // #endregion
        // #region LOGIC METHODS
        this.tick = (player) => {
            this.updateLighting();
            player.updateSlowMotion();
            this.lastEnemyCount = this.entities.filter((e) => e instanceof enemy_1.Enemy).length;
            for (const h of this.hitwarnings) {
                h.tick();
            }
            for (const p of this.projectiles) {
                p.tick();
            }
            this.clearDeadStuff();
            this.calculateWallInfo();
            this.entities = this.entities.filter((e) => !e.dead);
            for (let x = this.roomX; x < this.roomX + this.width; x++) {
                for (let y = this.roomY; y < this.roomY + this.height; y++) {
                    this.roomArray[x][y].tick();
                }
            }
            this.turn = TurnState.computerTurn;
            //player.actionTab.setState(ActionState.WAIT);
            //sets the action tab state to Ready
            this.playerTurnTime = Date.now();
            this.playerTicked = player;
            // Update Beam Effects lighting
            //console.log("updating lighting");
            this.updateLighting();
            player.map.saveMapData();
            this.clearDeadStuff();
        };
        this.computerTurn = () => {
            // take computer turn
            for (const e of this.entities) {
                e.tick();
            }
            this.entities = this.entities.filter((e) => !e.dead);
            for (const i of this.items) {
                i.tick();
            }
            for (const h of this.hitwarnings) {
                if (!this.roomArray[h.x] ||
                    !this.roomArray[h.x][h.y] ||
                    this.roomArray[h.x][h.y].isSolid()) {
                    h.dead = true;
                }
                h.removeOverlapping();
            }
            for (const p of this.projectiles) {
                if (this.roomArray[p.x] &&
                    this.roomArray[p.x][p.y] &&
                    this.roomArray[p.x][p.y].isSolid())
                    p.dead = true;
                for (const i in this.game.players) {
                    if (this.level.rooms[this.game.players[i].levelID] === this &&
                        p.x === this.game.players[i].x &&
                        p.y === this.game.players[i].y) {
                        p.hitPlayer(this.game.players[i]);
                    }
                }
                for (const e of this.entities) {
                    if (p.x === e.x && p.y === e.y) {
                        p.hitEnemy(e);
                    }
                }
            }
            for (let x = this.roomX; x < this.roomX + this.width; x++) {
                for (let y = this.roomY; y < this.roomY + this.height; y++) {
                    this.roomArray[x][y].tickEnd();
                }
            }
            this.entities = this.entities.filter((e) => !e.dead); // enemies may be killed by spiketrap
            this.clearDeadStuff();
            this.playerTicked.finishTick();
            this.checkForNoEnemies();
            //console.log(this.entities.filter((e) => e instanceof Enemy).length);
            this.turn = TurnState.playerTurn;
        };
        this.update = () => {
            if (this.turn == TurnState.computerTurn) {
                if (Date.now() - this.playerTurnTime >=
                    levelConstants_1.LevelConstants.COMPUTER_TURN_DELAY) {
                    this.computerTurn();
                }
            }
        };
        this.clearDeadStuff = () => {
            this.deadEntities = this.deadEntities.filter((e) => !e.dead);
            this.entities = this.entities.filter((e) => !e.dead);
            this.projectiles = this.projectiles.filter((p) => !p.dead);
            this.hitwarnings = this.hitwarnings.filter((h) => !h.dead);
            this.particles = this.particles.filter((p) => !p.dead);
        };
        this.catchUp = () => {
            if (this.turn === TurnState.computerTurn)
                this.computerTurn(); // player skipped computer's turn, catch up
        };
        this.tickHitWarnings = () => {
            for (const h of this.hitwarnings) {
                if (h.parent && (h.parent.dead || h.parent.unconscious)) {
                    h.tick();
                }
            }
        };
        // #endregion
        // #region LIGHTING METHODS
        this.fadeLighting = (delta) => {
            for (let x = this.roomX; x < this.roomX + this.width; x++) {
                for (let y = this.roomY; y < this.roomY + this.height; y++) {
                    let visDiff = this.softVis[x][y] - this.vis[x][y];
                    let softVis = this.softVis[x][y];
                    let flag = false;
                    if (Math.abs(visDiff) > 0.01)
                        flag = true;
                    if (!flag)
                        continue;
                    visDiff *= 0.05 * delta;
                    softVis -= visDiff;
                    if (softVis < 0)
                        softVis = 0;
                    if (softVis > 1)
                        softVis = 1;
                    this.softVis[x][y] = softVis;
                    // if (this.softVis[x][y] < 0.01) this.softVis[x][y] = 0;
                }
            }
        };
        this.fadeRgb = (delta) => {
            for (let x = this.roomX; x < this.roomX + this.width; x++) {
                for (let y = this.roomY; y < this.roomY + this.height; y++) {
                    const [softR, softG, softB] = this.softCol[x][y];
                    const [targetR, targetG, targetB] = this.col[x][y];
                    // Calculate differences
                    let diffR = softR - targetR;
                    let diffG = softG - targetG;
                    let diffB = softB - targetB;
                    let flagR = false;
                    let flagG = false;
                    let flagB = false;
                    if (Math.abs(diffR) > 0.001)
                        flagR = true;
                    if (Math.abs(diffG) > 0.001)
                        flagG = true;
                    if (Math.abs(diffB) > 0.001)
                        flagB = true;
                    if (!flagR && !flagG && !flagB) {
                        continue;
                    }
                    // Apply smoothing similar to fadeLighting
                    if (flagR) {
                        diffR *= 0.05 * delta;
                        this.softCol[x][y][0] = this.clamp(Math.round(softR - diffR), 0, 255);
                    }
                    if (flagG) {
                        diffG *= 0.05 * delta;
                        this.softCol[x][y][1] = this.clamp(Math.round(softG - diffG), 0, 255);
                    }
                    if (flagB) {
                        diffB *= 0.05 * delta;
                        this.softCol[x][y][2] = this.clamp(Math.round(softB - diffB), 0, 255);
                    }
                }
            }
        };
        this.resetDoorLightSources = () => {
            this.doors.forEach((d) => {
                d.lightSource.r = 0;
                d.linkedDoor.lightSource.r = 0;
            });
        };
        this.tileValuesToLightSource = (x, y, room) => {
            if (!room.roomArray[x])
                return null;
            if (!room.roomArray[x][y])
                return null;
            const color = room.col[x][y];
            const brightness = (1 - room.vis[x][y]) / 4;
            const radius = 9;
            return { color, brightness, radius };
        };
        this.updateDoorLightSources = () => {
            //works from inactive rooms onto their connected rooms
            if (!this.active)
                return;
            const directionOffsets = {
                [game_1.Direction.UP]: { x: 0, y: -1 },
                [game_1.Direction.DOWN]: { x: 0, y: 1 },
                [game_1.Direction.LEFT]: { x: -1, y: 0 },
                [game_1.Direction.RIGHT]: { x: 1, y: 0 },
            };
            let linkedDoors = [];
            this.doors.forEach((d) => {
                if (d.linkedDoor && d.room.entered)
                    linkedDoors.push(d.linkedDoor);
            });
            this.doors.forEach((d) => {
                d.lightSource.b = 0.1;
            });
            for (const d of linkedDoors) {
                d.lightSource.c = this.tileValuesToLightSource(d.linkedDoor.x, d.linkedDoor.y, this).color;
                d.lightSource.b = this.tileValuesToLightSource(d.linkedDoor.x, d.linkedDoor.y, this).brightness;
                d.lightSource.r = levelConstants_1.LevelConstants.LIGHTING_MAX_DISTANCE;
            }
            let connectedRooms = new Set(this.doors
                .filter((d) => d && d.linkedDoor) // Ensure door and linkedDoor exist
                .map((d) => d.linkedDoor.room)
                .filter((r) => r));
            for (const r of Array.from(connectedRooms)) {
                if (r.entered)
                    r.updateLighting();
            }
        };
        this.updateLighting = () => {
            if (!this.onScreen)
                return;
            // Start timing the initial setup
            //console.time("updateLighting: Initial Setup");
            this.updateDoorLightSources();
            let oldVis = [];
            let oldCol = [];
            for (let x = this.roomX; x < this.roomX + this.width; x++) {
                oldVis[x] = [];
                oldCol[x] = [];
                for (let y = this.roomY; y < this.roomY + this.height; y++) {
                    oldVis[x][y] = this.vis[x][y];
                    oldCol[x][y] = this.col[x][y];
                    this.vis[x][y] = 1;
                    this.col[x][y] = [1, 1, 1];
                    this.renderBuffer[x][y] = [];
                }
            }
            // End timing the initial setup
            //console.timeEnd("updateLighting: Initial Setup");
            // Start timing the processing of light sources
            //console.time("updateLighting: Process LightSources");
            for (const l of this.lightSources) {
                if (l.shouldUpdate()) {
                    for (let i = 0; i < 360; i += levelConstants_1.LevelConstants.LIGHTING_ANGLE_STEP) {
                        this.castTintAtAngle(i, l.x, l.y, l.r, l.c, l.b); // RGB color in sRGB
                    }
                }
            }
            let lightingAngleStep = levelConstants_1.LevelConstants.LIGHTING_ANGLE_STEP;
            for (const p in this.game.players) {
                let player = this.game.players[p];
                if (this === this.level.rooms[player.levelID]) {
                    //console.log(`i: ${player.angle}`);
                    for (let i = 0; i < 360; i += lightingAngleStep) {
                        let lightColor = levelConstants_1.LevelConstants.AMBIENT_LIGHT_COLOR;
                        let lightBrightness = 5;
                        if (player.lightEquipped) {
                            lightColor = levelConstants_1.LevelConstants.TORCH_LIGHT_COLOR;
                            lightBrightness = player.lightBrightness;
                        }
                        this.castTintAtAngle(i, player.x + 0.5, player.y + 0.5, 
                        /*
                        Math.min(
                          Math.max(
                            player.sightRadius - this.depth + 2,
                            Player.minSightRadius,
                          ),
                          10,
                        ),
                        */
                        levelConstants_1.LevelConstants.LIGHTING_MAX_DISTANCE, lightColor, // RGB color in sRGB
                        lightBrightness);
                    }
                }
            }
            // End timing the processing of player lighting
            //console.timeEnd("updateLighting: Process Players");
            // Start timing the blending of colors
            //console.time("updateLighting: Blend Colors Array");
            const roomX = this.roomX;
            const roomY = this.roomY;
            const width = this.width;
            const height = this.height;
            const renderBuffer = this.renderBuffer;
            for (let x = roomX; x < roomX + width; x++) {
                for (let y = roomY; y < roomY + height; y++) {
                    this.col[x][y] = this.blendColorsArray(renderBuffer[x][y]);
                }
            }
            // End timing the blending of colors
            //console.timeEnd("updateLighting: Blend Colors Array");
            // Start timing the conversion to luminance
            //console.time("updateLighting: Convert to Luminance");
            for (let x = roomX; x < roomX + width; x++) {
                for (let y = roomY; y < roomY + height; y++) {
                    this.vis[x][y] = this.rgbToLuminance(this.col[x][y]);
                }
            }
            // End timing the conversion to luminance
            //console.timeEnd("updateLighting: Convert to Luminance");
            this.updateDoorLightSources();
        };
        this.updateLightSources = (lightSource, remove) => {
            this.oldCol = [];
            this.oldVis = [];
            this.oldCol = this.col;
            this.oldVis = this.vis;
            if (lightSource) {
                for (let i = 0; i < 360; i += levelConstants_1.LevelConstants.LIGHTING_ANGLE_STEP) {
                    if (!remove) {
                        this.castTintAtAngle(i, lightSource.x, lightSource.y, lightSource.r, lightSource.c, lightSource.b); // RGB color in sRGB
                    }
                    else {
                        this.unCastTintAtAngle(i, lightSource.x, lightSource.y, lightSource.r, lightSource.c, lightSource.b);
                    }
                }
            }
            for (let x = this.roomX; x < this.roomX + this.width; x++) {
                for (let y = this.roomY; y < this.roomY + this.height; y++) {
                    this.col[x][y] = this.blendColorsArray(this.renderBuffer[x][y]);
                }
            }
            for (let x = this.roomX; x < this.roomX + this.width; x++) {
                for (let y = this.roomY; y < this.roomY + this.height; y++) {
                    this.vis[x][y] = this.rgbToLuminance(this.col[x][y]);
                }
            }
        };
        this.revertLightSources = () => {
            //console.log("reverting lighting");
            this.oldCol = [];
            this.oldVis = [];
            this.col = this.oldCol;
            this.vis = this.oldVis;
        };
        /**
         * Casts or uncategorizes a tint from a light source at a specific angle.
         *
         * @param angle - The angle in degrees at which to cast or uncast the tint.
         * @param px - The x-coordinate of the light source.
         * @param py - The y-coordinate of the light source.
         * @param radius - The radius of the light's influence.
         * @param color - The RGB color tuple representing the tint.
         * @param brightness - The brightness of the light source.
         * @param action - 'cast' to add tint, 'unCast' to remove tint.
         */
        this.processTintAtAngle = (angle, px, py, radius, color, brightness, action = "cast") => {
            const dx = Math.cos((angle * Math.PI) / 180);
            const dy = Math.sin((angle * Math.PI) / 180);
            // Convert input color from sRGB to linear RGB
            const linearColor = [
                this.sRGBToLinear(color[0]),
                this.sRGBToLinear(color[1]),
                this.sRGBToLinear(color[2]),
            ];
            for (let i = 0; i <= Math.min(levelConstants_1.LevelConstants.LIGHTING_MAX_DISTANCE, radius); i++) {
                const currentX = Math.floor(px + dx * i);
                const currentY = Math.floor(py + dy * i);
                if (!this.isPositionInRoom(currentX, currentY))
                    return; // Outside the room
                const tile = this.roomArray[currentX][currentY];
                if (tile.isOpaque()) {
                    return; // Stop processing through opaque tiles
                }
                else if (Math.random() < 1 - tile.opacity) {
                    return;
                }
                // Handle i=0 separately to ensure correct intensity
                let intensity;
                if (i === 0) {
                    intensity = brightness * 0.1;
                }
                else {
                    intensity = brightness / Math.E ** (i - 0.25);
                }
                if (intensity < 0.005)
                    intensity = 0;
                if (intensity <= 0)
                    continue;
                if (!this.renderBuffer[currentX]) {
                    this.renderBuffer[currentX] = [];
                }
                if (!this.renderBuffer[currentX][currentY]) {
                    this.renderBuffer[currentX][currentY] = [];
                }
                const weightedLinearColor = [
                    linearColor[0],
                    linearColor[1],
                    linearColor[2],
                    intensity,
                ];
                if (action === "cast") {
                    this.renderBuffer[currentX][currentY].push(weightedLinearColor);
                }
                else if (action === "unCast") {
                    this.renderBuffer[currentX][currentY] = this.renderBuffer[currentX][currentY].filter((colorEntry) => !(Math.abs(colorEntry[0] - weightedLinearColor[0]) < 0.0001 &&
                        Math.abs(colorEntry[1] - weightedLinearColor[1]) < 0.0001 &&
                        Math.abs(colorEntry[2] - weightedLinearColor[2]) < 0.0001 &&
                        Math.abs(colorEntry[3] - weightedLinearColor[3]) < 0.0001));
                }
            }
        };
        /**
         * Casts a tint from a light source at a specific angle.
         *
         * @param angle - The angle in degrees at which to cast the tint.
         * @param px - The x-coordinate of the light source.
         * @param py - The y-coordinate of the light source.
         * @param radius - The radius of the light's influence.
         * @param color - The RGB color tuple representing the tint.
         * @param brightness - The brightness of the light source.
         */
        this.castTintAtAngle = (angle, px, py, radius, color, brightness) => {
            this.processTintAtAngle(angle, px, py, radius, color, brightness / 3, "cast");
        };
        /**
         * Uncasts a tint from a light source at a specific angle.
         *
         * @param angle - The angle in degrees at which to uncast the tint.
         * @param px - The x-coordinate of the light source.
         * @param py - The y-coordinate of the light source.
         * @param radius - The radius of the light's influence.
         * @param color - The RGB color tuple representing the tint.
         * @param brightness - The brightness of the light source.
         */
        this.unCastTintAtAngle = (angle, px, py, radius, color, brightness) => {
            this.processTintAtAngle(angle, px, py, radius, color, brightness / 3, // added this
            "unCast");
        };
        this.sRGBToLinear = (value) => {
            const normalized = value / 255;
            if (normalized <= 0.04045) {
                return normalized / 12.92;
            }
            else {
                return Math.pow((normalized + 0.055) / 1.055, 2.2);
            }
        };
        this.linearToSRGB = (value) => {
            if (value <= 0.0031308) {
                return Math.round(12.92 * value * 255);
            }
            else {
                return Math.round((1.055 * Math.pow(value, 1 / 2.2 /*gamma*/) - 0.055) * 255);
            }
        };
        this.clamp = (value, min = 0, max = 1) => {
            return Math.min(Math.max(value, min), max);
        };
        /**
         * Blends an array of RGB colors into a single color without excessive darkness or clipping to white.
         *
         * @param colors - An array of RGB tuples to blend.
         * @returns A single RGB tuple representing the blended color.
         */
        this.blendColorsArray = (colors) => {
            if (colors.length === 0)
                return [0, 0, 0];
            // Sum all color channels in linear RGB
            const sum = colors.reduce((accumulator, color) => [
                accumulator[0] + color[0] * color[3],
                accumulator[1] + color[1] * color[3],
                accumulator[2] + color[2] * color[3],
            ], [0, 0, 0]);
            // Apply scaling factor to manage overall brightness
            const scalingFactor = 0.45 * 2.5; // Adjust as needed
            const scaledSum = [
                sum[0] * scalingFactor,
                sum[1] * scalingFactor,
                sum[2] * scalingFactor,
            ];
            // Clamp each channel to [0, 1] to prevent overflow
            const clampedSum = [
                this.clamp(scaledSum[0], 0, 1),
                this.clamp(scaledSum[1], 0, 1),
                this.clamp(scaledSum[2], 0, 1),
            ];
            // Convert back to sRGB
            return [
                this.linearToSRGB(clampedSum[0]),
                this.linearToSRGB(clampedSum[1]),
                this.linearToSRGB(clampedSum[2]),
            ];
        };
        this.rgbToLuminance = (color) => {
            //map to 1-0 range
            return 1 - (0.299 * color[0] + 0.587 * color[1] + 0.114 * color[2]) / 255;
        };
        this.draw = (delta) => {
            if (!this.onScreen)
                return;
            if (this.active) {
                hitWarning_1.HitWarning.updateFrame(delta);
                this.drawInterval = 4;
            }
            else if (!this.active) {
                this.drawInterval = 8;
            }
            this.drawTimestamp += delta;
            if (this.drawTimestamp - this.lastDraw >= this.drawInterval) {
                this.fadeRgb(delta + this.drawInterval);
                this.fadeLighting(delta + this.drawInterval);
                this.lastDraw = this.drawTimestamp;
            }
        };
        // added a multiplier to the input rgb values to avoid clipping to white
        this.drawColorLayer = () => {
            if (!this.onScreen)
                return;
            game_1.Game.ctx.save();
            // Clear the offscreen color canvas
            this.colorOffscreenCtx.clearRect(0, 0, this.colorOffscreenCanvas.width, this.colorOffscreenCanvas.height);
            let lastFillStyle = "";
            const offsetX = this.blurOffsetX;
            const offsetY = this.blurOffsetY;
            // Draw all color rectangles without any filters
            for (let x = this.roomX; x < this.roomX + this.width; x++) {
                for (let y = this.roomY; y < this.roomY + this.height; y++) {
                    const [r, g, b] = this.softCol[x][y];
                    if (r === 0 && g === 0 && b === 0)
                        continue; // Skip if no color
                    const fillStyle = `rgba(${r}, ${g}, ${b}, 1)`;
                    if (fillStyle !== lastFillStyle) {
                        this.colorOffscreenCtx.fillStyle = fillStyle;
                        lastFillStyle = fillStyle;
                    }
                    this.colorOffscreenCtx.fillRect((x - this.roomX + offsetX) * gameConstants_1.GameConstants.TILESIZE, (y - this.roomY + offsetY) * gameConstants_1.GameConstants.TILESIZE, gameConstants_1.GameConstants.TILESIZE, gameConstants_1.GameConstants.TILESIZE);
                }
            }
            // Draw the blurred color layer directly without masking
            game_1.Game.ctx.globalCompositeOperation =
                gameConstants_1.GameConstants.COLOR_LAYER_COMPOSITE_OPERATION;
            //Game.ctx.globalCompositeOperation = "source-over";
            game_1.Game.ctx.globalAlpha = 0.6; // 0.6;
            if (!gameConstants_1.GameConstants.ctxBlurEnabled) {
                this.applyGaussianBlur(this.colorOffscreenCanvas, 12);
            }
            else {
                game_1.Game.ctx.filter = "blur(6px)";
            }
            game_1.Game.ctx.drawImage(this.colorOffscreenCanvas, (this.roomX - offsetX) * gameConstants_1.GameConstants.TILESIZE, (this.roomY - offsetY) * gameConstants_1.GameConstants.TILESIZE);
            //draw slight haze
            game_1.Game.ctx.globalCompositeOperation = "lighten";
            game_1.Game.ctx.globalAlpha = 0.05;
            if (!gameConstants_1.GameConstants.ctxBlurEnabled)
                this.applyGaussianBlur(this.colorOffscreenCanvas, 24);
            else
                game_1.Game.ctx.filter = "blur(12px)";
            game_1.Game.ctx.drawImage(this.colorOffscreenCanvas, (this.roomX - offsetX) * gameConstants_1.GameConstants.TILESIZE, (this.roomY - offsetY) * gameConstants_1.GameConstants.TILESIZE);
            this.colorOffscreenCtx.clearRect(0, 0, this.colorOffscreenCanvas.width, this.colorOffscreenCanvas.height);
            game_1.Game.ctx.restore();
        };
        this.drawShadeLayer = () => {
            if (this.game.isMobile)
                return;
            if (!this.onScreen)
                return;
            game_1.Game.ctx.save();
            // Clear the offscreen shade canvas
            this.shadeOffscreenCtx.clearRect(0, 0, this.shadeOffscreenCanvas.width, this.shadeOffscreenCanvas.height);
            let lastFillStyle = "";
            const offsetX = this.blurOffsetX;
            const offsetY = this.blurOffsetY;
            // Draw all shade rectangles without any filters
            for (let x = this.roomX - 2; x < this.roomX + this.width + 4; x++) {
                for (let y = this.roomY - 2; y < this.roomY + this.height + 4; y++) {
                    let alpha = this.softVis[x] && this.softVis[x][y] ? this.softVis[x][y] : 0;
                    if (this.roomArray[x] &&
                        this.roomArray[x][y] &&
                        this.roomArray[x][y] instanceof wallTorch_1.WallTorch)
                        continue;
                    //if (alpha === 0) continue; // Skip if no visibility adjustment
                    let factor = !gameConstants_1.GameConstants.SMOOTH_LIGHTING ? 2 : 0.5;
                    let computedAlpha = alpha ** factor;
                    // if (computedAlpha <= 0) continue; // Skip if alpha is effectively zero
                    let fillX = x;
                    let fillY = y;
                    let fillWidth = 1;
                    let fillHeight = 1;
                    if (this.roomArray[x] &&
                        this.roomArray[x][y] &&
                        this.roomArray[x][y] instanceof wall_1.Wall) {
                        const wall = this.roomArray[x][y];
                        if (!this.innerWalls.includes(wall)) {
                            switch (wall.direction) {
                                case game_1.Direction.UP:
                                    fillY = y - 0.5;
                                    fillHeight = 0.5;
                                    break;
                                case game_1.Direction.DOWN:
                                    fillY = y - 0.5;
                                    fillHeight = 1.5;
                                    break;
                                case game_1.Direction.LEFT:
                                    fillX = x + 0.5;
                                    fillWidth = 0.5;
                                    break;
                                case game_1.Direction.RIGHT:
                                    fillX = x + 0;
                                    fillWidth = 0.5;
                                    break;
                                case game_1.Direction.DOWN_LEFT:
                                    fillX = x + 0.5;
                                    fillY = y - 0.5;
                                    fillWidth = 0.5;
                                    fillHeight = 1.5;
                                    break;
                                case game_1.Direction.DOWN_RIGHT:
                                    fillX = x;
                                    fillY = y - 0.5;
                                    fillWidth = 0.5;
                                    fillHeight = 1.5;
                                    break;
                                case game_1.Direction.UP_LEFT:
                                    fillX = x + 0.5;
                                    fillY = y - 0.5;
                                    fillWidth = 0.5;
                                    fillHeight = 0.5;
                                    break;
                                case game_1.Direction.UP_RIGHT:
                                    fillX = x - 0.5;
                                    fillY = y - 0.5;
                                    fillWidth = 0.5;
                                    fillHeight = 0.5;
                                    break;
                            }
                        }
                    }
                    /*
                    if (
                      this.roomArray[x] &&
                      this.roomArray[x][y] &&
                      this.roomArray[x][y] instanceof Door &&
                      !(this.roomArray[x][y] as Door).opened &&
                      !(this.roomArray[x][y] as Door).linkedDoor.room.entered
                    ) {
                      //computedAlpha = 1;
                      switch ((this.roomArray[x][y] as Door).doorDir) {
                        case Direction.UP:
                          fillY = y - 0.75;
                          fillX = x - 0.5;
                          fillHeight = 2;
                          fillWidth = 1.5;
            
                          break;
                        case Direction.DOWN:
                          fillX = x;
                          fillY = y + 0.5;
                          fillHeight = 2;
                          fillWidth = 1.5;
                          break;
                        case Direction.LEFT:
                          fillX = x;
                          fillY = y - 0.5;
                          fillWidth = 2;
                          fillHeight = 2;
                          break;
                        case Direction.RIGHT:
                          fillX = x - 0.5;
                          fillY = y - 0.5;
                          fillWidth = 2;
                          fillHeight = 2;
                          break;
                      }
                    }
                    */
                    const fillStyle = `rgba(0, 0, 0, ${computedAlpha * 0.5})`;
                    if (fillStyle !== lastFillStyle) {
                        this.shadeOffscreenCtx.fillStyle = fillStyle;
                        lastFillStyle = fillStyle;
                    }
                    fillY += 1;
                    fillX += 1;
                    this.shadeOffscreenCtx.fillRect((fillX - this.roomX + offsetX) * gameConstants_1.GameConstants.TILESIZE, (fillY - this.roomY + offsetY) * gameConstants_1.GameConstants.TILESIZE, fillWidth * gameConstants_1.GameConstants.TILESIZE, fillHeight * gameConstants_1.GameConstants.TILESIZE);
                }
            }
            // Draw the blurred shade layer directly without masking
            game_1.Game.ctx.globalCompositeOperation = "source-over";
            game_1.Game.ctx.globalAlpha = 1;
            if (!gameConstants_1.GameConstants.ctxBlurEnabled)
                this.applyGaussianBlur(this.shadeOffscreenCanvas, 10);
            else
                game_1.Game.ctx.filter = "blur(5px)";
            game_1.Game.ctx.drawImage(this.shadeOffscreenCanvas, (this.roomX - offsetX - 1) * gameConstants_1.GameConstants.TILESIZE, (this.roomY - offsetY - 1) * gameConstants_1.GameConstants.TILESIZE);
            game_1.Game.ctx.restore();
        };
        this.drawBloomLayer = (delta) => {
            if (this.game.isMobile || !this.onScreen)
                return;
            game_1.Game.ctx.save();
            // Clear the offscreen shade canvas
            this.bloomOffscreenCtx.clearRect(0, 0, this.bloomOffscreenCanvas.width, this.bloomOffscreenCanvas.height);
            const offsetX = this.blurOffsetX;
            const offsetY = this.blurOffsetY;
            let lastFillStyle = "";
            // Draw all shade rectangles without any filters
            const allEntities = this.entities.concat(this.deadEntities);
            if (allEntities.length > 0)
                for (let e of this.entities) {
                    if (e.hasBloom) {
                        e.updateBloom(delta);
                        this.bloomOffscreenCtx.globalAlpha =
                            1 * (1 - this.softVis[e.x][e.y]) * e.softBloomAlpha;
                        this.bloomOffscreenCtx.fillStyle = e.bloomColor;
                        this.bloomOffscreenCtx.fillRect((e.x - e.drawX - this.roomX + offsetX + 0.5 - e.bloomSize / 2) *
                            gameConstants_1.GameConstants.TILESIZE, (e.y -
                            e.drawY -
                            this.roomY -
                            0.5 +
                            offsetY +
                            0.5 -
                            e.bloomSize / 2) *
                            gameConstants_1.GameConstants.TILESIZE +
                            e.bloomOffsetY, gameConstants_1.GameConstants.TILESIZE * e.bloomSize, gameConstants_1.GameConstants.TILESIZE * e.bloomSize);
                    }
                }
            for (let x = this.roomX; x < this.roomX + this.width; x++) {
                for (let y = this.roomY; y < this.roomY + this.height; y++) {
                    if (this.roomArray[x][y].hasBloom) {
                        this.roomArray[x][y].updateBloom(delta);
                        this.bloomOffscreenCtx.globalAlpha =
                            1 * (1 - this.softVis[x][y]) * this.roomArray[x][y].softBloomAlpha;
                        this.bloomOffscreenCtx.fillStyle = this.roomArray[x][y].bloomColor;
                        this.bloomOffscreenCtx.fillRect((x - this.roomX + offsetX) * gameConstants_1.GameConstants.TILESIZE, (y - this.roomY - 0.25 + offsetY) * gameConstants_1.GameConstants.TILESIZE, gameConstants_1.GameConstants.TILESIZE, gameConstants_1.GameConstants.TILESIZE * 0.75);
                    }
                }
            }
            if (this.projectiles.length > 0)
                for (let p of this.projectiles) {
                    if (p.hasBloom) {
                        p.updateBloom(delta);
                        this.bloomOffscreenCtx.globalAlpha =
                            1 * (1 - this.softVis[p.x][p.y]) * p.softBloomAlpha;
                        this.bloomOffscreenCtx.fillStyle = p.bloomColor;
                        this.bloomOffscreenCtx.fillRect((p.x - this.roomX + offsetX) * gameConstants_1.GameConstants.TILESIZE, (p.y - this.roomY + offsetY) * gameConstants_1.GameConstants.TILESIZE, gameConstants_1.GameConstants.TILESIZE, gameConstants_1.GameConstants.TILESIZE);
                    }
                }
            // Draw the blurred shade layer directly without masking
            if (!gameConstants_1.GameConstants.ctxBlurEnabled)
                this.applyGaussianBlur(this.bloomOffscreenCanvas, 16);
            else
                game_1.Game.ctx.filter = "blur(8px)";
            game_1.Game.ctx.globalCompositeOperation = "screen";
            game_1.Game.ctx.globalAlpha = 1;
            game_1.Game.ctx.drawImage(this.bloomOffscreenCanvas, (this.roomX - offsetX) * gameConstants_1.GameConstants.TILESIZE, (this.roomY - offsetY) * gameConstants_1.GameConstants.TILESIZE);
            this.bloomOffscreenCtx.fillStyle = "rgba(0, 0, 0, 1)";
            this.bloomOffscreenCtx.fillRect(0, 0, this.bloomOffscreenCanvas.width, this.bloomOffscreenCanvas.height);
            game_1.Game.ctx.restore();
        };
        this.drawEntities = (delta, skipLocalPlayer) => {
            if (!this.onScreen)
                return;
            game_1.Game.ctx.save();
            let tiles = [];
            for (let x = this.roomX; x < this.roomX + this.width; x++) {
                for (let y = this.roomY; y < this.roomY + this.height; y++) {
                    this.roomArray[x][y].drawUnderPlayer(delta);
                    tiles.push(this.roomArray[x][y]);
                }
            }
            let drawables = new Array();
            let entities = new Array();
            entities = entities.concat(this.entities, this.deadEntities);
            drawables = drawables.concat(tiles, this.decorations, entities, this.hitwarnings, this.projectiles, this.particles, this.items);
            for (const i in this.game.players) {
                if (this.game.rooms[this.game.players[i].levelID] === this) {
                    if (!(skipLocalPlayer &&
                        this.game.players[i] === this.game.players[this.game.localPlayerID]))
                        drawables.push(this.game.players[i]);
                }
            }
            drawables.sort((a, b) => {
                if (a instanceof floor_1.Floor || a instanceof spawnfloor_1.SpawnFloor) {
                    return -1;
                }
                else if (b instanceof floor_1.Floor || b instanceof spawnfloor_1.SpawnFloor) {
                    return 1;
                }
                else if (a instanceof decoration_1.Decoration) {
                    return -1;
                }
                else if (b instanceof decoration_1.Decoration) {
                    return 1;
                }
                if (Math.abs(a.drawableY - b.drawableY) < 0.1) {
                    if (a instanceof player_1.Player) {
                        return 1;
                    }
                    else if (b instanceof player_1.Player) {
                        return -1;
                    }
                    else if (a instanceof entity_1.Entity) {
                        return 1;
                    }
                    else if (b instanceof entity_1.Entity) {
                        return -1;
                    }
                    else if (a instanceof particle_1.Particle) {
                        return 1;
                    }
                    else if (b instanceof particle_1.Particle) {
                        return -1;
                    }
                    else
                        return 0;
                }
                else {
                    return a.drawableY - b.drawableY;
                }
            });
            for (const d of drawables) {
                d.draw(delta);
            }
            this.drawAbovePlayer(delta);
            for (const i of this.items) {
                i.drawTopLayer(delta);
            }
            game_1.Game.ctx.restore();
        };
        this.drawAbovePlayer = (delta) => {
            for (let x = this.roomX; x < this.roomX + this.width; x++) {
                for (let y = this.roomY; y < this.roomY + this.height; y++) {
                    //if (this.softVis[x][y] < 1) this.roomArray[x][y].drawAbovePlayer(delta);
                }
            }
        };
        this.drawShade = (delta) => {
            if (!this.onScreen)
                return;
            game_1.Game.ctx.save();
            let bestSightRadius = 0;
            for (const p in this.game.players) {
                game_1.Game.ctx.globalCompositeOperation = "source-over"; // "soft-light";
                game_1.Game.ctx.globalAlpha = 1;
                if (this.level.rooms[this.game.players[p].levelID] === this &&
                    this.game.players[p].defaultSightRadius > bestSightRadius) {
                    bestSightRadius = this.game.players[p].defaultSightRadius;
                }
            }
            let shadingAlpha = Math.max(0, Math.min(0.8, 2 / bestSightRadius));
            if (gameConstants_1.GameConstants.ALPHA_ENABLED) {
                game_1.Game.ctx.globalAlpha = 0.25; //this.shadeOpacity();
                //Game.ctx.resetTransform();
                //Game.ctx.fillStyle = "#4a5d23"; // hex dark misty green
                game_1.Game.ctx.fillStyle = this.shadeColor;
                game_1.Game.ctx.fillRect(this.roomX * gameConstants_1.GameConstants.TILESIZE, (this.roomY - 1) * gameConstants_1.GameConstants.TILESIZE, this.width * gameConstants_1.GameConstants.TILESIZE, (this.height + 1) * gameConstants_1.GameConstants.TILESIZE);
                game_1.Game.ctx.globalAlpha = 1;
                game_1.Game.ctx.globalCompositeOperation = "source-over";
            }
            game_1.Game.ctx.restore();
        };
        this.shadeOpacity = () => {
            if (this.active) {
                return 0.25;
            }
            else {
                return 0.25;
            }
        };
        this.drawOverShade = (delta) => {
            game_1.Game.ctx.save();
            for (const e of this.entities) {
                e.drawTopLayer(delta); // health bars
            }
            for (const p of this.projectiles) {
                p.drawTopLayer(delta);
            }
            //Game.ctx.globalCompositeOperation = "overlay";
            for (const h of this.hitwarnings) {
                h.drawTopLayer(delta);
            }
            //Game.ctx.globalCompositeOperation = "source-over";
            for (const s of this.particles) {
                s.drawTopLayer(delta);
            }
            // draw over dithered shading
            for (let x = this.roomX; x < this.roomX + this.width; x++) {
                for (let y = this.roomY; y < this.roomY + this.height; y++) {
                    this.roomArray[x][y].drawAboveShading(delta);
                }
            }
            game_1.Game.ctx.restore();
        };
        // for stuff rendered on top of the player
        this.drawTopLayer = (delta) => {
            game_1.Game.ctx.save();
            // gui stuff
            // room name
            let old = game_1.Game.ctx.font;
            game_1.Game.ctx.font = gameConstants_1.GameConstants.SCRIPT_FONT_SIZE + "px Script";
            game_1.Game.ctx.fillStyle = levelConstants_1.LevelConstants.LEVEL_TEXT_COLOR;
            game_1.Game.fillText(this.message, gameConstants_1.GameConstants.WIDTH / 2 - game_1.Game.measureText(this.name).width / 2, 5);
            game_1.Game.ctx.font = old;
            game_1.Game.ctx.restore();
        };
        // src/room.ts
        this.createWallMask = () => {
            const maskCanvas = document.createElement("canvas");
            this.maskCanvases.push(maskCanvas); // <-- Track the canvas
            maskCanvas.width = this.width * gameConstants_1.GameConstants.TILESIZE;
            maskCanvas.height = this.height * gameConstants_1.GameConstants.TILESIZE;
            const ctx = maskCanvas.getContext("2d");
            if (!ctx) {
                throw new Error("Failed to create mask canvas context.");
            }
            // Fill the canvas with opaque color
            ctx.fillStyle = "rgba(255, 255, 255, 1)";
            ctx.fillRect(this.roomX * gameConstants_1.GameConstants.TILESIZE, this.roomY * gameConstants_1.GameConstants.TILESIZE, maskCanvas.width, maskCanvas.height);
            // Make wall areas transparent
            /*
            for (let x = this.roomX - 1; x < this.roomX + 1 + this.width; x++) {
              for (let y = this.roomY - 1; y < this.roomY + 1 + this.height; y++) {
                const tile = this.getTile(x, y);
                if (tile instanceof Wall) {
                  let offsetY = 0;
                  if (tile.direction === Direction.DOWN) offsetY = 1;
                  ctx.clearRect(
                    (x - this.roomX) * GameConstants.TILESIZE,
                    (y - 1 - this.roomY) * GameConstants.TILESIZE,
                    GameConstants.TILESIZE,
                    GameConstants.TILESIZE,
                  );
                }
              }
            }
              */
            return maskCanvas;
        };
        /**
         * Finds and returns the darkest and lightest tiles in the room based on their visibility.
         * Loops through the roomArray, sums all the vis values, sorts them, and identifies the extremes.
         *
         * @returns An object containing the darkest and lightest tiles with their coordinates and vis values.
         */
        this.getExtremeLuminance = () => {
            const visValues = [];
            // Loop through each tile in the room
            for (let x = this.roomX; x < this.roomX + this.width; x++) {
                for (let y = this.roomY; y < this.roomY + this.height; y++) {
                    if (this.vis[x] && this.vis[x][y] !== undefined) {
                        visValues.push({ x, y, vis: this.vis[x][y] });
                    }
                }
            }
            if (visValues.length === 0) {
                return { darkest: null, lightest: null };
            }
            // Sort the vis values in ascending order
            visValues.sort((a, b) => a.vis - b.vis);
            return {
                darkest: visValues[visValues.length - 1],
                lightest: visValues[0],
            };
        };
        /**
         * Finds and returns the darkest and lightest tiles adjacent to a given point.
         * It checks the tiles above, below, to the left, and to the right of the specified point.
         *
         * @param px - The x-coordinate of the reference point.
         * @param py - The y-coordinate of the reference point.
         * @returns An object containing the darkest and lightest adjacent tiles with their coordinates and vis values,
         *          or null if no valid adjacent tiles are found.
         */
        this.getExtremeLuminanceFromPoint = (px, py) => {
            const adjacentPositions = [
                { x: px, y: py - 1 },
                { x: px, y: py + 1 },
                { x: px - 1, y: py },
                { x: px + 1, y: py }, // Right
            ];
            const visValues = [];
            adjacentPositions.forEach((pos) => {
                const { x, y } = pos;
                if (this.vis[x] && this.vis[x][y] !== undefined) {
                    if (this.roomArray[x] && this.roomArray[x][y]) {
                        if (this.roomArray[x][y] instanceof floor_1.Floor) {
                            visValues.push({ x, y, vis: this.vis[x][y] });
                        }
                    }
                }
            });
            if (visValues.length === 0) {
                return { darkest: null, lightest: null };
            }
            // Sort the vis values in ascending order
            visValues.sort((a, b) => a.vis - b.vis);
            return {
                darkest: visValues[visValues.length - 1],
                lightest: visValues[0],
            };
        };
        this.getAverageLuminance = () => {
            let total = 0;
            let count = 0;
            for (let x = this.roomX - 2; x <= this.roomX + 2; x++) {
                if (this.roomArray[x] && this.roomArray[x][this.roomY]) {
                    for (let y = this.roomY - 2; y <= this.roomY + 2; y++) {
                        if (this.vis[x][y]) {
                            total += this.vis[x][y];
                            count++;
                        }
                    }
                }
            }
            return total / count;
        };
        this.tileInside = (tileX, tileY) => {
            return this.pointInside(tileX, tileY, this.roomX, this.roomY, this.width, this.height);
        };
        this.getEmptyTiles = () => {
            let returnVal = [];
            for (let x = this.roomX + 1; x < this.roomX + this.width - 1; x++) {
                for (let y = this.roomY + 1; y < this.roomY + this.height - 1; y++) {
                    if (!this.roomArray[x][y].isSolid() &&
                        !(this.roomArray[x][y] instanceof spiketrap_1.SpikeTrap) &&
                        !(this.roomArray[x][y] instanceof spawnfloor_1.SpawnFloor) &&
                        !(this.roomArray[x][y] instanceof downLadder_1.DownLadder)) {
                        returnVal.push(this.roomArray[x][y]);
                    }
                }
            }
            for (const e of this.entities) {
                returnVal = returnVal.filter((t) => !e.pointIn(t.x, t.y));
            }
            return returnVal;
        };
        this.getTile = (x, y) => {
            if (this.roomArray[x])
                return this.roomArray[x][y];
            else
                return undefined;
        };
        this.checkForNoEnemies = () => {
            let enemies = this.entities.filter((e) => e instanceof enemy_1.Enemy);
            if (enemies.length === 0 && this.lastEnemyCount > 0) {
                // if (this.doors[0].type === DoorType.GUARDEDDOOR) {
                this.doors.forEach((d) => {
                    if (d.type === door_1.DoorType.GUARDEDDOOR) {
                        d.unGuard();
                        this.game.pushMessage("The foes have been slain and the door allows you passage.");
                    }
                });
            }
        };
        // checks for obstructions between doors and finds paths avoiding obstacles.
        this.removeDoorObstructions = () => {
            let obstacles = [];
            for (const door of this.doors) {
                for (const otherDoor of this.doors) {
                    if (door === otherDoor || door === null || otherDoor === null)
                        break;
                    const pathObstacles = this.findPath(door, otherDoor);
                    if (pathObstacles.length > 0) {
                    }
                    obstacles.push(...pathObstacles);
                }
            }
            if (obstacles.length > 0) {
                for (let obstacle of obstacles) {
                    // console.log(`Removing obstacle at (${obstacle.x},${obstacle.y})`);
                    this.entities = this.entities.filter((e) => e !== obstacle);
                    obstacle = null;
                }
            }
        };
        // avoid blocking doorways with unbreakable entities
        this.findPath = (startTile, targetTile) => {
            let disablePositions = Array();
            let obstacleCandidates = [];
            for (const e of this.entities) {
                if (e instanceof vendingMachine_1.VendingMachine || e instanceof rockResource_1.Rock) {
                    disablePositions.push({ x: e.x, y: e.y });
                    obstacleCandidates.push(e);
                }
            }
            // Create a grid of the room
            let grid = [];
            for (let x = 0; x < this.roomX + this.width; x++) {
                grid[x] = [];
                for (let y = 0; y < this.roomY + this.height; y++) {
                    if (this.roomArray[x] && this.roomArray[x][y])
                        grid[x][y] = this.roomArray[x][y];
                    else
                        grid[x][y] = false;
                }
            }
            let moves = astarclass_1.astar.AStar.search(grid, startTile, targetTile, disablePositions, false, false, false);
            if (moves.length === 0) {
                return obstacleCandidates;
            }
            else {
                return [];
            }
        };
        // #endregion
        /**
         * Adds a door with offset to prevent overlapping doors.
         * If a door already exists at the desired (x, y) position, it offsets the door randomly to either side.
         * Ensures the new door is at least one tile away from the room's edge based on its direction.
         *
         * @param x - The x-coordinate for the door placement.
         * @param y - The y-coordinate for the door placement.
         * @param room - The Room object where the door is being placed. Defaults to the current room.
         * @param tunnelDoor - Whether the door is a tunnel door. Defaults to false.
         * @returns The created Door object or null if placement failed.
         */
        this.addDoorWithOffset = (x, y, room = this, tunnelDoor = false) => {
            // Check if a door already exists at the desired position
            if (room.roomArray[x]?.[y] instanceof door_1.Door) {
                // Determine the direction based on the door's position
                let direction = null;
                if (x === room.roomX) {
                    direction = game_1.Direction.RIGHT;
                }
                else if (x === room.roomX + room.width - 1) {
                    direction = game_1.Direction.LEFT;
                }
                else if (y === room.roomY) {
                    direction = game_1.Direction.DOWN;
                }
                else if (y === room.roomY + room.height - 1) {
                    direction = game_1.Direction.UP;
                }
                if (!direction) {
                    // console.log("Invalid door position.");
                    return null;
                }
                // Define possible offset adjustments based on door direction
                const offsetOptions = [];
                switch (direction) {
                    case game_1.Direction.RIGHT | game_1.Direction.LEFT:
                        // Offsets along the y-axis for vertical walls
                        offsetOptions.push({ dx: 0, dy: 1 }, { dx: 0, dy: -1 });
                        break;
                    case game_1.Direction.UP | game_1.Direction.DOWN:
                        // Offsets along the x-axis for horizontal walls
                        offsetOptions.push({ dx: 1, dy: 0 }, { dx: -1, dy: 0 });
                        break;
                }
                // Shuffle the offset options to randomize placement
                const shuffledOffsets = offsetOptions.sort(() => Math.random() - 0.5);
                for (const offset of shuffledOffsets) {
                    const newX = x + offset.dx;
                    const newY = y + offset.dy;
                    // Ensure the new position is within bounds and not on the edge
                    const isWithinBounds = newX > room.roomX &&
                        newX < room.roomX + room.width - 1 &&
                        newY > room.roomY &&
                        newY < room.roomY + room.height - 1;
                    if (isWithinBounds && !(room.roomArray[newX]?.[newY] instanceof door_1.Door)) {
                        // Offset the door placement
                        return room.addDoor(newX, newY, room, tunnelDoor);
                    }
                }
                return null;
            }
            // If no door exists at the desired position, place it normally
            return room.addDoor(x, y, room, tunnelDoor);
        };
        this.pointExists = (x, y) => {
            return this.roomArray[x] && this.roomArray[x][y];
        };
        this.game = game;
        this.roomX = x; //Math.floor(- this.width / 2);
        this.roomY = y; //Math.floor(- this.height / 2);
        this.width = w;
        this.height = h;
        this.type = type;
        this.depth = depth;
        this.mapGroup = mapGroup;
        this.entered = false;
        this.turn = TurnState.playerTurn;
        this.playerTurnTime = Date.now();
        this.items = Array();
        this.projectiles = Array();
        this.hitwarnings = Array();
        this.particles = Array();
        this.doors = Array();
        this.entities = Array();
        this.lightSources = Array();
        this.innerWalls = Array();
        this.level = level;
        this.id = 0;
        this.currentSpawnerCount = 0;
        this.deadEntities = Array();
        this.active = false;
        this.lastLightingUpdate = 0;
        this.walls = Array();
        this.decorations = Array();
        // Initialize Color Offscreen Canvas
        this.colorOffscreenCanvas = document.createElement("canvas");
        this.colorOffscreenCanvas.width =
            (this.width + 10) * gameConstants_1.GameConstants.TILESIZE;
        this.colorOffscreenCanvas.height =
            (this.height + 10) * gameConstants_1.GameConstants.TILESIZE;
        const colorCtx = this.colorOffscreenCanvas.getContext("2d");
        if (!colorCtx) {
            throw new Error("Failed to initialize color offscreen canvas context.");
        }
        this.colorOffscreenCtx = colorCtx;
        // Initialize Shade Offscreen Canvas
        this.shadeOffscreenCanvas = document.createElement("canvas");
        this.shadeOffscreenCanvas.width =
            (this.width + 10) * gameConstants_1.GameConstants.TILESIZE;
        this.shadeOffscreenCanvas.height =
            (this.height + 10) * gameConstants_1.GameConstants.TILESIZE;
        const shadeCtx = this.shadeOffscreenCanvas.getContext("2d");
        if (!shadeCtx) {
            throw new Error("Failed to initialize shade offscreen canvas context.");
        }
        this.shadeOffscreenCtx = shadeCtx;
        // Initialize Bloom Offscreen Canvas
        this.bloomOffscreenCanvas = document.createElement("canvas");
        this.bloomOffscreenCanvas.width =
            (this.width + 10) * gameConstants_1.GameConstants.TILESIZE;
        this.bloomOffscreenCanvas.height =
            (this.height + 10) * gameConstants_1.GameConstants.TILESIZE;
        const bloomCtx = this.bloomOffscreenCanvas.getContext("2d");
        if (!bloomCtx) {
            throw new Error("Failed to initialize bloom offscreen canvas context.");
        }
        this.bloomOffscreenCtx = bloomCtx;
        // #region initialize arrays
        //initialize room array
        this.roomArray = [];
        for (let x = this.roomX - 1; x < this.roomX + this.width + 1; x++) {
            this.roomArray[x] = [];
            for (let y = this.roomY - 1; y < this.roomY + this.height + 1; y++) {
                this.roomArray[x][y] = null;
            }
        }
        //initialize visibility & color arrays, as well as their soft variants
        this.vis = [];
        this.softVis = [];
        this.col = [];
        this.softCol = [];
        for (let x = this.roomX; x < this.roomX + this.width; x++) {
            this.vis[x] = [];
            this.softVis[x] = [];
            this.col[x] = [];
            this.softCol[x] = [];
            for (let y = this.roomY; y < this.roomY + this.height; y++) {
                this.vis[x][y] = 1;
                this.softVis[x][y] = 1;
                this.col[x][y] = [0, 0, 0];
                this.softCol[x][y] = [0, 0, 0];
            }
        }
        //initialize the render buffer array
        this.renderBuffer = [];
        for (let x = this.roomX; x < this.roomX + this.width; x++) {
            this.renderBuffer[x] = [];
            for (let y = this.roomY; y < this.roomY + this.height; y++) {
                this.renderBuffer[x][y] = [];
            }
        }
        //initialize the skin for the given environment
        this.skin = this.level.environment.skin;
        if (this.type === RoomType.ROPECAVE || this.type === RoomType.CAVE) {
            this.skin = tile_1.SkinType.CAVE;
        }
        this.builder = new roomBuilder_1.RoomBuilder(this);
        // #endregion
    }
    addTorches(numTorches, rand, placeX, placeY) {
        if (this.level.environment.type === environment_1.EnvType.FOREST &&
            this.type !== RoomType.DOWNLADDER)
            return;
        if (placeX !== undefined &&
            placeY !== undefined &&
            this.roomArray[placeX]?.[placeY] instanceof wall_1.Wall) {
            this.roomArray[placeX][placeY] = new wallTorch_1.WallTorch(this, placeX, placeY);
            return;
        }
        let walls = [];
        for (let xx = this.roomX + 1; xx < this.roomX + this.width - 2; xx++) {
            for (let yy = this.roomY; yy < this.roomY + this.height - 1; yy++) {
                if (this.roomArray[xx][yy] instanceof wall_1.Wall &&
                    !(this.roomArray[xx][yy + 1] instanceof wall_1.Wall)) {
                    walls.push(this.roomArray[xx][yy]);
                }
            }
        }
        for (let i = 0; i < numTorches; i++) {
            if (walls.length == 0)
                return;
            const randomIndex = game_1.Game.rand(0, walls.length - 1, rand);
            const t = walls.splice(randomIndex, 1)[0];
            const x = t.x;
            const y = t.y;
            this.roomArray[x][y] = new wallTorch_1.WallTorch(this, x, y);
        }
    }
    addChasms(rand) {
        // add chasms
        let w = game_1.Game.rand(2, 4, rand);
        let h = game_1.Game.rand(2, 4, rand);
        let xmin = this.roomX + 2;
        let xmax = this.roomX + this.width - w - 2;
        let ymin = this.roomY + 2;
        let ymax = this.roomY + this.height - h - 2;
        if (xmax < xmin || ymax < ymin)
            return;
        let x = game_1.Game.rand(xmin, xmax, rand);
        let y = game_1.Game.rand(ymin, ymax, rand);
        for (let xx = x - 1; xx < x + w + 1; xx++) {
            for (let yy = y - 1; yy < y + h + 1; yy++) {
                // add a floor border
                if (xx === x - 1 || xx === x + w || yy === y - 1 || yy === y + h) {
                    if (!(this.roomArray[xx][yy] instanceof spawnfloor_1.SpawnFloor))
                        this.roomArray[xx][yy] = new floor_1.Floor(this, xx, yy);
                }
                else
                    this.roomArray[xx][yy] = new chasm_1.Chasm(this, xx, yy, xx === x, xx === x + w - 1, yy === y, yy === y + h - 1);
            }
        }
    }
    // ... start of file ...
    addSpikeTraps(numSpikes, rand) {
        if (this.level.environment.type === environment_1.EnvType.FOREST)
            return;
        // add spikes
        let tiles = this.getEmptyTiles();
        for (let i = 0; i < numSpikes; i++) {
            const { x, y } = this.getRandomEmptyPosition(tiles);
            this.roomArray[x][y] = new spiketrap_1.SpikeTrap(this, x, y);
        }
    }
    // #endregion
    // #region ADDING ENTITIES
    // Function to add enemies to the room
    addEnemies(numEnemies, rand) {
        // Get all empty tiles in the room
        let tiles = this.getEmptyTiles();
        if (tiles === null)
            return;
        //don't put enemies near the entrances so you don't get screwed instantly
        // Create a Set to store coordinates that should be excluded
        const excludedCoords = new Set();
        // For each door, add coordinates in a 5x5 area around it to excluded set
        for (const door of this.doors) {
            for (let dx = -2; dx <= 2; dx++) {
                for (let dy = -2; dy <= 2; dy++) {
                    excludedCoords.add(`${door.x + dx},${door.y + dy}`);
                }
            }
        }
        // Filter tiles that aren't in the excluded set
        tiles = tiles.filter((tile) => !excludedCoords.has(`${tile.x},${tile.y}`));
        // Loop through the number of enemies to be added
        for (let i = 0; i < numEnemies; i++) {
            let rerolls = 1;
            if (tiles.length === 0) {
                console.log(`No tiles left to spawn enemies`);
                break;
            }
            let emptyTiles = this.getRandomEmptyPosition(tiles);
            if (emptyTiles.x === null || emptyTiles.y === null) {
                i = numEnemies;
                break;
            }
            const { x, y } = emptyTiles;
            // Define the enemy tables for each depth level
            let tables = this.level.enemyParameters.enemyTables;
            // Define the maximum depth level
            let max_depth_table = this.level.enemyParameters.maxDepthTable;
            // Get the current depth level, capped at the maximum
            let d = Math.min(this.depth, max_depth_table);
            // If there is a table for the current depth level
            if (tables[d] && tables[d].length > 0) {
                // Function to add an enemy to the room
                let addEnemy = (enemy) => {
                    // Check if the enemy overlaps with any other enemies
                    for (let xx = 0; xx < enemy.w; xx++) {
                        for (let yy = 0; yy < enemy.h; yy++) {
                            if (!tiles.some((tt) => tt.x === x + xx && tt.y === y + yy)) {
                                // If it does, increment the enemy count and return false
                                numEnemies++;
                                return false;
                            }
                        }
                    }
                    // If it doesn't, add the enemy to the room, remove the tiles used from the available pool, and return true
                    this.entities.push(enemy);
                    for (let xx = 0; xx < enemy.w; xx++) {
                        for (let yy = 0; yy < enemy.h; yy++) {
                            tiles = tiles.filter((t) => !(t.x === x + xx && t.y === y + yy));
                        }
                    }
                    return true;
                };
                // Randomly select an enemy type from the table
                let type = game_1.Game.randTable(tables[d], Math.random);
                switch (type) {
                    case 1:
                        crabEnemy_1.CrabEnemy.add(this, this.game, x, y);
                        break;
                    case 2:
                        frogEnemy_1.FrogEnemy.add(this, this.game, x, y);
                        break;
                    case 3:
                        zombieEnemy_1.ZombieEnemy.add(this, this.game, x, y);
                        break;
                    case 4:
                        skullEnemy_1.SkullEnemy.add(this, this.game, x, y);
                        break;
                    case 5:
                        energyWizard_1.EnergyWizardEnemy.add(this, this.game, x, y);
                        break;
                    case 6:
                        chargeEnemy_1.ChargeEnemy.add(this, this.game, x, y);
                        break;
                    case 7:
                        rookEnemy_1.RookEnemy.add(this, this.game, x, y);
                        break;
                    case 8:
                        bishopEnemy_1.BishopEnemy.add(this, this.game, x, y);
                        break;
                    case 9:
                        armoredzombieEnemy_1.ArmoredzombieEnemy.add(this, this.game, x, y);
                        break;
                    case 10:
                        if (addEnemy(new bigSkullEnemy_1.BigSkullEnemy(this, this.game, x, y))) {
                            // clear out some space
                            for (let xx = 0; xx < 2; xx++) {
                                for (let yy = 0; yy < 2; yy++) {
                                    this.roomArray[x + xx][y + yy] = new floor_1.Floor(this, x + xx, y + yy); // remove any walls
                                }
                            }
                        }
                        break;
                    case 11:
                        queenEnemy_1.QueenEnemy.add(this, this.game, x, y);
                        break;
                    case 12:
                        knightEnemy_1.KnightEnemy.add(this, this.game, x, y);
                        break;
                    case 13:
                        if (addEnemy(new bigKnightEnemy_1.BigKnightEnemy(this, this.game, x, y))) {
                            // clear out some space
                            for (let xx = 0; xx < 2; xx++) {
                                for (let yy = 0; yy < 2; yy++) {
                                    this.roomArray[x + xx][y + yy] = new floor_1.Floor(this, x + xx, y + yy); // remove any walls
                                }
                            }
                        }
                        break;
                    case 14:
                        armoredSkullEnemy_1.ArmoredSkullEnemy.add(this, this.game, x, y);
                        break;
                    case 15:
                        fireWizard_1.FireWizardEnemy.add(this, this.game, x, y);
                        break;
                }
            }
        }
        let spawnerAmounts = [
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2,
            2, 2, 3, 3, 4, 5, 3,
        ];
        if (this.depth > 0) {
            let spawnerAmount = game_1.Game.randTable(spawnerAmounts, rand);
            //console.log(`Adding ${spawnerAmount} spawners`);
            this.addSpawners(spawnerAmount, rand);
        }
        let occultistAmounts = [
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1,
        ];
        if (this.depth > 1) {
            let occultistAmount = game_1.Game.randTable(occultistAmounts, rand);
            //console.log(`Adding ${occultistAmount} occultists`);
            this.addOccultists(occultistAmount, rand);
        }
    }
    addRandomEnemies() {
        let numEmptyTiles = this.getEmptyTiles().length;
        let numEnemies = Math.ceil(numEmptyTiles * Math.min(this.depth * 0.1 + 0.5, 0.15));
        if (numEnemies > numEmptyTiles / 2)
            numEnemies = numEmptyTiles / 2;
        this.addEnemies(numEnemies, Math.random);
    }
    addSpawners(numSpawners, rand) {
        let tiles = this.getEmptyTiles();
        if (tiles === null) {
            //console.log(`No tiles left to spawn spawners`);
            return;
        }
        for (let i = 0; i < numSpawners; i++) {
            const { x, y } = this.getRandomEmptyPosition(tiles);
            let spawnTable = this.level
                .getEnemyParameters()
                .enemyTables[this.depth].filter((t) => t !== 7);
            spawner_1.Spawner.add(this, this.game, x, y, spawnTable);
        }
    }
    addOccultists(numOccultists, rand) {
        let tiles = this.getEmptyTiles();
        if (tiles === null) {
            //console.log(`No tiles left to spawn spawners`);
            return;
        }
        for (let i = 0; i < numOccultists; i++) {
            const { x, y } = this.getRandomEmptyPosition(tiles);
            occultistEnemy_1.OccultistEnemy.add(this, this.game, x, y);
        }
    }
    addChests(numChests, rand) {
        // add chests
        let tiles = this.getEmptyTiles();
        for (let i = 0; i < numChests; i++) {
            const { x, y } = this.getRandomEmptyPosition(tiles);
            this.entities.push(new chest_1.Chest(this, this.game, x, y));
        }
    }
    addObstacles(numObstacles, rand) {
        // add crates/barrels
        let tiles = this.getEmptyTiles();
        for (let i = 0; i < numObstacles; i++) {
            const { x, y } = this.getRandomEmptyPosition(tiles);
            const env = this.level.environment.type; //bootleg variable to start to vary the environments
            switch (game_1.Game.randTable([
                1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 5, 5, 5,
                6, 6, 6, 6, 6, 6, 6,
            ], rand)) {
                case 1:
                    if (env === environment_1.EnvType.FOREST)
                        break;
                    crate_1.Crate.add(this, this.game, x, y);
                    break;
                case 2:
                    if (env === environment_1.EnvType.FOREST)
                        break;
                    barrel_1.Barrel.add(this, this.game, x, y);
                    break;
                case 3:
                    if (env === environment_1.EnvType.CAVE)
                        break;
                    tombStone_1.TombStone.add(this, this.game, x, y, 1);
                    break;
                case 4:
                    if (env === environment_1.EnvType.CAVE)
                        break;
                    tombStone_1.TombStone.add(this, this.game, x, y, 0);
                    break;
                case 5:
                    if (env === environment_1.EnvType.CAVE)
                        break;
                    pumpkin_1.Pumpkin.add(this, this.game, x, y);
                    break;
                case 6:
                    block_1.Block.add(this, this.game, x, y);
                    break;
            }
        }
    }
    addBombs(numBombs, rand) {
        let tiles = this.getEmptyTiles();
        for (let i = 0; i < this.getEmptyTiles().length; i++) {
            const { x, y } = this.getRandomEmptyPosition(tiles);
            bomb_1.Bomb.add(this, this.game, x, y);
        }
    }
    addPlants(numPlants, rand) {
        let tiles = this.getEmptyTiles();
        for (let i = 0; i < numPlants; i++) {
            const { x, y } = this.getRandomEmptyPosition(tiles);
            let r = rand();
            if (r <= 0.45)
                pottedPlant_1.PottedPlant.add(this, this.game, x, y);
            else if (r <= 0.65)
                pot_1.Pot.add(this, this.game, x, y);
            else if (r <= 0.75)
                rockResource_1.Rock.add(this, this.game, x, y);
            else if (r <= 0.97)
                mushrooms_1.Mushrooms.add(this, this.game, x, y);
            else
                chest_1.Chest.add(this, this.game, x, y);
        }
    }
    addDecorations(numDecorations, rand) {
        let tiles = this.getEmptyTiles();
        for (let i = 0; i < numDecorations; i++) {
            const { x, y } = this.getRandomEmptyPosition(tiles);
            this.decorations.push(new puddle_1.Puddle(this, x, y));
        }
    }
    addResources(numResources, rand) {
        let tiles = this.getEmptyTiles();
        for (let i = 0; i < numResources; i++) {
            const { x, y } = this.getRandomEmptyPosition(tiles);
            let r = rand();
            if (r <= (10 - this.depth ** 3) / 10)
                coalResource_1.CoalResource.add(this, this.game, x, y);
            else if (r <= (10 - (this.depth - 2) ** 3) / 10)
                goldResource_1.GoldResource.add(this, this.game, x, y);
            else
                emeraldResource_1.EmeraldResource.add(this, this.game, x, y);
        }
    }
    addVendingMachine(rand, placeX, placeY) {
        const pos = this.getRandomEmptyPosition(this.getEmptyTiles());
        let x = placeX ? placeX : pos.x;
        let y = placeY ? placeY : pos.y;
        let table = this.depth > 0
            ? [1, 1, 1, 1, 1, 1, 1, 2, 3, 4, 5, 6, 7, 8, 9]
            : [1, 1, 1];
        let type = game_1.Game.randTable(table, rand);
        switch (type) {
            case 1:
                vendingMachine_1.VendingMachine.add(this, this.game, x, y, new heart_1.Heart(this, x, y));
                break;
            case 2:
                vendingMachine_1.VendingMachine.add(this, this.game, x, y, new lantern_1.Lantern(this, x, y));
                break;
            case 3:
                vendingMachine_1.VendingMachine.add(this, this.game, x, y, new armor_1.Armor(this, x, y));
                break;
            case 4:
                vendingMachine_1.VendingMachine.add(this, this.game, x, y, new dualdagger_1.DualDagger(this, x, y));
                break;
            case 5:
                vendingMachine_1.VendingMachine.add(this, this.game, x, y, new spear_1.Spear(this, x, y));
                break;
            case 6:
                vendingMachine_1.VendingMachine.add(this, this.game, x, y, new shotgun_1.Shotgun(this, x, y));
                break;
            case 7:
                vendingMachine_1.VendingMachine.add(this, this.game, x, y, new warhammer_1.Warhammer(this, x, y));
                break;
            case 8:
                vendingMachine_1.VendingMachine.add(this, this.game, x, y, new spellbook_1.Spellbook(this, x, y));
                break;
            case 9:
                vendingMachine_1.VendingMachine.add(this, this.game, x, y, new torch_1.Torch(this, x, y));
                break;
        }
    }
    // Many populate methods start with adding torches using the same pattern
    addRandomTorches(intensity = "medium") {
        const torchPatterns = {
            none: [0, 0, 0],
            low: [0, 0, 0, 1, 1],
            medium: [0, 0, 0, 1, 1, 2, 2, 3],
            high: [1, 1, 2, 2, 3, 3, 4],
        };
        const randTorches = game_1.Game.randTable(torchPatterns[intensity], random_1.Random.rand);
        this.addTorches(randTorches, random_1.Random.rand);
    }
    // Used in populateDungeon, populateCave, etc. NOT IN USE
    populateWithEntities(config) {
        const numEmptyTiles = this.getEmptyTiles().length;
        const numEnemies = Math.ceil(numEmptyTiles * config.enemyDensity);
        const numObstacles = Math.ceil(numEmptyTiles * config.obstacleDensity);
        const numPlants = Math.ceil(numEmptyTiles * config.plantDensity);
        this.addEnemies(numEnemies, random_1.Random.rand);
        this.addObstacles(numObstacles, random_1.Random.rand);
        this.addPlants(numPlants, random_1.Random.rand);
    }
    /**
     * Applies Gaussian blur to the specified offscreen canvas.
     *
     * @param {HTMLCanvasElement} canvas - The offscreen canvas to blur.
     * @param {number} radius - The radius of the blur.
     */
    applyGaussianBlur(canvas, radius) {
        const StackBlur = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module 'stackblur-canvas'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
        const ctx = canvas.getContext("2d");
        if (!ctx) {
            throw new Error("Failed to get canvas context for Gaussian blur.");
        }
        // Get the image data from the canvas
        const width = canvas.width;
        const height = canvas.height;
        //const imageData = ctx.getImageData(0, 0, width, height);
        let r = radius;
        if (!gameConstants_1.GameConstants.BLUR_ENABLED)
            r = 0;
        // Apply StackBlur
        StackBlur.canvasRGBA(canvas, 0, 0, width, height, Math.floor(r / 2));
    }
    //calculate wall info for proper wall rendering
    calculateWallInfo() {
        this.wallInfo.clear();
        for (let x = this.roomX; x < this.roomX + this.width; x++) {
            for (let y = this.roomY; y < this.roomY + this.height; y++) {
                const tile = this.getTile(x, y);
                if (tile instanceof wall_1.Wall || tile instanceof wallTorch_1.WallTorch) {
                    this.walls.push(tile);
                    const isTopWall = y === this.roomY;
                    const isBottomWall = y === this.roomY + this.height - 1;
                    const isLeftWall = x === this.roomX;
                    const isRightWall = x === this.roomX + this.width - 1;
                    const isInnerWall = !isTopWall && !isBottomWall && !isLeftWall && !isRightWall;
                    const isBelowDoorWall = y < this.roomY + this.height - 1 && this.getTile(x, y + 1)?.isDoor;
                    const isAboveDoorWall = y < this.roomY + this.height - 1 && this.getTile(x, y - 1)?.isDoor;
                    const isDoorWall = y < this.roomY + this.height && this.getTile(x, y + 1)?.isDoor;
                    let innerWallType = null;
                    if (isInnerWall) {
                        const hasWallAbove = this.getTile(x, y - 1) instanceof wall_1.Wall;
                        const hasWallBelow = this.getTile(x, y + 1) instanceof wall_1.Wall;
                        if (!hasWallAbove && hasWallBelow) {
                            innerWallType = "topInner";
                        }
                        else if (hasWallAbove && !hasWallBelow) {
                            innerWallType = "bottomInner";
                        }
                        else if (hasWallAbove && hasWallBelow) {
                            innerWallType = "surroundedInner";
                        }
                        else {
                            innerWallType = "isolatedInner";
                        }
                    }
                    this.wallInfo.set(`${x},${y}`, {
                        isTopWall,
                        isBottomWall,
                        isLeftWall,
                        isRightWall,
                        isInnerWall,
                        isBelowDoorWall,
                        isDoorWall,
                        innerWallType,
                        isAboveDoorWall,
                        shouldDrawBottom: isDoorWall ||
                            isBelowDoorWall ||
                            (isTopWall && !isLeftWall && !isRightWall) ||
                            isInnerWall,
                    });
                }
            }
        }
    }
    // #endregion
    // #region UTILITIES
    pointInside(x, y, rX, rY, rW, rH) {
        if (x < rX || x >= rX + rW)
            return false;
        if (y < rY || y >= rY + rH)
            return false;
        return true;
    }
    // This pattern appears in multiple methods like addVendingMachine, addChests, addSpikes, etc.
    getRandomEmptyPosition(tiles) {
        if (tiles.length === 0)
            return null;
        const tile = tiles.splice(game_1.Game.rand(0, tiles.length - 1, random_1.Random.rand), 1)[0];
        return { x: tile.x, y: tile.y };
    }
    // Used in populateUpLadder, populateDownLadder, populateRopeHole, populateRopeCave
    getRoomCenter() {
        return {
            x: Math.floor(this.roomX + this.width / 2),
            y: Math.floor(this.roomY + this.height / 2),
        };
    }
    // Used in multiple methods including castShadowsAtAngle
    isPositionInRoom(x, y) {
        return !(Math.floor(x) < this.roomX ||
            Math.floor(x) >= this.roomX + this.width ||
            Math.floor(y) < this.roomY ||
            Math.floor(y) >= this.roomY + this.height);
    }
    pathIsBlockedBy(tile, otherTile) {
        const entities = [];
        if (tile.isSolid())
            entities.push(tile);
        if (otherTile.isSolid())
            entities.push(otherTile);
        return entities;
    }
    // #endregion
    // #region MISC
    /**
     * Adds a new BeamEffect to the room.
     *
     * @param x1 - Starting tile X coordinate.
     * @param y1 - Starting tile Y coordinate.
     * @param x2 - Ending tile X coordinate.
     * @param y2 - Ending tile Y coordinate.
     */
    addBeamEffect(x1, y1, x2, y2, parent) {
        const beam = new beamEffect_1.BeamEffect(x1, y1, x2, y2, parent);
        this.beamEffects.push(beam);
    }
    async changeReverb(newImpulsePath) {
        await reverb_1.ReverbEngine.setReverbImpulse(newImpulsePath);
    }
    get roomArea() {
        let area = (this.width - 2) * (this.height - 2);
        let openTiles = [];
        for (let x = this.roomX + 1; x < this.roomX + this.width - 1; x++) {
            for (let y = this.roomY + 1; y < this.roomY + this.height - 1; y++) {
                if (this.roomArray[x][y] instanceof floor_1.Floor)
                    openTiles.push({ x, y });
            }
        }
        //console.log(area, openTiles.length);
        return openTiles.length;
    }
    /**
     * Determines if the room is currently on screen.
     * Uses a buffer of 2 tiles beyond the room's dimensions to account for partial visibility.
     *
     * @returns {boolean} - True if the room is on screen, otherwise false.
     */
    roomOnScreen(player) {
        const tileSize = gameConstants_1.GameConstants.TILESIZE;
        // Calculate room boundaries with a buffer of 2 tiles
        const roomLeft = (this.roomX - 2) * tileSize;
        const roomRight = (this.roomX + this.width + 2) * tileSize;
        const roomTop = (this.roomY - 2) * tileSize;
        const roomBottom = (this.roomY + this.height + 2) * tileSize;
        // Convert player position from tiles to pixels
        const playerPosX = player.x * tileSize;
        const playerPosY = player.y * tileSize;
        // Calculate camera position in pixels
        const cameraX = playerPosX -
            player.drawX +
            0.5 * tileSize -
            0.5 * gameConstants_1.GameConstants.WIDTH -
            this.game.screenShakeX; // X-coordinate of the camera's top-left corner
        const cameraY = playerPosY -
            player.drawY +
            0.5 * tileSize -
            0.5 * gameConstants_1.GameConstants.HEIGHT - // Corrected from WIDTH to HEIGHT
            this.game.screenShakeY; // Y-coordinate of the camera's top-left corner
        const cameraWidth = gameConstants_1.GameConstants.WIDTH; // Corrected from innerWidth
        const cameraHeight = gameConstants_1.GameConstants.HEIGHT; // Corrected from innerHeight
        // Define the camera's boundaries
        const cameraLeft = cameraX;
        const cameraRight = cameraX + cameraWidth;
        const cameraTop = cameraY;
        const cameraBottom = cameraY + cameraHeight;
        // Check if the room's boundaries overlap with the camera's view
        const isOverlapping = !(roomRight < cameraLeft ||
            roomLeft > cameraRight ||
            roomBottom < cameraTop ||
            roomTop > cameraBottom);
        this.onScreen = isOverlapping;
    }
    setReverb() {
        const roomArea = this.roomArea;
        if (roomArea < 10) {
            this.changeReverb(`res/SFX/impulses/small.mp3`);
        }
        else if (roomArea < 55) {
            this.changeReverb(`res/SFX/impulses/medium.mp3`);
        }
        else {
            this.changeReverb(`res/SFX/impulses/large.mp3`);
        }
    }
    /**
     * Finds all wall tiles that do not have a door in them or adjacent to them.
     * @returns An array of wall tiles without doors or adjacent doors.
     */
    getEmptyWall() {
        const emptyWalls = [];
        for (let x = this.roomX + 1; x < this.roomX + this.width - 1; x++) {
            for (let y = this.roomY - 1; y < this.roomY + this.height - 1; y++) {
                const tile = this.roomArray[x][y];
                if (tile instanceof wall_1.Wall || tile instanceof wallTorch_1.WallTorch) {
                    // Check if the current wall tile is not a door
                    if (!(tile instanceof door_1.Door)) {
                        // Check adjacent tiles for doors
                        const adjacentTiles = [
                            this.roomArray[x + 1]?.[y],
                            this.roomArray[x - 1]?.[y],
                            this.roomArray[x]?.[y + 1],
                            this.roomArray[x]?.[y - 1],
                        ];
                        const hasAdjacentDoor = adjacentTiles.some((adjTile) => adjTile instanceof door_1.Door);
                        if (!hasAdjacentDoor) {
                            emptyWalls.push(tile);
                        }
                    }
                }
            }
        }
        return emptyWalls;
    }
    /**
     * Removes a specified empty wall from the room.
     * @param wall - The wall tile to remove.
     * @returns An object containing the x and y coordinates of the removed wall.
     */
    removeEmptyWall(wall) {
        if (!(wall instanceof wall_1.Wall))
            return null;
        const { x, y } = wall;
        // Replace the wall with a Floor tile to maintain room integrity
        this.roomArray[x][y] = new floor_1.Floor(this, x, y);
        // Remove from innerWalls or outerWalls if applicable
        const initialInnerWallsCount = this.innerWalls.length;
        this.innerWalls = this.innerWalls.filter((w) => w !== wall);
        const finalInnerWallsCount = this.innerWalls.length;
        return { x, y };
    }
    /**
     * Places a VendingMachine in an empty wall.
     */
    placeVendingMachineInWall() {
        const emptyWalls = this.getEmptyWall();
        if (emptyWalls.length === 0)
            return;
        // Select a random empty wall
        const selectedWall = game_1.Game.randTable(emptyWalls, random_1.Random.rand);
        if (!selectedWall)
            return;
        // Remove the selected wall
        const removedWallInfo = this.removeEmptyWall(selectedWall);
        if (!removedWallInfo)
            return;
        const { x, y } = removedWallInfo;
        // Create and add the VendingMachine
        this.addVendingMachine(random_1.Random.rand, x, y);
    }
}
exports.Room = Room;


/***/ }),

/***/ "./src/room/roomBuilder.ts":
/*!*********************************!*\
  !*** ./src/room/roomBuilder.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RoomBuilder = void 0;
const game_1 = __webpack_require__(/*! ../game */ "./src/game.ts");
const floor_1 = __webpack_require__(/*! ../tile/floor */ "./src/tile/floor.ts");
const wall_1 = __webpack_require__(/*! ../tile/wall */ "./src/tile/wall.ts");
const room_1 = __webpack_require__(/*! ./room */ "./src/room/room.ts");
class RoomBuilder {
    constructor(room) {
        this.getWallType = (pointX, pointY, rectX, rectY, width, height) => {
            let directions = [];
            if (pointY === rectY && pointX >= rectX && pointX <= rectX + width)
                directions.push(room_1.WallDirection.NORTH);
            if (pointY === rectY + height && pointX >= rectX && pointX <= rectX + width)
                directions.push(room_1.WallDirection.SOUTH);
            if (pointX === rectX && pointY >= rectY && pointY <= rectY + height)
                directions.push(room_1.WallDirection.WEST);
            if (pointX === rectX + width && pointY >= rectY && pointY <= rectY + height)
                directions.push(room_1.WallDirection.EAST);
            return directions;
        };
        this.room = room;
        this.buildEmptyRoom();
    }
    buildEmptyRoom() {
        // fill in wall and floor
        for (let x = this.room.roomX; x < this.room.roomX + this.room.width; x++) {
            for (let y = this.room.roomY; y < this.room.roomY + this.room.height; y++) {
                if (this.room.pointInside(x, y, this.room.roomX + 1, this.room.roomY + 1, this.room.width - 2, this.room.height - 2)) {
                    this.room.roomArray[x][y] = new floor_1.Floor(this.room, x, y);
                }
                else {
                    this.room.roomArray[x][y] = new wall_1.Wall(this.room, x, y, this.getWallType(x, y, this.room.roomX, this.room.roomY, this.room.width, this.room.height));
                }
            }
        }
    }
    addWallBlocks(rand) {
        let numBlocks = game_1.Game.randTable([0, 0, 1, 1, 2, 2, 2, 2, 3], rand);
        if (this.room.width > 8 && rand() > 0.5)
            numBlocks *= 4;
        for (let i = 0; i < numBlocks; i++) {
            let blockW = Math.min(game_1.Game.randTable([2, 2, 2, 2, 2, 2, 3, 3, 3, 4, 5], rand), this.room.width - 4);
            let blockH = Math.min(blockW + game_1.Game.rand(-2, 2, rand), this.room.height - 4);
            let x = game_1.Game.rand(this.room.roomX + 2, this.room.roomX + this.room.width - blockW - 2, rand);
            let y = game_1.Game.rand(this.room.roomY + 2, this.room.roomY + this.room.height - blockH - 2, rand);
            let neighborCount = (wall) => {
                let count = 0;
                for (let xx = wall.x - 1; xx <= wall.x + 1; xx++) {
                    for (let yy = wall.y - 1; yy <= wall.y + 1; yy++) {
                        if (this.room.roomArray[xx]?.[yy] instanceof wall_1.Wall &&
                            !(xx === wall.x && yy === wall.y))
                            count++;
                    }
                }
                return count;
            };
            for (let xx = x; xx < x + blockW; xx++) {
                for (let yy = y; yy < y + blockH; yy++) {
                    let w = new wall_1.Wall(this.room, xx, yy);
                    this.room.roomArray[xx][yy] = w;
                    this.room.innerWalls.push(w);
                }
            }
            this.room.innerWalls.forEach((wall) => {
                if (neighborCount(wall) <= 1) {
                    this.room.removeWall(wall.x, wall.y);
                    this.room.roomArray[wall.x][wall.y] = new floor_1.Floor(this.room, wall.x, wall.y);
                    this.room.innerWalls = this.room.innerWalls.filter((w) => w !== wall);
                }
            });
        }
    }
}
exports.RoomBuilder = RoomBuilder;


/***/ }),

/***/ "./src/sound.ts":
/*!**********************!*\
  !*** ./src/sound.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Sound = void 0;
const game_1 = __webpack_require__(/*! ./game */ "./src/game.ts");
const reverb_1 = __webpack_require__(/*! ./reverb */ "./src/reverb.ts");
class Sound {
    static playSoundSafely(audio) {
        audio.play().catch((err) => {
            if (err.name === "NotAllowedError") {
                console.warn("Audio playback requires user interaction first");
            }
            else {
                console.error("Error playing sound:", err);
            }
        });
    }
    static async playWithReverb(audio) {
        await reverb_1.ReverbEngine.initialize();
        reverb_1.ReverbEngine.applyReverb(audio);
        this.playSoundSafely(audio);
    }
    static stopSound(audio) {
        audio.pause();
        audio.currentTime = 0;
    }
    static stopSoundWithReverb(audio) {
        reverb_1.ReverbEngine.removeReverb(audio);
        this.stopSound(audio);
    }
}
exports.Sound = Sound;
_a = Sound;
Sound.initialized = false;
Sound.audioMuted = true;
Sound.loopHandlers = new Map();
Sound.loadSounds = async () => {
    if (Sound.initialized)
        return;
    Sound.initialized = true;
    if (reverb_1.ReverbEngine.initialized)
        Sound.audioMuted = false;
    Sound.playerStoneFootsteps = new Array();
    [1, 2, 3].forEach((i) => Sound.playerStoneFootsteps.push(new Audio("res/SFX/footsteps/stone/footstep" + i + ".mp3")));
    for (let f of Sound.playerStoneFootsteps)
        f.volume = 1.0;
    Sound.enemyFootsteps = new Array();
    [1, 2, 3, 4, 5].forEach((i) => Sound.enemyFootsteps.push(new Audio("res/SFX/footsteps/enemy/enemyfootstep" + i + ".mp3")));
    for (let f of Sound.enemyFootsteps)
        f.volume = 1.0;
    Sound.swingSounds = new Array();
    [1, 2, 3, 4].forEach((i) => Sound.swingSounds.push(new Audio("res/SFX/attacks/swing" + i + ".mp3")));
    for (let f of Sound.swingSounds) {
        (f.volume = 0.5), f.load;
        //f.play();
    }
    Sound.hitSounds = new Array();
    [1, 2].forEach((i) => Sound.hitSounds.push(new Audio("res/SFX/attacks/hurt" + i + ".mp3")));
    for (let f of Sound.hitSounds) {
        (f.volume = 0.5), f.load;
        //f.play();
    }
    Sound.enemySpawnSound = new Audio("res/SFX/attacks/enemyspawn.mp3");
    Sound.enemySpawnSound.volume = 0.7;
    Sound.chestSounds = new Array();
    [1, 2, 3].forEach((i) => Sound.chestSounds.push(new Audio("res/SFX/chest/chest" + i + ".mp3")));
    for (let f of Sound.chestSounds)
        f.volume = 0.5;
    Sound.coinPickupSounds = new Array();
    [1, 2, 3, 4].forEach((i) => Sound.coinPickupSounds.push(new Audio("res/SFX/items/coins" + i + ".mp3")));
    for (let f of Sound.coinPickupSounds)
        f.volume = 1.0;
    Sound.miningSounds = new Array();
    [1, 2, 3, 4].forEach((i) => Sound.miningSounds.push(new Audio("res/SFX/resources/Pickaxe" + i + ".mp3")));
    for (let f of Sound.miningSounds)
        f.volume = 0.3;
    Sound.hurtSounds = new Array();
    [1].forEach((i) => Sound.hurtSounds.push(new Audio("res/SFX/attacks/hit.mp3")));
    for (let f of Sound.hurtSounds)
        f.volume = 0.3;
    Sound.genericPickupSound = new Audio("res/SFX/items/pickup.mp3");
    Sound.genericPickupSound.volume = 1.0;
    Sound.breakRockSound = new Audio("res/SFX/resources/rockbreak.mp3");
    Sound.breakRockSound.volume = 1.0;
    Sound.pushSounds = new Array();
    [1, 2].forEach((i) => Sound.pushSounds.push(new Audio("res/SFX/pushing/push" + i + ".mp3")));
    for (let f of Sound.pushSounds)
        f.volume = 1.0;
    Sound.healSound = new Audio("res/SFX/items/powerup1.mp3");
    Sound.healSound.volume = 0.5;
    Sound.music = new Audio("res/bewitched.mp3");
    Sound.graveSound = new Audio("res/SFX/attacks/skelespawn.mp3");
    Sound.ambientSound = new Audio("res/SFX/ambient/ambientDark2.mp3");
    Sound.ambientSound.volume = 1;
    Sound.goreSound = new Audio(`res/SFX/misc Unused/gore2.mp3`);
    Sound.goreSound.volume = 0.5;
    Sound.unlockSounds = new Array();
    [1].forEach((i) => Sound.unlockSounds.push(new Audio("res/SFX/door/unlock" + i + ".mp3")));
    for (let f of Sound.unlockSounds)
        f.volume = 0.5;
    Sound.doorOpenSounds = new Array();
    [1, 2].forEach((i) => Sound.doorOpenSounds.push(new Audio("res/SFX/door/open" + i + ".mp3")));
    for (let f of Sound.doorOpenSounds)
        f.volume = 0.5;
    Sound.keyPickupSound = new Audio("res/SFX/items/keyPickup.mp3");
    Sound.keyPickupSound.volume = 1.0;
    Sound.potSmashSounds = new Array();
    [1, 2, 3].forEach((i) => Sound.potSmashSounds.push(new Audio("res/SFX/objects/potSmash" + i + ".mp3")));
    for (let f of Sound.potSmashSounds)
        f.volume = 0.5;
    Sound.magicSound = new Audio("res/SFX/attacks/magic2.mp3");
    Sound.magicSound.volume = 0.25;
    Sound.wooshSound = new Audio("res/SFX/attacks/woosh1.mp3");
    Sound.wooshSound.volume = 0.2;
    Sound.bombSounds = new Array();
    [1, 2].forEach((i) => Sound.bombSounds.push(new Audio("res/SFX/attacks/explode" + i + ".mp3")));
    for (let f of Sound.bombSounds)
        f.volume = 0.7;
    Sound.fuseBurnSound = new Audio("res/SFX/attacks/fuse.mp3");
    Sound.fuseBurnSound.volume = 0.2;
    Sound.fuseLoopSound = new Audio("res/SFX/attacks/fuseLoop.mp3");
    Sound.fuseLoopSound.volume = 0.2;
    Sound.fuseStartSound = new Audio("res/SFX/attacks/fuseStart.mp3");
    Sound.fuseStartSound.volume = 0.2;
    Sound.warHammerSound = new Audio("res/SFX/attacks/warhammer.mp3");
    Sound.warHammerSound.volume = 1;
};
Sound.playerStoneFootstep = async () => {
    if (Sound.audioMuted)
        return;
    let f = game_1.Game.randTable(Sound.playerStoneFootsteps, Math.random);
    await _a.playWithReverb(f);
    f.currentTime = 0;
    f.play();
};
Sound.enemyFootstep = () => {
    if (Sound.audioMuted)
        return;
    let f = game_1.Game.randTable(Sound.enemyFootsteps, Math.random);
    _a.playWithReverb(f);
    f.currentTime = 0;
};
Sound.hit = () => {
    if (Sound.audioMuted)
        return;
    let f = game_1.Game.randTable(Sound.swingSounds, Math.random);
    _a.playWithReverb(f);
    f.currentTime = 0;
    setTimeout(() => {
        let f = game_1.Game.randTable(Sound.hitSounds, Math.random);
        _a.playWithReverb(f);
        f.currentTime = 0;
    }, 100);
};
Sound.hurt = () => {
    if (Sound.audioMuted)
        return;
    let f = game_1.Game.randTable(Sound.hurtSounds, Math.random);
    _a.playWithReverb(f);
    f.currentTime = 0;
};
Sound.enemySpawn = () => {
    if (Sound.audioMuted)
        return;
    _a.playWithReverb(Sound.enemySpawnSound);
    Sound.enemySpawnSound.currentTime = 0;
};
Sound.chest = () => {
    if (Sound.audioMuted)
        return;
    let f = game_1.Game.randTable(Sound.chestSounds, Math.random);
    _a.playWithReverb(f);
    f.currentTime = 0;
};
Sound.potSmash = () => {
    if (Sound.audioMuted)
        return;
    let f = game_1.Game.randTable(Sound.potSmashSounds, Math.random);
    _a.playWithReverb(f);
    f.currentTime = 0;
};
Sound.pickupCoin = () => {
    if (Sound.audioMuted)
        return;
    let f = game_1.Game.randTable(Sound.coinPickupSounds, Math.random);
    _a.playWithReverb(f);
    f.currentTime = 0;
};
Sound.mine = () => {
    if (Sound.audioMuted)
        return;
    let f = game_1.Game.randTable(Sound.miningSounds, Math.random);
    _a.playWithReverb(f);
    f.currentTime = 0;
};
Sound.breakRock = () => {
    if (Sound.audioMuted)
        return;
    setTimeout(() => {
        _a.playWithReverb(Sound.breakRockSound);
    }, 100);
    Sound.breakRockSound.currentTime = 0;
};
Sound.heal = () => {
    if (Sound.audioMuted)
        return;
    _a.playWithReverb(Sound.healSound);
    Sound.healSound.currentTime = 0;
};
Sound.genericPickup = () => {
    if (Sound.audioMuted)
        return;
    _a.playWithReverb(Sound.genericPickupSound);
    Sound.genericPickupSound.currentTime = 0;
};
Sound.keyPickup = () => {
    if (Sound.audioMuted)
        return;
    _a.playWithReverb(Sound.keyPickupSound);
    Sound.keyPickupSound.currentTime = 0;
};
Sound.push = () => {
    if (Sound.audioMuted)
        return;
    let f = game_1.Game.randTable(Sound.pushSounds, Math.random);
    _a.playWithReverb(f);
    f.currentTime = 0;
};
Sound.skeleSpawn = () => {
    if (Sound.audioMuted)
        return;
    _a.playWithReverb(Sound.graveSound);
    Sound.graveSound.currentTime = 0;
    Sound.graveSound.volume = 0.3;
};
Sound.unlock = () => {
    if (Sound.audioMuted)
        return;
    let f = game_1.Game.randTable(Sound.unlockSounds, Math.random);
    _a.playWithReverb(f);
    f.currentTime = 0;
};
Sound.playMusic = () => {
    if (Sound.audioMuted)
        return;
    /*
    Sound.music.addEventListener(
      "ended",
      () => {
        Sound.music.currentTime = 0;
        Sound.playSoundSafely(Sound.music);
      },
      false
    );
    Sound.playSoundSafely(Sound.music);
    */
};
Sound.doorOpen = () => {
    if (Sound.audioMuted)
        return;
    let f = game_1.Game.randTable(Sound.doorOpenSounds, Math.random);
    _a.playWithReverb(f);
    f.currentTime = 0;
};
Sound.playAmbient = () => {
    if (Sound.audioMuted)
        return;
    Sound.ambientSound.addEventListener("ended", () => {
        Sound.ambientSound.currentTime = 0;
        _a.playWithReverb(Sound.ambientSound);
    }, true);
    _a.playWithReverb(Sound.ambientSound);
};
Sound.playFuse = () => {
    if (Sound.audioMuted)
        return;
    Sound.fuseStartSound.currentTime = 0;
    // Play the start sound first
    _a.playWithReverb(Sound.fuseStartSound);
    // When start sound ends, begin the loop
    Sound.fuseStartSound.addEventListener("ended", () => {
        Sound.fuseLoopSound.currentTime = 0;
        _a.playWithReverb(Sound.fuseLoopSound);
    }, { once: true });
    // Set up loop sound to repeat
    Sound.fuseLoopSound.addEventListener("ended", () => {
        Sound.fuseLoopSound.currentTime = 0;
        _a.playWithReverb(Sound.fuseLoopSound);
    });
    // Store the loop handler so we can remove it later
    const loopHandler = () => {
        Sound.fuseLoopSound.currentTime = 0;
        _a.playWithReverb(Sound.fuseLoopSound);
    };
    Sound.loopHandlers.set(Sound.fuseLoopSound, loopHandler);
};
Sound.stopFuse = () => {
    Sound.fuseLoopSound.pause();
    Sound.fuseLoopSound.currentTime = 0;
    Sound.fuseStartSound.pause();
    Sound.fuseStartSound.currentTime = 0;
    // Remove the loop handler
    const handler = Sound.loopHandlers.get(Sound.fuseLoopSound);
    if (handler) {
        Sound.fuseLoopSound.removeEventListener("ended", handler);
        Sound.loopHandlers.delete(Sound.fuseLoopSound);
    }
};
Sound.playGore = () => {
    if (Sound.audioMuted)
        return;
    _a.playWithReverb(Sound.goreSound);
    Sound.goreSound.currentTime = 0;
};
Sound.playBomb = () => {
    if (Sound.audioMuted)
        return;
    let f = game_1.Game.randTable(Sound.bombSounds, Math.random);
    _a.playWithReverb(f);
    f.currentTime = 0;
};
Sound.playWarHammer = () => {
    if (Sound.audioMuted)
        return;
    _a.playWithReverb(Sound.warHammerSound);
    Sound.warHammerSound.currentTime = 0;
};
Sound.playMagic = () => {
    if (Sound.audioMuted)
        return;
    let f = Sound.magicSound;
    let woosh = Sound.wooshSound;
    _a.playWithReverb(f);
    _a.playWithReverb(woosh);
    f.currentTime = 0;
    woosh.currentTime = 0;
};
Sound.delayPlay = (method, delay) => {
    setTimeout(method, delay);
};


/***/ }),

/***/ "./src/stats.ts":
/*!**********************!*\
  !*** ./src/stats.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.statsTracker = void 0;
const eventBus_1 = __webpack_require__(/*! ./eventBus */ "./src/eventBus.ts");
const events_1 = __webpack_require__(/*! ./events */ "./src/events.ts");
class StatsTracker {
    constructor() {
        this.stats = {
            enemiesKilled: 0,
            damageDone: 0,
            damageTaken: 0,
            turnsPassed: 0,
            coinsCollected: 0,
            itemsCollected: 0,
            enemies: [],
        };
        this.handleEnemyKilled = (payload) => {
            this.stats.enemiesKilled += 1;
            this.stats.enemies.push(payload.enemyId);
            //console.log(`Enemy killed: ${payload.enemyId}`);
        };
        this.handleDamageDone = (payload) => {
            this.stats.damageDone += payload.amount;
            //console.log(`Damage done: ${payload.amount}`);
        };
        this.handleDamageTaken = (payload) => {
            this.stats.damageTaken += payload.amount;
            //console.log(`Damage taken: ${payload.amount}`);
        };
        this.handleTurnPassed = () => {
            this.stats.turnsPassed += 1;
            //console.log(`Turn passed: ${this.stats.turnsPassed}`);
        };
        this.handleCoinCollected = (payload) => {
            this.stats.coinsCollected += payload.amount;
            //console.log(`Coins collected: ${payload.amount}`);
        };
        this.handleItemCollected = (payload) => {
            this.stats.itemsCollected += 1;
            //console.log(`Item collected: ${payload.itemId}`);
        };
        this.initializeListeners();
    }
    initializeListeners() {
        eventBus_1.globalEventBus.on(events_1.EVENTS.ENEMY_KILLED, this.handleEnemyKilled);
        eventBus_1.globalEventBus.on(events_1.EVENTS.DAMAGE_DONE, this.handleDamageDone);
        eventBus_1.globalEventBus.on(events_1.EVENTS.DAMAGE_TAKEN, this.handleDamageTaken);
        eventBus_1.globalEventBus.on(events_1.EVENTS.TURN_PASSED, this.handleTurnPassed);
        eventBus_1.globalEventBus.on(events_1.EVENTS.COIN_COLLECTED, this.handleCoinCollected);
        eventBus_1.globalEventBus.on(events_1.EVENTS.ITEM_COLLECTED, this.handleItemCollected);
    }
    getStats() {
        return this.stats;
    }
    resetStats() {
        this.stats = {
            enemiesKilled: 0,
            damageDone: 0,
            damageTaken: 0,
            turnsPassed: 0,
            coinsCollected: 0,
            itemsCollected: 0,
            enemies: [],
        };
        //console.log("Stats have been reset.");
    }
}
exports.statsTracker = new StatsTracker();


/***/ }),

/***/ "./src/textbox.ts":
/*!************************!*\
  !*** ./src/textbox.ts ***!
  \************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TextBox = void 0;
const eventBus_1 = __webpack_require__(/*! ./eventBus */ "./src/eventBus.ts");
class TextBox {
    constructor(element) {
        this.allowedCharacters = "all";
        this.message = "";
        this.currentMessageIndex = -1;
        this.MAX_HISTORY = 50;
        this.handleKeyPress = (key) => {
            const fontHas = "abcdefghijklmnopqrstuvwxyz1234567890,.!?:'()[]%-/ ".split("");
            if (key.length === 1) {
                key = key.toLowerCase();
                if (fontHas.includes(key)) {
                    if (this.allowedCharacters === "all" ||
                        this.allowedCharacters.includes(key)) {
                        this.text =
                            this.text.substring(0, this.cursor) +
                                key +
                                this.text.substring(this.cursor, this.text.length);
                        this.cursor += 1;
                        this.updateElement();
                        this.message =
                            this.message.substring(0, this.cursor - 1) +
                                key +
                                this.message.substring(this.cursor - 1, this.message.length);
                    }
                }
                //console.log(`Current message: "${this.message}"`);
                return;
            }
            else {
                switch (key) {
                    case "Backspace":
                        if (this.cursor > 0) {
                            this.text =
                                this.text.substring(0, this.cursor - 1) +
                                    this.text.substring(this.cursor, this.text.length);
                            this.cursor = Math.max(0, this.cursor - 1);
                            this.updateElement();
                            this.message =
                                this.message.substring(0, this.cursor) +
                                    this.message.substring(this.cursor + 1, this.message.length);
                        }
                        break;
                    case "Delete":
                        if (this.cursor < this.text.length) {
                            this.text =
                                this.text.substring(0, this.cursor) +
                                    this.text.substring(this.cursor + 1, this.text.length);
                            this.updateElement();
                            this.message =
                                this.message.substring(0, this.cursor) +
                                    this.message.substring(this.cursor + 1, this.message.length);
                        }
                        break;
                    case "ArrowLeft":
                        this.cursor = Math.max(0, this.cursor - 1);
                        this.updateCursorPosition();
                        break;
                    case "ArrowRight":
                        this.cursor = Math.min(this.text.length, this.cursor + 1);
                        this.updateCursorPosition();
                        break;
                    case "ArrowUp":
                        if (this.sentMessages.length > 0 &&
                            this.currentMessageIndex < this.sentMessages.length - 1) {
                            this.currentMessageIndex++;
                            this.text =
                                this.sentMessages[this.sentMessages.length - 1 - this.currentMessageIndex];
                            this.updateElement();
                            this.message = this.text;
                        }
                        break;
                    case "ArrowDown":
                        if (this.currentMessageIndex > 0) {
                            this.currentMessageIndex--;
                            this.text =
                                this.sentMessages[this.sentMessages.length - 1 - this.currentMessageIndex];
                            this.updateElement();
                            this.message = this.text;
                        }
                        else if (this.currentMessageIndex === 0) {
                            this.currentMessageIndex = -1;
                            this.clear();
                        }
                        break;
                    case "Enter":
                        this.sendMessage();
                        this.escapeCallback();
                        break;
                    case "Escape":
                        this.escapeCallback();
                        break;
                }
            }
            //console.log(`Current message: "${this.message}"`);
        };
        this.handleTouchStart = (e) => {
            this.focus();
            e.preventDefault();
        };
        this.text = "";
        this.cursor = 0;
        this.enterCallback = () => { };
        this.escapeCallback = () => { };
        this.element = element;
        this.sentMessages = [];
        //this.element.addEventListener("touchstart", this.handleTouchStart);
    }
    setEnterCallback(callback) {
        this.enterCallback = callback;
    }
    setEscapeCallback(callback) {
        this.escapeCallback = callback;
    }
    clear() {
        this.text = "";
        this.cursor = 0;
        this.message = "";
        this.updateElement();
    }
    focus() {
        // Create a temporary input element to trigger the on-screen keyboard
        const tempInput = document.createElement("input");
        tempInput.type = "text";
        tempInput.style.position = "absolute";
        tempInput.style.opacity = "0";
        tempInput.style.zIndex = "-1"; // Ensure it doesn't interfere with the game UI
        document.body.appendChild(tempInput);
        tempInput.focus();
        tempInput.addEventListener("blur", () => {
            document.body.removeChild(tempInput);
        });
    }
    sendMessage() {
        let message = this.message.trim();
        if (message) {
            // Add the new message to the history
            this.sentMessages.push(message);
            // Ensure the history size doesn't exceed the maximum limit
            if (this.sentMessages.length > this.MAX_HISTORY) {
                this.sentMessages.shift(); // Remove the oldest message
            }
            eventBus_1.globalEventBus.emit("ChatMessageSent", message);
            console.log(this.sentMessages);
            this.enterCallback();
            if (message.startsWith("/")) {
                message = message.substring(1);
                eventBus_1.globalEventBus.emit("ChatCommand", message);
            }
            this.clear();
            // Reset the navigation index
            this.currentMessageIndex = -1;
        }
    }
    updateElement() {
        // Update the HTML element with the current text
        // Modify to handle multiple lines if necessary
        this.element.textContent = this.text;
        // Optionally, update cursor position in the UI
    }
    updateCursorPosition() {
        // Implement cursor position update in the UI if necessary
    }
}
exports.TextBox = TextBox;


/***/ }),

/***/ "./src/tile/bones.ts":
/*!***************************!*\
  !*** ./src/tile/bones.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Bones = void 0;
const game_1 = __webpack_require__(/*! ../game */ "./src/game.ts");
const floor_1 = __webpack_require__(/*! ./floor */ "./src/tile/floor.ts");
class Bones extends floor_1.Floor {
    constructor() {
        super(...arguments);
        this.draw = (delta) => {
            game_1.Game.drawTile(7, this.skin, 1, 1, this.x, this.y, 1, 1, this.room.shadeColor, this.shadeAmount());
        };
    }
}
exports.Bones = Bones;


/***/ }),

/***/ "./src/tile/button.ts":
/*!****************************!*\
  !*** ./src/tile/button.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Button = void 0;
const game_1 = __webpack_require__(/*! ../game */ "./src/game.ts");
const tile_1 = __webpack_require__(/*! ./tile */ "./src/tile/tile.ts");
class Button extends tile_1.Tile {
    constructor(room, x, y, linkedDoor) {
        super(room, x, y);
        this.press = () => {
            this.pressed = true;
            this.linkedDoor.opened = true;
        };
        this.unpress = () => {
            this.pressed = false;
            this.linkedDoor.opened = false;
        };
        this.onCollide = (player) => {
            this.press();
        };
        this.onCollideEnemy = (enemy) => {
            this.press();
        };
        this.tickEnd = () => {
            this.unpress();
            for (const i in this.room.game.players) {
                if (this.room.game.players[i].x === this.x &&
                    this.room.game.players[i].y === this.y)
                    this.press();
            }
            for (const e of this.room.entities) {
                if (e.x === this.x && e.y === this.y)
                    this.press();
            }
        };
        this.draw = (delta) => {
            game_1.Game.drawTile(1, 0, 1, 1, this.x, this.y, 1, 1, this.room.shadeColor, this.shadeAmount());
            if (this.pressed)
                game_1.Game.drawTile(18, 0, 1, 1, this.x, this.y, this.w, this.h, this.room.shadeColor, this.shadeAmount());
            else
                game_1.Game.drawTile(17, 0, 1, 1, this.x, this.y, this.w, this.h, this.room.shadeColor, this.shadeAmount());
        };
        this.w = 1;
        this.h = 1;
        this.pressed = false;
        this.turnsSincePressed = 1;
        this.linkedDoor = linkedDoor;
    }
}
exports.Button = Button;


/***/ }),

/***/ "./src/tile/chasm.ts":
/*!***************************!*\
  !*** ./src/tile/chasm.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Chasm = void 0;
const game_1 = __webpack_require__(/*! ../game */ "./src/game.ts");
const tile_1 = __webpack_require__(/*! ./tile */ "./src/tile/tile.ts");
class Chasm extends tile_1.Tile {
    constructor(room, x, y, leftEdge, rightEdge, topEdge, bottomEdge) {
        super(room, x, y);
        this.isSolid = () => {
            return true;
        };
        this.canCrushEnemy = () => {
            return true;
        };
        this.draw = (delta) => {
            if (this.topEdge)
                game_1.Game.drawTile(22, 0, 1, 2, this.x, this.y, 1, 2, this.room.shadeColor, this.shadeAmount());
            game_1.Game.drawTile(this.tileX, this.tileY, 1, 1, this.x, this.y, 1, 1, this.room.shadeColor, this.shadeAmount());
        };
        this.tileX = this.skin === 1 ? 24 : 20;
        this.tileY = 1;
        if (leftEdge)
            this.tileX--;
        else if (rightEdge)
            this.tileX++;
        if (topEdge)
            this.tileY--;
        else if (bottomEdge)
            this.tileY++;
        this.topEdge = topEdge;
    }
}
exports.Chasm = Chasm;


/***/ }),

/***/ "./src/tile/coffinTile.ts":
/*!********************************!*\
  !*** ./src/tile/coffinTile.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CoffinTile = void 0;
const game_1 = __webpack_require__(/*! ../game */ "./src/game.ts");
const tile_1 = __webpack_require__(/*! ./tile */ "./src/tile/tile.ts");
class CoffinTile extends tile_1.Tile {
    constructor(room, x, y, subTileY) {
        super(room, x, y);
        this.isSolid = () => {
            return true;
        };
        this.canCrushEnemy = () => {
            return true;
        };
        this.draw = (delta) => {
            if (this.subTileY === 0) {
                game_1.Game.drawTile(0, 5, 1, 1, this.x - 1, this.y - 1, 1, 1, this.room.shadeColor, this.shadeAmount());
                game_1.Game.drawTile(1, 5, 1, 1, this.x, this.y - 1, 1, 1, this.room.shadeColor, this.shadeAmount());
                game_1.Game.drawTile(2, 5, 1, 1, this.x + 1, this.y - 1, 1, 1, this.room.shadeColor, this.shadeAmount());
                game_1.Game.drawTile(0, 6, 1, 1, this.x - 1, this.y, 1, 1, this.room.shadeColor, this.shadeAmount());
                game_1.Game.drawTile(1, 6, 1, 1, this.x, this.y, 1, 1, this.room.shadeColor, this.shadeAmount());
                game_1.Game.drawTile(2, 6, 1, 1, this.x + 1, this.y, 1, 1, this.room.shadeColor, this.shadeAmount());
            }
            else {
                game_1.Game.drawTile(0, 7, 1, 1, this.x - 1, this.y, 1, 1, this.room.shadeColor, this.shadeAmount());
                game_1.Game.drawTile(1, 7, 1, 1, this.x, this.y, 1, 1, this.room.shadeColor, this.shadeAmount());
                game_1.Game.drawTile(2, 7, 1, 1, this.x + 1, this.y, 1, 1, this.room.shadeColor, this.shadeAmount());
            }
        };
        this.subTileY = subTileY;
    }
}
exports.CoffinTile = CoffinTile;


/***/ }),

/***/ "./src/tile/decorations/decoration.ts":
/*!********************************************!*\
  !*** ./src/tile/decorations/decoration.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Decoration = exports.SkinType = void 0;
const drawable_1 = __webpack_require__(/*! ../../drawable */ "./src/drawable.ts");
const gameConstants_1 = __webpack_require__(/*! ../../gameConstants */ "./src/gameConstants.ts");
const game_1 = __webpack_require__(/*! ../../game */ "./src/game.ts");
var SkinType;
(function (SkinType) {
    SkinType[SkinType["DUNGEON"] = 0] = "DUNGEON";
    SkinType[SkinType["CAVE"] = 1] = "CAVE";
    SkinType[SkinType["FOREST"] = 2] = "FOREST";
    SkinType[SkinType["SWAMP"] = 3] = "SWAMP";
    SkinType[SkinType["GLACIER"] = 4] = "GLACIER";
    SkinType[SkinType["CASTLE"] = 5] = "CASTLE";
})(SkinType = exports.SkinType || (exports.SkinType = {}));
class Decoration extends drawable_1.Drawable {
    constructor(room, x, y) {
        super();
        this.shadeAmount = (offsetX = 0, offsetY = 0) => {
            if (gameConstants_1.GameConstants.SMOOTH_LIGHTING)
                return 0;
            return this.room.softVis[this.x + offsetX][this.y + offsetY];
        };
        this.isSolid = () => {
            return false;
        };
        this.canCrushEnemy = () => {
            return false;
        };
        this.isOpaque = () => {
            return false;
        };
        this.onCollide = (player) => { };
        this.onCollideEnemy = (enemy) => { };
        this.tick = () => { };
        this.tickEnd = () => { };
        this.draw = (delta) => { };
        this.drawUnderPlayer = (delta) => {
            let tileY = 1;
            if (this.applySkin)
                tileY = this.skin;
            game_1.Game.drawTile(1, tileY, 1, 1, this.x, this.y, 1, 1, this.room.shadeColor, this.shadeAmount());
        };
        this.drawAbovePlayer = (delta) => { };
        this.drawAboveShading = (delta) => { };
        this.skin = room.skin;
        this.room = room;
        this.x = x;
        this.y = y;
        this.drawableY = y;
        this.isDoor = false;
        this.opacity = 1;
        this.applySkin = false;
    }
}
exports.Decoration = Decoration;


/***/ }),

/***/ "./src/tile/decorations/puddle.ts":
/*!****************************************!*\
  !*** ./src/tile/decorations/puddle.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Puddle = exports.SkinType = void 0;
const gameConstants_1 = __webpack_require__(/*! ../../gameConstants */ "./src/gameConstants.ts");
const game_1 = __webpack_require__(/*! ../../game */ "./src/game.ts");
const decoration_1 = __webpack_require__(/*! ./decoration */ "./src/tile/decorations/decoration.ts");
var SkinType;
(function (SkinType) {
    SkinType[SkinType["DUNGEON"] = 0] = "DUNGEON";
    SkinType[SkinType["CAVE"] = 1] = "CAVE";
    SkinType[SkinType["FOREST"] = 2] = "FOREST";
    SkinType[SkinType["SWAMP"] = 3] = "SWAMP";
    SkinType[SkinType["GLACIER"] = 4] = "GLACIER";
    SkinType[SkinType["CASTLE"] = 5] = "CASTLE";
})(SkinType = exports.SkinType || (exports.SkinType = {}));
class Puddle extends decoration_1.Decoration {
    constructor(room, x, y) {
        super(room, x, y);
        this.shadeAmount = (offsetX = 0, offsetY = 0) => {
            if (gameConstants_1.GameConstants.SMOOTH_LIGHTING)
                return 0;
            return this.room.softVis[this.x + offsetX][this.y + offsetY];
        };
        this.isSolid = () => {
            return false;
        };
        this.canCrushEnemy = () => {
            return false;
        };
        this.isOpaque = () => {
            return false;
        };
        this.onCollide = (player) => { };
        this.onCollideEnemy = (enemy) => { };
        this.tick = () => { };
        this.tickEnd = () => { };
        this.draw = (delta) => { };
        this.drawUnderPlayer = (delta) => {
            let tileY = 1;
            if (this.applySkin)
                tileY = this.skin;
            game_1.Game.drawTile(1, tileY, 1, 1, this.x, this.y, 1, 1, this.room.shadeColor, this.shadeAmount());
        };
        this.drawAbovePlayer = (delta) => { };
        this.drawAboveShading = (delta) => { };
        this.skin = room.skin;
        this.room = room;
        this.x = x;
        this.y = y;
        this.drawableY = y;
        this.isDoor = false;
        this.opacity = 1;
        this.applySkin = false;
    }
}
exports.Puddle = Puddle;


/***/ }),

/***/ "./src/tile/door.ts":
/*!**************************!*\
  !*** ./src/tile/door.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Door = exports.DoorType = exports.DoorDir = void 0;
const game_1 = __webpack_require__(/*! ../game */ "./src/game.ts");
const gameConstants_1 = __webpack_require__(/*! ../gameConstants */ "./src/gameConstants.ts");
const tile_1 = __webpack_require__(/*! ./tile */ "./src/tile/tile.ts");
const key_1 = __webpack_require__(/*! ../item/key */ "./src/item/key.ts");
const sound_1 = __webpack_require__(/*! ../sound */ "./src/sound.ts");
const lightSource_1 = __webpack_require__(/*! ../lightSource */ "./src/lightSource.ts");
var DoorDir;
(function (DoorDir) {
    DoorDir["North"] = "North";
    DoorDir["East"] = "East";
    DoorDir["South"] = "South";
    DoorDir["West"] = "West";
})(DoorDir = exports.DoorDir || (exports.DoorDir = {}));
var DoorType;
(function (DoorType) {
    DoorType[DoorType["DOOR"] = 0] = "DOOR";
    DoorType[DoorType["LOCKEDDOOR"] = 1] = "LOCKEDDOOR";
    DoorType[DoorType["GUARDEDDOOR"] = 2] = "GUARDEDDOOR";
    DoorType[DoorType["TUNNELDOOR"] = 3] = "TUNNELDOOR";
})(DoorType = exports.DoorType || (exports.DoorType = {}));
class Door extends tile_1.Tile {
    constructor(room, game, x, y, doorDir, doorType) {
        super(room, x, y);
        this.shadeAmount = (offsetX = 0, offsetY = 0) => {
            if (gameConstants_1.GameConstants.SMOOTH_LIGHTING)
                return 0;
            const vis = this.room.softVis[this.x + offsetX][this.y + offsetY];
            if (this.opened)
                return vis / 2;
            else
                return vis;
        };
        this.openTunnelXOffset = () => {
            if (this.type === DoorType.TUNNELDOOR) {
                if (!this.opened) {
                    return 0;
                }
                else {
                    return -3;
                }
            }
            return 0;
        };
        this.guard = () => {
            this.type = DoorType.GUARDEDDOOR;
            this.locked = true;
            this.iconTileX = 9;
            this.iconXOffset = 1 / 32;
        };
        this.lock = () => {
            this.type = DoorType.LOCKEDDOOR;
            this.locked = true;
            this.iconTileX = 10;
            this.iconXOffset = 1 / 32;
        };
        this.removeLock = () => {
            if (this.type !== DoorType.TUNNELDOOR)
                this.type = DoorType.DOOR;
            this.locked = false;
        };
        this.removeLockIcon = () => {
            this.iconYOffset = 0;
            this.unlocking = false;
            this.iconTileX = 2;
            this.iconXOffset = 0;
            this.iconAlpha = 1;
        };
        this.canUnlock = (player) => {
            if (this.type === DoorType.LOCKEDDOOR) {
                let k = player.inventory.hasItem(key_1.Key);
                if (k !== null) {
                    this.game.pushMessage("You use the key to unlock the door.");
                    return true;
                }
                else
                    this.game.pushMessage("The door is locked tightly and won't budge.");
                return false;
            }
            if (this.type === DoorType.GUARDEDDOOR) {
                this.room.checkForNoEnemies();
                this.game.pushMessage("There are still remaining foes guarding this door...");
                return false;
            }
            if (this.type === DoorType.TUNNELDOOR &&
                (!this.opened || !this.linkedDoor.opened)) {
                if (this.linkedDoor === this.room.level.exitRoom.tunnelDoor) {
                    this.game.pushMessage("The door refuses to budge from this side.");
                    return false;
                }
                else {
                    this.game.pushMessage("You clear the debris, revealing a narrow tunnel.");
                    return true;
                }
            }
            return true;
        };
        this.unlock = (player) => {
            if (this.type === DoorType.LOCKEDDOOR) {
                let k = player.inventory.hasItem(key_1.Key);
                if (k !== null) {
                    // remove key
                    player.inventory.removeItem(k);
                    sound_1.Sound.unlock();
                    this.removeLock();
                    this.unlocking = true;
                }
            }
            else if (this.type === DoorType.TUNNELDOOR) {
                this.locked = false;
                this.unlocking = true;
            }
        };
        this.unGuard = () => {
            if (this.type === DoorType.GUARDEDDOOR) {
                this.removeLock();
                this.game.tutorialActive = false;
            }
        };
        this.link = (other) => {
            this.linkedDoor = other;
        };
        this.isSolid = () => {
            if (this.locked) {
                return true;
            }
            else
                false;
        };
        this.canCrushEnemy = () => {
            return true;
        };
        this.onCollide = (player) => {
            if (!this.opened) {
                sound_1.Sound.doorOpen();
            }
            this.opened = true;
            this.linkedDoor.opened = true;
            if (this.doorDir === game_1.Direction.UP || this.doorDir === game_1.Direction.DOWN) {
                this.game.changeLevelThroughDoor(player, this.linkedDoor);
            }
            else
                this.game.changeLevelThroughDoor(player, this.linkedDoor, this.linkedDoor.room.roomX - this.room.roomX > 0 ? 1 : -1);
            this.linkedDoor.removeLock();
            this.linkedDoor.removeLockIcon();
            this.removeLockIcon();
        };
        this.draw = (delta) => {
            game_1.Game.ctx.save();
            if (this.doorDir === game_1.Direction.DOWN) {
                game_1.Game.drawTile(1, this.skin, 1, 1, this.x, this.y, 1, 1, this.room.shadeColor, this.shadeAmount());
            }
            if (this.doorDir === game_1.Direction.UP) {
                //if top door
                if (this.opened)
                    game_1.Game.drawTile(6 + this.tileXOffset + this.openTunnelXOffset(), this.skin, 1, 1, this.x, this.y, 1, 1, this.room.shadeColor, this.shadeAmount(0, 1));
                else
                    game_1.Game.drawTile(3 + this.tileXOffset + this.openTunnelXOffset(), this.skin, 1, 1, this.x, this.y, 1, 1, this.room.shadeColor, this.shadeAmount());
            }
            if (this.doorDir !== game_1.Direction.UP)
                //if not top door
                game_1.Game.drawTile(1, this.skin, 1, 1, this.x, this.y, 1, 1, this.room.shadeColor, this.shadeAmount());
            //the following used to be in the drawaboveplayer function
            if (this.doorDir === game_1.Direction.UP) {
                //if top door
                if (!this.drawTopOf)
                    return;
                if (!this.opened)
                    game_1.Game.drawTile(13, 0, 1, 1, this.x, this.y - 1, 1, 1, this.room.shadeColor, this.shadeAmount(0, 1));
                else
                    game_1.Game.drawTile(14, 0, 1, 1, this.x, this.y - 1, 1, 1, this.room.shadeColor, this.shadeAmount(0, 1));
            }
            game_1.Game.ctx.restore();
        };
        this.drawAbovePlayer = (delta) => { };
        this.drawAboveShading = (delta) => {
            if (this.type === DoorType.TUNNELDOOR)
                return;
            if (this.frame > 100)
                this.frame = 0;
            this.frame += 1 * delta;
            game_1.Game.ctx.globalAlpha = this.iconAlpha;
            let multiplier = 0.125;
            if (this.unlocking === true) {
                this.iconAlpha *= 0.92 ** delta;
                this.iconYOffset -= 0.035 * delta;
                multiplier = 0;
                if (this.iconAlpha <= 0.01) {
                    this.removeLockIcon();
                }
            }
            if (this.doorDir === game_1.Direction.UP) {
                //if top door
                game_1.Game.drawFX(this.iconTileX, 2, 1, 1, this.x + this.iconXOffset, this.y -
                    1.25 +
                    multiplier * Math.sin((this.frame * Math.PI) / 50) +
                    this.iconYOffset, 1, 1);
            }
            else {
                game_1.Game.drawFX(this.iconTileX, 2, 1, 1, this.x + this.iconXOffset, this.y -
                    1.25 +
                    multiplier * Math.sin((this.frame * Math.PI) / 50) +
                    this.iconYOffset, 1, 1); //if not top door
            }
            game_1.Game.ctx.globalAlpha = 1;
        };
        this.game = game;
        this.opened = false;
        this.doorDir = doorDir;
        this.locked = false;
        this.isDoor = true;
        this.type = doorType;
        this.iconTileX = 2;
        this.iconXOffset = 0;
        this.iconYOffset = 0;
        this.unlocking = false;
        this.iconAlpha = 1;
        this.frame = 0;
        this.tileXOffset = 0;
        this.tileX = 2;
        this.drawTopOf = true;
        let lightOffsetX = 0;
        let lightOffsetY = 0;
        this.alpha = 1;
        switch (this.doorDir) {
            case game_1.Direction.UP:
                lightOffsetY = -0.5;
            case game_1.Direction.DOWN:
                lightOffsetY = 0.5;
            case game_1.Direction.LEFT:
                lightOffsetX = -0.5;
            case game_1.Direction.RIGHT:
                lightOffsetX = 0.5;
        }
        this.lightSource = new lightSource_1.LightSource(x + 0.5, y + 0.5, 0, [0, 0, 0], 9);
        this.room.lightSources.push(this.lightSource);
        switch (this.type) {
            case DoorType.GUARDEDDOOR:
                this.guard();
                break;
            case DoorType.LOCKEDDOOR:
                this.lock();
                break;
            case DoorType.DOOR:
                this.removeLock();
                break;
            case DoorType.TUNNELDOOR:
                // this.tileX = ? find the right tile for this
                this.locked = true;
                this.iconTileX = 10;
                this.iconXOffset = 1 / 32;
                this.tileXOffset = 12;
                this.drawTopOf = false;
                break;
        }
    }
}
exports.Door = Door;


/***/ }),

/***/ "./src/tile/downLadder.ts":
/*!********************************!*\
  !*** ./src/tile/downLadder.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DownLadder = void 0;
const game_1 = __webpack_require__(/*! ../game */ "./src/game.ts");
const tile_1 = __webpack_require__(/*! ./tile */ "./src/tile/tile.ts");
const upLadder_1 = __webpack_require__(/*! ./upLadder */ "./src/tile/upLadder.ts");
const events_1 = __webpack_require__(/*! ../events */ "./src/events.ts");
const eventBus_1 = __webpack_require__(/*! ../eventBus */ "./src/eventBus.ts");
class DownLadder extends tile_1.Tile {
    constructor(room, game, x, y) {
        super(room, x, y);
        this.isRope = false;
        this.frame = 0;
        this.generate = async () => {
            if (!this.linkedLevel) {
                await this.game.levelgen.generate(this.game, this.room.depth + (this.isRope ? 0 : 1), this.isRope, (linkedLevel) => {
                    this.linkedLevel = linkedLevel;
                    outerLoop: for (let x = this.linkedLevel.roomX; x < this.linkedLevel.roomX + this.linkedLevel.width; x++) {
                        for (let y = this.linkedLevel.roomY; y < this.linkedLevel.roomY + this.linkedLevel.height; y++) {
                            let tile = this.linkedLevel.roomArray[x][y];
                            if (tile instanceof upLadder_1.UpLadder) {
                                tile.linkedLevel = this.game.levels[this.room.depth].exitRoom;
                                //console.log("linked level", tile.linkedLevel);
                                break outerLoop;
                            }
                        }
                    }
                });
            }
        };
        this.onCollide = (player) => {
            let allPlayersHere = true;
            for (const i in this.game.players) {
                if (this.game.levels[this.game.players[i].depth].rooms[this.game.players[i].levelID] !== this.room ||
                    this.game.players[i].x !== this.x ||
                    this.game.players[i].y !== this.y) {
                    allPlayersHere = false;
                }
            }
            if (allPlayersHere) {
                eventBus_1.globalEventBus.emit(events_1.EVENTS.LEVEL_GENERATION_STARTED, {});
                this.generate().then(() => {
                    eventBus_1.globalEventBus.emit(events_1.EVENTS.LEVEL_GENERATION_COMPLETED, {});
                    for (const i in this.game.players) {
                        this.game.changeLevelThroughLadder(this.game.players[i], this);
                    }
                });
            }
            else {
                if (player === this.game.players[this.game.localPlayerID])
                    this.game.chat.push(new game_1.ChatMessage("all players must be present"));
            }
        };
        this.draw = (delta) => {
            let xx = 4;
            if (this.isRope)
                xx = 16;
            game_1.Game.drawTile(1, this.skin, 1, 1, this.x, this.y, 1, 1, this.room.shadeColor, this.shadeAmount());
            game_1.Game.drawTile(xx, this.skin, 1, 1, this.x, this.y, 1, 1, this.room.shadeColor, this.shadeAmount());
        };
        this.drawAboveShading = (delta) => {
            if (this.frame > 100)
                this.frame = 0;
            this.frame += 1 * delta;
            let multiplier = 0.125;
            game_1.Game.drawFX(2, 2, 1, 1, this.x, this.y - 1.25 + multiplier * Math.sin((this.frame * Math.PI) / 50), 1, 1);
        };
        this.drawAbovePlayer = (delta) => { };
        this.game = game;
        this.linkedLevel = null;
        this.depth = room.depth;
    }
    get linkedRoom() {
        return this.game.levels[this.depth - 1].exitRoom;
    }
}
exports.DownLadder = DownLadder;


/***/ }),

/***/ "./src/tile/floor.ts":
/*!***************************!*\
  !*** ./src/tile/floor.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Floor = void 0;
const game_1 = __webpack_require__(/*! ../game */ "./src/game.ts");
const tile_1 = __webpack_require__(/*! ./tile */ "./src/tile/tile.ts");
class Floor extends tile_1.Tile {
    constructor(room, x, y) {
        super(room, x, y);
        this.draw = (delta) => {
            game_1.Game.drawTile(this.variation, this.skin, 1, 1, this.x, this.y, 1, 1, this.room.shadeColor, this.shadeAmount());
        };
        this.variation = 1;
        if (this.skin == tile_1.SkinType.DUNGEON)
            this.variation = game_1.Game.randTable([1, 1, 1, 1, 1, 1, 8, 8, 8, 9, 10, 10, 10, 10, 10, 12], Math.random);
        if (this.skin == tile_1.SkinType.CAVE)
            //this.variation = Game.randTable([1, 1, 1, 1, 8, 9, 10, 12], Math.random);
            this.variation = game_1.Game.randTable([1, 1, 1, 1, 1, 1, 8, 8, 8, 9, 10, 10, 10, 10, 10, 12], Math.random);
        if (this.skin == tile_1.SkinType.FOREST)
            //this.variation = Game.randTable([1, 1, 1, 1, 8, 9, 10, 12], Math.random);
            this.variation = game_1.Game.randTable([1, 1, 1, 1, 1, 1, 8, 8, 8, 9, 10, 10, 10, 10, 10, 12], Math.random);
    }
}
exports.Floor = Floor;


/***/ }),

/***/ "./src/tile/fountainTile.ts":
/*!**********************************!*\
  !*** ./src/tile/fountainTile.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FountainTile = void 0;
const game_1 = __webpack_require__(/*! ../game */ "./src/game.ts");
const tile_1 = __webpack_require__(/*! ./tile */ "./src/tile/tile.ts");
class FountainTile extends tile_1.Tile {
    constructor(room, x, y, subTileX, subTileY) {
        super(room, x, y);
        this.isSolid = () => {
            return true;
        };
        this.canCrushEnemy = () => {
            return true;
        };
        this.draw = (delta) => {
            game_1.Game.drawTile(1, this.skin, 1, 1, this.x, this.y, 1, 1, this.room.shadeColor, this.shadeAmount());
            game_1.Game.drawTile(this.subTileX, 2 + this.subTileY, 1, 1, this.x, this.y, 1, 1, this.room.shadeColor, this.shadeAmount());
        };
        this.subTileX = subTileX;
        this.subTileY = subTileY;
    }
}
exports.FountainTile = FountainTile;


/***/ }),

/***/ "./src/tile/insideLevelDoor.ts":
/*!*************************************!*\
  !*** ./src/tile/insideLevelDoor.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InsideLevelDoor = void 0;
const game_1 = __webpack_require__(/*! ../game */ "./src/game.ts");
const tile_1 = __webpack_require__(/*! ./tile */ "./src/tile/tile.ts");
class InsideLevelDoor extends tile_1.Tile {
    constructor(room, game, x, y) {
        super(room, x, y);
        this.isSolid = () => {
            return !this.opened;
        };
        this.canCrushEnemy = () => {
            return !this.opened;
        };
        this.isOpaque = () => {
            return !this.opened;
        };
        this.draw = (delta) => {
            game_1.Game.drawTile(1, 0, 1, 1, this.x, this.y, 1, 1, this.room.shadeColor, this.shadeAmount());
            if (this.opened)
                game_1.Game.drawTile(15, 1, 1, 1, this.x, this.y, 1, 1, this.room.shadeColor, this.shadeAmount());
            else
                game_1.Game.drawTile(3, this.skin, 1, 1, this.x, this.y, 1, 1, this.room.shadeColor, this.shadeAmount());
        };
        this.drawAbovePlayer = (delta) => {
            if (!this.opened)
                game_1.Game.drawTile(13, 0, 1, 1, this.x, this.y - 1, 1, 1, this.room.shadeColor, this.shadeAmount());
            else
                game_1.Game.drawTile(14, 0, 1, 1, this.x, this.y - 1, 1, 1, this.room.shadeColor, this.shadeAmount());
        };
        this.game = game;
        this.opened = false;
    }
}
exports.InsideLevelDoor = InsideLevelDoor;


/***/ }),

/***/ "./src/tile/spawnfloor.ts":
/*!********************************!*\
  !*** ./src/tile/spawnfloor.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SpawnFloor = void 0;
const game_1 = __webpack_require__(/*! ../game */ "./src/game.ts");
const tile_1 = __webpack_require__(/*! ./tile */ "./src/tile/tile.ts");
class SpawnFloor extends tile_1.Tile {
    constructor(room, x, y) {
        super(room, x, y);
        this.draw = (delta) => {
            game_1.Game.drawTile(this.variation, this.skin, 1, 1, this.x, this.y, 1, 1, this.room.shadeColor, this.shadeAmount());
        };
        this.variation = 1;
        if (this.skin == tile_1.SkinType.DUNGEON)
            this.variation = game_1.Game.randTable([1, 1, 1, 1, 1, 1, 8, 8, 8, 9, 10, 10, 10, 10, 10, 12], Math.random);
        if (this.skin == tile_1.SkinType.CAVE)
            //this.variation = Game.randTable([1, 1, 1, 1, 8, 9, 10, 12], Math.random);
            this.variation = game_1.Game.randTable([1, 1, 1, 1, 1, 1, 8, 8, 8, 9, 10, 10, 10, 10, 10, 12], Math.random);
    }
}
exports.SpawnFloor = SpawnFloor;


/***/ }),

/***/ "./src/tile/spiketrap.ts":
/*!*******************************!*\
  !*** ./src/tile/spiketrap.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SpikeTrap = void 0;
const game_1 = __webpack_require__(/*! ../game */ "./src/game.ts");
const tile_1 = __webpack_require__(/*! ./tile */ "./src/tile/tile.ts");
const crate_1 = __webpack_require__(/*! ../entity/object/crate */ "./src/entity/object/crate.ts");
const barrel_1 = __webpack_require__(/*! ../entity/object/barrel */ "./src/entity/object/barrel.ts");
const hitWarning_1 = __webpack_require__(/*! ../hitWarning */ "./src/hitWarning.ts");
class SpikeTrap extends tile_1.Tile {
    constructor(room, x, y, tickCount) {
        super(room, x, y);
        this.tick = () => {
            this.tickCount++;
            if (this.tickCount >= 4)
                this.tickCount = 0;
            this.on = this.tickCount === 0;
            if (this.on) {
                for (const i in this.room.game.players) {
                    if (this.room ===
                        this.room.game.rooms[this.room.game.players[i].levelID] &&
                        this.room.game.players[i].x === this.x &&
                        this.room.game.players[i].y === this.y)
                        this.room.game.players[i].hurt(0.5, "spike trap");
                }
            }
            if (this.tickCount === 3)
                this.room.hitwarnings.push(new hitWarning_1.HitWarning(this.room.game, this.x, this.y, this.x, this.y, false));
        };
        this.tickEnd = () => {
            if (this.on) {
                for (const e of this.room.entities) {
                    if (e.x === this.x && e.y === this.y) {
                        e.hurt(null, 1);
                    }
                }
            }
        };
        this.onCollideEnemy = (enemy) => {
            if (this.on && !(enemy instanceof crate_1.Crate || enemy instanceof barrel_1.Barrel))
                enemy.hurt(null, 1);
        };
        this.draw = (delta) => {
            this.drawableY = this.y - 0.01;
            game_1.Game.drawTile(1, this.skin, 1, 1, this.x, this.y, 1, 1, this.room.shadeColor, this.shadeAmount());
            let rumbleOffsetX = 0;
            this.t += delta;
            if (!this.on && this.tickCount === 3) {
                if (Math.floor(this.t) % 4 === 1)
                    rumbleOffsetX = 0.0325;
                if (Math.floor(this.t) % 4 === 3)
                    rumbleOffsetX = -0.0325;
            }
            let frames = [0, 1, 2, 3, 3, 4, 2, 0];
            let f = 6 + frames[Math.floor(this.frame)];
            if (this.tickCount === 1 ||
                (this.tickCount === 0 && frames[Math.floor(this.frame)] === 0)) {
                f = 5;
            }
            game_1.Game.drawObj(f, 0, 1, 2, this.x + rumbleOffsetX, this.y - 1, 1, 2, this.room.shadeColor, this.shadeAmount());
            if (this.on && this.frame < frames.length - 1) {
                if (frames[Math.floor(this.frame)] < 3)
                    this.frame += 0.4 * delta;
                else
                    this.frame += 0.2 * delta;
            }
            if (!this.on)
                this.frame = 0;
        };
        if (tickCount)
            this.tickCount = tickCount;
        else
            this.tickCount = 0;
        this.on = false;
        this.frame = 0;
        this.t = 0;
    }
}
exports.SpikeTrap = SpikeTrap;


/***/ }),

/***/ "./src/tile/tile.ts":
/*!**************************!*\
  !*** ./src/tile/tile.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Tile = exports.SkinType = void 0;
const drawable_1 = __webpack_require__(/*! ../drawable */ "./src/drawable.ts");
const gameConstants_1 = __webpack_require__(/*! ../gameConstants */ "./src/gameConstants.ts");
var SkinType;
(function (SkinType) {
    SkinType[SkinType["DUNGEON"] = 0] = "DUNGEON";
    SkinType[SkinType["CAVE"] = 1] = "CAVE";
    SkinType[SkinType["FOREST"] = 2] = "FOREST";
    SkinType[SkinType["SWAMP"] = 3] = "SWAMP";
    SkinType[SkinType["GLACIER"] = 4] = "GLACIER";
    SkinType[SkinType["CASTLE"] = 5] = "CASTLE";
})(SkinType = exports.SkinType || (exports.SkinType = {}));
class Tile extends drawable_1.Drawable {
    constructor(room, x, y) {
        super();
        this.hasPlayer = (player) => {
            if (player.x === this.x && player.y === this.y)
                return true;
            else
                return false;
        };
        this.shadeAmount = (offsetX = 0, offsetY = 0) => {
            if (gameConstants_1.GameConstants.SMOOTH_LIGHTING)
                return 0;
            return this.room.softVis[this.x + offsetX][this.y + offsetY];
        };
        this.isSolid = () => {
            return false;
        };
        this.canCrushEnemy = () => {
            return false;
        };
        this.isOpaque = () => {
            return false;
        };
        this.onCollide = (player) => { };
        this.onCollideEnemy = (enemy) => { };
        this.tick = () => { };
        this.tickEnd = () => { };
        this.draw = (delta) => { };
        this.drawUnderPlayer = (delta) => { };
        this.drawAbovePlayer = (delta) => { };
        this.drawAboveShading = (delta) => { };
        this.skin = room.skin;
        this.room = room;
        this.x = x;
        this.y = y;
        this.drawableY = y;
        this.isDoor = false;
        this.opacity = 1;
    }
}
exports.Tile = Tile;


/***/ }),

/***/ "./src/tile/trapdoor.ts":
/*!******************************!*\
  !*** ./src/tile/trapdoor.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Trapdoor = void 0;
const game_1 = __webpack_require__(/*! ../game */ "./src/game.ts");
const tile_1 = __webpack_require__(/*! ./tile */ "./src/tile/tile.ts");
class Trapdoor extends tile_1.Tile {
    constructor(room, game, x, y) {
        super(room, x, y);
        this.draw = (delta) => {
            game_1.Game.drawTile(13, this.skin, 1, 1, this.x, this.y, 1, 1, this.room.shadeColor, this.shadeAmount());
        };
        this.onCollide = (player) => {
            // TODO
        };
        this.game = game;
    }
}
exports.Trapdoor = Trapdoor;


/***/ }),

/***/ "./src/tile/upLadder.ts":
/*!******************************!*\
  !*** ./src/tile/upLadder.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UpLadder = void 0;
const game_1 = __webpack_require__(/*! ../game */ "./src/game.ts");
const tile_1 = __webpack_require__(/*! ./tile */ "./src/tile/tile.ts");
class UpLadder extends tile_1.Tile {
    constructor(room, game, x, y) {
        super(room, x, y);
        this.isRope = false;
        this.onCollide = (player) => {
            if (!this.game) {
                console.error("Game instance is undefined in UpLadder:", this);
                return;
            }
            try {
                this.linkLevel();
                this.game.changeLevelThroughLadder(player, this);
            }
            catch (error) {
                console.error("Error during changeLevelThroughLadder:", error);
            }
        };
        this.linkLevel = () => {
            this.linkedLevel = this.game.levels[this.depth - 1].exitRoom;
        };
        this.draw = (delta) => {
            let xx = 29;
            let yy = 0;
            if (this.isRope) {
                xx = 16;
                yy = 1;
            }
            game_1.Game.drawTile(1, this.skin, 1, 1, this.x, this.y, 1, 1, this.room.shadeColor, this.shadeAmount());
            if (!this.isRope)
                game_1.Game.drawTile(xx, yy, 1, 1, this.x, this.y - 1, 1, 1, this.room.shadeColor, this.shadeAmount());
            game_1.Game.drawTile(xx, yy + 1, 1, 1, this.x, this.y, 1, 1, this.room.shadeColor, this.shadeAmount());
        };
        this.drawAbovePlayer = (delta) => {
            if (this.isRope)
                game_1.Game.drawTile(16, 1, 1, 1, this.x, this.y - 1, 1, 1, this.room.shadeColor, this.shadeAmount());
        };
        this.game = game;
        this.depth = room.depth;
    }
}
exports.UpLadder = UpLadder;


/***/ }),

/***/ "./src/tile/wall.ts":
/*!**************************!*\
  !*** ./src/tile/wall.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Wall = void 0;
const game_1 = __webpack_require__(/*! ../game */ "./src/game.ts");
const tile_1 = __webpack_require__(/*! ./tile */ "./src/tile/tile.ts");
class Wall extends tile_1.Tile {
    constructor(room, x, y, wallDirections) {
        super(room, x, y);
        this.isSolid = () => {
            return true;
        };
        this.canCrushEnemy = () => {
            return true;
        };
        this.isOpaque = () => {
            const wallInfo = this.wallInfo();
            if (!wallInfo)
                return false;
            return ((!wallInfo.isTopWall && !wallInfo.isInnerWall) ||
                wallInfo.isLeftWall ||
                wallInfo.isRightWall);
        };
        this.wallInfo = () => {
            return this.room.wallInfo.get(`${this.x},${this.y}`);
        };
        this.draw = (delta) => {
            this.drawWall(delta);
        };
        this.drawWall = (delta) => {
            const wallInfo = this.room.wallInfo.get(`${this.x},${this.y}`);
            if (!wallInfo)
                return;
            // Set tileYOffset based on inner wall type
            this.tileXOffset =
                wallInfo.innerWallType === "bottomInner" ||
                    wallInfo.innerWallType === "surroundedInner"
                    ? 0
                    : 26;
            // Only draw the bottom part of the wall if it's not at the bottom edge of the room
            if (wallInfo.isDoorWall ||
                wallInfo.isBelowDoorWall ||
                (wallInfo.isTopWall && !wallInfo.isLeftWall && !wallInfo.isRightWall) ||
                wallInfo.isInnerWall)
                game_1.Game.drawTile(0, this.skin, 1, 1, this.x, this.y, 1, 1, this.room.shadeColor, this.shadeAmount());
            game_1.Game.drawTile(2 + this.tileXOffset, this.skin, 1, 1, this.x, this.y - 1, 1, 1, this.room.shadeColor, this.shadeAmount());
        };
        this.drawTopLayer = (delta) => {
            const wallInfo = this.room.wallInfo.get(`${this.x},${this.y}`);
            if (!wallInfo)
                return;
            if (wallInfo.isBottomWall ||
                wallInfo.isBelowDoorWall ||
                wallInfo.isAboveDoorWall) {
                game_1.Game.drawTile(2 + this.tileXOffset, this.skin, 1, 1, this.x, this.y - 1, 1, 1, this.room.shadeColor, this.shadeAmount());
            }
        };
        this.isDoor = false;
        this.tileXOffset = 6;
        this.wallDirections = wallDirections || [];
        this.opacity = 1;
    }
    get direction() {
        let directions = [];
        if (this.room.roomArray[this.x - 1][this.y] == null)
            directions.push(game_1.Direction.LEFT);
        if (this.room.roomArray[this.x + 1][this.y] == null)
            directions.push(game_1.Direction.RIGHT);
        if (this.room.roomArray[this.x][this.y - 1] == null)
            directions.push(game_1.Direction.DOWN);
        if (this.room.roomArray[this.x][this.y + 1] == null)
            directions.push(game_1.Direction.UP);
        if (directions.length == 1)
            return directions[0];
        if (directions.includes(game_1.Direction.UP) &&
            directions.includes(game_1.Direction.LEFT)) {
            this.opacity = 0.5;
            return game_1.Direction.UP_LEFT;
        }
        if (directions.includes(game_1.Direction.UP) &&
            directions.includes(game_1.Direction.RIGHT)) {
            this.opacity = 0.5;
            return game_1.Direction.UP_RIGHT;
        }
        if (directions.includes(game_1.Direction.DOWN) &&
            directions.includes(game_1.Direction.LEFT)) {
            this.opacity = 0.5;
            return game_1.Direction.DOWN_LEFT;
        }
        return game_1.Direction.DOWN_RIGHT;
    }
}
exports.Wall = Wall;


/***/ }),

/***/ "./src/tile/wallTorch.ts":
/*!*******************************!*\
  !*** ./src/tile/wallTorch.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WallTorch = void 0;
const game_1 = __webpack_require__(/*! ../game */ "./src/game.ts");
const lightSource_1 = __webpack_require__(/*! ../lightSource */ "./src/lightSource.ts");
const levelConstants_1 = __webpack_require__(/*! ../levelConstants */ "./src/levelConstants.ts");
const wall_1 = __webpack_require__(/*! ./wall */ "./src/tile/wall.ts");
class WallTorch extends wall_1.Wall {
    constructor(room, x, y) {
        super(room, x, y);
        this.isSolid = () => {
            return true;
        };
        this.canCrushEnemy = () => {
            return true;
        };
        this.isOpaque = () => {
            const wallInfo = this.room.wallInfo.get(`${this.x},${this.y}`);
            if (!wallInfo)
                return true;
            return ((!wallInfo.isTopWall && !wallInfo.isInnerWall) ||
                wallInfo.isLeftWall ||
                wallInfo.isRightWall);
        };
        this.draw = (delta) => {
            this.drawWall(delta);
            const wallInfo = this.room.wallInfo.get(`${this.x},${this.y}`);
            if (!wallInfo)
                this.tileYOffset = 6;
            this.frame += 0.3 * delta;
            if (this.frame >= 12)
                this.frame = 0;
            this.tileYOffset =
                wallInfo.innerWallType === "bottomInner" ||
                    wallInfo.innerWallType === "surroundedInner"
                    ? 0
                    : 6;
            game_1.Game.drawTile(0, this.skin, 1, 1, this.x, this.y, 1, 1, this.room.shadeColor, this.shadeAmount());
            game_1.Game.drawFX(Math.floor(this.frame), 32, 1, 2, this.x, this.y - 1, 1, 2);
        };
        this.room.lightSources.push(new lightSource_1.LightSource(this.x + 0.5, this.y + 0.5, 5, levelConstants_1.LevelConstants.TORCH_LIGHT_COLOR, 1.5));
        this.frame = Math.random() * 12;
        this.tileYOffset = 6;
        this.hasBloom = true;
        this.bloomColor = "#FFA500";
        this.bloomAlpha = 1;
        this.softBloomAlpha = 0;
    }
}
exports.WallTorch = WallTorch;


/***/ }),

/***/ "./src/tutorialListener.ts":
/*!*********************************!*\
  !*** ./src/tutorialListener.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TutorialListener = void 0;
const eventBus_1 = __webpack_require__(/*! ./eventBus */ "./src/eventBus.ts");
class TutorialListener {
    constructor(game) {
        this._seenEnemies = new Set();
        this._seenEnemyClasses = new Set();
        this.pendingNewEnemies = new Set();
        this.tutorialCreationTimeout = null;
        //console.log("Tutorial constructor called");
        this.setupEventListeners();
        this.game = game;
        this.player = this.game.player;
    }
    get seenEnemies() {
        if (this._seenEnemies === undefined) {
            this._seenEnemies = new Set();
        }
        return this._seenEnemies;
    }
    setupEventListeners() {
        //console.log("Setting up event listeners");
        eventBus_1.globalEventBus.on("EnemySeenPlayer", this.handleEnemySeen.bind(this));
    }
    handleEnemySeen(data) {
        if (!this.hasSeenEnemy(data.enemyType)) {
            this.game.pushMessage(`New enemy encountered: ${data.enemyName}`);
            this.addSeenEnemy(data.enemyType);
            this.pendingNewEnemies.add(data.enemyType);
            this.scheduleTutorialCreation();
            this.player.bestiary.addEntry(data.enemyType);
            console.log(this.player.bestiary.entries);
        }
    }
    scheduleTutorialCreation() {
        if (this.tutorialCreationTimeout === null) {
            this.tutorialCreationTimeout = setTimeout(() => {
                this.createTutorialRoom(Array.from(this.pendingNewEnemies));
                //this.game.pushMessage("Defeat the enemies guarding the exits.");
                this.pendingNewEnemies.clear();
                this.tutorialCreationTimeout = null;
            }, 100); // Wait 100ms to collect all new enemies
        }
    }
    createTutorialRoom(enemyTypes) {
        /*
        this.game.tutorialActive = true;
        this.game.room.doors.forEach((door: Door) => {
          door.guard();
        });
        */
    }
    // Method to check if an enemy has been seen before
    hasSeenEnemy(enemyType) {
        //console.log(`Checking if enemy has been seen: ${enemyType}`);
        return this._seenEnemies.has(enemyType);
    }
    // Method to manually add an enemy to the seen list (useful for testing or manual control)
    addSeenEnemy(enemyType) {
        //console.log(`Adding enemy to seen list: ${enemyType}`);
        this._seenEnemies.add(enemyType);
        this._seenEnemyClasses.add(enemyType.prototype);
    }
    // Method to reset the seen enemies list (useful for testing or game resets)
    resetSeenEnemies() {
        //console.log("Resetting seen enemies list");
        this._seenEnemies.clear();
        this._seenEnemyClasses.clear();
    }
    // Method to clean up event listeners when needed
    cleanup() {
        //console.log("Cleaning up event listeners");
        eventBus_1.globalEventBus.off("EnemySeenPlayer", this.handleEnemySeen.bind(this));
    }
}
exports.TutorialListener = TutorialListener;


/***/ }),

/***/ "./src/utils.ts":
/*!**********************!*\
  !*** ./src/utils.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Utils = void 0;
class Utils {
}
exports.Utils = Utils;
Utils.distance = (startX, startY, endX, endY) => {
    return Math.sqrt((endX - startX) ** 2 + (endY - startY) ** 2);
};
Utils.calculateExponentialFalloff = (distance, falloffRate) => {
    return Math.exp(-falloffRate * distance);
};
// Corrected HSV to HEX conversion
Utils.hsvToHex = (h, s, v) => {
    let c = v * s;
    let x = c * (1 - Math.abs(((h / 60) % 2) - 1));
    let m = v - c;
    let r = 0, g = 0, b = 0;
    if (h >= 0 && h < 60) {
        r = c;
        g = x;
        b = 0;
    }
    else if (h >= 60 && h < 120) {
        r = x;
        g = c;
        b = 0;
    }
    else if (h >= 120 && h < 180) {
        r = 0;
        g = c;
        b = x;
    }
    else if (h >= 180 && h < 240) {
        r = 0;
        g = x;
        b = c;
    }
    else if (h >= 240 && h < 300) {
        r = x;
        g = 0;
        b = c;
    }
    else {
        r = c;
        g = 0;
        b = x;
    }
    // Convert to RGB values
    const rFinal = Math.round((r + m) * 255);
    const gFinal = Math.round((g + m) * 255);
    const bFinal = Math.round((b + m) * 255);
    return Utils.rgbToHex(rFinal, gFinal, bFinal);
};
// RGB to HEX conversion
Utils.rgbToHex = (r, g, b) => {
    const toHex = (val) => {
        const hex = val.toString(16);
        return hex.length === 1 ? "0" + hex : hex;
    };
    return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
};


/***/ }),

/***/ "./src/weapon/dagger.ts":
/*!******************************!*\
  !*** ./src/weapon/dagger.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Dagger = void 0;
const weapon_1 = __webpack_require__(/*! ./weapon */ "./src/weapon/weapon.ts");
class Dagger extends weapon_1.Weapon {
    constructor(level, x, y) {
        super(level, x, y);
        this.degrade = () => { };
        this.tileX = 22;
        this.tileY = 0;
        this.name = "dagger";
        this.description = "A basic but dependable weapon.";
    }
}
exports.Dagger = Dagger;
Dagger.itemName = "dagger";


/***/ }),

/***/ "./src/weapon/dualdagger.ts":
/*!**********************************!*\
  !*** ./src/weapon/dualdagger.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DualDagger = void 0;
const weapon_1 = __webpack_require__(/*! ./weapon */ "./src/weapon/weapon.ts");
const attackAnimation_1 = __webpack_require__(/*! ../particle/attackAnimation */ "./src/particle/attackAnimation.ts");
class DualDagger extends weapon_1.Weapon {
    constructor(level, x, y) {
        super(level, x, y);
        this.tickInInventory = () => {
            this.firstAttack = true;
        };
        this.weaponMove = (newX, newY) => {
            let flag = false;
            for (let e of this.game.rooms[this.wielder.levelID].entities) {
                if (e.destroyable && !e.pushable && e.pointIn(newX, newY)) {
                    e.hurt(this.wielder, 1);
                    this.statusEffect(e);
                    flag = true;
                }
            }
            if (flag) {
                this.hitSound();
                this.wielder.setHitXY(newX, newY);
                if (this.firstAttack) {
                    this.game.rooms[this.wielder.levelID].particles.push(new attackAnimation_1.AttackAnimation(newX, newY, "dualdagger", this.wielder.direction));
                }
                else {
                    this.game.rooms[this.wielder.levelID].particles.push(new attackAnimation_1.AttackAnimation(newX, newY, "dualdagger2", this.wielder.direction));
                }
                this.game.rooms[this.wielder.levelID].entities = this.game.rooms[this.wielder.levelID].entities.filter((e) => !e.dead);
                if (!this.firstAttack) {
                    this.game.rooms[this.wielder.levelID].tick(this.wielder);
                }
                if (this.wielder === this.game.players[this.game.localPlayerID])
                    this.game.shakeScreen(10 * this.wielder.hitX, 10 * this.wielder.hitY);
                if (this.firstAttack) {
                    this.game.rooms[this.wielder.levelID].tickHitWarnings();
                    this.game.rooms[this.wielder.levelID].clearDeadStuff();
                    this.firstAttack = false;
                    this.wielder.beginSlowMotion();
                }
                this.degrade();
            }
            return !flag;
        };
        this.tileX = 23;
        this.tileY = 0;
        this.firstAttack = true;
        this.name = "Dual Daggers";
        this.durability = 75;
        this.durabilityMax = 75;
        this.description =
            "After the first attack, enemies will not take their turn until you attack or move again.";
    }
}
exports.DualDagger = DualDagger;
DualDagger.itemName = "dual daggers";


/***/ }),

/***/ "./src/weapon/greataxe.ts":
/*!********************************!*\
  !*** ./src/weapon/greataxe.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Greataxe = void 0;
const weapon_1 = __webpack_require__(/*! ./weapon */ "./src/weapon/weapon.ts");
const sound_1 = __webpack_require__(/*! ../sound */ "./src/sound.ts");
const game_1 = __webpack_require__(/*! ../game */ "./src/game.ts");
class Greataxe extends weapon_1.Weapon {
    constructor(level, x, y) {
        super(level, x, y);
        this.hitSound = () => {
            sound_1.Sound.hit();
            sound_1.Sound.playWarHammer();
        };
        this.adjustedDamage = () => {
            let hp = this.wielder?.health / this.wielder?.maxHealth;
            let damage = 1;
            if (hp <= 1)
                damage = 1;
            if (hp <= 0.75)
                damage = 2;
            if (hp <= 0.5)
                damage = 4;
            if (hp <= 0.25)
                damage = 8;
            return damage;
        };
        this.attack = (enemy) => {
            enemy.hurt(this.wielder, this.adjustedDamage());
            this.statusEffect(enemy);
        };
        this.shakeScreen = () => {
            this.wielder.beginSlowMotion();
            setTimeout(() => {
                this.wielder.endSlowMotion();
                //this.hitSound();
                switch (this.wielder.direction) {
                    case game_1.Direction.DOWN:
                        this.game.shakeScreen(0, -10 * this.adjustedDamage(), false);
                        break;
                    case game_1.Direction.UP:
                        this.game.shakeScreen(0, -10 * this.adjustedDamage(), false);
                        break;
                    case game_1.Direction.LEFT:
                        this.game.shakeScreen(-5, -10 * this.adjustedDamage(), false);
                        break;
                    case game_1.Direction.RIGHT:
                        this.game.shakeScreen(5, -10 * this.adjustedDamage(), false);
                        break;
                }
            }, this.hitDelay);
        };
        this.tileX = 24;
        this.tileY = 2;
        this.damage = 2;
        this.name = "greataxe";
        this.durability = 10;
        this.durabilityMax = 10;
        this.hitDelay = 225;
        this.offsetY = 0;
        this.iconOffset = 0.2;
    }
}
exports.Greataxe = Greataxe;
Greataxe.itemName = "greataxe";


/***/ }),

/***/ "./src/weapon/pickaxe.ts":
/*!*******************************!*\
  !*** ./src/weapon/pickaxe.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Pickaxe = void 0;
const weapon_1 = __webpack_require__(/*! ./weapon */ "./src/weapon/weapon.ts");
class Pickaxe extends weapon_1.Weapon {
    constructor(level, x, y) {
        super(level, x, y);
        this.tileX = 30;
        this.tileY = 0;
        this.canMine = true;
    }
}
exports.Pickaxe = Pickaxe;
Pickaxe.itemName = "pickaxe";


/***/ }),

/***/ "./src/weapon/shotgun.ts":
/*!*******************************!*\
  !*** ./src/weapon/shotgun.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Shotgun = void 0;
const weapon_1 = __webpack_require__(/*! ./weapon */ "./src/weapon/weapon.ts");
const genericParticle_1 = __webpack_require__(/*! ../particle/genericParticle */ "./src/particle/genericParticle.ts");
class Shotgun extends weapon_1.Weapon {
    constructor(level, x, y) {
        super(level, x, y);
        this.weaponMove = (newX, newY) => {
            let newX2 = 2 * newX - this.wielder.x;
            let newY2 = 2 * newY - this.wielder.y;
            let newX3 = 3 * newX - 2 * this.wielder.x;
            let newY3 = 3 * newY - 2 * this.wielder.y;
            let range = 3;
            if (!this.game.rooms[this.wielder.levelID].tileInside(newX, newY) ||
                this.game.rooms[this.wielder.levelID].roomArray[newX][newY].isSolid())
                //if current position is inside new position OR is solid
                return true;
            else if (!this.game.rooms[this.wielder.levelID].tileInside(newX2, newY2) ||
                this.game.rooms[this.wielder.levelID].roomArray[newX2][newY2].isSolid())
                //if current position is inside new position 2 OR is solid
                //set range as one
                range = 1;
            else if (!this.game.rooms[this.wielder.levelID].tileInside(newX3, newY3) ||
                this.game.rooms[this.wielder.levelID].roomArray[newX3][newY3].isSolid())
                //if current position is inside new position 3 OR is solid
                //set range as two
                range = 2;
            let enemyHitCandidates = [];
            let firstPushable = 4;
            let firstNonPushable = 5;
            let firstNonDestroyable = 5;
            for (let e of this.game.rooms[this.wielder.levelID].entities) {
                //loop through enemies in this weapons wielders level
                if (e.pushable) {
                    //case for pushables
                    if (e.pointIn(newX, newY))
                        return true;
                    //if pushable is in new position return true
                    if (e.pointIn(newX2, newY2) && range >= 2) {
                        enemyHitCandidates.push({ enemy: e, dist: 2 });
                        firstPushable = 2;
                        //if pushable is in position 2 set firstPushable var
                    }
                    if (e.pointIn(newX3, newY3) && range >= 3) {
                        enemyHitCandidates.push({ enemy: e, dist: 3 });
                        firstPushable = Math.min(firstPushable, 3);
                        //if pushable is in position 3 set firstPushable to min of firstPushable and 3
                    }
                }
                else if (e.destroyable) {
                    //case for destroyables
                    if (e.pointIn(newX, newY) && range >= 1) {
                        firstNonPushable = 1;
                        enemyHitCandidates.push({ enemy: e, dist: 1 });
                    }
                    //if enemy is in new position and range is enough push enemy to hit candidate array
                    if (e.pointIn(newX2, newY2) && range >= 2) {
                        firstNonPushable = Math.min(firstNonPushable, 2);
                        enemyHitCandidates.push({ enemy: e, dist: 2 });
                    }
                    //if enemy is in new position 2 and range is enough push enemy to hit candidate array
                    if (e.pointIn(newX3, newY3) && range >= 3) {
                        firstNonPushable = Math.min(firstNonPushable, 3);
                        enemyHitCandidates.push({ enemy: e, dist: 3 });
                    }
                    //if enemy is in new position 3 and range is enough push enemy to hit candidate array
                }
                else {
                    if (e.pointIn(newX, newY) && range >= 1) {
                        firstNonDestroyable = 1;
                    }
                    //if enemy is in new position and range is enough set first non destroyable to 1
                    if (e.pointIn(newX2, newY2) && range >= 2) {
                        firstNonDestroyable = Math.min(firstNonDestroyable, 2);
                    }
                    //if enemy is in new position and range is enough set first non destroyable to 2
                    if (e.pointIn(newX3, newY3) && range >= 3) {
                        firstNonDestroyable = Math.min(firstNonDestroyable, 3);
                    }
                    //if enemy is in new position and range is enough set first non destroyable to 3
                }
            }
            let targetX = newX3;
            let targetY = newY3;
            if (firstNonDestroyable < firstNonPushable &&
                firstNonDestroyable < firstPushable
            //if a non destroyable comes before the first non pushable and before the first pushable
            ) {
                return true;
                //return true and exit the function
            }
            if (firstNonPushable <= firstPushable) {
                for (const c of enemyHitCandidates) {
                    let e = c.enemy;
                    let d = c.dist;
                    if (d === 3)
                        e.hurt(this.wielder, 0.5);
                    else
                        e.hurt(this.wielder, 1);
                }
                //finally bro
                //for the array c of enemyHitCandidates if the enemy distance is 3 only do .5 damage
                //if they're closer do the usual damage
                //hits all candidates in enemyHitCandidates
                this.hitSound();
                this.wielder.setHitXY(newX, newY);
                genericParticle_1.GenericParticle.shotgun(this.game.rooms[this.wielder.levelID], this.wielder.x + 0.5, this.wielder.y, targetX + 0.5, targetY, "black");
                genericParticle_1.GenericParticle.shotgun(this.game.rooms[this.wielder.levelID], this.wielder.x + 0.5, this.wielder.y, targetX + 0.5, targetY, "#ffddff");
                let gp = new genericParticle_1.GenericParticle(this.game.rooms[this.wielder.levelID], 0.5 * (newX + this.wielder.x) + 0.5, 0.5 * (newY + this.wielder.y), 0, 1, 0, 0, 0, "white", 0);
                gp.expirationTimer = 10;
                this.game.rooms[this.wielder.levelID].particles.push(gp);
                //this.game.levels[this.wielder.levelID].particles.push(new SlashParticle(newX, newY));
                //this.game.levels[this.wielder.levelID].particles.push(new SlashParticle(newX2, newY2));
                //this.game.levels[this.wielder.levelID].particles.push(new SlashParticle(newX3, newY3));
                this.game.rooms[this.wielder.levelID].tick(this.wielder);
                if (this.wielder === this.game.players[this.game.localPlayerID])
                    this.game.shakeScreen(10 * this.wielder.hitX, 10 * this.wielder.hitY);
                this.degrade();
                return false;
            }
            return true;
        };
        this.tileX = 26;
        this.tileY = 0;
        this.name = "shotgun";
    }
}
exports.Shotgun = Shotgun;
Shotgun.itemName = "shotgun";


/***/ }),

/***/ "./src/weapon/spear.ts":
/*!*****************************!*\
  !*** ./src/weapon/spear.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Spear = void 0;
const weapon_1 = __webpack_require__(/*! ./weapon */ "./src/weapon/weapon.ts");
const sound_1 = __webpack_require__(/*! ../sound */ "./src/sound.ts");
const attackAnimation_1 = __webpack_require__(/*! ../particle/attackAnimation */ "./src/particle/attackAnimation.ts");
class Spear extends weapon_1.Weapon {
    constructor(level, x, y) {
        super(level, x, y);
        this.weaponMove = (newX, newY) => {
            let newX2 = 2 * newX - this.wielder.x;
            let newY2 = 2 * newY - this.wielder.y;
            let flag = false;
            let enemyHitCandidates = [];
            for (let e of this.game.rooms[this.wielder.levelID].entities) {
                if (e.destroyable) {
                    if (e.pointIn(newX, newY)) {
                        if (e.pushable)
                            return true;
                        else {
                            e.hurt(this.wielder, 1);
                            this.statusEffect(e);
                            flag = true;
                        }
                    }
                    if (e.pointIn(newX2, newY2) &&
                        !this.game.rooms[this.wielder.levelID].roomArray[newX][newY].isSolid()) {
                        //only hit targest 2 tiles away if they are enemies
                        if (!e.pushable)
                            enemyHitCandidates.push(e);
                    }
                }
            }
            if (!flag && enemyHitCandidates.length > 0) {
                for (const e of enemyHitCandidates)
                    e.hurt(this.wielder, 1);
                this.hitSound();
                this.wielder.setHitXY(newX, newY);
                //this.game.rooms[this.wielder.levelID].particles.push(
                //new AttackAnimation(newX, newY, "spear", this.wielder.direction),
                //);
                this.game.rooms[this.wielder.levelID].particles.push(new attackAnimation_1.AttackAnimation(newX2, newY2, "spear", this.wielder.direction));
                this.game.rooms[this.wielder.levelID].tick(this.wielder);
                this.shakeScreen(newX, newY);
                //if (this.wielder === this.game.players[this.game.localPlayerID])
                //this.game.shakeScreen(10 * this.wielder.hitX, 10 * this.wielder.hitY);
                this.degrade();
                return false;
            }
            if (flag) {
                if (this.wielder.game.room === this.wielder.game.rooms[this.wielder.levelID])
                    sound_1.Sound.hit();
                this.wielder.setHitXY(newX, newY);
                this.shakeScreen(newX, newY);
                this.game.rooms[this.wielder.levelID].particles.push(new attackAnimation_1.AttackAnimation(newX, newY, "spear", this.wielder.direction));
                this.game.rooms[this.wielder.levelID].tick(this.wielder);
                if (this.wielder === this.game.players[this.game.localPlayerID])
                    this.game.shakeScreen(10 * this.wielder.hitX, 10 * this.wielder.hitY);
                this.degrade();
            }
            return !flag;
        };
        this.tileX = 24;
        this.tileY = 0;
        this.name = "spear";
        this.description =
            "Hits enemies in front of you within a range of 2 tiles.";
        this.iconOffset = 0.1; //default 0
        this.offsetY = 0; //default -0.25
    }
}
exports.Spear = Spear;
Spear.itemName = "spear";


/***/ }),

/***/ "./src/weapon/spellbook.ts":
/*!*********************************!*\
  !*** ./src/weapon/spellbook.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Spellbook = void 0;
const weapon_1 = __webpack_require__(/*! ./weapon */ "./src/weapon/weapon.ts");
const sound_1 = __webpack_require__(/*! ../sound */ "./src/sound.ts");
const playerFireball_1 = __webpack_require__(/*! ../projectile/playerFireball */ "./src/projectile/playerFireball.ts");
const utils_1 = __webpack_require__(/*! ../utils */ "./src/utils.ts");
const game_1 = __webpack_require__(/*! ../game */ "./src/game.ts");
const spellbookPage_1 = __webpack_require__(/*! ../item/spellbookPage */ "./src/item/spellbookPage.ts");
class Spellbook extends weapon_1.Weapon {
    constructor(level, x, y) {
        super(level, x, y);
        this.getTargets = () => {
            this.targets = [];
            let entities = this.game.rooms[this.wielder.levelID].entities;
            this.targets = entities.filter((e) => !e.pushable &&
                utils_1.Utils.distance(this.wielder.x, this.wielder.y, e.x, e.y) <= this.range);
            let enemies = this.targets.filter((e) => e.isEnemy === true);
            //console.log(enemies);
            if (enemies.length > 0)
                return enemies;
            else {
                //console.log(this.targets);
                return this.targets;
            }
        };
        this.disassemble = () => {
            if (this.equipped) {
                this.game.pushMessage("I should probably unequip this before I try to disassemble it...");
                return;
            }
            this.game.pushMessage(`You tear the remaining pages out of your spellbook.`);
            let inventory = this.wielder.inventory;
            let inventoryX = this.x;
            let inventoryY = this.y;
            let numFragments = Math.floor(this.durability);
            this.toggleEquip();
            //inventory.weapon = null;
            inventory.removeItem(this);
            inventory.addItem(new spellbookPage_1.SpellbookPage(this.level, inventoryX, inventoryY, numFragments));
        };
        this.weaponMove = (newX, newY) => {
            this.getTargets();
            let direction = this.wielder.direction;
            let flag = false;
            let targets = this.targets;
            const isTargetInDirection = (e) => {
                switch (direction) {
                    case game_1.Direction.UP:
                        return e.y <= newY;
                    case game_1.Direction.RIGHT:
                        return e.x >= newX;
                    case game_1.Direction.DOWN:
                        return e.y >= newY;
                    case game_1.Direction.LEFT:
                        return e.x <= newX;
                    default:
                        return false;
                }
            };
            if (targets.length > 0) {
                this.isTargeting = true;
            }
            else {
                this.isTargeting = false;
            }
            targets = targets.filter(isTargetInDirection);
            for (let e of targets) {
                if (!this.game.rooms[this.wielder.levelID].roomArray[e.x][e.y].isSolid()) {
                    e.hurt(this.wielder, 1);
                    this.game.rooms[this.wielder.levelID].projectiles.push(new playerFireball_1.PlayerFireball(this.wielder, e.x, e.y));
                    flag = true;
                }
            }
            if (flag) {
                if (this.wielder.game.rooms[this.wielder.levelID] === this.wielder.game.room)
                    sound_1.Sound.hit();
                this.wielder.setHitXY(newX, newY);
                this.game.rooms[this.wielder.levelID].tick(this.wielder);
                if (this.wielder === this.game.players[this.game.localPlayerID])
                    this.game.shakeScreen(10 * this.wielder.hitX, 10 * this.wielder.hitY);
                sound_1.Sound.playMagic();
                this.degrade();
                setTimeout(() => {
                    this.isTargeting = false;
                }, 100);
            }
            return !flag;
        };
        this.range = 4;
        this.tileX = 25;
        this.tileY = 0;
        this.canMine = true;
        this.name = Spellbook.itemName;
        this.isTargeting = false;
        this.durability = 5;
        this.durabilityMax = 10;
        this.description = "Hits multiple enemies within a range of 4 tiles.";
    }
}
exports.Spellbook = Spellbook;
Spellbook.itemName = "spellbook";


/***/ }),

/***/ "./src/weapon/warhammer.ts":
/*!*********************************!*\
  !*** ./src/weapon/warhammer.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Warhammer = void 0;
const weapon_1 = __webpack_require__(/*! ./weapon */ "./src/weapon/weapon.ts");
const sound_1 = __webpack_require__(/*! ../sound */ "./src/sound.ts");
const game_1 = __webpack_require__(/*! ../game */ "./src/game.ts");
class Warhammer extends weapon_1.Weapon {
    constructor(level, x, y) {
        super(level, x, y);
        this.hitSound = () => {
            sound_1.Sound.hit();
            sound_1.Sound.playWarHammer();
        };
        this.shakeScreen = () => {
            this.wielder.beginSlowMotion();
            setTimeout(() => {
                this.wielder.endSlowMotion();
                //this.hitSound();
                switch (this.wielder.direction) {
                    case game_1.Direction.DOWN:
                        this.game.shakeScreen(0, -30, false);
                        break;
                    case game_1.Direction.UP:
                        this.game.shakeScreen(0, -30, false);
                        break;
                    case game_1.Direction.LEFT:
                        this.game.shakeScreen(-5, -30, false);
                        break;
                    case game_1.Direction.RIGHT:
                        this.game.shakeScreen(5, -30, false);
                        break;
                }
            }, this.hitDelay);
        };
        this.tileX = 22;
        this.tileY = 2;
        this.damage = 2;
        this.name = "warhammer";
        this.durability = 25;
        this.durabilityMax = 25;
        this.hitDelay = 225;
    }
}
exports.Warhammer = Warhammer;
Warhammer.itemName = "warhammer";


/***/ }),

/***/ "./src/weapon/weapon.ts":
/*!******************************!*\
  !*** ./src/weapon/weapon.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Weapon = void 0;
const game_1 = __webpack_require__(/*! ../game */ "./src/game.ts");
const equippable_1 = __webpack_require__(/*! ../item/equippable */ "./src/item/equippable.ts");
const sound_1 = __webpack_require__(/*! ../sound */ "./src/sound.ts");
const gameConstants_1 = __webpack_require__(/*! ../gameConstants */ "./src/gameConstants.ts");
const weaponFragments_1 = __webpack_require__(/*! ../item/weaponFragments */ "./src/item/weaponFragments.ts");
const attackAnimation_1 = __webpack_require__(/*! ../particle/attackAnimation */ "./src/particle/attackAnimation.ts");
class Weapon extends equippable_1.Equippable {
    constructor(level, x, y, status) {
        super(level, x, y);
        this.break = () => {
            this.durability = 0;
            this.wielder.inventory.weapon = null;
            this.toggleEquip();
            //this.wielder.inventory.removeItem(this);
            //this.wielder = null;
            this.game.pushMessage("Your weapon breaks");
            if (this.status.poison || this.status.blood) {
                this.clearStatus();
            }
            this.broken = true;
        };
        this.coEquippable = (other) => {
            if (other instanceof Weapon)
                return false;
            return true;
        };
        this.applyStatus = (status) => {
            this.status = status;
            if (this.status.blood) {
                this.damage = Math.max(0.5, this.damage - 0.5);
            }
        };
        this.clearStatus = () => {
            const status = this.status.poison ? "poison" : "bleed";
            this.game.pushMessage(`Your ${this.name}'s ${status} effect dries up`);
            this.status = { poison: false, blood: false };
            this.statusApplicationCount = 0;
        };
        this.statusEffect = (entity) => {
            if (!entity.isEnemy)
                return;
            const enemy = entity;
            if (!enemy.status.poison.active || !enemy.status.bleed.active) {
                if (this.wielder.applyStatus(enemy, this.status)) {
                    this.statusApplicationCount++;
                    const message = this.status.poison
                        ? `Your weapon poisons the ${enemy.name}`
                        : `Your cursed weapon draws blood from the ${enemy.name}`;
                    this.game.pushMessage(message);
                    //if (this.statusApplicationCount >= 10) this.clearStatus();
                }
            }
        };
        this.disassemble = () => {
            if (this.equipped) {
                this.game.pushMessage("I should probably unequip this before I try to disassemble it...");
                return;
            }
            this.game.pushMessage(`You dissassemble your ${this.name} into fragments.`);
            let inventory = this.wielder.inventory;
            let inventoryX = this.x;
            let inventoryY = this.y;
            let numFragments = Math.floor(this.durability / 1.5);
            this.toggleEquip();
            //inventory.weapon = null;
            inventory.removeItem(this);
            inventory.addItem(new weaponFragments_1.WeaponFragments(this.level, inventoryX, inventoryY, numFragments));
        };
        this.dropFromInventory = () => {
            if (this.wielder.inventory.weapon === this)
                this.wielder.inventory.weapon = null;
            this.wielder = null;
            this.equipped = false;
        };
        this.weaponMove = (newX, newY) => {
            let flag = false;
            for (let e of this.game.rooms[this.wielder.levelID].entities) {
                if (e.destroyable && !e.pushable && e.pointIn(newX, newY)) {
                    this.attack(e);
                    flag = true;
                }
            }
            if (flag) {
                this.wielder.busyAnimating = true;
                this.attackAnimation(newX, newY);
                this.game.rooms[this.wielder.levelID].tick(this.wielder);
                this.shakeScreen(newX, newY);
                this.degrade();
                setTimeout(() => {
                    this.wielder.busyAnimating = false;
                    this.hitSound();
                }, this.hitDelay);
            }
            return !flag;
        };
        this.attack = (enemy) => {
            enemy.hurt(this.wielder, this.damage);
            this.statusEffect(enemy);
        };
        this.attackAnimation = (newX, newY) => {
            this.wielder.setHitXY(newX, newY);
            this.game.rooms[this.wielder.levelID].particles.push(new attackAnimation_1.AttackAnimation(newX, newY, this.name, this.wielder.direction));
        };
        this.shakeScreen = (eX, eY) => {
            if (this.wielder.game.rooms[this.wielder.levelID] === this.wielder.game.room)
                this.wielder.shakeScreen(this.wielder.x, this.wielder.y, eX, eY);
        };
        this.hitSound = () => {
            if (this.wielder.game.rooms[this.wielder.levelID] === this.wielder.game.room)
                sound_1.Sound.hit();
        };
        this.drawStatus = (x, y) => {
            if (this.status.poison || this.status.blood) {
                let tileX = 3;
                if (this.status.poison) {
                    tileX = 4;
                }
                if (this.status.blood) {
                    tileX = 3;
                }
                game_1.Game.drawFX(tileX, 0, 1, 1, x - 1 / gameConstants_1.GameConstants.TILESIZE, y - 1 / gameConstants_1.GameConstants.TILESIZE, 1, 1);
            }
        };
        this.getDescription = () => {
            let broken = this.broken ? " (broken)" : "";
            let status = [];
            let durability = "";
            if (this.status.poison)
                status.push("Poison");
            if (this.status.blood)
                status.push(" Bleed");
            if (this.durability < this.durabilityMax)
                durability = ` Durability: ${this.durability}/${this.durabilityMax}`;
            return `${this.name}${broken}\n${status.join(", ")}\n${durability}\n${this.description}\ndamage: ${this.damage}`;
        };
        this.tick = () => { };
        if (level)
            this.game = level.game;
        this.canMine = false;
        this.range = 1;
        this.damage = 1;
        this.status = status || { poison: false, blood: false };
        this.durability = 50;
        this.durabilityMax = 50;
        this.statusApplicationCount = 0;
        this.equipTick = true;
        this.name = this.constructor.prototype.itemName;
    }
}
exports.Weapon = Weapon;
Weapon.itemName = "weapon";


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./src/game.ts");
/******/ 	
/******/ })()
;
//# sourceMappingURL=bundle.js.map